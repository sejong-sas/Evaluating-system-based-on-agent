{
    "model_id": "moonshotai/Kimi-K2-Base",
    "files": [
        ".gitattributes",
        "LICENSE",
        "README.md",
        "THIRD_PARTY_NOTICES.md",
        "config.json",
        "configuration_deepseek.py",
        "docs/deploy_guidance.md",
        "docs/tool_call_guidance.md",
        "figures/banner.png",
        "figures/kimi-logo.png",
        "generation_config.json",
        "kimi-logo.png",
        "model-1-of-61.safetensors",
        "model-10-of-61.safetensors",
        "model-11-of-61.safetensors",
        "model-12-of-61.safetensors",
        "model-13-of-61.safetensors",
        "model-14-of-61.safetensors",
        "model-15-of-61.safetensors",
        "model-16-of-61.safetensors",
        "model-17-of-61.safetensors",
        "model-18-of-61.safetensors",
        "model-19-of-61.safetensors",
        "model-2-of-61.safetensors",
        "model-20-of-61.safetensors",
        "model-21-of-61.safetensors",
        "model-22-of-61.safetensors",
        "model-23-of-61.safetensors",
        "model-24-of-61.safetensors",
        "model-25-of-61.safetensors",
        "model-26-of-61.safetensors",
        "model-27-of-61.safetensors",
        "model-28-of-61.safetensors",
        "model-29-of-61.safetensors",
        "model-3-of-61.safetensors",
        "model-30-of-61.safetensors",
        "model-31-of-61.safetensors",
        "model-32-of-61.safetensors",
        "model-33-of-61.safetensors",
        "model-34-of-61.safetensors",
        "model-35-of-61.safetensors",
        "model-36-of-61.safetensors",
        "model-37-of-61.safetensors",
        "model-38-of-61.safetensors",
        "model-39-of-61.safetensors",
        "model-4-of-61.safetensors",
        "model-40-of-61.safetensors",
        "model-41-of-61.safetensors",
        "model-42-of-61.safetensors",
        "model-43-of-61.safetensors",
        "model-44-of-61.safetensors",
        "model-45-of-61.safetensors",
        "model-46-of-61.safetensors",
        "model-47-of-61.safetensors",
        "model-48-of-61.safetensors",
        "model-49-of-61.safetensors",
        "model-5-of-61.safetensors",
        "model-50-of-61.safetensors",
        "model-51-of-61.safetensors",
        "model-52-of-61.safetensors",
        "model-53-of-61.safetensors",
        "model-54-of-61.safetensors",
        "model-55-of-61.safetensors",
        "model-56-of-61.safetensors",
        "model-57-of-61.safetensors",
        "model-58-of-61.safetensors",
        "model-59-of-61.safetensors",
        "model-6-of-61.safetensors",
        "model-60-of-61.safetensors",
        "model-61-of-61.safetensors",
        "model-7-of-61.safetensors",
        "model-8-of-61.safetensors",
        "model-9-of-61.safetensors",
        "model.safetensors.index.json",
        "modeling_deepseek.py",
        "tiktoken.model",
        "tokenization_kimi.py",
        "tokenizer_config.json"
    ],
    "readme": "---\nlicense: other\nlicense_name: modified-mit\nlibrary_name: transformers\n---\n<div align=\"center\">\n  <picture>\n      <img src=\"figures/kimi-logo.png\" width=\"30%\" alt=\"Kimi K2: Open Agentic Intellignece\">\n  </picture>\n</div>\n\n<hr>\n\n<div align=\"center\" style=\"line-height:1\">\n  <a href=\"https://www.kimi.com\" target=\"_blank\"><img alt=\"Chat\" src=\"https://img.shields.io/badge/ðŸ¤–%20Chat-Kimi%20K2-ff6b6b?color=1783ff&logoColor=white\"/></a>\n  <a href=\"https://github.com/moonshotai/Kimi-K2\"><img alt=\"github\" src=\"https://img.shields.io/badge/ðŸ¤–%20Github-Kimi%20K2-ff6b6b?color=1783ff&logoColor=white\"/></a>\n  <a href=\"https://www.moonshot.ai\" target=\"_blank\"><img alt=\"Homepage\" src=\"https://img.shields.io/badge/Homepage-Moonshot%20AI-white?logo=Kimi&logoColor=white\"/></a>\n</div>\n\n<div align=\"center\" style=\"line-height: 1;\">\n  <a href=\"https://huggingface.co/moonshotai\" target=\"_blank\"><img alt=\"Hugging Face\" src=\"https://img.shields.io/badge/%F0%9F%A4%97%20Hugging%20Face-Moonshot%20AI-ffc107?color=ffc107&logoColor=white\"/></a>\n  <a href=\"https://twitter.com/kimi_moonshot\" target=\"_blank\"><img alt=\"Twitter Follow\" src=\"https://img.shields.io/badge/Twitter-Kimi.ai-white?logo=x&logoColor=white\"/></a>\n    <a href=\"https://discord.gg/TYU2fdJykW\" target=\"_blank\"><img alt=\"Discord\" src=\"https://img.shields.io/badge/Discord-Kimi.ai-white?logo=discord&logoColor=white\"/></a>\n</div>\n\n<div align=\"center\" style=\"line-height: 1;\">\n  <a href=\"https://github.com/moonshotai/Kimi-K2/blob/main/LICENSE\"><img alt=\"License\" src=\"https://img.shields.io/badge/License-Modified_MIT-f5de53?&color=f5de53\"/></a>\n</div>\n\n<p align=\"center\">\n<b>ðŸ“°&nbsp;&nbsp;<a href=\"https://moonshotai.github.io/Kimi-K2/\">Tech Blog</a></b> &nbsp;&nbsp;&nbsp; | &nbsp;&nbsp;&nbsp; <b>ðŸ“„&nbsp;&nbsp;Paper Link (comming soon)</b>\n</p>\n\n## 1. Model Introduction\n\nKimi K2 is a state-of-the-art mixture-of-experts (MoE) language model with 32 billion activated parameters and 1 trillion total parameters. Trained with the Muon optimizer, Kimi K2 achieves exceptional performance across frontier knowledge, reasoning, and coding tasks while being meticulously optimized for agentic capabilities.\n\n### Key Features\n- Large-Scale Training: Pre-trained a 1T parameter MoE model on 15.5T tokens with zero training instability.\n- MuonClip Optimizer: We apply the Muon optimizer to an unprecedented scale, and develop novel optimization techniques to resolve instabilities while scaling up.\n- Agentic Intelligence: Specifically designed for tool use, reasoning, and autonomous problem-solving.\n\n### Model Variants\n- **Kimi-K2-Base**: The foundation model, a strong start for researchers and builders who want full control for fine-tuning and custom solutions.\n- **Kimi-K2-Instruct**: The post-trained model best for drop-in, general-purpose chat and agentic experiences. It is a reflex-grade model without long thinking.\n\n<div align=\"center\">\n  <picture>\n      <img src=\"figures/banner.png\" width=\"80%\" alt=\"Evaluation Results\">\n  </picture>\n</div>\n\n## 2. Model Summary\n\n<div align=\"center\">\n\n\n| | |\n|:---:|:---:|\n| **Architecture** | Mixture-of-Experts (MoE) |\n| **Total Parameters** | 1T |\n| **Activated Parameters** | 32B |\n| **Number of Layers** (Dense layer included) | 61 |\n| **Number of Dense Layers** | 1 |\n| **Attention Hidden Dimension** | 7168 |\n| **MoE Hidden Dimension** (per Expert) | 2048 |\n| **Number of Attention Heads** | 64 |\n| **Number of Experts** | 384 |\n| **Selected Experts per Token** | 8 |\n| **Number of Shared Experts** | 1 |\n| **Vocabulary Size** | 160K |\n| **Context Length** | 128K |\n| **Attention Mechanism** | MLA |\n| **Activation Function** | SwiGLU |\n</div>\n\n## 3. Evaluation Results\n\n#### Instruction model evaluation results\n\n<div align=\"center\">\n<table>\n<thead>\n<tr>\n<th align=\"center\">Benchmark</th>\n<th align=\"center\">Metric</th>\n<th align=\"center\"><sup>Kimi K2 Instruct</sup></th>\n<th align=\"center\"><sup>DeepSeek-V3-0324</sup></th>\n<th align=\"center\"><sup>Qwen3-235B-A22B <br><sup>(non-thinking)</sup></sup></th>\n<th align=\"center\"><sup>Claude Sonnet 4 <br><sup>(w/o extended thinking)</sup></sup></th>\n<th align=\"center\"><sup>Claude Opus 4 <br><sup>(w/o extended thinking)</sup></sup></th>\n<th align=\"center\"><sup>GPT-4.1</sup></th>\n<th align=\"center\"><sup>Gemini 2.5 Flash <br> Preview (05-20)</sup></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\" colspan=9><strong>Coding Tasks</strong></td>\n</tr>\n<tr>\n<td align=\"center\">LiveCodeBench v6<br><sup>(Aug 24 - May 25)</sup></td>\n<td align=\"center\">Pass@1</td>\n<td align=\"center\"><strong>53.7</strong></td>\n<td align=\"center\">46.9</td>\n<td align=\"center\">37.0</td>\n<td align=\"center\">48.5</td>\n<td align=\"center\">47.4</td>\n<td align=\"center\">44.7</td>\n<td align=\"center\">44.7</td>\n</tr>\n<tr>\n<td align=\"center\">OJBench</td>\n<td align=\"center\">Pass@1</td>\n<td align=\"center\"><strong>27.1</strong></td>\n<td align=\"center\">24.0</td>\n<td align=\"center\">11.3</td>\n<td align=\"center\">15.3</td>\n<td align=\"center\">19.6</td>\n<td align=\"center\">19.5</td>\n<td align=\"center\">19.5</td>\n</tr>\n\n<tr>\n<td align=\"center\">MultiPL-E</td>\n<td align=\"center\">Pass@1</td>\n<td align=\"center\"><ins><strong>85.7</strong></ins></td>\n<td align=\"center\">83.1</td>\n<td align=\"center\">78.2</td>\n<td align=\"center\">88.6</td>\n<td align=\"center\"><strong>89.6</strong></td>\n<td align=\"center\">86.7</td>\n<td align=\"center\">85.6</td>\n</tr>\n\n<tr>\n<td align=\"center\">SWE-bench Verified <br/><sup>(Agentless Coding)</sup></td>\n<td align=\"center\">Single Patch w/o Test (Acc)</td>\n<td align=\"center\"><ins><strong>51.8</strong></ins></td>\n<td align=\"center\">36.6</td>\n<td align=\"center\">39.4</td>\n<td align=\"center\">50.2</td>\n<td align=\"center\"><strong>53.0</strong></td>\n<td align=\"center\">40.8</td>\n<td align=\"center\">32.6</td>\n</tr>\n\n<tr>\n<td align=\"center\" rowspan=\"2\">SWE-bench Verified <br/> <sup>(Agentic Coding)</sup></td>\n<td align=\"center\">Single Attempt (Acc)</td>\n<td align=\"center\"><ins><strong>65.8</strong></ins></td>\n<td align=\"center\">38.8</td>\n<td align=\"center\">34.4</td>\n<td align=\"center\"><strong>72.7</strong><sup>*</sup></td>\n<td align=\"center\">72.5<sup>*</sup></td>\n<td align=\"center\">54.6</td>\n<td align=\"center\">â€”</td>\n</tr>\n\n<tr>\n<!--<td align=\"center\">(Agentic Coding)</td>-->\n<td align=\"center\">Multiple Attempts (Acc)</td>\n<td align=\"center\"><ins><strong>71.6</strong></ins></td>\n<td align=\"center\">â€”</td>\n<td align=\"center\">â€”</td>\n<td align=\"center\"><strong>80.2</strong></td>\n<td align=\"center\">79.4<sup>*</sup></td>\n<td align=\"center\">â€”</td>\n<td align=\"center\">â€”</td>\n</tr>\n\n<tr>\n<td align=\"center\">SWE-bench Multilingual<br /> <sup>(Agentic Coding)</sup></td>\n<td align=\"center\">Single Attempt (Acc)</td>\n<td align=\"center\"><ins><strong>47.3</strong> </ins></td>\n<td align=\"center\">25.8</td>\n<td align=\"center\">20.9</td>\n<td align=\"center\"><strong>51.0</strong></td>\n<td align=\"center\">â€”</td>\n<td align=\"center\">31.5</td>\n<td align=\"center\">â€”</td>\n</tr>\n\n<tr>\n<td align=\"center\" rowspan=\"2\">TerminalBench</td>\n<td align=\"center\">Inhouse Framework (Acc)</td>\n<td align=\"center\"><ins><strong>30.0</strong></ins></td>\n<td align=\"center\">â€”</td>\n<td align=\"center\">â€”</td>\n<td align=\"center\">35.5</td>\n<td align=\"center\"><strong>43.2</strong></td>\n<td align=\"center\">8.3</td>\n<td align=\"center\">â€”</td>\n</tr>\n\n<tr>\n<!--<td align=\"center\">TerminalBench</td>-->\n<td align=\"center\">Terminus (Acc)</td>\n<td align=\"center\"><ins><strong>25.0</strong> </ins></td>\n<td align=\"center\">16.3</td>\n<td align=\"center\">6.6</td>\n<td align=\"center\">â€”</td>\n<td align=\"center\">â€”</td>\n<td align=\"center\"><strong>30.3</strong></td>\n<td align=\"center\">16.8</td>\n</tr>\n<tr>\n<td align=\"center\">Aider-Polyglot</td>\n<td align=\"center\">Acc</td>\n<td align=\"center\">60.0</td>\n<td align=\"center\">55.1</td>\n<td align=\"center\"><ins><strong>61.8</strong></ins></td>\n<td align=\"center\">56.4</td>\n<td align=\"center\"><strong>70.7</strong></td>\n<td align=\"center\">52.4</td>\n<td align=\"center\">44.0</td>\n</tr>\n<tr>\n<td align=\"center\" colspan=9><strong>Tool Use Tasks</strong></td>\n</tr>\n<tr>\n<td align=\"center\">Tau2 retail</td>\n<td align=\"center\">Avg@4</td>\n<td align=\"center\"><ins><strong>70.6</strong></ins></td>\n<td align=\"center\">69.1</td>\n<td align=\"center\">57.0</td>\n<td align=\"center\">75.0</td>\n<td align=\"center\"><strong>81.8</strong></td>\n<td align=\"center\">74.8</td>\n<td align=\"center\">64.3</td>\n</tr>\n<tr>\n<td align=\"center\">Tau2 airline</td>\n<td align=\"center\">Avg@4</td>\n<td align=\"center\"><ins><strong>56.5</strong></ins></td>\n<td align=\"center\">39.0</td>\n<td align=\"center\">26.5</td>\n<td align=\"center\">55.5</td>\n<td align=\"center\"><strong>60.0</strong></td>\n<td align=\"center\">54.5</td>\n<td align=\"center\">42.5</td>\n</tr>\n<tr>\n<td align=\"center\">Tau2 telecom</td>\n<td align=\"center\">Avg@4</td>\n<td align=\"center\"><strong>65.8</strong></td>\n<td align=\"center\">32.5</td>\n<td align=\"center\">22.1</td>\n<td align=\"center\">45.2</td>\n<td align=\"center\">57.0</td>\n<td align=\"center\">38.6</td>\n<td align=\"center\">16.9</td>\n</tr>\n<tr>\n<td align=\"center\">AceBench</td>\n<td align=\"center\">Acc</td>\n<td align=\"center\"><ins><strong>76.5</strong></ins></td>\n<td align=\"center\">72.7</td>\n<td align=\"center\">70.5</td>\n<td align=\"center\">76.2</td>\n<td align=\"center\">75.6</td>\n<td align=\"center\"><strong>80.1</strong></td>\n<td align=\"center\">74.5</td>\n</tr>\n<tr>\n<td align=\"center\" colspan=9><strong>Math &amp; STEM Tasks</strong></td>\n</tr>\n<tr>\n<td align=\"center\">AIME 2024</td>\n<td align=\"center\">Avg@64</td>\n<td align=\"center\"><strong>69.6</strong></td>\n<td align=\"center\">59.4<sup>*</sup></td>\n<td align=\"center\">40.1<sup>*</sup></td>\n<td align=\"center\">43.4</td>\n<td align=\"center\">48.2</td>\n<td align=\"center\">46.5</td>\n<td align=\"center\">61.3</td>\n</tr>\n<tr>\n<td align=\"center\">AIME 2025</td>\n<td align=\"center\">Avg@64</td>\n<td align=\"center\"><strong>49.5</strong></td>\n<td align=\"center\">46.7</td>\n<td align=\"center\">24.7<sup>*</sup></td>\n<td align=\"center\">33.1<sup>*</sup></td>\n<td align=\"center\">33.9<sup>*</sup></td>\n<td align=\"center\">37.0</td>\n<td align=\"center\">46.6</td>\n</tr>\n<tr>\n<td align=\"center\">MATH-500</td>\n<td align=\"center\">Acc</td>\n<td align=\"center\"><strong>97.4</strong></td>\n<td align=\"center\">94.0<sup>*</sup></td>\n<td align=\"center\">91.2<sup>*</sup></td>\n<td align=\"center\">94.0</td>\n<td align=\"center\">94.4</td>\n<td align=\"center\">92.4</td>\n<td align=\"center\">95.4</td>\n</tr>\n<tr>\n<td align=\"center\">HMMT 2025</td>\n<td align=\"center\">Avg@32</td>\n<td align=\"center\"><strong>38.8</strong></td>\n<td align=\"center\">27.5</td>\n<td align=\"center\">11.9</td>\n<td align=\"center\">15.9</td>\n<td align=\"center\">15.9</td>\n<td align=\"center\">19.4</td>\n<td align=\"center\">34.7</td>\n</tr>\n<tr>\n<td align=\"center\">CNMO 2024</td>\n<td align=\"center\">Avg@16</td>\n<td align=\"center\">74.3</td>\n<td align=\"center\"><ins><strong>74.7</strong></ins></td>\n<td align=\"center\">48.6</td>\n<td align=\"center\">60.4</td>\n<td align=\"center\">57.6</td>\n<td align=\"center\">56.6</td>\n<td align=\"center\"><strong>75.0</strong></td>\n</tr>\n<tr>\n<td align=\"center\">PolyMath-en</td>\n<td align=\"center\">Avg@4</td>\n<td align=\"center\"><strong>65.1</strong></td>\n<td align=\"center\">59.5</td>\n<td align=\"center\">51.9</td>\n<td align=\"center\">52.8</td>\n<td align=\"center\">49.8</td>\n<td align=\"center\">54.0</td>\n<td align=\"center\">49.9</td>\n</tr>\n\n<tr>\n<td align=\"center\">ZebraLogic</td>\n<td align=\"center\">Acc</td>\n<td align=\"center\"><strong>89.0</strong></td>\n<td align=\"center\">84.0</td>\n<td align=\"center\">37.7<sup>*</sup></td>\n<td align=\"center\">73.7</td>\n<td align=\"center\">59.3</td>\n<td align=\"center\">58.5</td>\n<td align=\"center\">57.9</td>\n</tr>\n\n<tr>\n<td align=\"center\">AutoLogi</td>\n<td align=\"center\">Acc</td>\n<td align=\"center\"><ins><strong>89.5</strong></ins></td>\n<td align=\"center\">88.9</td>\n<td align=\"center\">83.3</td>\n<td align=\"center\"><strong>89.8</strong></td>\n<td align=\"center\">86.1</td>\n<td align=\"center\">88.2</td>\n<td align=\"center\">84.1</td>\n</tr>\n\n<tr>\n<td align=\"center\">GPQA-Diamond</td>\n<td align=\"center\">Avg@8</td>\n<td align=\"center\"><strong>75.1</strong></td>\n<td align=\"center\">68.4<sup>*</sup></td>\n<td align=\"center\">62.9<sup>*</sup></td>\n<td align=\"center\">70.0<sup>*</sup></td>\n<td align=\"center\">74.9<sup>*</sup></td>\n<td align=\"center\">66.3</td>\n<td align=\"center\">68.2</td>\n</tr>\n\n<tr>\n<td align=\"center\">SuperGPQA</td>\n<td align=\"center\">Acc</td>\n<td align=\"center\"><strong>57.2</strong></td>\n<td align=\"center\">53.7</td>\n<td align=\"center\">50.2</td>\n<td align=\"center\">55.7</td>\n<td align=\"center\">56.5</td>\n<td align=\"center\">50.8</td>\n<td align=\"center\">49.6</td>\n</tr>\n\n<tr>\n<td align=\"center\">Humanity's Last Exam<br><sup>(Text Only)</sup></td>\n<td align=\"center\">-</td>\n<td align=\"center\">4.7</td>\n<td align=\"center\">5.2</td>\n<td align=\"center\"><ins><strong>5.7</strong></ins></td>\n<td align=\"center\">5.8</td>\n<td align=\"center\"><strong>7.1</strong></td>\n<td align=\"center\">3.7</td>\n<td align=\"center\">5.6</td>\n</tr>\n\n<tr>\n<td align=\"center\" colspan=9><strong>General Tasks</strong></td>\n</tr>\n\n<tr>\n<td align=\"center\">MMLU</td>\n<td align=\"center\">EM</td>\n<td align=\"center\"><ins><strong>89.5</strong></ins></td>\n<td align=\"center\">89.4</td>\n<td align=\"center\">87.0</td>\n<td align=\"center\">91.5</td>\n<td align=\"center\"><strong>92.9</strong></td>\n<td align=\"center\">90.4</td>\n<td align=\"center\">90.1</td>\n</tr>\n\n<tr>\n<td align=\"center\">MMLU-Redux</td>\n<td align=\"center\">EM</td>\n<td align=\"center\"><ins><strong>92.7</strong></ins></td>\n<td align=\"center\">90.5</td>\n<td align=\"center\">89.2</td>\n<td align=\"center\">93.6</td>\n<td align=\"center\"><strong>94.2</strong></td>\n<td align=\"center\">92.4</td>\n<td align=\"center\">90.6</td>\n</tr>\n\n<tr>\n<td align=\"center\">MMLU-Pro</td>\n<td align=\"center\">EM</td>\n<td align=\"center\">81.1</td>\n<td align=\"center\"><ins><strong>81.2</strong></ins><sup>*</sup></td>\n<td align=\"center\">77.3</td>\n<td align=\"center\">83.7</td>\n<td align=\"center\"><strong>86.6</strong></td>\n<td align=\"center\">81.8</td>\n<td align=\"center\">79.4</td>\n</tr>\n\n<tr>\n<td align=\"center\">IFEval</td>\n<td align=\"center\">Prompt Strict</td>\n<td align=\"center\"><strong>89.8</strong></td>\n<td align=\"center\">81.1</td>\n<td align=\"center\">83.2<sup>*</sup></td>\n<td align=\"center\">87.6</td>\n<td align=\"center\">87.4</td>\n<td align=\"center\">88.0</td>\n<td align=\"center\">84.3</td>\n</tr>\n\n<tr>\n<td align=\"center\">Multi-Challenge</td>\n<td align=\"center\">Acc</td>\n<td align=\"center\"><strong>54.1</strong></td>\n<td align=\"center\">31.4</td>\n<td align=\"center\">34.0</td>\n<td align=\"center\">46.8</td>\n<td align=\"center\">49.0</td>\n<td align=\"center\">36.4</td>\n<td align=\"center\">39.5</td>\n</tr>\n\n<tr>\n<td align=\"center\">SimpleQA</td>\n<td align=\"center\">Correct</td>\n<td align=\"center\"><ins><strong>31.0</strong></ins></td>\n<td align=\"center\">27.7</td>\n<td align=\"center\">13.2</td>\n<td align=\"center\">15.9</td>\n<td align=\"center\">22.8</td>\n<td align=\"center\"><strong>42.3</strong></td>\n<td align=\"center\">23.3</td>\n</tr>\n\n<tr>\n<td align=\"center\">Livebench</td>\n<td align=\"center\">Pass@1</td>\n<td align=\"center\"><strong>76.4</strong></td>\n<td align=\"center\">72.4</td>\n<td align=\"center\">67.6</td>\n<td align=\"center\">74.8</td>\n<td align=\"center\">74.6</td>\n<td align=\"center\">69.8</td>\n<td align=\"center\">67.8</td>\n</tr>\n</tbody>\n</table>\n</div>\n<sup>\nâ€¢ Bold denotes global SOTA, and underlined denotes open-source SOTA.\n</sup><br/><sup>\nâ€¢ Data points marked with * are taken directly from the model's tech report or blog.\n</sup><br/><sup>\nâ€¢ All metrics, except for SWE-bench Verified (Agentless), are evaluated with an 8k output token length. SWE-bench Verified (Agentless) is limited to a 16k output token length.\n</sup><br/><sup>\nâ€¢ Kimi K2 achieves 65.8% pass@1 on the SWE-bench Verified tests with bash/editor tools (single-attempt patches, no test-time compute). It also achieves a 47.3% pass@1 on the SWE-bench Multilingual tests under the same conditions. Additionally, we report results on SWE-bench Verified tests (71.6%) that leverage parallel test-time compute by sampling multiple sequences and selecting the single best via an internal scoring model.\n</sup><br/><sup>\nâ€¢ To ensure the stability of the evaluation, we employed avg@k on the AIME, HMMT, CNMO, PolyMath-en, GPQA-Diamond, EvalPlus, Tau2.\n</sup><br/><sup>\nâ€¢ Some data points have been omitted due to prohibitively expensive evaluation costs.\n    </sup>\n\n---\n\n#### Base model evaluation results\n\n<div align=\"center\">\n\n<table>\n<thead>\n<tr>\n<th align=\"center\">Benchmark</th>\n<th align=\"center\">Metric</th>\n<th align=\"center\">Shot</th>\n<th align=\"center\">Kimi K2 Base</th>\n<th align=\"center\">Deepseek-V3-Base</th>\n<th align=\"center\">Qwen2.5-72B</th>\n<th align=\"center\">Llama 4 Maverick</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\" colspan=\"7\"><strong>General Tasks</strong></td>\n</tr>\n<tr>\n<td align=\"center\">MMLU</td>\n<td align=\"center\">EM</td>\n<td align=\"center\">5-shot</td>\n<td align=\"center\"><strong>87.8</strong></td>\n<td align=\"center\">87.1</td>\n<td align=\"center\">86.1</td>\n<td align=\"center\">84.9</td>\n</tr>\n<tr>\n<td align=\"center\">MMLU-pro</td>\n<td align=\"center\">EM</td>\n<td align=\"center\">5-shot</td>\n<td align=\"center\"><strong>69.2</strong></td>\n<td align=\"center\">60.6</td>\n<td align=\"center\">62.8</td>\n<td align=\"center\">63.5</td>\n</tr>\n<tr>\n<td align=\"center\">MMLU-redux-2.0</td>\n<td align=\"center\">EM</td>\n<td align=\"center\">5-shot</td>\n<td align=\"center\"><strong>90.2</strong></td>\n<td align=\"center\">89.5</td>\n<td align=\"center\">87.8</td>\n<td align=\"center\">88.2</td>\n</tr>\n<tr>\n<td align=\"center\">SimpleQA</td>\n<td align=\"center\">Correct</td>\n<td align=\"center\">5-shot</td>\n<td align=\"center\"><strong>35.3</strong></td>\n<td align=\"center\">26.5</td>\n<td align=\"center\">10.3</td>\n<td align=\"center\">23.7</td>\n</tr>\n<tr>\n<td align=\"center\">TriviaQA</td>\n<td align=\"center\">EM</td>\n<td align=\"center\">5-shot</td>\n<td align=\"center\"><strong>85.1</strong></td>\n<td align=\"center\">84.1</td>\n<td align=\"center\">76.0</td>\n<td align=\"center\">79.3</td>\n</tr>\n<tr>\n<td align=\"center\">GPQA-Diamond</td>\n<td align=\"center\">Avg@8</td>\n<td align=\"center\">5-shot</td>\n<td align=\"center\">48.1</td>\n<td align=\"center\"><strong>50.5</strong></td>\n<td align=\"center\">40.8</td>\n<td align=\"center\">49.4</td>\n</tr>\n<tr>\n<td align=\"center\">SuperGPQA</td>\n<td align=\"center\">EM</td>\n<td align=\"center\">5-shot</td>\n<td align=\"center\"><strong>44.7</strong></td>\n<td align=\"center\">39.2</td>\n<td align=\"center\">34.2</td>\n<td align=\"center\">38.8</td>\n</tr>\n<tr>\n<td align=\"center\" colspan=\"7\"><strong>Coding Tasks</strong></td>\n</tr>\n<tr>\n<td align=\"center\">LiveCodeBench v6</td>\n<td align=\"center\">Pass@1</td>\n<td align=\"center\">1-shot</td>\n<td align=\"center\"><strong>26.3</strong></td>\n<td align=\"center\">22.9</td>\n<td align=\"center\">21.1</td>\n<td align=\"center\">25.1</td>\n</tr>\n<tr>\n<td align=\"center\">EvalPlus</td>\n<td align=\"center\">Pass@1</td>\n<td align=\"center\">-</td>\n<td align=\"center\"><strong>80.3</strong></td>\n<td align=\"center\">65.6</td>\n<td align=\"center\">66.0</td>\n<td align=\"center\">65.5</td>\n</tr>\n<tr>\n<td align=\"center\" colspan=\"7\"><strong>Mathematics Tasks</strong></td>\n</tr>\n<tr>\n<td align=\"center\">MATH</td>\n<td align=\"center\">EM</td>\n<td align=\"center\">4-shot</td>\n<td align=\"center\"><strong>70.2</strong></td>\n<td align=\"center\">60.1</td>\n<td align=\"center\">61.0</td>\n<td align=\"center\">63.0</td>\n</tr>\n<tr>\n<td align=\"center\">GSM8k</td>\n<td align=\"center\">EM</td>\n<td align=\"center\">8-shot</td>\n<td align=\"center\"><strong>92.1</strong></td>\n<td align=\"center\">91.7</td>\n<td align=\"center\">90.4</td>\n<td align=\"center\">86.3</td>\n</tr>\n<tr>\n<td align=\"center\" colspan=\"7\"><strong>Chinese Tasks</strong></td>\n</tr>\n<tr>\n<td align=\"center\">C-Eval</td>\n<td align=\"center\">EM</td>\n<td align=\"center\">5-shot</td>\n<td align=\"center\"><strong>92.5</strong></td>\n<td align=\"center\">90.0</td>\n<td align=\"center\">90.9</td>\n<td align=\"center\">80.9</td>\n</tr>\n<tr>\n<td align=\"center\">CSimpleQA</td>\n<td align=\"center\">Correct</td>\n<td align=\"center\">5-shot</td>\n<td align=\"center\"><strong>77.6</strong></td>\n<td align=\"center\">72.1</td>\n<td align=\"center\">50.5</td>\n<td align=\"center\">53.5</td>\n</tr>\n</tbody>\n</table>\n</div>\n<sup>\nâ€¢ We only evaluate open-source pretrained models in this work. We report results for Qwen2.5-72B because the base checkpoint for Qwen3-235B-A22B was not open-sourced at the time of our study.\n</sup><br/><sup>\nâ€¢ All models are evaluated using the same evaluation protocol.\n\n</sup>\n\n\n## 4. Deployment\n> [!Note]\n> You can access Kimi K2's API on https://platform.moonshot.ai , we provide OpenAI/Anthropic-compatible API for you.\n>\n> The Anthropic-compatible API maps temperature by `real_temperature = request_temperature * 0.6` for better compatible with existing applications.\n\nOur model checkpoints are stored in the block-fp8 format, you can find it on [Huggingface](https://huggingface.co/moonshotai/Kimi-K2-Instruct).\n\nCurrently, Kimi-K2 is recommended to run on the following inference engines:\n\n* vLLM\n* SGLang\n* KTransformers\n* TensorRT-LLM\n\nDeployment examples for vLLM and SGLang can be found in the [Model Deployment Guide](docs/deploy_guidance.md).\n\n---\n\n## 5. Model Usage\n\n### Chat Completion\n\nOnce the local inference service is up, you can interact with it through the chat endpoint:\n\n```python\ndef simple_chat(client: OpenAI, model_name: str):\n    messages = [\n        {\"role\": \"system\", \"content\": \"You are Kimi, an AI assistant created by Moonshot AI.\"},\n        {\"role\": \"user\", \"content\": [{\"type\": \"text\", \"text\": \"Please give a brief self-introduction.\"}]},\n    ]\n    response = client.chat.completions.create(\n        model=model_name,\n        messages=messages,\n        stream=False,\n        temperature=0.6,\n        max_tokens=256\n    )\n    print(response.choices[0].message.content)\n```\n\n> [!NOTE]\n> The recommended temperature for Kimi-K2-Instruct is `temperature = 0.6`.\n> If no special instructions are required, the system prompt above is a good default.\n\n---\n\n### Tool Calling\n\nKimi-K2-Instruct has strong tool-calling capabilities.\nTo enable them, you need to pass the list of available tools in each request, then the model will autonomously decide when and how to invoke them.\n\nThe following example demonstrates calling a weather tool end-to-end:\n\n```python\n# Your tool implementation\ndef get_weather(city: str) -> dict:\n    return {\"weather\": \"Sunny\"}\n\n# Tool schema definition\ntools = [{\n    \"type\": \"function\",\n    \"function\": {\n        \"name\": \"get_weather\",\n        \"description\": \"Retrieve current weather information. Call this when the user asks about the weather.\",\n        \"parameters\": {\n            \"type\": \"object\",\n            \"required\": [\"city\"],\n            \"properties\": {\n                \"city\": {\n                    \"type\": \"string\",\n                    \"description\": \"Name of the city\"\n                }\n            }\n        }\n    }\n}]\n\n# Map tool names to their implementations\ntool_map = {\n    \"get_weather\": get_weather\n}\n\ndef tool_call_with_client(client: OpenAI, model_name: str):\n    messages = [\n        {\"role\": \"system\", \"content\": \"You are Kimi, an AI assistant created by Moonshot AI.\"},\n        {\"role\": \"user\", \"content\": \"What's the weather like in Beijing today? Use the tool to check.\"}\n    ]\n    finish_reason = None\n    while finish_reason is None or finish_reason == \"tool_calls\":\n        completion = client.chat.completions.create(\n            model=model_name,\n            messages=messages,\n            temperature=0.6,\n            tools=tools,          # tool list defined above\n            tool_choice=\"auto\"\n        )\n        choice = completion.choices[0]\n        finish_reason = choice.finish_reason\n        if finish_reason == \"tool_calls\":\n            messages.append(choice.message)\n            for tool_call in choice.message.tool_calls:\n                tool_call_name = tool_call.function.name\n                tool_call_arguments = json.loads(tool_call.function.arguments)\n                tool_function = tool_map[tool_call_name]\n                tool_result = tool_function(**tool_call_arguments)\n                print(\"tool_result:\", tool_result)\n\n                messages.append({\n                    \"role\": \"tool\",\n                    \"tool_call_id\": tool_call.id,\n                    \"name\": tool_call_name,\n                    \"content\": json.dumps(tool_result)\n                })\n    print(\"-\" * 100)\n    print(choice.message.content)\n```\n\nThe `tool_call_with_client` function implements the pipeline from user query to tool execution.\nThis pipeline requires the inference engine to support Kimi-K2â€™s native tool-parsing logic.\nFor streaming output and manual tool-parsing, see the [Tool Calling Guide](docs/tool_call_guidance.md).\n\n---\n\n## 6. License\n\nBoth the code repository and the model weights are released under the [Modified MIT License](LICENSE).\n\n---\n\n## 7. Third Party Notices\n\nSee [THIRD PARTY NOTICES](THIRD_PARTY_NOTICES.md)\n\n---\n\n## 7. Contact Us\n\nIf you have any questions, please reach out at [support@moonshot.cn](mailto:support@moonshot.cn).\n",
    "config": "{\n  \"architectures\": [\n    \"DeepseekV3ForCausalLM\"\n  ],\n  \"attention_bias\": false,\n  \"attention_dropout\": 0.0,\n  \"auto_map\": {\n    \"AutoConfig\": \"configuration_deepseek.DeepseekV3Config\",\n    \"AutoModel\": \"modeling_deepseek.DeepseekV3Model\",\n    \"AutoModelForCausalLM\": \"modeling_deepseek.DeepseekV3ForCausalLM\"\n  },\n  \"aux_loss_alpha\": 0.001,\n  \"bos_token_id\": 163584,\n  \"eos_token_id\": 163585,\n  \"first_k_dense_replace\": 1,\n  \"hidden_act\": \"silu\",\n  \"hidden_size\": 7168,\n  \"initializer_range\": 0.02,\n  \"intermediate_size\": 18432,\n  \"kv_lora_rank\": 512,\n  \"max_position_embeddings\": 131072,\n  \"model_type\": \"kimi_k2\",\n  \"moe_intermediate_size\": 2048,\n  \"moe_layer_freq\": 1,\n  \"n_group\": 1,\n  \"n_routed_experts\": 384,\n  \"n_shared_experts\": 1,\n  \"norm_topk_prob\": true,\n  \"num_attention_heads\": 64,\n  \"num_experts_per_tok\": 8,\n  \"num_hidden_layers\": 61,\n  \"num_key_value_heads\": 64,\n  \"num_nextn_predict_layers\": 0,\n  \"pretraining_tp\": 1,\n  \"q_lora_rank\": 1536,\n  \"qk_nope_head_dim\": 128,\n  \"qk_rope_head_dim\": 64,\n  \"quantization_config\": {\n    \"activation_scheme\": \"dynamic\",\n    \"fmt\": \"e4m3\",\n    \"quant_method\": \"fp8\",\n    \"weight_block_size\": [\n      128,\n      128\n    ]\n  },\n  \"rms_norm_eps\": 1e-06,\n  \"rope_theta\": 50000.0,\n  \"routed_scaling_factor\": 2.827,\n  \"rope_scaling\": {\n    \"beta_fast\": 1.0,\n    \"beta_slow\": 1.0,\n    \"factor\": 32.0,\n    \"mscale\": 1.0,\n    \"mscale_all_dim\": 1.0,\n    \"original_max_position_embeddings\": 4096,\n    \"type\": \"yarn\"\n  },\n  \"scoring_func\": \"sigmoid\",\n  \"seq_aux\": true,\n  \"tie_word_embeddings\": false,\n  \"topk_group\": 1,\n  \"topk_method\": \"noaux_tc\",\n  \"torch_dtype\": \"bfloat16\",\n  \"transformers_version\": \"4.48.3\",\n  \"use_cache\": true,\n  \"v_head_dim\": 128,\n  \"vocab_size\": 163840\n}",
    "generation_config": "{\n  \"max_length\": 131072,\n  \"eos_token_id\": 163585\n}",
    "license_file": "Modified MIT License\n\nCopyright (c) 2025 Moonshot AI\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the â€œSoftwareâ€), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED â€œAS ISâ€, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\nOur only modification part is that, if the Software (or any derivative works\nthereof) is used for any of your commercial products or services that have\nmore than 100 million monthly active users, or more than 20 million US dollars\n(or equivalent in other currencies) in monthly revenue, you shall prominently\ndisplay \"Kimi K2\" on the user interface of such product or service.\n",
    "py_files": {
        "configuration_deepseek.py": "# Copy from https://huggingface.co/deepseek-ai/DeepSeek-V3/blob/main/configuration_deepseek.py\n\nfrom transformers.configuration_utils import PretrainedConfig\nfrom transformers.utils import logging\n\nlogger = logging.get_logger(__name__)\n\nDEEPSEEK_PRETRAINED_CONFIG_ARCHIVE_MAP = {}\nclass DeepseekV3Config(PretrainedConfig):\n    r\"\"\"\n    This is the configuration class to store the configuration of a [`DeepseekV3Model`]. It is used to instantiate an DeepSeek\n    model according to the specified arguments, defining the model architecture. Instantiating a configuration with the\n    defaults will yield a similar configuration to that of the DeepSeek-V3.\n\n    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n    documentation from [`PretrainedConfig`] for more information.\n\n\n    Args:\n        vocab_size (`int`, *optional*, defaults to 129280):\n            Vocabulary size of the Deep model. Defines the number of different tokens that can be represented by the\n            `inputs_ids` passed when calling [`DeepseekV3Model`]\n        hidden_size (`int`, *optional*, defaults to 4096):\n            Dimension of the hidden representations.\n        intermediate_size (`int`, *optional*, defaults to 11008):\n            Dimension of the MLP representations.\n        moe_intermediate_size (`int`, *optional*, defaults to 1407):\n            Dimension of the MoE representations.\n        num_hidden_layers (`int`, *optional*, defaults to 32):\n            Number of hidden layers in the Transformer decoder.\n        num_nextn_predict_layers (`int`, *optional*, defaults to 1):\n            Number of nextn predict layers in the DeepSeekV3 Model.\n        num_attention_heads (`int`, *optional*, defaults to 32):\n            Number of attention heads for each attention layer in the Transformer decoder.\n        n_shared_experts (`int`, *optional*, defaults to None):\n            Number of shared experts, None means dense model.\n        n_routed_experts (`int`, *optional*, defaults to None):\n            Number of routed experts, None means dense model.\n        routed_scaling_factor (`float`, *optional*, defaults to 1.0):\n            Scaling factor or routed experts.\n        topk_method (`str`, *optional*, defaults to `gready`):\n            Topk method used in routed gate.\n        n_group (`int`, *optional*, defaults to None):\n            Number of groups for routed experts.\n        topk_group (`int`, *optional*, defaults to None):\n            Number of selected groups for each token(for each token, ensuring the selected experts is only within `topk_group` groups).\n        num_experts_per_tok (`int`, *optional*, defaults to None):\n            Number of selected experts, None means dense model.\n        moe_layer_freq (`int`, *optional*, defaults to 1):\n            The frequency of the MoE layer: one expert layer for every `moe_layer_freq - 1` dense layers.\n        first_k_dense_replace (`int`, *optional*, defaults to 0):\n            Number of dense layers in shallow layers(embed->dense->dense->...->dense->moe->moe...->lm_head).\n                                                            \\--k dense layers--/\n        norm_topk_prob (`bool`, *optional*, defaults to False):\n            Whether to normalize the weights of the routed experts.\n        scoring_func (`str`, *optional*, defaults to 'softmax'):\n            Method of computing expert weights.\n        aux_loss_alpha (`float`, *optional*, defaults to 0.001):\n            Auxiliary loss weight coefficient.\n        seq_aux = (`bool`, *optional*, defaults to True):\n            Whether to compute the auxiliary loss for each individual sample.\n        num_key_value_heads (`int`, *optional*):\n            This is the number of key_value heads that should be used to implement Grouped Query Attention. If\n            `num_key_value_heads=num_attention_heads`, the model will use Multi Head Attention (MHA), if\n            `num_key_value_heads=1 the model will use Multi Query Attention (MQA) otherwise GQA is used. When\n            converting a multi-head checkpoint to a GQA checkpoint, each group key and value head should be constructed\n            by meanpooling all the original heads within that group. For more details checkout [this\n            paper](https://arxiv.org/pdf/2305.13245.pdf). If it is not specified, will default to\n            `num_attention_heads`.\n        hidden_act (`str` or `function`, *optional*, defaults to `\"silu\"`):\n            The non-linear activation function (function or string) in the decoder.\n        max_position_embeddings (`int`, *optional*, defaults to 2048):\n            The maximum sequence length that this model might ever be used with.\n        initializer_range (`float`, *optional*, defaults to 0.02):\n            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n        rms_norm_eps (`float`, *optional*, defaults to 1e-06):\n            The epsilon used by the rms normalization layers.\n        use_cache (`bool`, *optional*, defaults to `True`):\n            Whether or not the model should return the last key/values attentions (not used by all models). Only\n            relevant if `config.is_decoder=True`.\n        pad_token_id (`int`, *optional*):\n            Padding token id.\n        bos_token_id (`int`, *optional*, defaults to 1):\n            Beginning of stream token id.\n        eos_token_id (`int`, *optional*, defaults to 2):\n            End of stream token id.\n        pretraining_tp (`int`, *optional*, defaults to 1):\n            Experimental feature. Tensor parallelism rank used during pretraining. Please refer to [this\n            document](https://huggingface.co/docs/transformers/parallelism) to understand more about it. This value is\n            necessary to ensure exact reproducibility of the pretraining results. Please refer to [this\n            issue](https://github.com/pytorch/pytorch/issues/76232).\n        tie_word_embeddings (`bool`, *optional*, defaults to `False`):\n            Whether to tie weight embeddings\n        rope_theta (`float`, *optional*, defaults to 10000.0):\n            The base period of the RoPE embeddings.\n        rope_scaling (`Dict`, *optional*):\n            Dictionary containing the scaling configuration for the RoPE embeddings. Currently supports two scaling\n            strategies: linear and dynamic. Their scaling factor must be a float greater than 1. The expected format is\n            `{\"type\": strategy name, \"factor\": scaling factor}`. When using this flag, don't update\n            `max_position_embeddings` to the expected new maximum.\n        attention_bias (`bool`, defaults to `False`, *optional*, defaults to `False`):\n            Whether to use a bias in the query, key, value and output projection layers during self-attention.\n        attention_dropout (`float`, *optional*, defaults to 0.0):\n            The dropout ratio for the attention probabilities.\n\n    ```python\n    >>> from transformers import DeepseekV3Model, DeepseekV3Config\n\n    >>> # Initializing a Deepseek-V3 style configuration\n    >>> configuration = DeepseekV3Config()\n\n    >>> # Accessing the model configuration\n    >>> configuration = model.config\n    ```\"\"\"\n\n    model_type = \"deepseek_v3\"\n    keys_to_ignore_at_inference = [\"past_key_values\"]\n\n    def __init__(\n        self,\n        vocab_size=129280,\n        hidden_size=7168,\n        intermediate_size=18432,\n        moe_intermediate_size = 2048,\n        num_hidden_layers=61,\n        num_nextn_predict_layers=1,\n        num_attention_heads=128,\n        num_key_value_heads=128,\n        n_shared_experts = 1,\n        n_routed_experts = 256,\n        ep_size = 1,\n        routed_scaling_factor = 2.5,\n        kv_lora_rank = 512,\n        q_lora_rank = 1536,\n        qk_rope_head_dim = 64,\n        v_head_dim = 128,\n        qk_nope_head_dim = 128,\n        topk_method = 'noaux_tc',\n        n_group = 8,\n        topk_group = 4,\n        num_experts_per_tok = 8,\n        moe_layer_freq = 1,\n        first_k_dense_replace = 3,\n        norm_topk_prob = True,\n        scoring_func = 'sigmoid',\n        aux_loss_alpha = 0.001,\n        seq_aux = True,\n        hidden_act=\"silu\",\n        max_position_embeddings=4096,\n        initializer_range=0.02,\n        rms_norm_eps=1e-6,\n        use_cache=True,\n        pad_token_id=None,\n        bos_token_id=0,\n        eos_token_id=1,\n        pretraining_tp=1,\n        tie_word_embeddings=False,\n        rope_theta=10000.0,\n        rope_scaling=None,\n        attention_bias=False,\n        attention_dropout=0.0,\n        **kwargs,\n    ):\n        self.vocab_size = vocab_size\n        self.max_position_embeddings = max_position_embeddings\n        self.hidden_size = hidden_size\n        self.intermediate_size = intermediate_size\n        self.moe_intermediate_size = moe_intermediate_size\n        self.num_hidden_layers = num_hidden_layers\n        self.num_nextn_predict_layers = num_nextn_predict_layers\n        self.num_attention_heads = num_attention_heads\n        self.n_shared_experts = n_shared_experts\n        self.n_routed_experts = n_routed_experts\n        self.ep_size = ep_size\n        self.routed_scaling_factor = routed_scaling_factor\n        self.kv_lora_rank = kv_lora_rank\n        self.q_lora_rank = q_lora_rank\n        self.qk_rope_head_dim = qk_rope_head_dim\n        self.v_head_dim = v_head_dim\n        self.qk_nope_head_dim = qk_nope_head_dim\n        self.topk_method = topk_method\n        self.n_group = n_group\n        self.topk_group = topk_group\n        self.num_experts_per_tok = num_experts_per_tok\n        self.moe_layer_freq = moe_layer_freq\n        self.first_k_dense_replace = first_k_dense_replace\n        self.norm_topk_prob = norm_topk_prob\n        self.scoring_func = scoring_func\n        self.aux_loss_alpha = aux_loss_alpha\n        self.seq_aux = seq_aux\n        # for backward compatibility\n        if num_key_value_heads is None:\n            num_key_value_heads = num_attention_heads\n\n        self.num_key_value_heads = num_key_value_heads\n        self.hidden_act = hidden_act\n        self.initializer_range = initializer_range\n        self.rms_norm_eps = rms_norm_eps\n        self.pretraining_tp = pretraining_tp\n        self.use_cache = use_cache\n        self.rope_theta = rope_theta\n        self.rope_scaling = rope_scaling\n        self.attention_bias = attention_bias\n        self.attention_dropout = attention_dropout\n\n        super().__init__(\n            pad_token_id=pad_token_id,\n            bos_token_id=bos_token_id,\n            eos_token_id=eos_token_id,\n            tie_word_embeddings=tie_word_embeddings,\n            **kwargs,\n        )",
        "modeling_deepseek.py": "# coding=utf-8\n# Copyright 2023 DeepSeek-AI and The HuggingFace Inc. team. All rights reserved.\n#\n# This code is based on EleutherAI's GPT-NeoX library and the GPT-NeoX\n# and OPT implementations in this library. It has been modified from its\n# original forms to accommodate minor architectural differences compared\n# to GPT-NeoX and OPT used by the Meta AI team that trained the model.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\" PyTorch DeepSeek model.\"\"\"\nimport math\nimport warnings\nfrom typing import List, Optional, Tuple, Union\n\nimport torch\nimport torch.nn.functional as F\nimport torch.utils.checkpoint\nfrom torch import nn\nfrom torch.nn import BCEWithLogitsLoss, CrossEntropyLoss, MSELoss\n\nfrom transformers.activations import ACT2FN\nfrom transformers.cache_utils import Cache, DynamicCache\nfrom transformers.modeling_attn_mask_utils import (\n    AttentionMaskConverter,\n    _prepare_4d_attention_mask,\n    _prepare_4d_causal_attention_mask,\n)\nfrom transformers.modeling_outputs import (\n    BaseModelOutputWithPast,\n    CausalLMOutputWithPast,\n    SequenceClassifierOutputWithPast,\n)\nfrom transformers.modeling_utils import PreTrainedModel\nfrom transformers.pytorch_utils import (\n    ALL_LAYERNORM_LAYERS,\n    is_torch_greater_or_equal_than_1_13,\n)\nfrom transformers.utils import (\n    add_start_docstrings,\n    add_start_docstrings_to_model_forward,\n    is_flash_attn_2_available,\n    is_flash_attn_greater_or_equal_2_10,\n    logging,\n    replace_return_docstrings,\n)\nfrom transformers.utils.import_utils import is_torch_fx_available\nfrom .configuration_deepseek import DeepseekV3Config\nimport torch.distributed as dist\nimport numpy as np\n\nif is_flash_attn_2_available():\n    from flash_attn import flash_attn_func, flash_attn_varlen_func\n    from flash_attn.bert_padding import index_first_axis, pad_input, unpad_input  # noqa\n\n\n# This makes `_prepare_4d_causal_attention_mask` a leaf function in the FX graph.\n# It means that the function will not be traced through and simply appear as a node in the graph.\nif is_torch_fx_available():\n    if not is_torch_greater_or_equal_than_1_13:\n        import torch.fx\n\n    _prepare_4d_causal_attention_mask = torch.fx.wrap(_prepare_4d_causal_attention_mask)\n\n\nlogger = logging.get_logger(__name__)\n\n_CONFIG_FOR_DOC = \"DeepseekV3Config\"\n\n\ndef _get_unpad_data(attention_mask):\n    seqlens_in_batch = attention_mask.sum(dim=-1, dtype=torch.int32)\n    indices = torch.nonzero(attention_mask.flatten(), as_tuple=False).flatten()\n    max_seqlen_in_batch = seqlens_in_batch.max().item()\n    cu_seqlens = F.pad(\n        torch.cumsum(seqlens_in_batch, dim=0, dtype=torch.torch.int32), (1, 0)\n    )\n    return (\n        indices,\n        cu_seqlens,\n        max_seqlen_in_batch,\n    )\n\n\nclass DeepseekV3RMSNorm(nn.Module):\n    def __init__(self, hidden_size, eps=1e-6):\n        \"\"\"\n        DeepseekV3RMSNorm is equivalent to T5LayerNorm\n        \"\"\"\n        super().__init__()\n        self.weight = nn.Parameter(torch.ones(hidden_size))\n        self.variance_epsilon = eps\n\n    def forward(self, hidden_states):\n        input_dtype = hidden_states.dtype\n        hidden_states = hidden_states.to(torch.float32)\n        variance = hidden_states.pow(2).mean(-1, keepdim=True)\n        hidden_states = hidden_states * torch.rsqrt(variance + self.variance_epsilon)\n        return self.weight * hidden_states.to(input_dtype)\n\n\nALL_LAYERNORM_LAYERS.append(DeepseekV3RMSNorm)\n\n\nclass DeepseekV3RotaryEmbedding(nn.Module):\n    def __init__(self, dim, max_position_embeddings=2048, base=10000, device=None):\n        super().__init__()\n\n        self.dim = dim\n        self.max_position_embeddings = max_position_embeddings\n        self.base = base\n        inv_freq = 1.0 / (\n            self.base ** (torch.arange(0, self.dim, 2).float().to(device) / self.dim)\n        )\n        self.register_buffer(\"inv_freq\", inv_freq, persistent=False)\n\n        # Build here to make `torch.jit.trace` work.\n        self._set_cos_sin_cache(\n            seq_len=max_position_embeddings,\n            device=self.inv_freq.device,\n            dtype=torch.get_default_dtype(),\n        )\n        self.max_seq_len_cached = None\n\n    def _set_cos_sin_cache(self, seq_len, device, dtype):\n        self.max_seq_len_cached = seq_len\n        t = torch.arange(\n            self.max_seq_len_cached, device=device, dtype=self.inv_freq.dtype\n        )\n\n        freqs = torch.outer(t, self.inv_freq.to(t.device))\n        # Different from paper, but it uses a different permutation in order to obtain the same calculation\n        emb = torch.cat((freqs, freqs), dim=-1)\n        self.register_buffer(\"cos_cached\", emb.cos().to(dtype), persistent=False)\n        self.register_buffer(\"sin_cached\", emb.sin().to(dtype), persistent=False)\n\n    def forward(self, x, seq_len=None):\n        # x: [bs, num_attention_heads, seq_len, head_size]\n        if self.max_seq_len_cached is None or seq_len > self.max_seq_len_cached:\n            self._set_cos_sin_cache(seq_len=seq_len, device=x.device, dtype=x.dtype)\n\n        return (\n            self.cos_cached[:seq_len].to(dtype=x.dtype),\n            self.sin_cached[:seq_len].to(dtype=x.dtype),\n        )\n\n\n# Copied from transformers.models.llama.modeling_llama.LlamaLinearScalingRotaryEmbedding with Llama->DeepseekV3\nclass DeepseekV3LinearScalingRotaryEmbedding(DeepseekV3RotaryEmbedding):\n    \"\"\"DeepseekV3RotaryEmbedding extended with linear scaling. Credits to the Reddit user /u/kaiokendev\"\"\"\n\n    def __init__(\n        self,\n        dim,\n        max_position_embeddings=2048,\n        base=10000,\n        device=None,\n        scaling_factor=1.0,\n    ):\n        self.scaling_factor = scaling_factor\n        super().__init__(dim, max_position_embeddings, base, device)\n\n    def _set_cos_sin_cache(self, seq_len, device, dtype):\n        self.max_seq_len_cached = seq_len\n        t = torch.arange(\n            self.max_seq_len_cached, device=device, dtype=self.inv_freq.dtype\n        )\n        t = t / self.scaling_factor\n\n        freqs = torch.outer(t, self.inv_freq)\n        # Different from paper, but it uses a different permutation in order to obtain the same calculation\n        emb = torch.cat((freqs, freqs), dim=-1)\n        self.register_buffer(\"cos_cached\", emb.cos().to(dtype), persistent=False)\n        self.register_buffer(\"sin_cached\", emb.sin().to(dtype), persistent=False)\n\n\n# Copied from transformers.models.llama.modeling_llama.LlamaDynamicNTKScalingRotaryEmbedding with Llama->DeepseekV3\nclass DeepseekV3DynamicNTKScalingRotaryEmbedding(DeepseekV3RotaryEmbedding):\n    \"\"\"DeepseekV3RotaryEmbedding extended with Dynamic NTK scaling. Credits to the Reddit users /u/bloc97 and /u/emozilla\"\"\"\n\n    def __init__(\n        self,\n        dim,\n        max_position_embeddings=2048,\n        base=10000,\n        device=None,\n        scaling_factor=1.0,\n    ):\n        self.scaling_factor = scaling_factor\n        super().__init__(dim, max_position_embeddings, base, device)\n\n    def _set_cos_sin_cache(self, seq_len, device, dtype):\n        self.max_seq_len_cached = seq_len\n\n        if seq_len > self.max_position_embeddings:\n            base = self.base * (\n                (self.scaling_factor * seq_len / self.max_position_embeddings)\n                - (self.scaling_factor - 1)\n            ) ** (self.dim / (self.dim - 2))\n            inv_freq = 1.0 / (\n                base ** (torch.arange(0, self.dim, 2).float().to(device) / self.dim)\n            )\n            self.register_buffer(\"inv_freq\", inv_freq, persistent=False)\n\n        t = torch.arange(\n            self.max_seq_len_cached, device=device, dtype=self.inv_freq.dtype\n        )\n\n        freqs = torch.outer(t, self.inv_freq)\n        # Different from paper, but it uses a different permutation in order to obtain the same calculation\n        emb = torch.cat((freqs, freqs), dim=-1)\n        self.register_buffer(\"cos_cached\", emb.cos().to(dtype), persistent=False)\n        self.register_buffer(\"sin_cached\", emb.sin().to(dtype), persistent=False)\n\n\n# Inverse dim formula to find dim based on number of rotations\ndef yarn_find_correction_dim(\n    num_rotations, dim, base=10000, max_position_embeddings=2048\n):\n    return (dim * math.log(max_position_embeddings / (num_rotations * 2 * math.pi))) / (\n        2 * math.log(base)\n    )\n\n\n# Find dim range bounds based on rotations\ndef yarn_find_correction_range(\n    low_rot, high_rot, dim, base=10000, max_position_embeddings=2048\n):\n    low = math.floor(\n        yarn_find_correction_dim(low_rot, dim, base, max_position_embeddings)\n    )\n    high = math.ceil(\n        yarn_find_correction_dim(high_rot, dim, base, max_position_embeddings)\n    )\n    return max(low, 0), min(high, dim - 1)  # Clamp values just in case\n\n\ndef yarn_get_mscale(scale=1, mscale=1):\n    if scale <= 1:\n        return 1.0\n    return 0.1 * mscale * math.log(scale) + 1.0\n\n\ndef yarn_linear_ramp_mask(min, max, dim):\n    if min == max:\n        max += 0.001  # Prevent singularity\n\n    linear_func = (torch.arange(dim, dtype=torch.float32) - min) / (max - min)\n    ramp_func = torch.clamp(linear_func, 0, 1)\n    return ramp_func\n\n\nclass DeepseekV3YarnRotaryEmbedding(DeepseekV3RotaryEmbedding):\n\n    def __init__(\n        self,\n        dim,\n        max_position_embeddings=2048,\n        base=10000,\n        device=None,\n        scaling_factor=1.0,\n        original_max_position_embeddings=4096,\n        beta_fast=32,\n        beta_slow=1,\n        mscale=1,\n        mscale_all_dim=0,\n    ):\n        self.scaling_factor = scaling_factor\n        self.original_max_position_embeddings = original_max_position_embeddings\n        self.beta_fast = beta_fast\n        self.beta_slow = beta_slow\n        self.mscale = mscale\n        self.mscale_all_dim = mscale_all_dim\n        super().__init__(dim, max_position_embeddings, base, device)\n\n    def _set_cos_sin_cache(self, seq_len, device, dtype):\n        self.max_seq_len_cached = seq_len\n        dim = self.dim\n\n        freq_extra = 1.0 / (\n            self.base\n            ** (torch.arange(0, dim, 2, dtype=torch.float32, device=device) / dim)\n        )\n        freq_inter = 1.0 / (\n            self.scaling_factor\n            * self.base\n            ** (torch.arange(0, dim, 2, dtype=torch.float32, device=device) / dim)\n        )\n\n        low, high = yarn_find_correction_range(\n            self.beta_fast,\n            self.beta_slow,\n            dim,\n            self.base,\n            self.original_max_position_embeddings,\n        )\n        inv_freq_mask = 1.0 - yarn_linear_ramp_mask(low, high, dim // 2).to(\n            device=device, dtype=torch.float32\n        )\n        inv_freq = freq_inter * (1 - inv_freq_mask) + freq_extra * inv_freq_mask\n        self.register_buffer(\"inv_freq\", inv_freq, persistent=False)\n\n        t = torch.arange(seq_len, device=device, dtype=torch.float32)\n\n        freqs = torch.outer(t, inv_freq)\n\n        _mscale = float(\n            yarn_get_mscale(self.scaling_factor, self.mscale)\n            / yarn_get_mscale(self.scaling_factor, self.mscale_all_dim)\n        )\n\n        emb = torch.cat((freqs, freqs), dim=-1)\n        self.register_buffer(\n            \"cos_cached\", (emb.cos() * _mscale).to(dtype), persistent=False\n        )\n        self.register_buffer(\n            \"sin_cached\", (emb.sin() * _mscale).to(dtype), persistent=False\n        )\n\n\n# Copied from transformers.models.llama.modeling_llama.rotate_half\ndef rotate_half(x):\n    \"\"\"Rotates half the hidden dims of the input.\"\"\"\n    x1 = x[..., : x.shape[-1] // 2]\n    x2 = x[..., x.shape[-1] // 2 :]\n    return torch.cat((-x2, x1), dim=-1)\n\n\n# Copied from transformers.models.llama.modeling_llama.apply_rotary_pos_emb\ndef apply_rotary_pos_emb(q, k, cos, sin, position_ids, unsqueeze_dim=1):\n    \"\"\"Applies Rotary Position Embedding to the query and key tensors.\n\n    Args:\n        q (`torch.Tensor`): The query tensor.\n        k (`torch.Tensor`): The key tensor.\n        cos (`torch.Tensor`): The cosine part of the rotary embedding.\n        sin (`torch.Tensor`): The sine part of the rotary embedding.\n        position_ids (`torch.Tensor`):\n            The position indices of the tokens corresponding to the query and key tensors. For example, this can be\n            used to pass offsetted position ids when working with a KV-cache.\n        unsqueeze_dim (`int`, *optional*, defaults to 1):\n            The 'unsqueeze_dim' argument specifies the dimension along which to unsqueeze cos[position_ids] and\n            sin[position_ids] so that they can be properly broadcasted to the dimensions of q and k. For example, note\n            that cos[position_ids] and sin[position_ids] have the shape [batch_size, seq_len, head_dim]. Then, if q and\n            k have the shape [batch_size, heads, seq_len, head_dim], then setting unsqueeze_dim=1 makes\n            cos[position_ids] and sin[position_ids] broadcastable to the shapes of q and k. Similarly, if q and k have\n            the shape [batch_size, seq_len, heads, head_dim], then set unsqueeze_dim=2.\n    Returns:\n        `tuple(torch.Tensor)` comprising of the query and key tensors rotated using the Rotary Position Embedding.\n    \"\"\"\n    cos = cos[position_ids].unsqueeze(unsqueeze_dim)\n    sin = sin[position_ids].unsqueeze(unsqueeze_dim)\n\n    b, h, s, d = q.shape\n    q = q.view(b, h, s, d // 2, 2).transpose(4, 3).reshape(b, h, s, d)\n\n    b, h, s, d = k.shape\n    k = k.view(b, h, s, d // 2, 2).transpose(4, 3).reshape(b, h, s, d)\n\n    q_embed = (q * cos) + (rotate_half(q) * sin)\n    k_embed = (k * cos) + (rotate_half(k) * sin)\n    return q_embed, k_embed\n\n\nclass DeepseekV3MLP(nn.Module):\n    def __init__(self, config, hidden_size=None, intermediate_size=None):\n        super().__init__()\n        self.config = config\n        self.hidden_size = config.hidden_size if hidden_size is None else hidden_size\n        self.intermediate_size = (\n            config.intermediate_size if intermediate_size is None else intermediate_size\n        )\n\n        self.gate_proj = nn.Linear(self.hidden_size, self.intermediate_size, bias=False)\n        self.up_proj = nn.Linear(self.hidden_size, self.intermediate_size, bias=False)\n        self.down_proj = nn.Linear(self.intermediate_size, self.hidden_size, bias=False)\n        self.act_fn = ACT2FN[config.hidden_act]\n\n    def forward(self, x):\n        down_proj = self.down_proj(self.act_fn(self.gate_proj(x)) * self.up_proj(x))\n        return down_proj\n\n\nclass MoEGate(nn.Module):\n    def __init__(self, config):\n        super().__init__()\n        self.config = config\n        self.top_k = config.num_experts_per_tok\n        self.n_routed_experts = config.n_routed_experts\n        self.routed_scaling_factor = config.routed_scaling_factor\n        self.scoring_func = config.scoring_func\n        self.seq_aux = config.seq_aux\n        self.topk_method = config.topk_method\n        self.n_group = config.n_group\n        self.topk_group = config.topk_group\n\n        # topk selection algorithm\n        self.norm_topk_prob = config.norm_topk_prob\n        self.gating_dim = config.hidden_size\n        self.weight = nn.Parameter(\n            torch.empty((self.n_routed_experts, self.gating_dim))\n        )\n        if self.topk_method == \"noaux_tc\":\n            self.e_score_correction_bias = nn.Parameter(\n                torch.empty((self.n_routed_experts))\n            )\n        self.reset_parameters()\n\n    def reset_parameters(self) -> None:\n        import torch.nn.init as init\n\n        init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n\n    def forward(self, hidden_states):\n        bsz, seq_len, h = hidden_states.shape\n        ### compute gating score\n        hidden_states = hidden_states.view(-1, h)\n        logits = F.linear(\n            hidden_states.type(torch.float32), self.weight.type(torch.float32), None\n        )\n        if self.scoring_func == \"sigmoid\":\n            scores = logits.sigmoid()\n        else:\n            raise NotImplementedError(\n                f\"insupportable scoring function for MoE gating: {self.scoring_func}\"\n            )\n\n        ### select top-k experts\n        if self.topk_method == \"noaux_tc\":\n            assert not self.training\n            scores_for_choice = scores.view(bsz * seq_len, -1) + self.e_score_correction_bias.unsqueeze(0)\n            group_scores = (\n                scores_for_choice.view(bsz * seq_len, self.n_group, -1).topk(2, dim=-1)[0].sum(dim = -1)\n            )  # [n, n_group]\n            group_idx = torch.topk(\n                group_scores, k=self.topk_group, dim=-1, sorted=False\n            )[\n                1\n            ]  # [n, top_k_group]\n            group_mask = torch.zeros_like(group_scores)  # [n, n_group]\n            group_mask.scatter_(1, group_idx, 1)  # [n, n_group]\n            score_mask = (\n                group_mask.unsqueeze(-1)\n                .expand(\n                    bsz * seq_len, self.n_group, self.n_routed_experts // self.n_group\n                )\n                .reshape(bsz * seq_len, -1)\n            )  # [n, e]\n            tmp_scores = scores_for_choice.masked_fill(~score_mask.bool(), 0.0)  # [n, e]\n            _, topk_idx = torch.topk(\n                tmp_scores, k=self.top_k, dim=-1, sorted=False\n            )\n            topk_weight = scores.gather(1, topk_idx)\n        else:\n            raise NotImplementedError(\n                f\"insupportable TopK function for MoE gating: {self.topk_method}\"\n            )\n\n        ### norm gate to sum 1\n        if self.top_k > 1 and self.norm_topk_prob:\n            denominator = topk_weight.sum(dim=-1, keepdim=True) + 1e-20\n            topk_weight = topk_weight / denominator\n        topk_weight = topk_weight * self.routed_scaling_factor # must multiply the scaling factor\n\n        return topk_idx, topk_weight\n\nclass DeepseekV3MoE(nn.Module):\n    \"\"\"\n    A mixed expert module containing shared experts.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.config = config\n        self.num_experts_per_tok = config.num_experts_per_tok\n\n        if hasattr(config, \"ep_size\") and config.ep_size > 1:\n            assert config.ep_size == dist.get_world_size()\n            self.ep_size = config.ep_size\n            self.experts_per_rank = config.n_routed_experts // config.ep_size\n            self.ep_rank = dist.get_rank()\n            self.experts = nn.ModuleList(\n                [\n                    (\n                        DeepseekV3MLP(\n                            config, intermediate_size=config.moe_intermediate_size\n                        )\n                        if i >= self.ep_rank * self.experts_per_rank\n                        and i < (self.ep_rank + 1) * self.experts_per_rank\n                        else None\n                    )\n                    for i in range(config.n_routed_experts)\n                ]\n            )\n        else:\n            self.ep_size = 1\n            self.experts_per_rank = config.n_routed_experts\n            self.ep_rank = 0\n            self.experts = nn.ModuleList(\n                [\n                    DeepseekV3MLP(\n                        config, intermediate_size=config.moe_intermediate_size\n                    )\n                    for i in range(config.n_routed_experts)\n                ]\n            )\n        self.gate = MoEGate(config)\n        if config.n_shared_experts is not None:\n            intermediate_size = config.moe_intermediate_size * config.n_shared_experts\n            self.shared_experts = DeepseekV3MLP(\n                config=config, intermediate_size=intermediate_size\n            )\n\n    def forward(self, hidden_states):\n        identity = hidden_states\n        orig_shape = hidden_states.shape\n        topk_idx, topk_weight = self.gate(hidden_states)\n        hidden_states = hidden_states.view(-1, hidden_states.shape[-1])\n        flat_topk_idx = topk_idx.view(-1)\n        if not self.training:\n            y = self.moe_infer(hidden_states, topk_idx, topk_weight).view(*orig_shape)\n        if self.config.n_shared_experts is not None:\n            y = y + self.shared_experts(identity)\n        return y\n\n    @torch.no_grad()\n    def moe_infer(self, x, topk_ids, topk_weight):\n        cnts = topk_ids.new_zeros((topk_ids.shape[0], len(self.experts)))\n        cnts.scatter_(1, topk_ids, 1)\n        tokens_per_expert = cnts.sum(dim=0)\n        idxs = topk_ids.view(-1).argsort()\n        sorted_tokens = x[idxs // topk_ids.shape[1]]\n        sorted_tokens_shape = sorted_tokens.shape\n        if self.ep_size > 1:\n            tokens_per_ep_rank = tokens_per_expert.view(self.ep_size, -1).sum(dim=1)\n            tokens_per_expert_group = tokens_per_expert.new_empty(\n                tokens_per_expert.shape[0]\n            )\n            dist.all_to_all_single(tokens_per_expert_group, tokens_per_expert)\n            output_splits = (\n                tokens_per_expert_group.view(self.ep_size, -1)\n                .sum(1)\n                .cpu()\n                .numpy()\n                .tolist()\n            )\n            gathered_tokens = sorted_tokens.new_empty(\n                tokens_per_expert_group.sum(dim=0).cpu().item(), sorted_tokens.shape[1]\n            )\n            input_split_sizes = tokens_per_ep_rank.cpu().numpy().tolist()\n            dist.all_to_all(\n                list(gathered_tokens.split(output_splits)),\n                list(sorted_tokens.split(input_split_sizes)),\n            )\n            tokens_per_expert_post_gather = tokens_per_expert_group.view(\n                self.ep_size, self.experts_per_rank\n            ).sum(dim=0)\n            gatherd_idxs = np.zeros(shape=(gathered_tokens.shape[0],), dtype=np.int32)\n            s = 0\n            for i, k in enumerate(tokens_per_expert_group.cpu().numpy()):\n                gatherd_idxs[s : s + k] = i % self.experts_per_rank\n                s += k\n            gatherd_idxs = gatherd_idxs.argsort()\n            sorted_tokens = gathered_tokens[gatherd_idxs]\n            tokens_per_expert = tokens_per_expert_post_gather\n        tokens_per_expert = tokens_per_expert.cpu().numpy()\n\n        outputs = []\n        start_idx = 0\n        for i, num_tokens in enumerate(tokens_per_expert):\n            end_idx = start_idx + num_tokens\n            if num_tokens == 0:\n                continue\n            expert = self.experts[i + self.ep_rank * self.experts_per_rank]\n            tokens_for_this_expert = sorted_tokens[start_idx:end_idx]\n            expert_out = expert(tokens_for_this_expert)\n            outputs.append(expert_out)\n            start_idx = end_idx\n\n        outs = torch.cat(outputs, dim=0) if len(outputs) else sorted_tokens.new_empty(0)\n        if self.ep_size > 1:\n            new_x = torch.empty_like(outs)\n            new_x[gatherd_idxs] = outs\n            gathered_tokens = new_x.new_empty(*sorted_tokens_shape)\n            dist.all_to_all(\n                list(gathered_tokens.split(input_split_sizes)),\n                list(new_x.split(output_splits)),\n            )\n            outs = gathered_tokens\n\n        new_x = torch.empty_like(outs)\n        new_x[idxs] = outs\n        final_out = (\n            new_x.view(*topk_ids.shape, -1)\n            .type(topk_weight.dtype)\n            .mul_(topk_weight.unsqueeze(dim=-1))\n            .sum(dim=1)\n            .type(new_x.dtype)\n        )\n        return final_out\n\n\n# Copied from transformers.models.llama.modeling_llama.repeat_kv\ndef repeat_kv(hidden_states: torch.Tensor, n_rep: int) -> torch.Tensor:\n    \"\"\"\n    This is the equivalent of torch.repeat_interleave(x, dim=1, repeats=n_rep). The hidden states go from (batch,\n    num_key_value_heads, seqlen, head_dim) to (batch, num_attention_heads, seqlen, head_dim)\n    \"\"\"\n    batch, num_key_value_heads, slen, head_dim = hidden_states.shape\n    if n_rep == 1:\n        return hidden_states\n    hidden_states = hidden_states[:, :, None, :, :].expand(\n        batch, num_key_value_heads, n_rep, slen, head_dim\n    )\n    return hidden_states.reshape(batch, num_key_value_heads * n_rep, slen, head_dim)\n\n\n# Copied from transformers.models.llama.modeling_llama.LlamaAttention with Llama->DeepseekV3\nclass DeepseekV3Attention(nn.Module):\n    \"\"\"Multi-headed attention from 'Attention Is All You Need' paper\"\"\"\n\n    def __init__(self, config: DeepseekV3Config, layer_idx: Optional[int] = None):\n        super().__init__()\n        self.config = config\n        self.layer_idx = layer_idx\n        if layer_idx is None:\n            logger.warning_once(\n                f\"Instantiating {self.__class__.__name__} without passing `layer_idx` is not recommended and will \"\n                \"to errors during the forward call, if caching is used. Please make sure to provide a `layer_idx` \"\n                \"when creating this class.\"\n            )\n\n        self.attention_dropout = config.attention_dropout\n        self.hidden_size = config.hidden_size\n        self.num_heads = config.num_attention_heads\n\n        self.max_position_embeddings = config.max_position_embeddings\n        self.rope_theta = config.rope_theta\n        self.q_lora_rank = config.q_lora_rank\n        self.qk_rope_head_dim = config.qk_rope_head_dim\n        self.kv_lora_rank = config.kv_lora_rank\n        self.v_head_dim = config.v_head_dim\n        self.qk_nope_head_dim = config.qk_nope_head_dim\n        self.q_head_dim = config.qk_nope_head_dim + config.qk_rope_head_dim\n\n        self.is_causal = True\n\n        if self.q_lora_rank is None:\n            self.q_proj = nn.Linear(\n                self.hidden_size, self.num_heads * self.q_head_dim, bias=False\n            )\n        else:\n            self.q_a_proj = nn.Linear(\n                self.hidden_size, config.q_lora_rank, bias=config.attention_bias\n            )\n            self.q_a_layernorm = DeepseekV3RMSNorm(config.q_lora_rank)\n            self.q_b_proj = nn.Linear(\n                config.q_lora_rank, self.num_heads * self.q_head_dim, bias=False\n            )\n\n        self.kv_a_proj_with_mqa = nn.Linear(\n            self.hidden_size,\n            config.kv_lora_rank + config.qk_rope_head_dim,\n            bias=config.attention_bias,\n        )\n        self.kv_a_layernorm = DeepseekV3RMSNorm(config.kv_lora_rank)\n        self.kv_b_proj = nn.Linear(\n            config.kv_lora_rank,\n            self.num_heads\n            * (self.q_head_dim - self.qk_rope_head_dim + self.v_head_dim),\n            bias=False,\n        )\n\n        self.o_proj = nn.Linear(\n            self.num_heads * self.v_head_dim,\n            self.hidden_size,\n            bias=config.attention_bias,\n        )\n        self._init_rope()\n\n        self.softmax_scale = self.q_head_dim ** (-0.5)\n        if self.config.rope_scaling is not None:\n            mscale_all_dim = self.config.rope_scaling.get(\"mscale_all_dim\", 0)\n            scaling_factor = self.config.rope_scaling[\"factor\"]\n            if mscale_all_dim:\n                mscale = yarn_get_mscale(scaling_factor, mscale_all_dim)\n                self.softmax_scale = self.softmax_scale * mscale * mscale\n\n    def _init_rope(self):\n        if self.config.rope_scaling is None:\n            self.rotary_emb = DeepseekV3RotaryEmbedding(\n                self.qk_rope_head_dim,\n                max_position_embeddings=self.max_position_embeddings,\n                base=self.rope_theta,\n            )\n        else:\n            scaling_type = self.config.rope_scaling[\"type\"]\n            scaling_factor = self.config.rope_scaling[\"factor\"]\n            if scaling_type == \"linear\":\n                self.rotary_emb = DeepseekV3LinearScalingRotaryEmbedding(\n                    self.qk_rope_head_dim,\n                    max_position_embeddings=self.max_position_embeddings,\n                    scaling_factor=scaling_factor,\n                    base=self.rope_theta,\n                )\n            elif scaling_type == \"dynamic\":\n                self.rotary_emb = DeepseekV3DynamicNTKScalingRotaryEmbedding(\n                    self.qk_rope_head_dim,\n                    max_position_embeddings=self.max_position_embeddings,\n                    scaling_factor=scaling_factor,\n                    base=self.rope_theta,\n                )\n            elif scaling_type == \"yarn\":\n                kwargs = {\n                    key: self.config.rope_scaling[key]\n                    for key in [\n                        \"original_max_position_embeddings\",\n                        \"beta_fast\",\n                        \"beta_slow\",\n                        \"mscale\",\n                        \"mscale_all_dim\",\n                    ]\n                    if key in self.config.rope_scaling\n                }\n                self.rotary_emb = DeepseekV3YarnRotaryEmbedding(\n                    self.qk_rope_head_dim,\n                    max_position_embeddings=self.max_position_embeddings,\n                    scaling_factor=scaling_factor,\n                    base=self.rope_theta,\n                    **kwargs,\n                )\n            else:\n                raise ValueError(f\"Unknown RoPE scaling type {scaling_type}\")\n\n    def _shape(self, tensor: torch.Tensor, seq_len: int, bsz: int):\n        return (\n            tensor.view(bsz, seq_len, self.num_heads, self.v_head_dim)\n            .transpose(1, 2)\n            .contiguous()\n        )\n\n    def forward(\n        self,\n        hidden_states: torch.Tensor,\n        attention_mask: Optional[torch.Tensor] = None,\n        position_ids: Optional[torch.LongTensor] = None,\n        past_key_value: Optional[Cache] = None,\n        output_attentions: bool = False,\n        use_cache: bool = False,\n        **kwargs,\n    ) -> Tuple[torch.Tensor, Optional[torch.Tensor], Optional[Tuple[torch.Tensor]]]:\n        if \"padding_mask\" in kwargs:\n            warnings.warn(\n                \"Passing `padding_mask` is deprecated and will be removed in v4.37. Please make sure use `attention_mask` instead.`\"\n            )\n        bsz, q_len, _ = hidden_states.size()\n\n        if self.q_lora_rank is None:\n            q = self.q_proj(hidden_states)\n        else:\n            q = self.q_b_proj(self.q_a_layernorm(self.q_a_proj(hidden_states)))\n        q = q.view(bsz, q_len, self.num_heads, self.q_head_dim).transpose(1, 2)\n        q_nope, q_pe = torch.split(\n            q, [self.qk_nope_head_dim, self.qk_rope_head_dim], dim=-1\n        )\n\n        compressed_kv = self.kv_a_proj_with_mqa(hidden_states)\n        compressed_kv, k_pe = torch.split(\n            compressed_kv, [self.kv_lora_rank, self.qk_rope_head_dim], dim=-1\n        )\n        k_pe = k_pe.view(bsz, q_len, 1, self.qk_rope_head_dim).transpose(1, 2)\n        kv = (\n            self.kv_b_proj(self.kv_a_layernorm(compressed_kv))\n            .view(bsz, q_len, self.num_heads, self.qk_nope_head_dim + self.v_head_dim)\n            .transpose(1, 2)\n        )\n\n        k_nope, value_states = torch.split(\n            kv, [self.qk_nope_head_dim, self.v_head_dim], dim=-1\n        )\n        kv_seq_len = value_states.shape[-2]\n        if past_key_value is not None:\n            if self.layer_idx is None:\n                raise ValueError(\n                    f\"The cache structure has changed since version v4.36. If you are using {self.__class__.__name__} \"\n                    \"for auto-regressive decoding with k/v caching, please make sure to initialize the attention class \"\n                    \"with a layer index.\"\n                )\n            kv_seq_len += past_key_value.get_usable_length(kv_seq_len, self.layer_idx)\n        cos, sin = self.rotary_emb(value_states, seq_len=kv_seq_len)\n\n        q_pe, k_pe = apply_rotary_pos_emb(q_pe, k_pe, cos, sin, position_ids)\n\n        query_states = k_pe.new_empty(bsz, self.num_heads, q_len, self.q_head_dim)\n        query_states[:, :, :, : self.qk_nope_head_dim] = q_nope\n        query_states[:, :, :, self.qk_nope_head_dim :] = q_pe\n\n        key_states = k_pe.new_empty(bsz, self.num_heads, q_len, self.q_head_dim)\n        key_states[:, :, :, : self.qk_nope_head_dim] = k_nope\n        key_states[:, :, :, self.qk_nope_head_dim :] = k_pe\n        if past_key_value is not None:\n            cache_kwargs = {\"sin\": sin, \"cos\": cos}  # Specific to RoPE models\n            key_states, value_states = past_key_value.update(\n                key_states, value_states, self.layer_idx, cache_kwargs\n            )\n\n        attn_weights = (\n            torch.matmul(query_states, key_states.transpose(2, 3)) * self.softmax_scale\n        )\n\n        if attn_weights.size() != (bsz, self.num_heads, q_len, kv_seq_len):\n            raise ValueError(\n                f\"Attention weights should be of size {(bsz, self.num_heads, q_len, kv_seq_len)}, but is\"\n                f\" {attn_weights.size()}\"\n            )\n        assert attention_mask is not None\n        if attention_mask is not None:\n            if attention_mask.size() != (bsz, 1, q_len, kv_seq_len):\n                raise ValueError(\n                    f\"Attention mask should be of size {(bsz, 1, q_len, kv_seq_len)}, but is {attention_mask.size()}\"\n                )\n            attn_weights = attn_weights + attention_mask\n\n        # upcast attention to fp32\n        attn_weights = nn.functional.softmax(\n            attn_weights, dim=-1, dtype=torch.float32\n        ).to(query_states.dtype)\n        attn_weights = nn.functional.dropout(\n            attn_weights, p=self.attention_dropout, training=self.training\n        )\n        attn_output = torch.matmul(attn_weights, value_states)\n\n        if attn_output.size() != (bsz, self.num_heads, q_len, self.v_head_dim):\n            raise ValueError(\n                f\"`attn_output` should be of size {(bsz, self.num_heads, q_len, self.v_head_dim)}, but is\"\n                f\" {attn_output.size()}\"\n            )\n\n        attn_output = attn_output.transpose(1, 2).contiguous()\n\n        attn_output = attn_output.reshape(bsz, q_len, self.num_heads * self.v_head_dim)\n\n        attn_output = self.o_proj(attn_output)\n\n        if not output_attentions:\n            attn_weights = None\n\n        return attn_output, attn_weights, past_key_value\n\n\n# Copied from transformers.models.llama.modeling_llama.LlamaFlashAttention2 with Llama->DeepseekV3\nclass DeepseekV3FlashAttention2(DeepseekV3Attention):\n    \"\"\"\n    DeepseekV3 flash attention module. This module inherits from `DeepseekV3Attention` as the weights of the module stays\n    untouched. The only required change would be on the forward pass where it needs to correctly call the public API of\n    flash attention and deal with padding tokens in case the input contains any of them.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        # TODO: Should be removed once Flash Attention for RoCm is bumped to 2.1.\n        # flash_attn<2.1 generates top-left aligned causal mask, while what is needed here is bottom-right alignement, that was made default for flash_attn>=2.1. This attribute is used to handle this difference. Reference: https://github.com/Dao-AILab/flash-attention/releases/tag/v2.1.0.\n        # Beware that with flash_attn<2.1, using q_seqlen != k_seqlen (except for the case q_seqlen == 1) produces a wrong mask (top-left).\n        self._flash_attn_uses_top_left_mask = not is_flash_attn_greater_or_equal_2_10()\n\n    def forward(\n        self,\n        hidden_states: torch.Tensor,\n        attention_mask: Optional[torch.LongTensor] = None,\n        position_ids: Optional[torch.LongTensor] = None,\n        past_key_value: Optional[Cache] = None,\n        output_attentions: bool = False,\n        use_cache: bool = False,\n        **kwargs,\n    ) -> Tuple[torch.Tensor, Optional[torch.Tensor], Optional[Tuple[torch.Tensor]]]:\n        # DeepseekV3FlashAttention2 attention does not support output_attentions\n        if \"padding_mask\" in kwargs:\n            warnings.warn(\n                \"Passing `padding_mask` is deprecated and will be removed in v4.37. Please make sure use `attention_mask` instead.`\"\n            )\n\n            # overwrite attention_mask with padding_mask\n            attention_mask = kwargs.pop(\"padding_mask\")\n\n        output_attentions = False\n\n        bsz, q_len, _ = hidden_states.size()\n\n        if self.q_lora_rank is None:\n            q = self.q_proj(hidden_states)\n        else:\n            q = self.q_b_proj(self.q_a_layernorm(self.q_a_proj(hidden_states)))\n        q = q.view(bsz, q_len, self.num_heads, self.q_head_dim).transpose(1, 2)\n        q_nope, q_pe = torch.split(\n            q, [self.qk_nope_head_dim, self.qk_rope_head_dim], dim=-1\n        )\n\n        # Flash attention requires the input to have the shape\n        # batch_size x seq_length x head_dim x hidden_dim\n        # therefore we just need to keep the original shape\n        compressed_kv = self.kv_a_proj_with_mqa(hidden_states)\n        compressed_kv, k_pe = torch.split(\n            compressed_kv, [self.kv_lora_rank, self.qk_rope_head_dim], dim=-1\n        )\n        k_pe = k_pe.view(bsz, q_len, 1, self.qk_rope_head_dim).transpose(1, 2)\n        kv = (\n            self.kv_b_proj(self.kv_a_layernorm(compressed_kv))\n            .view(bsz, q_len, self.num_heads, self.qk_nope_head_dim + self.v_head_dim)\n            .transpose(1, 2)\n        )\n\n        k_nope, value_states = torch.split(\n            kv, [self.qk_nope_head_dim, self.v_head_dim], dim=-1\n        )\n        kv_seq_len = value_states.shape[-2]\n\n        kv_seq_len = value_states.shape[-2]\n        if past_key_value is not None:\n            kv_seq_len += past_key_value.get_usable_length(kv_seq_len, self.layer_idx)\n\n        cos, sin = self.rotary_emb(value_states, seq_len=kv_seq_len)\n        q_pe, k_pe = apply_rotary_pos_emb(q_pe, k_pe, cos, sin, position_ids)\n\n        query_states = k_pe.new_empty(bsz, self.num_heads, q_len, self.q_head_dim)\n        query_states[:, :, :, : self.qk_nope_head_dim] = q_nope\n        query_states[:, :, :, self.qk_nope_head_dim :] = q_pe\n\n        key_states = k_pe.new_empty(bsz, self.num_heads, q_len, self.q_head_dim)\n        key_states[:, :, :, : self.qk_nope_head_dim] = k_nope\n        key_states[:, :, :, self.qk_nope_head_dim :] = k_pe\n\n        if self.q_head_dim != self.v_head_dim:\n            value_states = F.pad(value_states, [0, self.q_head_dim - self.v_head_dim])\n\n        if past_key_value is not None:\n            cache_kwargs = {\"sin\": sin, \"cos\": cos}  # Specific to RoPE models\n            key_states, value_states = past_key_value.update(\n                key_states, value_states, self.layer_idx, cache_kwargs\n            )\n\n        # TODO: These transpose are quite inefficient but Flash Attention requires the layout [batch_size, sequence_length, num_heads, head_dim]. We would need to refactor the KV cache\n        # to be able to avoid many of these transpose/reshape/view.\n        query_states = query_states.transpose(1, 2)\n        key_states = key_states.transpose(1, 2)\n        value_states = value_states.transpose(1, 2)\n\n        dropout_rate = self.attention_dropout if self.training else 0.0\n\n        # In PEFT, usually we cast the layer norms in float32 for training stability reasons\n        # therefore the input hidden states gets silently casted in float32. Hence, we need\n        # cast them back in the correct dtype just to be sure everything works as expected.\n        # This might slowdown training & inference so it is recommended to not cast the LayerNorms\n        # in fp32. (DeepseekV3RMSNorm handles it correctly)\n\n        input_dtype = query_states.dtype\n        if input_dtype == torch.float32:\n            # Handle the case where the model is quantized\n            if hasattr(self.config, \"_pre_quantization_dtype\"):\n                target_dtype = self.config._pre_quantization_dtype\n            elif torch.is_autocast_enabled():\n                target_dtype = torch.get_autocast_gpu_dtype()\n            else:\n                target_dtype = (\n                    self.q_proj.weight.dtype\n                    if self.q_lora_rank is None\n                    else self.q_a_proj.weight.dtype\n                )\n\n            logger.warning_once(\n                f\"The input hidden states seems to be silently casted in float32, this might be related to\"\n                f\" the fact you have upcasted embedding or layer norm layers in float32. We will cast back the input in\"\n                f\" {target_dtype}.\"\n            )\n\n            query_states = query_states.to(target_dtype)\n            key_states = key_states.to(target_dtype)\n            value_states = value_states.to(target_dtype)\n\n        attn_output = self._flash_attention_forward(\n            query_states,\n            key_states,\n            value_states,\n            attention_mask,\n            q_len,\n            dropout=dropout_rate,\n            softmax_scale=self.softmax_scale,\n        )\n        if self.q_head_dim != self.v_head_dim:\n            attn_output = attn_output[:, :, :, : self.v_head_dim]\n\n        attn_output = attn_output.reshape(\n            bsz, q_len, self.num_heads * self.v_head_dim\n        ).contiguous()\n        attn_output = self.o_proj(attn_output)\n\n        if not output_attentions:\n            attn_weights = None\n\n        return attn_output, attn_weights, past_key_value\n\n    def _flash_attention_forward(\n        self,\n        query_states,\n        key_states,\n        value_states,\n        attention_mask,\n        query_length,\n        dropout=0.0,\n        softmax_scale=None,\n    ):\n        \"\"\"\n        Calls the forward method of Flash Attention - if the input hidden states contain at least one padding token\n        first unpad the input, then computes the attention scores and pad the final attention scores.\n\n        Args:\n            query_states (`torch.Tensor`):\n                Input query states to be passed to Flash Attention API\n            key_states (`torch.Tensor`):\n                Input key states to be passed to Flash Attention API\n            value_states (`torch.Tensor`):\n                Input value states to be passed to Flash Attention API\n            attention_mask (`torch.Tensor`):\n                The padding mask - corresponds to a tensor of size `(batch_size, seq_len)` where 0 stands for the\n                position of padding tokens and 1 for the position of non-padding tokens.\n            dropout (`int`, *optional*):\n                Attention dropout\n            softmax_scale (`float`, *optional*):\n                The scaling of QK^T before applying softmax. Default to 1 / sqrt(head_dim)\n        \"\"\"\n        if not self._flash_attn_uses_top_left_mask:\n            causal = self.is_causal\n        else:\n            # TODO: Remove the `query_length != 1` check once Flash Attention for RoCm is bumped to 2.1. For details, please see the comment in DeepseekV3FlashAttention2 __init__.\n            causal = self.is_causal and query_length != 1\n\n        # Contains at least one padding token in the sequence\n        if attention_mask is not None:\n            batch_size = query_states.shape[0]\n            (\n                query_states,\n                key_states,\n                value_states,\n                indices_q,\n                cu_seq_lens,\n                max_seq_lens,\n            ) = self._upad_input(\n                query_states, key_states, value_states, attention_mask, query_length\n            )\n\n            cu_seqlens_q, cu_seqlens_k = cu_seq_lens\n            max_seqlen_in_batch_q, max_seqlen_in_batch_k = max_seq_lens\n\n            attn_output_unpad = flash_attn_varlen_func(\n                query_states,\n                key_states,\n                value_states,\n                cu_seqlens_q=cu_seqlens_q,\n                cu_seqlens_k=cu_seqlens_k,\n                max_seqlen_q=max_seqlen_in_batch_q,\n                max_seqlen_k=max_seqlen_in_batch_k,\n                dropout_p=dropout,\n                softmax_scale=softmax_scale,\n                causal=causal,\n            )\n\n            attn_output = pad_input(\n                attn_output_unpad, indices_q, batch_size, query_length\n            )\n        else:\n            attn_output = flash_attn_func(\n                query_states,\n                key_states,\n                value_states,\n                dropout,\n                softmax_scale=softmax_scale,\n                causal=causal,\n            )\n\n        return attn_output\n\n    def _upad_input(\n        self, query_layer, key_layer, value_layer, attention_mask, query_length\n    ):\n        indices_k, cu_seqlens_k, max_seqlen_in_batch_k = _get_unpad_data(attention_mask)\n        batch_size, kv_seq_len, num_key_value_heads, head_dim = key_layer.shape\n\n        key_layer = index_first_axis(\n            key_layer.reshape(batch_size * kv_seq_len, num_key_value_heads, head_dim),\n            indices_k,\n        )\n        value_layer = index_first_axis(\n            value_layer.reshape(batch_size * kv_seq_len, num_key_value_heads, head_dim),\n            indices_k,\n        )\n        if query_length == kv_seq_len:\n            query_layer = index_first_axis(\n                query_layer.reshape(batch_size * kv_seq_len, self.num_heads, head_dim),\n                indices_k,\n            )\n            cu_seqlens_q = cu_seqlens_k\n            max_seqlen_in_batch_q = max_seqlen_in_batch_k\n            indices_q = indices_k\n        elif query_length == 1:\n            max_seqlen_in_batch_q = 1\n            cu_seqlens_q = torch.arange(\n                batch_size + 1, dtype=torch.int32, device=query_layer.device\n            )  # There is a memcpy here, that is very bad.\n            indices_q = cu_seqlens_q[:-1]\n            query_layer = query_layer.squeeze(1)\n        else:\n            # The -q_len: slice assumes left padding.\n            attention_mask = attention_mask[:, -query_length:]\n            query_layer, indices_q, cu_seqlens_q, max_seqlen_in_batch_q = unpad_input(\n                query_layer, attention_mask\n            )\n\n        return (\n            query_layer,\n            key_layer,\n            value_layer,\n            indices_q,\n            (cu_seqlens_q, cu_seqlens_k),\n            (max_seqlen_in_batch_q, max_seqlen_in_batch_k),\n        )\n\n\nATTENTION_CLASSES = {\n    \"eager\": DeepseekV3Attention,\n    \"flash_attention_2\": DeepseekV3FlashAttention2,\n}\n\n\nclass DeepseekV3DecoderLayer(nn.Module):\n    def __init__(self, config: DeepseekV3Config, layer_idx: int):\n        super().__init__()\n        self.hidden_size = config.hidden_size\n\n        self.self_attn = ATTENTION_CLASSES[config._attn_implementation](\n            config=config, layer_idx=layer_idx\n        )\n\n        self.mlp = (\n            DeepseekV3MoE(config)\n            if (\n                config.n_routed_experts is not None\n                and layer_idx >= config.first_k_dense_replace\n                and layer_idx % config.moe_layer_freq == 0\n            )\n            else DeepseekV3MLP(config)\n        )\n        self.input_layernorm = DeepseekV3RMSNorm(\n            config.hidden_size, eps=config.rms_norm_eps\n        )\n        self.post_attention_layernorm = DeepseekV3RMSNorm(\n            config.hidden_size, eps=config.rms_norm_eps\n        )\n\n    def forward(\n        self,\n        hidden_states: torch.Tensor,\n        attention_mask: Optional[torch.Tensor] = None,\n        position_ids: Optional[torch.LongTensor] = None,\n        past_key_value: Optional[Tuple[torch.Tensor]] = None,\n        output_attentions: Optional[bool] = False,\n        use_cache: Optional[bool] = False,\n        **kwargs,\n    ) -> Tuple[\n        torch.FloatTensor, Optional[Tuple[torch.FloatTensor, torch.FloatTensor]]\n    ]:\n        \"\"\"\n        Args:\n            hidden_states (`torch.FloatTensor`): input to the layer of shape `(batch, seq_len, embed_dim)`\n            attention_mask (`torch.FloatTensor`, *optional*):\n                attention mask of size `(batch_size, sequence_length)` if flash attention is used or `(batch_size, 1,\n                query_sequence_length, key_sequence_length)` if default attention is used.\n            output_attentions (`bool`, *optional*):\n                Whether or not to return the attentions tensors of all attention layers. See `attentions` under\n                returned tensors for more detail.\n            use_cache (`bool`, *optional*):\n                If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding\n                (see `past_key_values`).\n            past_key_value (`Tuple(torch.FloatTensor)`, *optional*): cached past key and value projection states\n        \"\"\"\n        if \"padding_mask\" in kwargs:\n            warnings.warn(\n                \"Passing `padding_mask` is deprecated and will be removed in v4.37. Please make sure use `attention_mask` instead.`\"\n            )\n        residual = hidden_states\n\n        hidden_states = self.input_layernorm(hidden_states)\n\n        # Self Attention\n        hidden_states, self_attn_weights, present_key_value = self.self_attn(\n            hidden_states=hidden_states,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            past_key_value=past_key_value,\n            output_attentions=output_attentions,\n            use_cache=use_cache,\n            **kwargs,\n        )\n        hidden_states = residual + hidden_states\n\n        # Fully Connected\n        residual = hidden_states\n        hidden_states = self.post_attention_layernorm(hidden_states)\n        hidden_states = self.mlp(hidden_states)\n        hidden_states = residual + hidden_states\n\n        outputs = (hidden_states,)\n\n        if output_attentions:\n            outputs += (self_attn_weights,)\n\n        if use_cache:\n            outputs += (present_key_value,)\n\n        return outputs\n\n\nDeepseekV3_START_DOCSTRING = r\"\"\"\n    This model inherits from [`PreTrainedModel`]. Check the superclass documentation for the generic methods the\n    library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads\n    etc.)\n\n    This model is also a PyTorch [torch.nn.Module](https://pytorch.org/docs/stable/nn.html#torch.nn.Module) subclass.\n    Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage\n    and behavior.\n\n    Parameters:\n        config ([`DeepseekV3Config`]):\n            Model configuration class with all the parameters of the model. Initializing with a config file does not\n            load the weights associated with the model, only the configuration. Check out the\n            [`~PreTrainedModel.from_pretrained`] method to load the model weights.\n\"\"\"\n\n\n@add_start_docstrings(\n    \"The bare DeepseekV3 Model outputting raw hidden-states without any specific head on top.\",\n    DeepseekV3_START_DOCSTRING,\n)\nclass DeepseekV3PreTrainedModel(PreTrainedModel):\n    config_class = DeepseekV3Config\n    base_model_prefix = \"model\"\n    supports_gradient_checkpointing = True\n    _no_split_modules = [\"DeepseekV3DecoderLayer\"]\n    _skip_keys_device_placement = \"past_key_values\"\n    _supports_flash_attn_2 = True\n    _supports_cache_class = True\n\n    def _init_weights(self, module):\n        std = self.config.initializer_range\n        if isinstance(module, nn.Linear):\n            module.weight.data.normal_(mean=0.0, std=std)\n            if module.bias is not None:\n                module.bias.data.zero_()\n        elif isinstance(module, nn.Embedding):\n            module.weight.data.normal_(mean=0.0, std=std)\n            if module.padding_idx is not None:\n                module.weight.data[module.padding_idx].zero_()\n\n\nDeepseekV3_INPUTS_DOCSTRING = r\"\"\"\n    Args:\n        input_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`):\n            Indices of input sequence tokens in the vocabulary. Padding will be ignored by default should you provide\n            it.\n\n            Indices can be obtained using [`AutoTokenizer`]. See [`PreTrainedTokenizer.encode`] and\n            [`PreTrainedTokenizer.__call__`] for details.\n\n            [What are input IDs?](../glossary#input-ids)\n        attention_mask (`torch.Tensor` of shape `(batch_size, sequence_length)`, *optional*):\n            Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:\n\n            - 1 for tokens that are **not masked**,\n            - 0 for tokens that are **masked**.\n\n            [What are attention masks?](../glossary#attention-mask)\n\n            Indices can be obtained using [`AutoTokenizer`]. See [`PreTrainedTokenizer.encode`] and\n            [`PreTrainedTokenizer.__call__`] for details.\n\n            If `past_key_values` is used, optionally only the last `input_ids` have to be input (see\n            `past_key_values`).\n\n            If you want to change padding behavior, you should read [`modeling_opt._prepare_decoder_attention_mask`]\n            and modify to your needs. See diagram 1 in [the paper](https://arxiv.org/abs/1910.13461) for more\n            information on the default strategy.\n\n            - 1 indicates the head is **not masked**,\n            - 0 indicates the head is **masked**.\n        position_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n            Indices of positions of each input sequence tokens in the position embeddings. Selected in the range `[0,\n            config.n_positions - 1]`.\n\n            [What are position IDs?](../glossary#position-ids)\n        past_key_values (`Cache` or `tuple(tuple(torch.FloatTensor))`, *optional*):\n            Pre-computed hidden-states (key and values in the self-attention blocks and in the cross-attention\n            blocks) that can be used to speed up sequential decoding. This typically consists in the `past_key_values`\n            returned by the model at a previous stage of decoding, when `use_cache=True` or `config.use_cache=True`.\n\n            Two formats are allowed:\n            - a [`~cache_utils.Cache`] instance;\n            - Tuple of `tuple(torch.FloatTensor)` of length `config.n_layers`, with each tuple having 2 tensors of\n            shape `(batch_size, num_heads, sequence_length, embed_size_per_head)`). This is also known as the legacy\n            cache format.\n\n            The model will output the same cache format that is fed as input. If no `past_key_values` are passed, the\n            legacy cache format will be returned.\n\n            If `past_key_values` are used, the user can optionally input only the last `input_ids` (those that don't\n            have their past key value states given to this model) of shape `(batch_size, 1)` instead of all `input_ids`\n            of shape `(batch_size, sequence_length)`.\n        inputs_embeds (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*):\n            Optionally, instead of passing `input_ids` you can choose to directly pass an embedded representation. This\n            is useful if you want more control over how to convert `input_ids` indices into associated vectors than the\n            model's internal embedding lookup matrix.\n        use_cache (`bool`, *optional*):\n            If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding (see\n            `past_key_values`).\n        output_attentions (`bool`, *optional*):\n            Whether or not to return the attentions tensors of all attention layers. See `attentions` under returned\n            tensors for more detail.\n        output_hidden_states (`bool`, *optional*):\n            Whether or not to return the hidden states of all layers. See `hidden_states` under returned tensors for\n            more detail.\n        return_dict (`bool`, *optional*):\n            Whether or not to return a [`~utils.ModelOutput`] instead of a plain tuple.\n\"\"\"\n\n\n@add_start_docstrings(\n    \"The bare DeepseekV3 Model outputting raw hidden-states without any specific head on top.\",\n    DeepseekV3_START_DOCSTRING,\n)\nclass DeepseekV3Model(DeepseekV3PreTrainedModel):\n    \"\"\"\n    Transformer decoder consisting of *config.num_hidden_layers* layers. Each layer is a [`DeepseekV3DecoderLayer`]\n\n    Args:\n        config: DeepseekV3Config\n    \"\"\"\n\n    def __init__(self, config: DeepseekV3Config):\n        super().__init__(config)\n        self.padding_idx = config.pad_token_id\n        self.vocab_size = config.vocab_size\n\n        self.embed_tokens = nn.Embedding(\n            config.vocab_size, config.hidden_size, self.padding_idx\n        )\n        self.layers = nn.ModuleList(\n            [\n                DeepseekV3DecoderLayer(config, layer_idx)\n                for layer_idx in range(config.num_hidden_layers)\n            ]\n        )\n        self._use_flash_attention_2 = config._attn_implementation == \"flash_attention_2\"\n        self.norm = DeepseekV3RMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n\n        self.gradient_checkpointing = False\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def get_input_embeddings(self):\n        return self.embed_tokens\n\n    def set_input_embeddings(self, value):\n        self.embed_tokens = value\n\n    @add_start_docstrings_to_model_forward(DeepseekV3_INPUTS_DOCSTRING)\n    def forward(\n        self,\n        input_ids: torch.LongTensor = None,\n        attention_mask: Optional[torch.Tensor] = None,\n        position_ids: Optional[torch.LongTensor] = None,\n        past_key_values: Optional[List[torch.FloatTensor]] = None,\n        inputs_embeds: Optional[torch.FloatTensor] = None,\n        use_cache: Optional[bool] = None,\n        output_attentions: Optional[bool] = None,\n        output_hidden_states: Optional[bool] = None,\n        return_dict: Optional[bool] = None,\n    ) -> Union[Tuple, BaseModelOutputWithPast]:\n        output_attentions = (\n            output_attentions\n            if output_attentions is not None\n            else self.config.output_attentions\n        )\n        output_hidden_states = (\n            output_hidden_states\n            if output_hidden_states is not None\n            else self.config.output_hidden_states\n        )\n        use_cache = use_cache if use_cache is not None else self.config.use_cache\n\n        return_dict = (\n            return_dict if return_dict is not None else self.config.use_return_dict\n        )\n\n        # retrieve input_ids and inputs_embeds\n        if input_ids is not None and inputs_embeds is not None:\n            raise ValueError(\n                \"You cannot specify both input_ids and inputs_embeds at the same time\"\n            )\n        elif input_ids is not None:\n            batch_size, seq_length = input_ids.shape[:2]\n        elif inputs_embeds is not None:\n            batch_size, seq_length = inputs_embeds.shape[:2]\n        else:\n            raise ValueError(\"You have to specify either input_ids or inputs_embeds\")\n\n        past_key_values_length = 0\n        if use_cache:\n            use_legacy_cache = not isinstance(past_key_values, Cache)\n            if use_legacy_cache:\n                past_key_values = DynamicCache.from_legacy_cache(past_key_values)\n            past_key_values_length = past_key_values.get_usable_length(seq_length)\n\n        if position_ids is None:\n            device = input_ids.device if input_ids is not None else inputs_embeds.device\n            position_ids = torch.arange(\n                past_key_values_length,\n                seq_length + past_key_values_length,\n                dtype=torch.long,\n                device=device,\n            )\n            position_ids = position_ids.unsqueeze(0)\n\n        if inputs_embeds is None:\n            inputs_embeds = self.embed_tokens(input_ids)\n\n        if self._use_flash_attention_2:\n            # 2d mask is passed through the layers\n            attention_mask = (\n                attention_mask\n                if (attention_mask is not None and 0 in attention_mask)\n                else None\n            )\n        else:\n            # 4d mask is passed through the layers\n            attention_mask = _prepare_4d_causal_attention_mask(\n                attention_mask,\n                (batch_size, seq_length),\n                inputs_embeds,\n                past_key_values_length,\n            )\n\n        # embed positions\n        hidden_states = inputs_embeds\n\n        # decoder layers\n        all_hidden_states = () if output_hidden_states else None\n        all_self_attns = () if output_attentions else None\n        next_decoder_cache = None\n\n        for decoder_layer in self.layers:\n            if output_hidden_states:\n                all_hidden_states += (hidden_states,)\n\n            layer_outputs = decoder_layer(\n                hidden_states,\n                attention_mask=attention_mask,\n                position_ids=position_ids,\n                past_key_value=past_key_values,\n                output_attentions=output_attentions,\n                use_cache=use_cache,\n            )\n\n            hidden_states = layer_outputs[0]\n\n            if use_cache:\n                next_decoder_cache = layer_outputs[2 if output_attentions else 1]\n\n            if output_attentions:\n                all_self_attns += (layer_outputs[1],)\n\n        hidden_states = self.norm(hidden_states)\n\n        # add hidden states from the last decoder layer\n        if output_hidden_states:\n            all_hidden_states += (hidden_states,)\n\n        next_cache = None\n        if use_cache:\n            next_cache = (\n                next_decoder_cache.to_legacy_cache()\n                if use_legacy_cache\n                else next_decoder_cache\n            )\n        if not return_dict:\n            return tuple(\n                v\n                for v in [hidden_states, next_cache, all_hidden_states, all_self_attns]\n                if v is not None\n            )\n        return BaseModelOutputWithPast(\n            last_hidden_state=hidden_states,\n            past_key_values=next_cache,\n            hidden_states=all_hidden_states,\n            attentions=all_self_attns,\n        )\n\n\nclass DeepseekV3ForCausalLM(DeepseekV3PreTrainedModel):\n    _tied_weights_keys = [\"lm_head.weight\"]\n\n    def __init__(self, config):\n        super().__init__(config)\n        self.model = DeepseekV3Model(config)\n        self.vocab_size = config.vocab_size\n        self.lm_head = nn.Linear(config.hidden_size, config.vocab_size, bias=False)\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def get_input_embeddings(self):\n        return self.model.embed_tokens\n\n    def set_input_embeddings(self, value):\n        self.model.embed_tokens = value\n\n    def get_output_embeddings(self):\n        return self.lm_head\n\n    def set_output_embeddings(self, new_embeddings):\n        self.lm_head = new_embeddings\n\n    def set_decoder(self, decoder):\n        self.model = decoder\n\n    def get_decoder(self):\n        return self.model\n\n    @add_start_docstrings_to_model_forward(DeepseekV3_INPUTS_DOCSTRING)\n    @replace_return_docstrings(\n        output_type=CausalLMOutputWithPast, config_class=_CONFIG_FOR_DOC\n    )\n    def forward(\n        self,\n        input_ids: torch.LongTensor = None,\n        attention_mask: Optional[torch.Tensor] = None,\n        position_ids: Optional[torch.LongTensor] = None,\n        past_key_values: Optional[List[torch.FloatTensor]] = None,\n        inputs_embeds: Optional[torch.FloatTensor] = None,\n        labels: Optional[torch.LongTensor] = None,\n        use_cache: Optional[bool] = None,\n        output_attentions: Optional[bool] = None,\n        output_hidden_states: Optional[bool] = None,\n        return_dict: Optional[bool] = None,\n    ) -> Union[Tuple, CausalLMOutputWithPast]:\n        r\"\"\"\n        Args:\n            labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n                Labels for computing the masked language modeling loss. Indices should either be in `[0, transformers.,\n                config.vocab_size]` or -100 (see `input_ids` docstring). Tokens with indices set to `-100` are ignored\n                (masked), the loss is only computed for the tokens with labels in `[0, transformers., config.vocab_size]`.\n\n        Returns:\n\n        Example:\n\n        ```python\n        >>> from transformers import AutoTokenizer, DeepseekV3ForCausalLM\n\n        >>> model = DeepseekV3ForCausalLM.from_pretrained(PATH_TO_CONVERTED_WEIGHTS)\n        >>> tokenizer = AutoTokenizer.from_pretrained(PATH_TO_CONVERTED_TOKENIZER)\n\n        >>> prompt = \"Hey, are you conscious? Can you talk to me?\"\n        >>> inputs = tokenizer(prompt, return_tensors=\"pt\")\n\n        >>> # Generate\n        >>> generate_ids = model.generate(inputs.input_ids, max_length=30)\n        >>> tokenizer.batch_decode(generate_ids, skip_special_tokens=True, clean_up_tokenization_spaces=False)[0]\n        \"Hey, are you conscious? Can you talk to me?\\nI'm not conscious, but I can talk to you.\"\n        ```\"\"\"\n        output_attentions = (\n            output_attentions\n            if output_attentions is not None\n            else self.config.output_attentions\n        )\n        output_hidden_states = (\n            output_hidden_states\n            if output_hidden_states is not None\n            else self.config.output_hidden_states\n        )\n        return_dict = (\n            return_dict if return_dict is not None else self.config.use_return_dict\n        )\n\n        # decoder outputs consists of (dec_features, layer_state, dec_hidden, dec_attn)\n        outputs = self.model(\n            input_ids=input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            past_key_values=past_key_values,\n            inputs_embeds=inputs_embeds,\n            use_cache=use_cache,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n        )\n\n        hidden_states = outputs[0]\n        logits = self.lm_head(hidden_states)\n        logits = logits.float()\n\n        loss = None\n        if labels is not None:\n            # Shift so that tokens < n predict n\n            shift_logits = logits[..., :-1, :].contiguous()\n            shift_labels = labels[..., 1:].contiguous()\n            # Flatten the tokens\n            loss_fct = CrossEntropyLoss()\n            shift_logits = shift_logits.view(-1, self.config.vocab_size)\n            shift_labels = shift_labels.view(-1)\n            # Enable model parallelism\n            shift_labels = shift_labels.to(shift_logits.device)\n            loss = loss_fct(shift_logits, shift_labels)\n\n        if not return_dict:\n            output = (logits,) + outputs[1:]\n            return (loss,) + output if loss is not None else output\n\n        return CausalLMOutputWithPast(\n            loss=loss,\n            logits=logits,\n            past_key_values=outputs.past_key_values,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n\n    def prepare_inputs_for_generation(\n        self,\n        input_ids,\n        past_key_values=None,\n        attention_mask=None,\n        inputs_embeds=None,\n        **kwargs,\n    ):\n        if past_key_values is not None:\n            if isinstance(past_key_values, Cache):\n                cache_length = past_key_values.get_seq_length()\n                past_length = past_key_values.seen_tokens\n                max_cache_length = past_key_values.get_max_length()\n            else:\n                cache_length = past_length = past_key_values[0][0].shape[2]\n                max_cache_length = None\n\n            # Keep only the unprocessed tokens:\n            # 1 - If the length of the attention_mask exceeds the length of input_ids, then we are in a setting where\n            # some of the inputs are exclusivelly passed as part of the cache (e.g. when passing input_embeds as\n            # input)\n            if (\n                attention_mask is not None\n                and attention_mask.shape[1] > input_ids.shape[1]\n            ):\n                input_ids = input_ids[:, -(attention_mask.shape[1] - past_length) :]\n            # 2 - If the past_length is smaller than input_ids', then input_ids holds all input tokens. We can discard\n            # input_ids based on the past_length.\n            elif past_length < input_ids.shape[1]:\n                input_ids = input_ids[:, past_length:]\n            # 3 - Otherwise (past_length >= input_ids.shape[1]), let's assume input_ids only has unprocessed tokens.\n\n            # If we are about to go beyond the maximum cache length, we need to crop the input attention mask.\n            if (\n                max_cache_length is not None\n                and attention_mask is not None\n                and cache_length + input_ids.shape[1] > max_cache_length\n            ):\n                attention_mask = attention_mask[:, -max_cache_length:]\n\n        position_ids = kwargs.get(\"position_ids\", None)\n        if attention_mask is not None and position_ids is None:\n            # create position_ids on the fly for batch generation\n            position_ids = attention_mask.long().cumsum(-1) - 1\n            position_ids.masked_fill_(attention_mask == 0, 1)\n            if past_key_values:\n                position_ids = position_ids[:, -input_ids.shape[1] :]\n\n        # if `inputs_embeds` are passed, we only want to use them in the 1st generation step\n        if inputs_embeds is not None and past_key_values is None:\n            model_inputs = {\"inputs_embeds\": inputs_embeds}\n        else:\n            model_inputs = {\"input_ids\": input_ids}\n\n        model_inputs.update(\n            {\n                \"position_ids\": position_ids,\n                \"past_key_values\": past_key_values,\n                \"use_cache\": kwargs.get(\"use_cache\"),\n                \"attention_mask\": attention_mask,\n            }\n        )\n        return model_inputs\n\n    @staticmethod\n    def _reorder_cache(past_key_values, beam_idx):\n        reordered_past = ()\n        for layer_past in past_key_values:\n            reordered_past += (\n                tuple(\n                    past_state.index_select(0, beam_idx.to(past_state.device))\n                    for past_state in layer_past\n                ),\n            )\n        return reordered_past\n\n\n@add_start_docstrings(\n    \"\"\"\n    The DeepseekV3 Model transformer with a sequence classification head on top (linear layer).\n\n    [`DeepseekV3ForSequenceClassification`] uses the last token in order to do the classification, as other causal models\n    (e.g. GPT-2) do.\n\n    Since it does classification on the last token, it requires to know the position of the last token. If a\n    `pad_token_id` is defined in the configuration, it finds the last token that is not a padding token in each row. If\n    no `pad_token_id` is defined, it simply takes the last value in each row of the batch. Since it cannot guess the\n    padding tokens when `inputs_embeds` are passed instead of `input_ids`, it does the same (take the last value in\n    each row of the batch).\n    \"\"\",\n    DeepseekV3_START_DOCSTRING,\n)\nclass DeepseekV3ForSequenceClassification(DeepseekV3PreTrainedModel):\n    def __init__(self, config):\n        super().__init__(config)\n        self.num_labels = config.num_labels\n        self.model = DeepseekV3Model(config)\n        self.score = nn.Linear(config.hidden_size, self.num_labels, bias=False)\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def get_input_embeddings(self):\n        return self.model.embed_tokens\n\n    def set_input_embeddings(self, value):\n        self.model.embed_tokens = value\n\n    @add_start_docstrings_to_model_forward(DeepseekV3_INPUTS_DOCSTRING)\n    def forward(\n        self,\n        input_ids: torch.LongTensor = None,\n        attention_mask: Optional[torch.Tensor] = None,\n        position_ids: Optional[torch.LongTensor] = None,\n        past_key_values: Optional[List[torch.FloatTensor]] = None,\n        inputs_embeds: Optional[torch.FloatTensor] = None,\n        labels: Optional[torch.LongTensor] = None,\n        use_cache: Optional[bool] = None,\n        output_attentions: Optional[bool] = None,\n        output_hidden_states: Optional[bool] = None,\n        return_dict: Optional[bool] = None,\n    ) -> Union[Tuple, SequenceClassifierOutputWithPast]:\n        r\"\"\"\n        labels (`torch.LongTensor` of shape `(batch_size,)`, *optional*):\n            Labels for computing the sequence classification/regression loss. Indices should be in `[0, transformers.,\n            config.num_labels - 1]`. If `config.num_labels == 1` a regression loss is computed (Mean-Square loss), If\n            `config.num_labels > 1` a classification loss is computed (Cross-Entropy).\n        \"\"\"\n        return_dict = (\n            return_dict if return_dict is not None else self.config.use_return_dict\n        )\n\n        transformer_outputs = self.model(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            past_key_values=past_key_values,\n            inputs_embeds=inputs_embeds,\n            use_cache=use_cache,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n        )\n        hidden_states = transformer_outputs[0]\n        logits = self.score(hidden_states)\n\n        if input_ids is not None:\n            batch_size = input_ids.shape[0]\n        else:\n            batch_size = inputs_embeds.shape[0]\n\n        if self.config.pad_token_id is None and batch_size != 1:\n            raise ValueError(\n                \"Cannot handle batch sizes > 1 if no padding token is defined.\"\n            )\n        if self.config.pad_token_id is None:\n            sequence_lengths = -1\n        else:\n            if input_ids is not None:\n                sequence_lengths = (\n                    torch.eq(input_ids, self.config.pad_token_id).int().argmax(-1) - 1\n                ).to(logits.device)\n            else:\n                sequence_lengths = -1\n\n        pooled_logits = logits[\n            torch.arange(batch_size, device=logits.device), sequence_lengths\n        ]\n\n        loss = None\n        if labels is not None:\n            labels = labels.to(logits.device)\n            if self.config.problem_type is None:\n                if self.num_labels == 1:\n                    self.config.problem_type = \"regression\"\n                elif self.num_labels > 1 and (\n                    labels.dtype == torch.long or labels.dtype == torch.int\n                ):\n                    self.config.problem_type = \"single_label_classification\"\n                else:\n                    self.config.problem_type = \"multi_label_classification\"\n\n            if self.config.problem_type == \"regression\":\n                loss_fct = MSELoss()\n                if self.num_labels == 1:\n                    loss = loss_fct(pooled_logits.squeeze(), labels.squeeze())\n                else:\n                    loss = loss_fct(pooled_logits, labels)\n            elif self.config.problem_type == \"single_label_classification\":\n                loss_fct = CrossEntropyLoss()\n                loss = loss_fct(\n                    pooled_logits.view(-1, self.num_labels), labels.view(-1)\n                )\n            elif self.config.problem_type == \"multi_label_classification\":\n                loss_fct = BCEWithLogitsLoss()\n                loss = loss_fct(pooled_logits, labels)\n        if not return_dict:\n            output = (pooled_logits,) + transformer_outputs[1:]\n            return ((loss,) + output) if loss is not None else output\n\n        return SequenceClassifierOutputWithPast(\n            loss=loss,\n            logits=pooled_logits,\n            past_key_values=transformer_outputs.past_key_values,\n            hidden_states=transformer_outputs.hidden_states,\n            attentions=transformer_outputs.attentions,\n        )\n",
        "tokenization_kimi.py": "import os\nimport tiktoken\n\nfrom logging import getLogger\nfrom pathlib import Path\nfrom typing import (\n    cast,\n    Tuple,\n    Dict,\n    Iterator,\n    List,\n    Union,\n    Optional,\n)\nfrom shutil import copyfile\nfrom tiktoken.load import load_tiktoken_bpe\nfrom tokenizers import AddedToken, pre_tokenizers, Regex\nfrom transformers.tokenization_utils import PreTrainedTokenizer\nfrom transformers.models.gpt2.tokenization_gpt2 import bytes_to_unicode\n\n\n\nlogger = getLogger(__name__)\nVOCAB_FILES_NAMES = {\"vocab_file\": \"tiktoken.model\"}\n\nclass TikTokenTokenizer(PreTrainedTokenizer):\n    \"\"\"\n    Tokenizing and encoding/decoding text using the Tiktoken tokenizer. See megatron/tokenizer/tiktoken_tokenizer.py.\n\n    This tokenizer inherits from [`PreTrainedTokenizer`] which contains most of the main methods. Users should refer to\n    this superclass for more information regarding those methods.\n\n    Args:\n        vocab_file (`str`):\n            The path to the Tiktoken model file.\n        bos_token (`str` or `tokenizers.AddedToken`, *optional*, defaults to `\"<|begin_of_text|>\",`):\n            The beginning of sequence token that was used during pretraining. Can be used a sequence classifier token.\n        eos_token (`str` or `tokenizers.AddedToken`, *optional*, defaults to `\"<|end_of_text|>\"`):\n            The end of sequence token.\n        unk_token (`str` or `tokenizers.AddedToken`, *optional*, defaults to `\"<|reserved_special_token_249|>\"`):\n            The unknown token. A token that is not in the vocabulary cannot be converted to an ID and is set to be this\n            token instead. The second to last item in special_tokens.\n        pad_token (`str` or `tokenizers.AddedToken`, *optional*, defaults to `\"<|reserved_special_token_250|>\"`):\n            The token used for padding, for example when batching sequences of different lengths.\n        additional_special_tokens (list of `str`, *optional*):\n            A tuple or a list of additional tokens, which will be marked as `special`, meaning that they will be\n            skipped when decoding if `skip_special_tokens` is set to `True`.\n    \"\"\"\n\n    vocab_files_names = VOCAB_FILES_NAMES\n\n    model_input_names = [\"input_ids\", \"attention_mask\"]\n\n    special_tokens: Dict[str, int]\n\n    num_reserved_special_tokens = 256\n\n    pat_str = \"|\".join(\n        [\n            r\"\"\"[\\p{Han}]+\"\"\",\n            r\"\"\"[^\\r\\n\\p{L}\\p{N}]?[\\p{Lu}\\p{Lt}\\p{Lm}\\p{Lo}\\p{M}&&[^\\p{Han}]]*[\\p{Ll}\\p{Lm}\\p{Lo}\\p{M}&&[^\\p{Han}]]+(?i:'s|'t|'re|'ve|'m|'ll|'d)?\"\"\",\n            r\"\"\"[^\\r\\n\\p{L}\\p{N}]?[\\p{Lu}\\p{Lt}\\p{Lm}\\p{Lo}\\p{M}&&[^\\p{Han}]]+[\\p{Ll}\\p{Lm}\\p{Lo}\\p{M}&&[^\\p{Han}]]*(?i:'s|'t|'re|'ve|'m|'ll|'d)?\"\"\",\n            r\"\"\"\\p{N}{1,3}\"\"\",\n            r\"\"\" ?[^\\s\\p{L}\\p{N}]+[\\r\\n]*\"\"\",\n            r\"\"\"\\s*[\\r\\n]+\"\"\",\n            r\"\"\"\\s+(?!\\S)\"\"\",\n            r\"\"\"\\s+\"\"\",\n        ]\n    )\n\n    def __init__(\n        self,\n        vocab_file,\n        bos_token: Union[str, AddedToken]=\"[BOS]\",\n        eos_token: Union[str, AddedToken]=\"[EOS]\",\n        unk_token: Union[str, AddedToken, None]=None,\n        pad_token: Union[str, AddedToken, None]=None,\n        additional_special_tokens: List[str]=None,\n        added_tokens_decoder: Optional[dict] = None,\n        **kwargs,\n    ):\n        assert os.path.isfile(vocab_file), vocab_file\n\n        if additional_special_tokens is None:\n            additional_special_tokens  = [\n                \"<|im_end|>\",\n                \"<|im_user|>\", \n                \"<|im_assistant|>\", \n                \"<|start_header_id|>\", \n                \"<|end_header_id|>\", \n                \"[EOT]\", \n                \"<|im_system|>\", \n                \"<|im_middle|>\",\n            ] \n        \n        special_tokens_mapping = {\n        i: added_tokens_decoder[i].content for i in added_tokens_decoder\n    }\n\n        self.vocab_file = vocab_file\n        mergeable_ranks = load_tiktoken_bpe(vocab_file)\n        num_base_tokens = len(mergeable_ranks)\n        self.special_tokens = {\n            special_tokens_mapping.get(i, f\"<|reserved_token_{i}|>\"): i\n            for i in range(\n                num_base_tokens, num_base_tokens + self.num_reserved_special_tokens + 2\n            )\n        }\n\n\n\n        self.model = tiktoken.Encoding(\n            name=Path(vocab_file).name,\n            pat_str=self.pat_str,\n            mergeable_ranks=mergeable_ranks,\n            special_tokens=self.special_tokens,\n        )\n        logger.info(f\"Reloaded tiktoken model from {vocab_file}\")\n\n        self.n_words: int = self.model.n_vocab\n        # BOS / EOS token IDs\n        self.bos_id: int = self.special_tokens[str(bos_token)]\n        self.eos_id: int = self.special_tokens[str(eos_token)]\n        logger.info(\n            f\"#words: {self.n_words} - BOS ID: {self.bos_id} - EOS ID: {self.eos_id}\"\n        )\n\n        self.pad_id: int = self.special_tokens[str(pad_token)]\n        self.unk_id: int = self.special_tokens[str(unk_token)]\n\n        self.byte_encoder = bytes_to_unicode()\n        self.byte_decoder = {v: k for k, v in self.byte_encoder.items()}\n\n        self.decoder = {}\n        for i in range(self.n_words):\n            # Taken from https://gist.github.com/xenova/a452a6474428de0182b17605a98631ee\n            decoding = ''.join([\n                self.byte_encoder[ord(char)] for char in\n                self.model.decode_single_token_bytes(i).decode('latin-1')\n            ])\n            self.decoder[i] = decoding\n\n        self.encoder = {}\n        for i in range(self.n_words):\n            if i in self.decoder:\n                self.encoder[self.decoder[i]] = i\n\n        super().__init__(\n            bos_token=bos_token,\n            eos_token=eos_token,\n            unk_token=unk_token,\n            pad_token=pad_token,\n            additional_special_tokens=additional_special_tokens,\n            **kwargs,\n        )\n        self.all_special_ids_set = set(self.all_special_ids)\n\n    def encode(\n        self,\n        text: str,\n        **kwargs\n    ) -> List[int]:\n        \"\"\"\n        Encodes a string into a list of token IDs.\n\n        Args:\n            text (str): The input string to be encoded.\n\n        Returns:\n            list[int]: A list of token IDs.\n        \"\"\"\n        # If there are other args, we should call super().encode because there are a lot of code\n        # to handle those args. supper().encode finally will call _tokenize and _convert_token_to_id.\n        # NOTE: our encode method is not compatible with the super().encode method,\n        #   e.g. split_special_tokens' default is True in our encode method.\n        if len(kwargs) > 0:\n            logger.warning( f\"Calling super().encode with {kwargs}\" )\n            return super().encode(text, **kwargs)\n\n        assert type(text) is str\n\n        # The tiktoken tokenizer can handle <=400k chars without\n        # pyo3_runtime.PanicException.\n        TIKTOKEN_MAX_ENCODE_CHARS = 400_000\n\n        # https://github.com/openai/tiktoken/issues/195\n        # Here we iterate over subsequences and split if we exceed the limit\n        # of max consecutive non-whitespace or whitespace characters.\n        MAX_NO_WHITESPACES_CHARS = 25_000\n\n        texts = self.pre_tokenizer_process(text)\n\n        all_substrs = []\n        for text in texts:\n            substrs = (\n                substr\n                for i in range(0, len(text), TIKTOKEN_MAX_ENCODE_CHARS)\n                for substr in self._split_whitespaces_or_nonwhitespaces(\n                    text[i: i + TIKTOKEN_MAX_ENCODE_CHARS], MAX_NO_WHITESPACES_CHARS\n                )\n            )\n            all_substrs.extend(substrs)\n\n        t: List[int] = []\n        for substr in all_substrs:\n            t.extend(\n                # we should consider special token as a common token\n                self.model.encode(\n                    substr,\n                    disallowed_special=(),\n                )\n            )\n\n        return t\n\n    def decode(\n        self,\n        token_ids: Union[int, List[int]],\n        **kwargs\n    ) -> str:\n        \"\"\"\n        Decodes a list of token IDs into a string.\n\n        Args:\n            token_ids (List[int]): The list of token IDs to be decoded.\n\n        Returns:\n            str: The decoded string.\n        \"\"\"\n        # If there are other args, we should call super().decode because there are a lot of code\n        # to handle those args. supper().encode finally will call convert_tokens_to_string and _convert_id_to_token.\n        if len(kwargs) > 0:\n            return super().decode(token_ids, **kwargs)\n\n        if type(token_ids) is int:\n            token_ids = [token_ids]\n\n        return self.model.decode(cast(List[int], token_ids))\n\n    @staticmethod\n    def _split_whitespaces_or_nonwhitespaces(\n        s: str, max_consecutive_slice_len: int\n    ) -> Iterator[str]:\n        \"\"\"\n        Splits the string `s` so that each substring contains no more than `max_consecutive_slice_len`\n        consecutive whitespaces or consecutive non-whitespaces.\n        \"\"\"\n        current_slice_len = 0\n        current_slice_is_space = s[0].isspace() if len(s) > 0 else False\n        slice_start = 0\n\n        for i in range(len(s)):\n            is_now_space = s[i].isspace()\n\n            if current_slice_is_space ^ is_now_space:\n                current_slice_len = 1\n                current_slice_is_space = is_now_space\n            else:\n                current_slice_len += 1\n                if current_slice_len > max_consecutive_slice_len:\n                    yield s[slice_start:i]\n                    slice_start = i\n                    current_slice_len = 1\n        yield s[slice_start:]\n\n    def pre_tokenizer_process(self, text: str) -> List[str]:\n        \"\"\"\n        pre-tokenizes the input text into a list of tokens.\n        This method is used to split the input text into smaller chunks for internal processing.\n        \"\"\"\n        return [text]\n\n\n    \"\"\" ----- Below are the abstract methods required by PreTrainedTokenizer ----- \"\"\"\n    @property\n    def vocab_size(self) -> int:\n        return self.n_words\n\n    def get_vocab(self) -> Dict[str, int]:\n        return self.encoder\n\n    def _tokenize(self, text: str, **kwargs) -> List[str]:\n        return [\n            self.decoder[t]\n            for t in self.encode(text)\n        ]\n\n    def _convert_token_to_id(self, token: str) -> int:\n        return self.encoder.get(token, self.unk_id)\n\n    def _convert_id_to_token(self, index: int) -> str:\n        return self.decoder.get(index)\n\n    @staticmethod\n    def clean_up_tokenization(out_string: str) -> str:\n        return out_string\n\n    def convert_tokens_to_string(self, tokens: List[str]) -> str:\n        text = ''.join(tokens)\n        text = bytearray([self.byte_decoder[c] for c in text]).decode('utf-8', 'replace')\n        return text\n\n    def save_vocabulary(self, save_directory: str, filename_prefix: Optional[str] = None) -> Tuple[str]:\n        if not os.path.isdir(save_directory):\n            raise ValueError(f\"vocabulary path ({save_directory}) should be a directory\")\n        out_vocab_file = os.path.join(\n            save_directory, (filename_prefix + \"-\" if filename_prefix else \"\") + VOCAB_FILES_NAMES[\"vocab_file\"]\n        )\n\n        if os.path.abspath(self.vocab_file) != os.path.abspath(out_vocab_file) and os.path.isfile(self.vocab_file):\n            copyfile(self.vocab_file, out_vocab_file)\n\n        return (out_vocab_file,)\n"
    }
}