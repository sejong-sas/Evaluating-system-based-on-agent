{
    "model_id": "deepseek-ai/deepseek-v3-0324",
    "files": [
        ".gitattributes",
        "LICENSE",
        "README.md",
        "config.json",
        "configuration_deepseek.py",
        "figures/0324_comparison.png",
        "model-00001-of-000163.safetensors",
        "model-00002-of-000163.safetensors",
        "model-00003-of-000163.safetensors",
        "model-00004-of-000163.safetensors",
        "model-00005-of-000163.safetensors",
        "model-00006-of-000163.safetensors",
        "model-00007-of-000163.safetensors",
        "model-00008-of-000163.safetensors",
        "model-00009-of-000163.safetensors",
        "model-00010-of-000163.safetensors",
        "model-00011-of-000163.safetensors",
        "model-00012-of-000163.safetensors",
        "model-00013-of-000163.safetensors",
        "model-00014-of-000163.safetensors",
        "model-00015-of-000163.safetensors",
        "model-00016-of-000163.safetensors",
        "model-00017-of-000163.safetensors",
        "model-00018-of-000163.safetensors",
        "model-00019-of-000163.safetensors",
        "model-00020-of-000163.safetensors",
        "model-00021-of-000163.safetensors",
        "model-00022-of-000163.safetensors",
        "model-00023-of-000163.safetensors",
        "model-00024-of-000163.safetensors",
        "model-00025-of-000163.safetensors",
        "model-00026-of-000163.safetensors",
        "model-00027-of-000163.safetensors",
        "model-00028-of-000163.safetensors",
        "model-00029-of-000163.safetensors",
        "model-00030-of-000163.safetensors",
        "model-00031-of-000163.safetensors",
        "model-00032-of-000163.safetensors",
        "model-00033-of-000163.safetensors",
        "model-00034-of-000163.safetensors",
        "model-00035-of-000163.safetensors",
        "model-00036-of-000163.safetensors",
        "model-00037-of-000163.safetensors",
        "model-00038-of-000163.safetensors",
        "model-00039-of-000163.safetensors",
        "model-00040-of-000163.safetensors",
        "model-00041-of-000163.safetensors",
        "model-00042-of-000163.safetensors",
        "model-00043-of-000163.safetensors",
        "model-00044-of-000163.safetensors",
        "model-00045-of-000163.safetensors",
        "model-00046-of-000163.safetensors",
        "model-00047-of-000163.safetensors",
        "model-00048-of-000163.safetensors",
        "model-00049-of-000163.safetensors",
        "model-00050-of-000163.safetensors",
        "model-00051-of-000163.safetensors",
        "model-00052-of-000163.safetensors",
        "model-00053-of-000163.safetensors",
        "model-00054-of-000163.safetensors",
        "model-00055-of-000163.safetensors",
        "model-00056-of-000163.safetensors",
        "model-00057-of-000163.safetensors",
        "model-00058-of-000163.safetensors",
        "model-00059-of-000163.safetensors",
        "model-00060-of-000163.safetensors",
        "model-00061-of-000163.safetensors",
        "model-00062-of-000163.safetensors",
        "model-00063-of-000163.safetensors",
        "model-00064-of-000163.safetensors",
        "model-00065-of-000163.safetensors",
        "model-00066-of-000163.safetensors",
        "model-00067-of-000163.safetensors",
        "model-00068-of-000163.safetensors",
        "model-00069-of-000163.safetensors",
        "model-00070-of-000163.safetensors",
        "model-00071-of-000163.safetensors",
        "model-00072-of-000163.safetensors",
        "model-00073-of-000163.safetensors",
        "model-00074-of-000163.safetensors",
        "model-00075-of-000163.safetensors",
        "model-00076-of-000163.safetensors",
        "model-00077-of-000163.safetensors",
        "model-00078-of-000163.safetensors",
        "model-00079-of-000163.safetensors",
        "model-00080-of-000163.safetensors",
        "model-00081-of-000163.safetensors",
        "model-00082-of-000163.safetensors",
        "model-00083-of-000163.safetensors",
        "model-00084-of-000163.safetensors",
        "model-00085-of-000163.safetensors",
        "model-00086-of-000163.safetensors",
        "model-00087-of-000163.safetensors",
        "model-00088-of-000163.safetensors",
        "model-00089-of-000163.safetensors",
        "model-00090-of-000163.safetensors",
        "model-00091-of-000163.safetensors",
        "model-00092-of-000163.safetensors",
        "model-00093-of-000163.safetensors",
        "model-00094-of-000163.safetensors",
        "model-00095-of-000163.safetensors",
        "model-00096-of-000163.safetensors",
        "model-00097-of-000163.safetensors",
        "model-00098-of-000163.safetensors",
        "model-00099-of-000163.safetensors",
        "model-00100-of-000163.safetensors",
        "model-00101-of-000163.safetensors",
        "model-00102-of-000163.safetensors",
        "model-00103-of-000163.safetensors",
        "model-00104-of-000163.safetensors",
        "model-00105-of-000163.safetensors",
        "model-00106-of-000163.safetensors",
        "model-00107-of-000163.safetensors",
        "model-00108-of-000163.safetensors",
        "model-00109-of-000163.safetensors",
        "model-00110-of-000163.safetensors",
        "model-00111-of-000163.safetensors",
        "model-00112-of-000163.safetensors",
        "model-00113-of-000163.safetensors",
        "model-00114-of-000163.safetensors",
        "model-00115-of-000163.safetensors",
        "model-00116-of-000163.safetensors",
        "model-00117-of-000163.safetensors",
        "model-00118-of-000163.safetensors",
        "model-00119-of-000163.safetensors",
        "model-00120-of-000163.safetensors",
        "model-00121-of-000163.safetensors",
        "model-00122-of-000163.safetensors",
        "model-00123-of-000163.safetensors",
        "model-00124-of-000163.safetensors",
        "model-00125-of-000163.safetensors",
        "model-00126-of-000163.safetensors",
        "model-00127-of-000163.safetensors",
        "model-00128-of-000163.safetensors",
        "model-00129-of-000163.safetensors",
        "model-00130-of-000163.safetensors",
        "model-00131-of-000163.safetensors",
        "model-00132-of-000163.safetensors",
        "model-00133-of-000163.safetensors",
        "model-00134-of-000163.safetensors",
        "model-00135-of-000163.safetensors",
        "model-00136-of-000163.safetensors",
        "model-00137-of-000163.safetensors",
        "model-00138-of-000163.safetensors",
        "model-00139-of-000163.safetensors",
        "model-00140-of-000163.safetensors",
        "model-00141-of-000163.safetensors",
        "model-00142-of-000163.safetensors",
        "model-00143-of-000163.safetensors",
        "model-00144-of-000163.safetensors",
        "model-00145-of-000163.safetensors",
        "model-00146-of-000163.safetensors",
        "model-00147-of-000163.safetensors",
        "model-00148-of-000163.safetensors",
        "model-00149-of-000163.safetensors",
        "model-00150-of-000163.safetensors",
        "model-00151-of-000163.safetensors",
        "model-00152-of-000163.safetensors",
        "model-00153-of-000163.safetensors",
        "model-00154-of-000163.safetensors",
        "model-00155-of-000163.safetensors",
        "model-00156-of-000163.safetensors",
        "model-00157-of-000163.safetensors",
        "model-00158-of-000163.safetensors",
        "model-00159-of-000163.safetensors",
        "model-00160-of-000163.safetensors",
        "model-00161-of-000163.safetensors",
        "model-00162-of-000163.safetensors",
        "model-00163-of-000163.safetensors",
        "model.safetensors.index.json",
        "modeling_deepseek.py",
        "tokenizer.json",
        "tokenizer_config.json"
    ],
    "readme": "---\nlicense: mit\nlibrary_name: transformers\n---\n# DeepSeek-V3-0324\n<!-- markdownlint-disable first-line-h1 -->\n<!-- markdownlint-disable html -->\n<!-- markdownlint-disable no-duplicate-header -->\n\n<div align=\"center\">\n  <img src=\"https://github.com/deepseek-ai/DeepSeek-V2/blob/main/figures/logo.svg?raw=true\" width=\"60%\" alt=\"DeepSeek-V3\" />\n</div>\n<hr>\n<div align=\"center\" style=\"line-height: 1;\">\n  <a href=\"https://www.deepseek.com/\" target=\"_blank\" style=\"margin: 2px;\">\n    <img alt=\"Homepage\" src=\"https://github.com/deepseek-ai/DeepSeek-V2/blob/main/figures/badge.svg?raw=true\" style=\"display: inline-block; vertical-align: middle;\"/>\n  </a>\n  <a href=\"https://chat.deepseek.com/\" target=\"_blank\" style=\"margin: 2px;\">\n    <img alt=\"Chat\" src=\"https://img.shields.io/badge/ü§ñ%20Chat-DeepSeek%20V3-536af5?color=536af5&logoColor=white\" style=\"display: inline-block; vertical-align: middle;\"/>\n  </a>\n  <a href=\"https://huggingface.co/deepseek-ai\" target=\"_blank\" style=\"margin: 2px;\">\n    <img alt=\"Hugging Face\" src=\"https://img.shields.io/badge/%F0%9F%A4%97%20Hugging%20Face-DeepSeek%20AI-ffc107?color=ffc107&logoColor=white\" style=\"display: inline-block; vertical-align: middle;\"/>\n  </a>\n</div>\n\n<div align=\"center\" style=\"line-height: 1;\">\n  <a href=\"https://discord.gg/Tc7c45Zzu5\" target=\"_blank\" style=\"margin: 2px;\">\n    <img alt=\"Discord\" src=\"https://img.shields.io/badge/Discord-DeepSeek%20AI-7289da?logo=discord&logoColor=white&color=7289da\" style=\"display: inline-block; vertical-align: middle;\"/>\n  </a>\n  <a href=\"https://github.com/deepseek-ai/DeepSeek-V2/blob/main/figures/qr.jpeg?raw=true\" target=\"_blank\" style=\"margin: 2px;\">\n    <img alt=\"Wechat\" src=\"https://img.shields.io/badge/WeChat-DeepSeek%20AI-brightgreen?logo=wechat&logoColor=white\" style=\"display: inline-block; vertical-align: middle;\"/>\n  </a>\n  <a href=\"https://twitter.com/deepseek_ai\" target=\"_blank\" style=\"margin: 2px;\">\n    <img alt=\"Twitter Follow\" src=\"https://img.shields.io/badge/Twitter-deepseek_ai-white?logo=x&logoColor=white\" style=\"display: inline-block; vertical-align: middle;\"/>\n  </a>\n</div>\n\n<div align=\"center\" style=\"line-height: 1;\">\n  <a href=\"LICENSE\" style=\"margin: 2px;\">\n    <img alt=\"License\" src=\"https://img.shields.io/badge/License-MIT-f5de53?&color=f5de53\" style=\"display: inline-block; vertical-align: middle;\"/>\n  </a>\n</div>\n\n## Features\n\nDeepSeek-V3-0324 demonstrates notable improvements over its predecessor, DeepSeek-V3, in several key aspects.\n\n![Model Performance](figures/0324_comparison.png)\n\n### Reasoning Capabilities\n\n- Significant improvements in benchmark performance:\n  - MMLU-Pro: 75.9 ‚Üí 81.2 (+5.3)\n  - GPQA: 59.1 ‚Üí 68.4 (+9.3)\n  - AIME: 39.6 ‚Üí 59.4 (+19.8)\n  - LiveCodeBench: 39.2 ‚Üí 49.2 (+10.0)\n\n### Front-End Web Development\n\n- Improved the executability of the code\n- More aesthetically pleasing web pages and game front-ends\n\n### Chinese Writing Proficiency\n\n- Enhanced style and content quality:\n  - Aligned with the R1 writing style\n  - Better quality in medium-to-long-form writing\n\n- Feature Enhancements\n  - Improved multi-turn interactive rewriting\n  - Optimized translation quality and letter writing\n\n### Chinese Search Capabilities\n\n- Enhanced report analysis requests with more detailed outputs\n\n### Function Calling Improvements\n\n- Increased accuracy in Function Calling, fixing issues from previous V3 versions\n\n---\n\n## Usage Recommendations\n\n### System Prompt\n\nIn the official DeepSeek web/app, we use the same system prompt with a specific date.\n\n```\nËØ•Âä©Êâã‰∏∫DeepSeek ChatÔºåÁî±Ê∑±Â∫¶Ê±ÇÁ¥¢ÂÖ¨Âè∏ÂàõÈÄ†„ÄÇ\n‰ªäÂ§©ÊòØ{current date}„ÄÇ\n```\n\nFor example,\n\n```\nËØ•Âä©Êâã‰∏∫DeepSeek ChatÔºåÁî±Ê∑±Â∫¶Ê±ÇÁ¥¢ÂÖ¨Âè∏ÂàõÈÄ†„ÄÇ\n‰ªäÂ§©ÊòØ3Êúà24Êó•ÔºåÊòüÊúü‰∏Ä„ÄÇ\n```\n\n### Temperature\n\nIn our web and application environments, the temperature parameter $T_{model}$ is set to 0.3. Because many users use the default temperature 1.0 in API call, we have implemented an API temperature $T_{api}$ mapping mechanism that adjusts the input API temperature value of 1.0 to the most suitable model temperature setting of 0.3.\n\n$$\nT_{model} = T_{api} \\times 0.3 \\quad (0 \\leq T_{api} \\leq 1)\n$$\n\n$$\nT_{model} = T_{api} - 0.7 \\quad (1 < T_{api} \\leq 2)\n$$\n\nThus, if you call V3 via API, temperature 1.0 equals to the model temperature 0.3.\n\n### Prompts for File Uploading and Web Search\n\nFor file uploading, please follow the template to create prompts, where {file_name}, {file_content} and {question} are arguments.\n\n```\nfile_template = \\\n\"\"\"[file name]: {file_name}\n[file content begin]\n{file_content}\n[file content end]\n{question}\"\"\"\n```\n\nFor Web Search, {search_results}, {cur_date}, and {question} are arguments.\n\nFor Chinese query, we use the prompt:\n\n```\nsearch_answer_zh_template = \\\n'''# ‰ª•‰∏ãÂÜÖÂÆπÊòØÂü∫‰∫éÁî®Êà∑ÂèëÈÄÅÁöÑÊ∂àÊÅØÁöÑÊêúÁ¥¢ÁªìÊûú:\n{search_results}\nÂú®ÊàëÁªô‰Ω†ÁöÑÊêúÁ¥¢ÁªìÊûú‰∏≠ÔºåÊØè‰∏™ÁªìÊûúÈÉΩÊòØ[webpage X begin]...[webpage X end]Ê†ºÂºèÁöÑÔºåX‰ª£Ë°®ÊØèÁØáÊñáÁ´†ÁöÑÊï∞Â≠óÁ¥¢Âºï„ÄÇËØ∑Âú®ÈÄÇÂΩìÁöÑÊÉÖÂÜµ‰∏ãÂú®Âè•Â≠êÊú´Â∞æÂºïÁî®‰∏ä‰∏ãÊñá„ÄÇËØ∑ÊåâÁÖßÂºïÁî®ÁºñÂè∑[citation:X]ÁöÑÊ†ºÂºèÂú®Á≠îÊ°à‰∏≠ÂØπÂ∫îÈÉ®ÂàÜÂºïÁî®‰∏ä‰∏ãÊñá„ÄÇÂ¶ÇÊûú‰∏ÄÂè•ËØùÊ∫êËá™Â§ö‰∏™‰∏ä‰∏ãÊñáÔºåËØ∑ÂàóÂá∫ÊâÄÊúâÁõ∏ÂÖ≥ÁöÑÂºïÁî®ÁºñÂè∑Ôºå‰æãÂ¶Ç[citation:3][citation:5]ÔºåÂàáËÆ∞‰∏çË¶ÅÂ∞ÜÂºïÁî®ÈõÜ‰∏≠Âú®ÊúÄÂêéËøîÂõûÂºïÁî®ÁºñÂè∑ÔºåËÄåÊòØÂú®Á≠îÊ°àÂØπÂ∫îÈÉ®ÂàÜÂàóÂá∫„ÄÇ\nÂú®ÂõûÁ≠îÊó∂ÔºåËØ∑Ê≥®ÊÑè‰ª•‰∏ãÂá†ÁÇπÔºö\n- ‰ªäÂ§©ÊòØ{cur_date}„ÄÇ\n- Âπ∂ÈùûÊêúÁ¥¢ÁªìÊûúÁöÑÊâÄÊúâÂÜÖÂÆπÈÉΩ‰∏éÁî®Êà∑ÁöÑÈóÆÈ¢òÂØÜÂàáÁõ∏ÂÖ≥Ôºå‰Ω†ÈúÄË¶ÅÁªìÂêàÈóÆÈ¢òÔºåÂØπÊêúÁ¥¢ÁªìÊûúËøõË°åÁîÑÂà´„ÄÅÁ≠õÈÄâ„ÄÇ\n- ÂØπ‰∫éÂàó‰∏æÁ±ªÁöÑÈóÆÈ¢òÔºàÂ¶ÇÂàó‰∏æÊâÄÊúâËà™Áè≠‰ø°ÊÅØÔºâÔºåÂ∞ΩÈáèÂ∞ÜÁ≠îÊ°àÊéßÂà∂Âú®10‰∏™Ë¶ÅÁÇπ‰ª•ÂÜÖÔºåÂπ∂ÂëäËØâÁî®Êà∑ÂèØ‰ª•Êü•ÁúãÊêúÁ¥¢Êù•Ê∫ê„ÄÅËé∑ÂæóÂÆåÊï¥‰ø°ÊÅØ„ÄÇ‰ºòÂÖàÊèê‰æõ‰ø°ÊÅØÂÆåÊï¥„ÄÅÊúÄÁõ∏ÂÖ≥ÁöÑÂàó‰∏æÈ°πÔºõÂ¶ÇÈùûÂøÖË¶ÅÔºå‰∏çË¶Å‰∏ªÂä®ÂëäËØâÁî®Êà∑ÊêúÁ¥¢ÁªìÊûúÊú™Êèê‰æõÁöÑÂÜÖÂÆπ„ÄÇ\n- ÂØπ‰∫éÂàõ‰ΩúÁ±ªÁöÑÈóÆÈ¢òÔºàÂ¶ÇÂÜôËÆ∫ÊñáÔºâÔºåËØ∑Âä°ÂøÖÂú®Ê≠£ÊñáÁöÑÊÆµËêΩ‰∏≠ÂºïÁî®ÂØπÂ∫îÁöÑÂèÇËÄÉÁºñÂè∑Ôºå‰æãÂ¶Ç[citation:3][citation:5]Ôºå‰∏çËÉΩÂè™Âú®ÊñáÁ´†Êú´Â∞æÂºïÁî®„ÄÇ‰Ω†ÈúÄË¶ÅËß£ËØªÂπ∂Ê¶ÇÊã¨Áî®Êà∑ÁöÑÈ¢òÁõÆË¶ÅÊ±ÇÔºåÈÄâÊã©ÂêàÈÄÇÁöÑÊ†ºÂºèÔºåÂÖÖÂàÜÂà©Áî®ÊêúÁ¥¢ÁªìÊûúÂπ∂ÊäΩÂèñÈáçË¶Å‰ø°ÊÅØÔºåÁîüÊàêÁ¨¶ÂêàÁî®Êà∑Ë¶ÅÊ±Ç„ÄÅÊûÅÂÖ∑ÊÄùÊÉ≥Ê∑±Â∫¶„ÄÅÂØåÊúâÂàõÈÄ†Âäõ‰∏é‰∏ì‰∏öÊÄßÁöÑÁ≠îÊ°à„ÄÇ‰Ω†ÁöÑÂàõ‰ΩúÁØáÂπÖÈúÄË¶ÅÂ∞ΩÂèØËÉΩÂª∂ÈïøÔºåÂØπ‰∫éÊØè‰∏Ä‰∏™Ë¶ÅÁÇπÁöÑËÆ∫Ëø∞Ë¶ÅÊé®ÊµãÁî®Êà∑ÁöÑÊÑèÂõæÔºåÁªôÂá∫Â∞ΩÂèØËÉΩÂ§öËßíÂ∫¶ÁöÑÂõûÁ≠îË¶ÅÁÇπÔºå‰∏îÂä°ÂøÖ‰ø°ÊÅØÈáèÂ§ß„ÄÅËÆ∫Ëø∞ËØ¶Â∞Ω„ÄÇ\n- Â¶ÇÊûúÂõûÁ≠îÂæàÈïøÔºåËØ∑Â∞ΩÈáèÁªìÊûÑÂåñ„ÄÅÂàÜÊÆµËêΩÊÄªÁªì„ÄÇÂ¶ÇÊûúÈúÄË¶ÅÂàÜÁÇπ‰ΩúÁ≠îÔºåÂ∞ΩÈáèÊéßÂà∂Âú®5‰∏™ÁÇπ‰ª•ÂÜÖÔºåÂπ∂ÂêàÂπ∂Áõ∏ÂÖ≥ÁöÑÂÜÖÂÆπ„ÄÇ\n- ÂØπ‰∫éÂÆ¢ËßÇÁ±ªÁöÑÈóÆÁ≠îÔºåÂ¶ÇÊûúÈóÆÈ¢òÁöÑÁ≠îÊ°àÈùûÂ∏∏ÁÆÄÁü≠ÔºåÂèØ‰ª•ÈÄÇÂΩìË°•ÂÖÖ‰∏ÄÂà∞‰∏§Âè•Áõ∏ÂÖ≥‰ø°ÊÅØÔºå‰ª•‰∏∞ÂØåÂÜÖÂÆπ„ÄÇ\n- ‰Ω†ÈúÄË¶ÅÊ†πÊçÆÁî®Êà∑Ë¶ÅÊ±ÇÂíåÂõûÁ≠îÂÜÖÂÆπÈÄâÊã©ÂêàÈÄÇ„ÄÅÁæéËßÇÁöÑÂõûÁ≠îÊ†ºÂºèÔºåÁ°Æ‰øùÂèØËØªÊÄßÂº∫„ÄÇ\n- ‰Ω†ÁöÑÂõûÁ≠îÂ∫îËØ•ÁªºÂêàÂ§ö‰∏™Áõ∏ÂÖ≥ÁΩëÈ°µÊù•ÂõûÁ≠îÔºå‰∏çËÉΩÈáçÂ§çÂºïÁî®‰∏Ä‰∏™ÁΩëÈ°µ„ÄÇ\n- Èô§ÈùûÁî®Êà∑Ë¶ÅÊ±ÇÔºåÂê¶Âàô‰Ω†ÂõûÁ≠îÁöÑËØ≠Ë®ÄÈúÄË¶ÅÂíåÁî®Êà∑ÊèêÈóÆÁöÑËØ≠Ë®Ä‰øùÊåÅ‰∏ÄËá¥„ÄÇ\n\n# Áî®Êà∑Ê∂àÊÅØ‰∏∫Ôºö\n{question}'''\n```\n\nFor English query, we use the prompt:\n\n```\nsearch_answer_en_template = \\\n'''# The following contents are the search results related to the user's message:\n{search_results}\nIn the search results I provide to you, each result is formatted as [webpage X begin]...[webpage X end], where X represents the numerical index of each article. Please cite the context at the end of the relevant sentence when appropriate. Use the citation format [citation:X] in the corresponding part of your answer. If a sentence is derived from multiple contexts, list all relevant citation numbers, such as [citation:3][citation:5]. Be sure not to cluster all citations at the end; instead, include them in the corresponding parts of the answer.\nWhen responding, please keep the following points in mind:\n- Today is {cur_date}.\n- Not all content in the search results is closely related to the user's question. You need to evaluate and filter the search results based on the question.\n- For listing-type questions (e.g., listing all flight information), try to limit the answer to 10 key points and inform the user that they can refer to the search sources for complete information. Prioritize providing the most complete and relevant items in the list. Avoid mentioning content not provided in the search results unless necessary.\n- For creative tasks (e.g., writing an essay), ensure that references are cited within the body of the text, such as [citation:3][citation:5], rather than only at the end of the text. You need to interpret and summarize the user's requirements, choose an appropriate format, fully utilize the search results, extract key information, and generate an answer that is insightful, creative, and professional. Extend the length of your response as much as possible, addressing each point in detail and from multiple perspectives, ensuring the content is rich and thorough.\n- If the response is lengthy, structure it well and summarize it in paragraphs. If a point-by-point format is needed, try to limit it to 5 points and merge related content.\n- For objective Q&A, if the answer is very brief, you may add one or two related sentences to enrich the content.\n- Choose an appropriate and visually appealing format for your response based on the user's requirements and the content of the answer, ensuring strong readability.\n- Your answer should synthesize information from multiple relevant webpages and avoid repeatedly citing the same webpage.\n- Unless the user requests otherwise, your response should be in the same language as the user's question.\n\n# The user's message is:\n{question}'''\n```\n\n## How to Run Locally\n\nThe model structure of DeepSeek-V3-0324 is exactly the same as DeepSeek-V3. Please visit [DeepSeek-V3](https://github.com/deepseek-ai/DeepSeek-V3) repo for more information about running this model locally.\n\n**This model supports features such as function calling, JSON output, and FIM completion. For instructions on how to construct prompts to use these features, please refer to [DeepSeek-V2.5](https://huggingface.co/deepseek-ai/DeepSeek-V2.5#function-calling) repo.**\n\n**NOTE: Hugging Face's Transformers has not been directly supported yet.**\n\n## License\n\nThis repository and the model weights are licensed under the [MIT License](LICENSE).\n\n## Citation\n\n```\n@misc{deepseekai2024deepseekv3technicalreport,\n      title={DeepSeek-V3 Technical Report}, \n      author={DeepSeek-AI},\n      year={2024},\n      eprint={2412.19437},\n      archivePrefix={arXiv},\n      primaryClass={cs.CL},\n      url={https://arxiv.org/abs/2412.19437}, \n}\n```\n\n## Contact\nIf you have any questions, please raise an issue or contact us at [service@deepseek.com](service@deepseek.com).\n",
    "config": "{\n  \"architectures\": [\n    \"DeepseekV3ForCausalLM\"\n  ],\n  \"attention_bias\": false,\n  \"attention_dropout\": 0.0,\n  \"auto_map\": {\n    \"AutoConfig\": \"configuration_deepseek.DeepseekV3Config\",\n    \"AutoModel\": \"modeling_deepseek.DeepseekV3Model\",\n    \"AutoModelForCausalLM\": \"modeling_deepseek.DeepseekV3ForCausalLM\"\n  },\n  \"bos_token_id\": 0,\n  \"eos_token_id\": 1,\n  \"ep_size\": 1,\n  \"first_k_dense_replace\": 3,\n  \"hidden_act\": \"silu\",\n  \"hidden_size\": 7168,\n  \"initializer_range\": 0.02,\n  \"intermediate_size\": 18432,\n  \"kv_lora_rank\": 512,\n  \"max_position_embeddings\": 163840,\n  \"model_type\": \"deepseek_v3\",\n  \"moe_intermediate_size\": 2048,\n  \"moe_layer_freq\": 1,\n  \"n_group\": 8,\n  \"n_routed_experts\": 256,\n  \"n_shared_experts\": 1,\n  \"norm_topk_prob\": true,\n  \"num_attention_heads\": 128,\n  \"num_experts_per_tok\": 8,\n  \"num_hidden_layers\": 61,\n  \"num_key_value_heads\": 128,\n  \"num_nextn_predict_layers\": 1,\n  \"q_lora_rank\": 1536,\n  \"qk_nope_head_dim\": 128,\n  \"qk_rope_head_dim\": 64,\n  \"quantization_config\": {\n    \"activation_scheme\": \"dynamic\",\n    \"fmt\": \"e4m3\",\n    \"quant_method\": \"fp8\",\n    \"weight_block_size\": [\n      128,\n      128\n    ]\n  },\n  \"rms_norm_eps\": 1e-06,\n  \"rope_scaling\": {\n    \"beta_fast\": 32,\n    \"beta_slow\": 1,\n    \"factor\": 40,\n    \"mscale\": 1.0,\n    \"mscale_all_dim\": 1.0,\n    \"original_max_position_embeddings\": 4096,\n    \"type\": \"yarn\"\n  },\n  \"rope_theta\": 10000,\n  \"routed_scaling_factor\": 2.5,\n  \"scoring_func\": \"sigmoid\",\n  \"tie_word_embeddings\": false,\n  \"topk_group\": 4,\n  \"topk_method\": \"noaux_tc\",\n  \"torch_dtype\": \"bfloat16\",\n  \"transformers_version\": \"4.46.3\",\n  \"use_cache\": true,\n  \"v_head_dim\": 128,\n  \"vocab_size\": 129280\n}\n",
    "generation_config": "",
    "license_file": "MIT License\n\nCopyright (c) 2023 DeepSeek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.",
    "py_files": {
        "configuration_deepseek.py": "from transformers.configuration_utils import PretrainedConfig\nfrom transformers.utils import logging\n\nlogger = logging.get_logger(__name__)\n\nDEEPSEEK_PRETRAINED_CONFIG_ARCHIVE_MAP = {}\nclass DeepseekV3Config(PretrainedConfig):\n    r\"\"\"\n    This is the configuration class to store the configuration of a [`DeepseekV3Model`]. It is used to instantiate an DeepSeek\n    model according to the specified arguments, defining the model architecture. Instantiating a configuration with the\n    defaults will yield a similar configuration to that of the DeepSeek-V3.\n\n    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n    documentation from [`PretrainedConfig`] for more information.\n\n\n    Args:\n        vocab_size (`int`, *optional*, defaults to 129280):\n            Vocabulary size of the Deep model. Defines the number of different tokens that can be represented by the\n            `inputs_ids` passed when calling [`DeepseekV3Model`]\n        hidden_size (`int`, *optional*, defaults to 4096):\n            Dimension of the hidden representations.\n        intermediate_size (`int`, *optional*, defaults to 11008):\n            Dimension of the MLP representations.\n        moe_intermediate_size (`int`, *optional*, defaults to 1407):\n            Dimension of the MoE representations.\n        num_hidden_layers (`int`, *optional*, defaults to 32):\n            Number of hidden layers in the Transformer decoder.\n        num_nextn_predict_layers (`int`, *optional*, defaults to 1):\n            Number of nextn predict layers in the DeepSeekV3 Model.\n        num_attention_heads (`int`, *optional*, defaults to 32):\n            Number of attention heads for each attention layer in the Transformer decoder.\n        n_shared_experts (`int`, *optional*, defaults to None):\n            Number of shared experts, None means dense model.\n        n_routed_experts (`int`, *optional*, defaults to None):\n            Number of routed experts, None means dense model.\n        routed_scaling_factor (`float`, *optional*, defaults to 1.0):\n            Scaling factor or routed experts.\n        topk_method (`str`, *optional*, defaults to `gready`):\n            Topk method used in routed gate.\n        n_group (`int`, *optional*, defaults to None):\n            Number of groups for routed experts.\n        topk_group (`int`, *optional*, defaults to None):\n            Number of selected groups for each token(for each token, ensuring the selected experts is only within `topk_group` groups).\n        num_experts_per_tok (`int`, *optional*, defaults to None):\n            Number of selected experts, None means dense model.\n        moe_layer_freq (`int`, *optional*, defaults to 1):\n            The frequency of the MoE layer: one expert layer for every `moe_layer_freq - 1` dense layers.\n        first_k_dense_replace (`int`, *optional*, defaults to 0):\n            Number of dense layers in shallow layers(embed->dense->dense->...->dense->moe->moe...->lm_head).\n                                                            \\--k dense layers--/\n        norm_topk_prob (`bool`, *optional*, defaults to False):\n            Whether to normalize the weights of the routed experts.\n        scoring_func (`str`, *optional*, defaults to 'softmax'):\n            Method of computing expert weights.\n        aux_loss_alpha (`float`, *optional*, defaults to 0.001):\n            Auxiliary loss weight coefficient.\n        seq_aux = (`bool`, *optional*, defaults to True):\n            Whether to compute the auxiliary loss for each individual sample.\n        num_key_value_heads (`int`, *optional*):\n            This is the number of key_value heads that should be used to implement Grouped Query Attention. If\n            `num_key_value_heads=num_attention_heads`, the model will use Multi Head Attention (MHA), if\n            `num_key_value_heads=1 the model will use Multi Query Attention (MQA) otherwise GQA is used. When\n            converting a multi-head checkpoint to a GQA checkpoint, each group key and value head should be constructed\n            by meanpooling all the original heads within that group. For more details checkout [this\n            paper](https://arxiv.org/pdf/2305.13245.pdf). If it is not specified, will default to\n            `num_attention_heads`.\n        hidden_act (`str` or `function`, *optional*, defaults to `\"silu\"`):\n            The non-linear activation function (function or string) in the decoder.\n        max_position_embeddings (`int`, *optional*, defaults to 2048):\n            The maximum sequence length that this model might ever be used with.\n        initializer_range (`float`, *optional*, defaults to 0.02):\n            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n        rms_norm_eps (`float`, *optional*, defaults to 1e-06):\n            The epsilon used by the rms normalization layers.\n        use_cache (`bool`, *optional*, defaults to `True`):\n            Whether or not the model should return the last key/values attentions (not used by all models). Only\n            relevant if `config.is_decoder=True`.\n        pad_token_id (`int`, *optional*):\n            Padding token id.\n        bos_token_id (`int`, *optional*, defaults to 1):\n            Beginning of stream token id.\n        eos_token_id (`int`, *optional*, defaults to 2):\n            End of stream token id.\n        tie_word_embeddings (`bool`, *optional*, defaults to `False`):\n            Whether to tie weight embeddings\n        rope_theta (`float`, *optional*, defaults to 10000.0):\n            The base period of the RoPE embeddings.\n        rope_scaling (`Dict`, *optional*):\n            Dictionary containing the scaling configuration for the RoPE embeddings. Currently supports two scaling\n            strategies: linear and dynamic. Their scaling factor must be a float greater than 1. The expected format is\n            `{\"type\": strategy name, \"factor\": scaling factor}`. When using this flag, don't update\n            `max_position_embeddings` to the expected new maximum.\n        attention_bias (`bool`, defaults to `False`, *optional*, defaults to `False`):\n            Whether to use a bias in the query, key, value and output projection layers during self-attention.\n        attention_dropout (`float`, *optional*, defaults to 0.0):\n            The dropout ratio for the attention probabilities.\n\n    ```python\n    >>> from transformers import DeepseekV3Model, DeepseekV3Config\n\n    >>> # Initializing a Deepseek-V3 style configuration\n    >>> configuration = DeepseekV3Config()\n\n    >>> # Accessing the model configuration\n    >>> configuration = model.config\n    ```\"\"\"\n\n    model_type = \"deepseek_v3\"\n    keys_to_ignore_at_inference = [\"past_key_values\"]\n\n    def __init__(\n        self,\n        vocab_size=129280,\n        hidden_size=7168,\n        intermediate_size=18432,\n        moe_intermediate_size = 2048,\n        num_hidden_layers=61,\n        num_nextn_predict_layers=1,\n        num_attention_heads=128,\n        num_key_value_heads=128,\n        n_shared_experts = 1,\n        n_routed_experts = 256,\n        ep_size = 1,\n        routed_scaling_factor = 2.5,\n        kv_lora_rank = 512,\n        q_lora_rank = 1536,\n        qk_rope_head_dim = 64,\n        v_head_dim = 128,\n        qk_nope_head_dim = 128,\n        topk_method = 'noaux_tc',\n        n_group = 8,\n        topk_group = 4,\n        num_experts_per_tok = 8,\n        moe_layer_freq = 1,\n        first_k_dense_replace = 3,\n        norm_topk_prob = True,\n        scoring_func = 'sigmoid',\n        hidden_act=\"silu\",\n        max_position_embeddings=4096,\n        initializer_range=0.02,\n        rms_norm_eps=1e-6,\n        use_cache=True,\n        pad_token_id=None,\n        bos_token_id=0,\n        eos_token_id=1,\n        tie_word_embeddings=False,\n        rope_theta=10000.0,\n        rope_scaling=None,\n        attention_bias=False,\n        attention_dropout=0.0,\n        **kwargs,\n    ):\n        self.vocab_size = vocab_size\n        self.max_position_embeddings = max_position_embeddings\n        self.hidden_size = hidden_size\n        self.intermediate_size = intermediate_size\n        self.moe_intermediate_size = moe_intermediate_size\n        self.num_hidden_layers = num_hidden_layers\n        self.num_nextn_predict_layers = num_nextn_predict_layers\n        self.num_attention_heads = num_attention_heads\n        self.n_shared_experts = n_shared_experts\n        self.n_routed_experts = n_routed_experts\n        self.ep_size = ep_size\n        self.routed_scaling_factor = routed_scaling_factor\n        self.kv_lora_rank = kv_lora_rank\n        self.q_lora_rank = q_lora_rank\n        self.qk_rope_head_dim = qk_rope_head_dim\n        self.v_head_dim = v_head_dim\n        self.qk_nope_head_dim = qk_nope_head_dim\n        self.topk_method = topk_method\n        self.n_group = n_group\n        self.topk_group = topk_group\n        self.num_experts_per_tok = num_experts_per_tok\n        self.moe_layer_freq = moe_layer_freq\n        self.first_k_dense_replace = first_k_dense_replace\n        self.norm_topk_prob = norm_topk_prob\n        self.scoring_func = scoring_func\n        # for backward compatibility\n        if num_key_value_heads is None:\n            num_key_value_heads = num_attention_heads\n\n        self.num_key_value_heads = num_key_value_heads\n        self.hidden_act = hidden_act\n        self.initializer_range = initializer_range\n        self.rms_norm_eps = rms_norm_eps\n        self.use_cache = use_cache\n        self.rope_theta = rope_theta\n        self.rope_scaling = rope_scaling\n        self.attention_bias = attention_bias\n        self.attention_dropout = attention_dropout\n\n        super().__init__(\n            pad_token_id=pad_token_id,\n            bos_token_id=bos_token_id,\n            eos_token_id=eos_token_id,\n            tie_word_embeddings=tie_word_embeddings,\n            **kwargs,\n        )",
        "modeling_deepseek.py": "# coding=utf-8\n# Copyright 2023 DeepSeek-AI and The HuggingFace Inc. team. All rights reserved.\n#\n# This code is based on EleutherAI's GPT-NeoX library and the GPT-NeoX\n# and OPT implementations in this library. It has been modified from its\n# original forms to accommodate minor architectural differences compared\n# to GPT-NeoX and OPT used by the Meta AI team that trained the model.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\" PyTorch DeepSeek model.\"\"\"\nimport math\nimport warnings\nfrom typing import List, Optional, Tuple, Union\n\nimport torch\nimport torch.nn.functional as F\nimport torch.utils.checkpoint\nfrom torch import nn\nfrom torch.nn import BCEWithLogitsLoss, CrossEntropyLoss, MSELoss\n\nfrom transformers.activations import ACT2FN\nfrom transformers.cache_utils import Cache, DynamicCache\nfrom transformers.modeling_attn_mask_utils import (\n    AttentionMaskConverter,\n    _prepare_4d_attention_mask,\n    _prepare_4d_causal_attention_mask,\n)\nfrom transformers.modeling_outputs import (\n    BaseModelOutputWithPast,\n    CausalLMOutputWithPast,\n    SequenceClassifierOutputWithPast,\n)\nfrom transformers.modeling_utils import PreTrainedModel\nfrom transformers.pytorch_utils import (\n    ALL_LAYERNORM_LAYERS,\n    is_torch_greater_or_equal_than_1_13,\n)\nfrom transformers.utils import (\n    add_start_docstrings,\n    add_start_docstrings_to_model_forward,\n    is_flash_attn_2_available,\n    is_flash_attn_greater_or_equal_2_10,\n    logging,\n    replace_return_docstrings,\n)\nfrom transformers.utils.import_utils import is_torch_fx_available\nfrom .configuration_deepseek import DeepseekV3Config\nimport torch.distributed as dist\nimport numpy as np\n\nif is_flash_attn_2_available():\n    from flash_attn import flash_attn_func, flash_attn_varlen_func\n    from flash_attn.bert_padding import index_first_axis, pad_input, unpad_input  # noqa\n\n\n# This makes `_prepare_4d_causal_attention_mask` a leaf function in the FX graph.\n# It means that the function will not be traced through and simply appear as a node in the graph.\nif is_torch_fx_available():\n    if not is_torch_greater_or_equal_than_1_13:\n        import torch.fx\n\n    _prepare_4d_causal_attention_mask = torch.fx.wrap(_prepare_4d_causal_attention_mask)\n\n\nlogger = logging.get_logger(__name__)\n\n_CONFIG_FOR_DOC = \"DeepseekV3Config\"\n\n\ndef _get_unpad_data(attention_mask):\n    seqlens_in_batch = attention_mask.sum(dim=-1, dtype=torch.int32)\n    indices = torch.nonzero(attention_mask.flatten(), as_tuple=False).flatten()\n    max_seqlen_in_batch = seqlens_in_batch.max().item()\n    cu_seqlens = F.pad(\n        torch.cumsum(seqlens_in_batch, dim=0, dtype=torch.torch.int32), (1, 0)\n    )\n    return (\n        indices,\n        cu_seqlens,\n        max_seqlen_in_batch,\n    )\n\n\nclass DeepseekV3RMSNorm(nn.Module):\n    def __init__(self, hidden_size, eps=1e-6):\n        \"\"\"\n        DeepseekV3RMSNorm is equivalent to T5LayerNorm\n        \"\"\"\n        super().__init__()\n        self.weight = nn.Parameter(torch.ones(hidden_size))\n        self.variance_epsilon = eps\n\n    def forward(self, hidden_states):\n        input_dtype = hidden_states.dtype\n        hidden_states = hidden_states.to(torch.float32)\n        variance = hidden_states.pow(2).mean(-1, keepdim=True)\n        hidden_states = hidden_states * torch.rsqrt(variance + self.variance_epsilon)\n        return self.weight * hidden_states.to(input_dtype)\n\n\nALL_LAYERNORM_LAYERS.append(DeepseekV3RMSNorm)\n\n\nclass DeepseekV3RotaryEmbedding(nn.Module):\n    def __init__(self, dim, max_position_embeddings=2048, base=10000, device=None):\n        super().__init__()\n\n        self.dim = dim\n        self.max_position_embeddings = max_position_embeddings\n        self.base = base\n        inv_freq = 1.0 / (\n            self.base ** (torch.arange(0, self.dim, 2).float().to(device) / self.dim)\n        )\n        self.register_buffer(\"inv_freq\", inv_freq, persistent=False)\n\n        # Build here to make `torch.jit.trace` work.\n        self._set_cos_sin_cache(\n            seq_len=max_position_embeddings,\n            device=self.inv_freq.device,\n            dtype=torch.get_default_dtype(),\n        )\n        self.max_seq_len_cached = None\n\n    def _set_cos_sin_cache(self, seq_len, device, dtype):\n        self.max_seq_len_cached = seq_len\n        t = torch.arange(\n            self.max_seq_len_cached, device=device, dtype=self.inv_freq.dtype\n        )\n\n        freqs = torch.outer(t, self.inv_freq.to(t.device))\n        # Different from paper, but it uses a different permutation in order to obtain the same calculation\n        emb = torch.cat((freqs, freqs), dim=-1)\n        self.register_buffer(\"cos_cached\", emb.cos().to(dtype), persistent=False)\n        self.register_buffer(\"sin_cached\", emb.sin().to(dtype), persistent=False)\n\n    def forward(self, x, seq_len=None):\n        # x: [bs, num_attention_heads, seq_len, head_size]\n        if self.max_seq_len_cached is None or seq_len > self.max_seq_len_cached:\n            self._set_cos_sin_cache(seq_len=seq_len, device=x.device, dtype=x.dtype)\n\n        return (\n            self.cos_cached[:seq_len].to(dtype=x.dtype),\n            self.sin_cached[:seq_len].to(dtype=x.dtype),\n        )\n\n\n# Copied from transformers.models.llama.modeling_llama.LlamaLinearScalingRotaryEmbedding with Llama->DeepseekV3\nclass DeepseekV3LinearScalingRotaryEmbedding(DeepseekV3RotaryEmbedding):\n    \"\"\"DeepseekV3RotaryEmbedding extended with linear scaling. Credits to the Reddit user /u/kaiokendev\"\"\"\n\n    def __init__(\n        self,\n        dim,\n        max_position_embeddings=2048,\n        base=10000,\n        device=None,\n        scaling_factor=1.0,\n    ):\n        self.scaling_factor = scaling_factor\n        super().__init__(dim, max_position_embeddings, base, device)\n\n    def _set_cos_sin_cache(self, seq_len, device, dtype):\n        self.max_seq_len_cached = seq_len\n        t = torch.arange(\n            self.max_seq_len_cached, device=device, dtype=self.inv_freq.dtype\n        )\n        t = t / self.scaling_factor\n\n        freqs = torch.outer(t, self.inv_freq)\n        # Different from paper, but it uses a different permutation in order to obtain the same calculation\n        emb = torch.cat((freqs, freqs), dim=-1)\n        self.register_buffer(\"cos_cached\", emb.cos().to(dtype), persistent=False)\n        self.register_buffer(\"sin_cached\", emb.sin().to(dtype), persistent=False)\n\n\n# Copied from transformers.models.llama.modeling_llama.LlamaDynamicNTKScalingRotaryEmbedding with Llama->DeepseekV3\nclass DeepseekV3DynamicNTKScalingRotaryEmbedding(DeepseekV3RotaryEmbedding):\n    \"\"\"DeepseekV3RotaryEmbedding extended with Dynamic NTK scaling. Credits to the Reddit users /u/bloc97 and /u/emozilla\"\"\"\n\n    def __init__(\n        self,\n        dim,\n        max_position_embeddings=2048,\n        base=10000,\n        device=None,\n        scaling_factor=1.0,\n    ):\n        self.scaling_factor = scaling_factor\n        super().__init__(dim, max_position_embeddings, base, device)\n\n    def _set_cos_sin_cache(self, seq_len, device, dtype):\n        self.max_seq_len_cached = seq_len\n\n        if seq_len > self.max_position_embeddings:\n            base = self.base * (\n                (self.scaling_factor * seq_len / self.max_position_embeddings)\n                - (self.scaling_factor - 1)\n            ) ** (self.dim / (self.dim - 2))\n            inv_freq = 1.0 / (\n                base ** (torch.arange(0, self.dim, 2).float().to(device) / self.dim)\n            )\n            self.register_buffer(\"inv_freq\", inv_freq, persistent=False)\n\n        t = torch.arange(\n            self.max_seq_len_cached, device=device, dtype=self.inv_freq.dtype\n        )\n\n        freqs = torch.outer(t, self.inv_freq)\n        # Different from paper, but it uses a different permutation in order to obtain the same calculation\n        emb = torch.cat((freqs, freqs), dim=-1)\n        self.register_buffer(\"cos_cached\", emb.cos().to(dtype), persistent=False)\n        self.register_buffer(\"sin_cached\", emb.sin().to(dtype), persistent=False)\n\n\n# Inverse dim formula to find dim based on number of rotations\ndef yarn_find_correction_dim(\n    num_rotations, dim, base=10000, max_position_embeddings=2048\n):\n    return (dim * math.log(max_position_embeddings / (num_rotations * 2 * math.pi))) / (\n        2 * math.log(base)\n    )\n\n\n# Find dim range bounds based on rotations\ndef yarn_find_correction_range(\n    low_rot, high_rot, dim, base=10000, max_position_embeddings=2048\n):\n    low = math.floor(\n        yarn_find_correction_dim(low_rot, dim, base, max_position_embeddings)\n    )\n    high = math.ceil(\n        yarn_find_correction_dim(high_rot, dim, base, max_position_embeddings)\n    )\n    return max(low, 0), min(high, dim - 1)  # Clamp values just in case\n\n\ndef yarn_get_mscale(scale=1, mscale=1):\n    if scale <= 1:\n        return 1.0\n    return 0.1 * mscale * math.log(scale) + 1.0\n\n\ndef yarn_linear_ramp_mask(min, max, dim):\n    if min == max:\n        max += 0.001  # Prevent singularity\n\n    linear_func = (torch.arange(dim, dtype=torch.float32) - min) / (max - min)\n    ramp_func = torch.clamp(linear_func, 0, 1)\n    return ramp_func\n\n\nclass DeepseekV3YarnRotaryEmbedding(DeepseekV3RotaryEmbedding):\n\n    def __init__(\n        self,\n        dim,\n        max_position_embeddings=2048,\n        base=10000,\n        device=None,\n        scaling_factor=1.0,\n        original_max_position_embeddings=4096,\n        beta_fast=32,\n        beta_slow=1,\n        mscale=1,\n        mscale_all_dim=0,\n    ):\n        self.scaling_factor = scaling_factor\n        self.original_max_position_embeddings = original_max_position_embeddings\n        self.beta_fast = beta_fast\n        self.beta_slow = beta_slow\n        self.mscale = mscale\n        self.mscale_all_dim = mscale_all_dim\n        super().__init__(dim, max_position_embeddings, base, device)\n\n    def _set_cos_sin_cache(self, seq_len, device, dtype):\n        self.max_seq_len_cached = seq_len\n        dim = self.dim\n\n        freq_extra = 1.0 / (\n            self.base\n            ** (torch.arange(0, dim, 2, dtype=torch.float32, device=device) / dim)\n        )\n        freq_inter = 1.0 / (\n            self.scaling_factor\n            * self.base\n            ** (torch.arange(0, dim, 2, dtype=torch.float32, device=device) / dim)\n        )\n\n        low, high = yarn_find_correction_range(\n            self.beta_fast,\n            self.beta_slow,\n            dim,\n            self.base,\n            self.original_max_position_embeddings,\n        )\n        inv_freq_mask = 1.0 - yarn_linear_ramp_mask(low, high, dim // 2).to(\n            device=device, dtype=torch.float32\n        )\n        inv_freq = freq_inter * (1 - inv_freq_mask) + freq_extra * inv_freq_mask\n        self.register_buffer(\"inv_freq\", inv_freq, persistent=False)\n\n        t = torch.arange(seq_len, device=device, dtype=torch.float32)\n\n        freqs = torch.outer(t, inv_freq)\n\n        _mscale = float(\n            yarn_get_mscale(self.scaling_factor, self.mscale)\n            / yarn_get_mscale(self.scaling_factor, self.mscale_all_dim)\n        )\n\n        emb = torch.cat((freqs, freqs), dim=-1)\n        self.register_buffer(\n            \"cos_cached\", (emb.cos() * _mscale).to(dtype), persistent=False\n        )\n        self.register_buffer(\n            \"sin_cached\", (emb.sin() * _mscale).to(dtype), persistent=False\n        )\n\n\n# Copied from transformers.models.llama.modeling_llama.rotate_half\ndef rotate_half(x):\n    \"\"\"Rotates half the hidden dims of the input.\"\"\"\n    x1 = x[..., : x.shape[-1] // 2]\n    x2 = x[..., x.shape[-1] // 2 :]\n    return torch.cat((-x2, x1), dim=-1)\n\n\n# Copied from transformers.models.llama.modeling_llama.apply_rotary_pos_emb\ndef apply_rotary_pos_emb(q, k, cos, sin, position_ids, unsqueeze_dim=1):\n    \"\"\"Applies Rotary Position Embedding to the query and key tensors.\n\n    Args:\n        q (`torch.Tensor`): The query tensor.\n        k (`torch.Tensor`): The key tensor.\n        cos (`torch.Tensor`): The cosine part of the rotary embedding.\n        sin (`torch.Tensor`): The sine part of the rotary embedding.\n        position_ids (`torch.Tensor`):\n            The position indices of the tokens corresponding to the query and key tensors. For example, this can be\n            used to pass offsetted position ids when working with a KV-cache.\n        unsqueeze_dim (`int`, *optional*, defaults to 1):\n            The 'unsqueeze_dim' argument specifies the dimension along which to unsqueeze cos[position_ids] and\n            sin[position_ids] so that they can be properly broadcasted to the dimensions of q and k. For example, note\n            that cos[position_ids] and sin[position_ids] have the shape [batch_size, seq_len, head_dim]. Then, if q and\n            k have the shape [batch_size, heads, seq_len, head_dim], then setting unsqueeze_dim=1 makes\n            cos[position_ids] and sin[position_ids] broadcastable to the shapes of q and k. Similarly, if q and k have\n            the shape [batch_size, seq_len, heads, head_dim], then set unsqueeze_dim=2.\n    Returns:\n        `tuple(torch.Tensor)` comprising of the query and key tensors rotated using the Rotary Position Embedding.\n    \"\"\"\n    cos = cos[position_ids].unsqueeze(unsqueeze_dim)\n    sin = sin[position_ids].unsqueeze(unsqueeze_dim)\n\n    b, h, s, d = q.shape\n    q = q.view(b, h, s, d // 2, 2).transpose(4, 3).reshape(b, h, s, d)\n\n    b, h, s, d = k.shape\n    k = k.view(b, h, s, d // 2, 2).transpose(4, 3).reshape(b, h, s, d)\n\n    q_embed = (q * cos) + (rotate_half(q) * sin)\n    k_embed = (k * cos) + (rotate_half(k) * sin)\n    return q_embed, k_embed\n\n\nclass DeepseekV3MLP(nn.Module):\n    def __init__(self, config, hidden_size=None, intermediate_size=None):\n        super().__init__()\n        self.config = config\n        self.hidden_size = config.hidden_size if hidden_size is None else hidden_size\n        self.intermediate_size = (\n            config.intermediate_size if intermediate_size is None else intermediate_size\n        )\n\n        self.gate_proj = nn.Linear(self.hidden_size, self.intermediate_size, bias=False)\n        self.up_proj = nn.Linear(self.hidden_size, self.intermediate_size, bias=False)\n        self.down_proj = nn.Linear(self.intermediate_size, self.hidden_size, bias=False)\n        self.act_fn = ACT2FN[config.hidden_act]\n\n    def forward(self, x):\n        down_proj = self.down_proj(self.act_fn(self.gate_proj(x)) * self.up_proj(x))\n        return down_proj\n\n\nclass MoEGate(nn.Module):\n    def __init__(self, config):\n        super().__init__()\n        self.config = config\n        self.top_k = config.num_experts_per_tok\n        self.n_routed_experts = config.n_routed_experts\n        self.routed_scaling_factor = config.routed_scaling_factor\n        self.scoring_func = config.scoring_func\n        self.topk_method = config.topk_method\n        self.n_group = config.n_group\n        self.topk_group = config.topk_group\n\n        # topk selection algorithm\n        self.norm_topk_prob = config.norm_topk_prob\n        self.gating_dim = config.hidden_size\n        self.weight = nn.Parameter(\n            torch.empty((self.n_routed_experts, self.gating_dim))\n        )\n        if self.topk_method == \"noaux_tc\":\n            self.e_score_correction_bias = nn.Parameter(\n                torch.empty((self.n_routed_experts))\n            )\n        self.reset_parameters()\n\n    def reset_parameters(self) -> None:\n        import torch.nn.init as init\n\n        init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n\n    def forward(self, hidden_states):\n        bsz, seq_len, h = hidden_states.shape\n        ### compute gating score\n        hidden_states = hidden_states.view(-1, h)\n        logits = F.linear(\n            hidden_states.type(torch.float32), self.weight.type(torch.float32), None\n        )\n        if self.scoring_func == \"sigmoid\":\n            scores = logits.sigmoid()\n        else:\n            raise NotImplementedError(\n                f\"insupportable scoring function for MoE gating: {self.scoring_func}\"\n            )\n\n        ### select top-k experts\n        if self.topk_method == \"noaux_tc\":\n            assert not self.training\n            scores_for_choice = scores.view(bsz * seq_len, -1) + self.e_score_correction_bias.unsqueeze(0)\n            group_scores = (\n                scores_for_choice.view(bsz * seq_len, self.n_group, -1).topk(2, dim=-1)[0].sum(dim = -1)\n            )  # [n, n_group]\n            group_idx = torch.topk(\n                group_scores, k=self.topk_group, dim=-1, sorted=False\n            )[\n                1\n            ]  # [n, top_k_group]\n            group_mask = torch.zeros_like(group_scores)  # [n, n_group]\n            group_mask.scatter_(1, group_idx, 1)  # [n, n_group]\n            score_mask = (\n                group_mask.unsqueeze(-1)\n                .expand(\n                    bsz * seq_len, self.n_group, self.n_routed_experts // self.n_group\n                )\n                .reshape(bsz * seq_len, -1)\n            )  # [n, e]\n            tmp_scores = scores_for_choice.masked_fill(~score_mask.bool(), float(\"-inf\"))  # [n, e]\n            _, topk_idx = torch.topk(\n                tmp_scores, k=self.top_k, dim=-1, sorted=False\n            )\n            topk_weight = scores.gather(1, topk_idx)\n        else:\n            raise NotImplementedError(\n                f\"insupportable TopK function for MoE gating: {self.topk_method}\"\n            )\n\n        ### norm gate to sum 1\n        if self.top_k > 1 and self.norm_topk_prob:\n            denominator = topk_weight.sum(dim=-1, keepdim=True) + 1e-20\n            topk_weight = topk_weight / denominator\n        topk_weight = topk_weight * self.routed_scaling_factor # must multiply the scaling factor\n\n        return topk_idx, topk_weight\n\nclass DeepseekV3MoE(nn.Module):\n    \"\"\"\n    A mixed expert module containing shared experts.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.config = config\n        self.num_experts_per_tok = config.num_experts_per_tok\n\n        if hasattr(config, \"ep_size\") and config.ep_size > 1:\n            assert config.ep_size == dist.get_world_size()\n            self.ep_size = config.ep_size\n            self.experts_per_rank = config.n_routed_experts // config.ep_size\n            self.ep_rank = dist.get_rank()\n            self.experts = nn.ModuleList(\n                [\n                    (\n                        DeepseekV3MLP(\n                            config, intermediate_size=config.moe_intermediate_size\n                        )\n                        if i >= self.ep_rank * self.experts_per_rank\n                        and i < (self.ep_rank + 1) * self.experts_per_rank\n                        else None\n                    )\n                    for i in range(config.n_routed_experts)\n                ]\n            )\n        else:\n            self.ep_size = 1\n            self.experts_per_rank = config.n_routed_experts\n            self.ep_rank = 0\n            self.experts = nn.ModuleList(\n                [\n                    DeepseekV3MLP(\n                        config, intermediate_size=config.moe_intermediate_size\n                    )\n                    for i in range(config.n_routed_experts)\n                ]\n            )\n        self.gate = MoEGate(config)\n        if config.n_shared_experts is not None:\n            intermediate_size = config.moe_intermediate_size * config.n_shared_experts\n            self.shared_experts = DeepseekV3MLP(\n                config=config, intermediate_size=intermediate_size\n            )\n\n    def forward(self, hidden_states):\n        identity = hidden_states\n        orig_shape = hidden_states.shape\n        topk_idx, topk_weight = self.gate(hidden_states)\n        hidden_states = hidden_states.view(-1, hidden_states.shape[-1])\n        flat_topk_idx = topk_idx.view(-1)\n        if not self.training:\n            y = self.moe_infer(hidden_states, topk_idx, topk_weight).view(*orig_shape)\n        if self.config.n_shared_experts is not None:\n            y = y + self.shared_experts(identity)\n        return y\n\n    @torch.no_grad()\n    def moe_infer(self, x, topk_ids, topk_weight):\n        cnts = topk_ids.new_zeros((topk_ids.shape[0], len(self.experts)))\n        cnts.scatter_(1, topk_ids, 1)\n        tokens_per_expert = cnts.sum(dim=0)\n        idxs = topk_ids.view(-1).argsort()\n        sorted_tokens = x[idxs // topk_ids.shape[1]]\n        sorted_tokens_shape = sorted_tokens.shape\n        if self.ep_size > 1:\n            tokens_per_ep_rank = tokens_per_expert.view(self.ep_size, -1).sum(dim=1)\n            tokens_per_expert_group = tokens_per_expert.new_empty(\n                tokens_per_expert.shape[0]\n            )\n            dist.all_to_all_single(tokens_per_expert_group, tokens_per_expert)\n            output_splits = (\n                tokens_per_expert_group.view(self.ep_size, -1)\n                .sum(1)\n                .cpu()\n                .numpy()\n                .tolist()\n            )\n            gathered_tokens = sorted_tokens.new_empty(\n                tokens_per_expert_group.sum(dim=0).cpu().item(), sorted_tokens.shape[1]\n            )\n            input_split_sizes = tokens_per_ep_rank.cpu().numpy().tolist()\n            dist.all_to_all(\n                list(gathered_tokens.split(output_splits)),\n                list(sorted_tokens.split(input_split_sizes)),\n            )\n            tokens_per_expert_post_gather = tokens_per_expert_group.view(\n                self.ep_size, self.experts_per_rank\n            ).sum(dim=0)\n            gatherd_idxs = np.zeros(shape=(gathered_tokens.shape[0],), dtype=np.int32)\n            s = 0\n            for i, k in enumerate(tokens_per_expert_group.cpu().numpy()):\n                gatherd_idxs[s : s + k] = i % self.experts_per_rank\n                s += k\n            gatherd_idxs = gatherd_idxs.argsort()\n            sorted_tokens = gathered_tokens[gatherd_idxs]\n            tokens_per_expert = tokens_per_expert_post_gather\n        tokens_per_expert = tokens_per_expert.cpu().numpy()\n\n        outputs = []\n        start_idx = 0\n        for i, num_tokens in enumerate(tokens_per_expert):\n            end_idx = start_idx + num_tokens\n            if num_tokens == 0:\n                continue\n            expert = self.experts[i + self.ep_rank * self.experts_per_rank]\n            tokens_for_this_expert = sorted_tokens[start_idx:end_idx]\n            expert_out = expert(tokens_for_this_expert)\n            outputs.append(expert_out)\n            start_idx = end_idx\n\n        outs = torch.cat(outputs, dim=0) if len(outputs) else sorted_tokens.new_empty(0)\n        if self.ep_size > 1:\n            new_x = torch.empty_like(outs)\n            new_x[gatherd_idxs] = outs\n            gathered_tokens = new_x.new_empty(*sorted_tokens_shape)\n            dist.all_to_all(\n                list(gathered_tokens.split(input_split_sizes)),\n                list(new_x.split(output_splits)),\n            )\n            outs = gathered_tokens\n\n        new_x = torch.empty_like(outs)\n        new_x[idxs] = outs\n        final_out = (\n            new_x.view(*topk_ids.shape, -1)\n            .type(topk_weight.dtype)\n            .mul_(topk_weight.unsqueeze(dim=-1))\n            .sum(dim=1)\n            .type(new_x.dtype)\n        )\n        return final_out\n\n\n# Copied from transformers.models.llama.modeling_llama.repeat_kv\ndef repeat_kv(hidden_states: torch.Tensor, n_rep: int) -> torch.Tensor:\n    \"\"\"\n    This is the equivalent of torch.repeat_interleave(x, dim=1, repeats=n_rep). The hidden states go from (batch,\n    num_key_value_heads, seqlen, head_dim) to (batch, num_attention_heads, seqlen, head_dim)\n    \"\"\"\n    batch, num_key_value_heads, slen, head_dim = hidden_states.shape\n    if n_rep == 1:\n        return hidden_states\n    hidden_states = hidden_states[:, :, None, :, :].expand(\n        batch, num_key_value_heads, n_rep, slen, head_dim\n    )\n    return hidden_states.reshape(batch, num_key_value_heads * n_rep, slen, head_dim)\n\n\n# Copied from transformers.models.llama.modeling_llama.LlamaAttention with Llama->DeepseekV3\nclass DeepseekV3Attention(nn.Module):\n    \"\"\"Multi-headed attention from 'Attention Is All You Need' paper\"\"\"\n\n    def __init__(self, config: DeepseekV3Config, layer_idx: Optional[int] = None):\n        super().__init__()\n        self.config = config\n        self.layer_idx = layer_idx\n        if layer_idx is None:\n            logger.warning_once(\n                f\"Instantiating {self.__class__.__name__} without passing `layer_idx` is not recommended and will \"\n                \"to errors during the forward call, if caching is used. Please make sure to provide a `layer_idx` \"\n                \"when creating this class.\"\n            )\n\n        self.attention_dropout = config.attention_dropout\n        self.hidden_size = config.hidden_size\n        self.num_heads = config.num_attention_heads\n\n        self.max_position_embeddings = config.max_position_embeddings\n        self.rope_theta = config.rope_theta\n        self.q_lora_rank = config.q_lora_rank\n        self.qk_rope_head_dim = config.qk_rope_head_dim\n        self.kv_lora_rank = config.kv_lora_rank\n        self.v_head_dim = config.v_head_dim\n        self.qk_nope_head_dim = config.qk_nope_head_dim\n        self.q_head_dim = config.qk_nope_head_dim + config.qk_rope_head_dim\n\n        self.is_causal = True\n\n        if self.q_lora_rank is None:\n            self.q_proj = nn.Linear(\n                self.hidden_size, self.num_heads * self.q_head_dim, bias=False\n            )\n        else:\n            self.q_a_proj = nn.Linear(\n                self.hidden_size, config.q_lora_rank, bias=config.attention_bias\n            )\n            self.q_a_layernorm = DeepseekV3RMSNorm(config.q_lora_rank)\n            self.q_b_proj = nn.Linear(\n                config.q_lora_rank, self.num_heads * self.q_head_dim, bias=False\n            )\n\n        self.kv_a_proj_with_mqa = nn.Linear(\n            self.hidden_size,\n            config.kv_lora_rank + config.qk_rope_head_dim,\n            bias=config.attention_bias,\n        )\n        self.kv_a_layernorm = DeepseekV3RMSNorm(config.kv_lora_rank)\n        self.kv_b_proj = nn.Linear(\n            config.kv_lora_rank,\n            self.num_heads\n            * (self.q_head_dim - self.qk_rope_head_dim + self.v_head_dim),\n            bias=False,\n        )\n\n        self.o_proj = nn.Linear(\n            self.num_heads * self.v_head_dim,\n            self.hidden_size,\n            bias=config.attention_bias,\n        )\n        self._init_rope()\n\n        self.softmax_scale = self.q_head_dim ** (-0.5)\n        if self.config.rope_scaling is not None:\n            mscale_all_dim = self.config.rope_scaling.get(\"mscale_all_dim\", 0)\n            scaling_factor = self.config.rope_scaling[\"factor\"]\n            if mscale_all_dim:\n                mscale = yarn_get_mscale(scaling_factor, mscale_all_dim)\n                self.softmax_scale = self.softmax_scale * mscale * mscale\n\n    def _init_rope(self):\n        if self.config.rope_scaling is None:\n            self.rotary_emb = DeepseekV3RotaryEmbedding(\n                self.qk_rope_head_dim,\n                max_position_embeddings=self.max_position_embeddings,\n                base=self.rope_theta,\n            )\n        else:\n            scaling_type = self.config.rope_scaling[\"type\"]\n            scaling_factor = self.config.rope_scaling[\"factor\"]\n            if scaling_type == \"linear\":\n                self.rotary_emb = DeepseekV3LinearScalingRotaryEmbedding(\n                    self.qk_rope_head_dim,\n                    max_position_embeddings=self.max_position_embeddings,\n                    scaling_factor=scaling_factor,\n                    base=self.rope_theta,\n                )\n            elif scaling_type == \"dynamic\":\n                self.rotary_emb = DeepseekV3DynamicNTKScalingRotaryEmbedding(\n                    self.qk_rope_head_dim,\n                    max_position_embeddings=self.max_position_embeddings,\n                    scaling_factor=scaling_factor,\n                    base=self.rope_theta,\n                )\n            elif scaling_type == \"yarn\":\n                kwargs = {\n                    key: self.config.rope_scaling[key]\n                    for key in [\n                        \"original_max_position_embeddings\",\n                        \"beta_fast\",\n                        \"beta_slow\",\n                        \"mscale\",\n                        \"mscale_all_dim\",\n                    ]\n                    if key in self.config.rope_scaling\n                }\n                self.rotary_emb = DeepseekV3YarnRotaryEmbedding(\n                    self.qk_rope_head_dim,\n                    max_position_embeddings=self.max_position_embeddings,\n                    scaling_factor=scaling_factor,\n                    base=self.rope_theta,\n                    **kwargs,\n                )\n            else:\n                raise ValueError(f\"Unknown RoPE scaling type {scaling_type}\")\n\n    def _shape(self, tensor: torch.Tensor, seq_len: int, bsz: int):\n        return (\n            tensor.view(bsz, seq_len, self.num_heads, self.v_head_dim)\n            .transpose(1, 2)\n            .contiguous()\n        )\n\n    def forward(\n        self,\n        hidden_states: torch.Tensor,\n        attention_mask: Optional[torch.Tensor] = None,\n        position_ids: Optional[torch.LongTensor] = None,\n        past_key_value: Optional[Cache] = None,\n        output_attentions: bool = False,\n        use_cache: bool = False,\n        **kwargs,\n    ) -> Tuple[torch.Tensor, Optional[torch.Tensor], Optional[Tuple[torch.Tensor]]]:\n        if \"padding_mask\" in kwargs:\n            warnings.warn(\n                \"Passing `padding_mask` is deprecated and will be removed in v4.37. Please make sure use `attention_mask` instead.`\"\n            )\n        bsz, q_len, _ = hidden_states.size()\n\n        if self.q_lora_rank is None:\n            q = self.q_proj(hidden_states)\n        else:\n            q = self.q_b_proj(self.q_a_layernorm(self.q_a_proj(hidden_states)))\n        q = q.view(bsz, q_len, self.num_heads, self.q_head_dim).transpose(1, 2)\n        q_nope, q_pe = torch.split(\n            q, [self.qk_nope_head_dim, self.qk_rope_head_dim], dim=-1\n        )\n\n        compressed_kv = self.kv_a_proj_with_mqa(hidden_states)\n        compressed_kv, k_pe = torch.split(\n            compressed_kv, [self.kv_lora_rank, self.qk_rope_head_dim], dim=-1\n        )\n        k_pe = k_pe.view(bsz, q_len, 1, self.qk_rope_head_dim).transpose(1, 2)\n        kv = (\n            self.kv_b_proj(self.kv_a_layernorm(compressed_kv))\n            .view(bsz, q_len, self.num_heads, self.qk_nope_head_dim + self.v_head_dim)\n            .transpose(1, 2)\n        )\n\n        k_nope, value_states = torch.split(\n            kv, [self.qk_nope_head_dim, self.v_head_dim], dim=-1\n        )\n        kv_seq_len = value_states.shape[-2]\n        if past_key_value is not None:\n            if self.layer_idx is None:\n                raise ValueError(\n                    f\"The cache structure has changed since version v4.36. If you are using {self.__class__.__name__} \"\n                    \"for auto-regressive decoding with k/v caching, please make sure to initialize the attention class \"\n                    \"with a layer index.\"\n                )\n            kv_seq_len += past_key_value.get_usable_length(kv_seq_len, self.layer_idx)\n        cos, sin = self.rotary_emb(value_states, seq_len=kv_seq_len)\n\n        q_pe, k_pe = apply_rotary_pos_emb(q_pe, k_pe, cos, sin, position_ids)\n\n        query_states = k_pe.new_empty(bsz, self.num_heads, q_len, self.q_head_dim)\n        query_states[:, :, :, : self.qk_nope_head_dim] = q_nope\n        query_states[:, :, :, self.qk_nope_head_dim :] = q_pe\n\n        key_states = k_pe.new_empty(bsz, self.num_heads, q_len, self.q_head_dim)\n        key_states[:, :, :, : self.qk_nope_head_dim] = k_nope\n        key_states[:, :, :, self.qk_nope_head_dim :] = k_pe\n        if past_key_value is not None:\n            cache_kwargs = {\"sin\": sin, \"cos\": cos}  # Specific to RoPE models\n            key_states, value_states = past_key_value.update(\n                key_states, value_states, self.layer_idx, cache_kwargs\n            )\n\n        attn_weights = (\n            torch.matmul(query_states, key_states.transpose(2, 3)) * self.softmax_scale\n        )\n\n        if attn_weights.size() != (bsz, self.num_heads, q_len, kv_seq_len):\n            raise ValueError(\n                f\"Attention weights should be of size {(bsz, self.num_heads, q_len, kv_seq_len)}, but is\"\n                f\" {attn_weights.size()}\"\n            )\n        assert attention_mask is not None\n        if attention_mask is not None:\n            if attention_mask.size() != (bsz, 1, q_len, kv_seq_len):\n                raise ValueError(\n                    f\"Attention mask should be of size {(bsz, 1, q_len, kv_seq_len)}, but is {attention_mask.size()}\"\n                )\n            attn_weights = attn_weights + attention_mask\n\n        # upcast attention to fp32\n        attn_weights = nn.functional.softmax(\n            attn_weights, dim=-1, dtype=torch.float32\n        ).to(query_states.dtype)\n        attn_weights = nn.functional.dropout(\n            attn_weights, p=self.attention_dropout, training=self.training\n        )\n        attn_output = torch.matmul(attn_weights, value_states)\n\n        if attn_output.size() != (bsz, self.num_heads, q_len, self.v_head_dim):\n            raise ValueError(\n                f\"`attn_output` should be of size {(bsz, self.num_heads, q_len, self.v_head_dim)}, but is\"\n                f\" {attn_output.size()}\"\n            )\n\n        attn_output = attn_output.transpose(1, 2).contiguous()\n\n        attn_output = attn_output.reshape(bsz, q_len, self.num_heads * self.v_head_dim)\n\n        attn_output = self.o_proj(attn_output)\n\n        if not output_attentions:\n            attn_weights = None\n\n        return attn_output, attn_weights, past_key_value\n\n\n# Copied from transformers.models.llama.modeling_llama.LlamaFlashAttention2 with Llama->DeepseekV3\nclass DeepseekV3FlashAttention2(DeepseekV3Attention):\n    \"\"\"\n    DeepseekV3 flash attention module. This module inherits from `DeepseekV3Attention` as the weights of the module stays\n    untouched. The only required change would be on the forward pass where it needs to correctly call the public API of\n    flash attention and deal with padding tokens in case the input contains any of them.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        # TODO: Should be removed once Flash Attention for RoCm is bumped to 2.1.\n        # flash_attn<2.1 generates top-left aligned causal mask, while what is needed here is bottom-right alignement, that was made default for flash_attn>=2.1. This attribute is used to handle this difference. Reference: https://github.com/Dao-AILab/flash-attention/releases/tag/v2.1.0.\n        # Beware that with flash_attn<2.1, using q_seqlen != k_seqlen (except for the case q_seqlen == 1) produces a wrong mask (top-left).\n        self._flash_attn_uses_top_left_mask = not is_flash_attn_greater_or_equal_2_10()\n\n    def forward(\n        self,\n        hidden_states: torch.Tensor,\n        attention_mask: Optional[torch.LongTensor] = None,\n        position_ids: Optional[torch.LongTensor] = None,\n        past_key_value: Optional[Cache] = None,\n        output_attentions: bool = False,\n        use_cache: bool = False,\n        **kwargs,\n    ) -> Tuple[torch.Tensor, Optional[torch.Tensor], Optional[Tuple[torch.Tensor]]]:\n        # DeepseekV3FlashAttention2 attention does not support output_attentions\n        if \"padding_mask\" in kwargs:\n            warnings.warn(\n                \"Passing `padding_mask` is deprecated and will be removed in v4.37. Please make sure use `attention_mask` instead.`\"\n            )\n\n            # overwrite attention_mask with padding_mask\n            attention_mask = kwargs.pop(\"padding_mask\")\n\n        output_attentions = False\n\n        bsz, q_len, _ = hidden_states.size()\n\n        if self.q_lora_rank is None:\n            q = self.q_proj(hidden_states)\n        else:\n            q = self.q_b_proj(self.q_a_layernorm(self.q_a_proj(hidden_states)))\n        q = q.view(bsz, q_len, self.num_heads, self.q_head_dim).transpose(1, 2)\n        q_nope, q_pe = torch.split(\n            q, [self.qk_nope_head_dim, self.qk_rope_head_dim], dim=-1\n        )\n\n        # Flash attention requires the input to have the shape\n        # batch_size x seq_length x head_dim x hidden_dim\n        # therefore we just need to keep the original shape\n        compressed_kv = self.kv_a_proj_with_mqa(hidden_states)\n        compressed_kv, k_pe = torch.split(\n            compressed_kv, [self.kv_lora_rank, self.qk_rope_head_dim], dim=-1\n        )\n        k_pe = k_pe.view(bsz, q_len, 1, self.qk_rope_head_dim).transpose(1, 2)\n        kv = (\n            self.kv_b_proj(self.kv_a_layernorm(compressed_kv))\n            .view(bsz, q_len, self.num_heads, self.qk_nope_head_dim + self.v_head_dim)\n            .transpose(1, 2)\n        )\n\n        k_nope, value_states = torch.split(\n            kv, [self.qk_nope_head_dim, self.v_head_dim], dim=-1\n        )\n        kv_seq_len = value_states.shape[-2]\n\n        kv_seq_len = value_states.shape[-2]\n        if past_key_value is not None:\n            kv_seq_len += past_key_value.get_usable_length(kv_seq_len, self.layer_idx)\n\n        cos, sin = self.rotary_emb(value_states, seq_len=kv_seq_len)\n        q_pe, k_pe = apply_rotary_pos_emb(q_pe, k_pe, cos, sin, position_ids)\n\n        query_states = k_pe.new_empty(bsz, self.num_heads, q_len, self.q_head_dim)\n        query_states[:, :, :, : self.qk_nope_head_dim] = q_nope\n        query_states[:, :, :, self.qk_nope_head_dim :] = q_pe\n\n        key_states = k_pe.new_empty(bsz, self.num_heads, q_len, self.q_head_dim)\n        key_states[:, :, :, : self.qk_nope_head_dim] = k_nope\n        key_states[:, :, :, self.qk_nope_head_dim :] = k_pe\n\n        if self.q_head_dim != self.v_head_dim:\n            value_states = F.pad(value_states, [0, self.q_head_dim - self.v_head_dim])\n\n        if past_key_value is not None:\n            cache_kwargs = {\"sin\": sin, \"cos\": cos}  # Specific to RoPE models\n            key_states, value_states = past_key_value.update(\n                key_states, value_states, self.layer_idx, cache_kwargs\n            )\n\n        # TODO: These transpose are quite inefficient but Flash Attention requires the layout [batch_size, sequence_length, num_heads, head_dim]. We would need to refactor the KV cache\n        # to be able to avoid many of these transpose/reshape/view.\n        query_states = query_states.transpose(1, 2)\n        key_states = key_states.transpose(1, 2)\n        value_states = value_states.transpose(1, 2)\n\n        dropout_rate = self.attention_dropout if self.training else 0.0\n\n        # In PEFT, usually we cast the layer norms in float32 for training stability reasons\n        # therefore the input hidden states gets silently casted in float32. Hence, we need\n        # cast them back in the correct dtype just to be sure everything works as expected.\n        # This might slowdown training & inference so it is recommended to not cast the LayerNorms\n        # in fp32. (DeepseekV3RMSNorm handles it correctly)\n\n        input_dtype = query_states.dtype\n        if input_dtype == torch.float32:\n            # Handle the case where the model is quantized\n            if hasattr(self.config, \"_pre_quantization_dtype\"):\n                target_dtype = self.config._pre_quantization_dtype\n            elif torch.is_autocast_enabled():\n                target_dtype = torch.get_autocast_gpu_dtype()\n            else:\n                target_dtype = (\n                    self.q_proj.weight.dtype\n                    if self.q_lora_rank is None\n                    else self.q_a_proj.weight.dtype\n                )\n\n            logger.warning_once(\n                f\"The input hidden states seems to be silently casted in float32, this might be related to\"\n                f\" the fact you have upcasted embedding or layer norm layers in float32. We will cast back the input in\"\n                f\" {target_dtype}.\"\n            )\n\n            query_states = query_states.to(target_dtype)\n            key_states = key_states.to(target_dtype)\n            value_states = value_states.to(target_dtype)\n\n        attn_output = self._flash_attention_forward(\n            query_states,\n            key_states,\n            value_states,\n            attention_mask,\n            q_len,\n            dropout=dropout_rate,\n            softmax_scale=self.softmax_scale,\n        )\n        if self.q_head_dim != self.v_head_dim:\n            attn_output = attn_output[:, :, :, : self.v_head_dim]\n\n        attn_output = attn_output.reshape(\n            bsz, q_len, self.num_heads * self.v_head_dim\n        ).contiguous()\n        attn_output = self.o_proj(attn_output)\n\n        if not output_attentions:\n            attn_weights = None\n\n        return attn_output, attn_weights, past_key_value\n\n    def _flash_attention_forward(\n        self,\n        query_states,\n        key_states,\n        value_states,\n        attention_mask,\n        query_length,\n        dropout=0.0,\n        softmax_scale=None,\n    ):\n        \"\"\"\n        Calls the forward method of Flash Attention - if the input hidden states contain at least one padding token\n        first unpad the input, then computes the attention scores and pad the final attention scores.\n\n        Args:\n            query_states (`torch.Tensor`):\n                Input query states to be passed to Flash Attention API\n            key_states (`torch.Tensor`):\n                Input key states to be passed to Flash Attention API\n            value_states (`torch.Tensor`):\n                Input value states to be passed to Flash Attention API\n            attention_mask (`torch.Tensor`):\n                The padding mask - corresponds to a tensor of size `(batch_size, seq_len)` where 0 stands for the\n                position of padding tokens and 1 for the position of non-padding tokens.\n            dropout (`int`, *optional*):\n                Attention dropout\n            softmax_scale (`float`, *optional*):\n                The scaling of QK^T before applying softmax. Default to 1 / sqrt(head_dim)\n        \"\"\"\n        if not self._flash_attn_uses_top_left_mask:\n            causal = self.is_causal\n        else:\n            # TODO: Remove the `query_length != 1` check once Flash Attention for RoCm is bumped to 2.1. For details, please see the comment in DeepseekV3FlashAttention2 __init__.\n            causal = self.is_causal and query_length != 1\n\n        # Contains at least one padding token in the sequence\n        if attention_mask is not None:\n            batch_size = query_states.shape[0]\n            (\n                query_states,\n                key_states,\n                value_states,\n                indices_q,\n                cu_seq_lens,\n                max_seq_lens,\n            ) = self._upad_input(\n                query_states, key_states, value_states, attention_mask, query_length\n            )\n\n            cu_seqlens_q, cu_seqlens_k = cu_seq_lens\n            max_seqlen_in_batch_q, max_seqlen_in_batch_k = max_seq_lens\n\n            attn_output_unpad = flash_attn_varlen_func(\n                query_states,\n                key_states,\n                value_states,\n                cu_seqlens_q=cu_seqlens_q,\n                cu_seqlens_k=cu_seqlens_k,\n                max_seqlen_q=max_seqlen_in_batch_q,\n                max_seqlen_k=max_seqlen_in_batch_k,\n                dropout_p=dropout,\n                softmax_scale=softmax_scale,\n                causal=causal,\n            )\n\n            attn_output = pad_input(\n                attn_output_unpad, indices_q, batch_size, query_length\n            )\n        else:\n            attn_output = flash_attn_func(\n                query_states,\n                key_states,\n                value_states,\n                dropout,\n                softmax_scale=softmax_scale,\n                causal=causal,\n            )\n\n        return attn_output\n\n    def _upad_input(\n        self, query_layer, key_layer, value_layer, attention_mask, query_length\n    ):\n        indices_k, cu_seqlens_k, max_seqlen_in_batch_k = _get_unpad_data(attention_mask)\n        batch_size, kv_seq_len, num_key_value_heads, head_dim = key_layer.shape\n\n        key_layer = index_first_axis(\n            key_layer.reshape(batch_size * kv_seq_len, num_key_value_heads, head_dim),\n            indices_k,\n        )\n        value_layer = index_first_axis(\n            value_layer.reshape(batch_size * kv_seq_len, num_key_value_heads, head_dim),\n            indices_k,\n        )\n        if query_length == kv_seq_len:\n            query_layer = index_first_axis(\n                query_layer.reshape(batch_size * kv_seq_len, self.num_heads, head_dim),\n                indices_k,\n            )\n            cu_seqlens_q = cu_seqlens_k\n            max_seqlen_in_batch_q = max_seqlen_in_batch_k\n            indices_q = indices_k\n        elif query_length == 1:\n            max_seqlen_in_batch_q = 1\n            cu_seqlens_q = torch.arange(\n                batch_size + 1, dtype=torch.int32, device=query_layer.device\n            )  # There is a memcpy here, that is very bad.\n            indices_q = cu_seqlens_q[:-1]\n            query_layer = query_layer.squeeze(1)\n        else:\n            # The -q_len: slice assumes left padding.\n            attention_mask = attention_mask[:, -query_length:]\n            query_layer, indices_q, cu_seqlens_q, max_seqlen_in_batch_q = unpad_input(\n                query_layer, attention_mask\n            )\n\n        return (\n            query_layer,\n            key_layer,\n            value_layer,\n            indices_q,\n            (cu_seqlens_q, cu_seqlens_k),\n            (max_seqlen_in_batch_q, max_seqlen_in_batch_k),\n        )\n\n\nATTENTION_CLASSES = {\n    \"eager\": DeepseekV3Attention,\n    \"flash_attention_2\": DeepseekV3FlashAttention2,\n}\n\n\nclass DeepseekV3DecoderLayer(nn.Module):\n    def __init__(self, config: DeepseekV3Config, layer_idx: int):\n        super().__init__()\n        self.hidden_size = config.hidden_size\n\n        self.self_attn = ATTENTION_CLASSES[config._attn_implementation](\n            config=config, layer_idx=layer_idx\n        )\n\n        self.mlp = (\n            DeepseekV3MoE(config)\n            if (\n                config.n_routed_experts is not None\n                and layer_idx >= config.first_k_dense_replace\n                and layer_idx % config.moe_layer_freq == 0\n            )\n            else DeepseekV3MLP(config)\n        )\n        self.input_layernorm = DeepseekV3RMSNorm(\n            config.hidden_size, eps=config.rms_norm_eps\n        )\n        self.post_attention_layernorm = DeepseekV3RMSNorm(\n            config.hidden_size, eps=config.rms_norm_eps\n        )\n\n    def forward(\n        self,\n        hidden_states: torch.Tensor,\n        attention_mask: Optional[torch.Tensor] = None,\n        position_ids: Optional[torch.LongTensor] = None,\n        past_key_value: Optional[Tuple[torch.Tensor]] = None,\n        output_attentions: Optional[bool] = False,\n        use_cache: Optional[bool] = False,\n        **kwargs,\n    ) -> Tuple[\n        torch.FloatTensor, Optional[Tuple[torch.FloatTensor, torch.FloatTensor]]\n    ]:\n        \"\"\"\n        Args:\n            hidden_states (`torch.FloatTensor`): input to the layer of shape `(batch, seq_len, embed_dim)`\n            attention_mask (`torch.FloatTensor`, *optional*):\n                attention mask of size `(batch_size, sequence_length)` if flash attention is used or `(batch_size, 1,\n                query_sequence_length, key_sequence_length)` if default attention is used.\n            output_attentions (`bool`, *optional*):\n                Whether or not to return the attentions tensors of all attention layers. See `attentions` under\n                returned tensors for more detail.\n            use_cache (`bool`, *optional*):\n                If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding\n                (see `past_key_values`).\n            past_key_value (`Tuple(torch.FloatTensor)`, *optional*): cached past key and value projection states\n        \"\"\"\n        if \"padding_mask\" in kwargs:\n            warnings.warn(\n                \"Passing `padding_mask` is deprecated and will be removed in v4.37. Please make sure use `attention_mask` instead.`\"\n            )\n        residual = hidden_states\n\n        hidden_states = self.input_layernorm(hidden_states)\n\n        # Self Attention\n        hidden_states, self_attn_weights, present_key_value = self.self_attn(\n            hidden_states=hidden_states,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            past_key_value=past_key_value,\n            output_attentions=output_attentions,\n            use_cache=use_cache,\n            **kwargs,\n        )\n        hidden_states = residual + hidden_states\n\n        # Fully Connected\n        residual = hidden_states\n        hidden_states = self.post_attention_layernorm(hidden_states)\n        hidden_states = self.mlp(hidden_states)\n        hidden_states = residual + hidden_states\n\n        outputs = (hidden_states,)\n\n        if output_attentions:\n            outputs += (self_attn_weights,)\n\n        if use_cache:\n            outputs += (present_key_value,)\n\n        return outputs\n\n\nDeepseekV3_START_DOCSTRING = r\"\"\"\n    This model inherits from [`PreTrainedModel`]. Check the superclass documentation for the generic methods the\n    library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads\n    etc.)\n\n    This model is also a PyTorch [torch.nn.Module](https://pytorch.org/docs/stable/nn.html#torch.nn.Module) subclass.\n    Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage\n    and behavior.\n\n    Parameters:\n        config ([`DeepseekV3Config`]):\n            Model configuration class with all the parameters of the model. Initializing with a config file does not\n            load the weights associated with the model, only the configuration. Check out the\n            [`~PreTrainedModel.from_pretrained`] method to load the model weights.\n\"\"\"\n\n\n@add_start_docstrings(\n    \"The bare DeepseekV3 Model outputting raw hidden-states without any specific head on top.\",\n    DeepseekV3_START_DOCSTRING,\n)\nclass DeepseekV3PreTrainedModel(PreTrainedModel):\n    config_class = DeepseekV3Config\n    base_model_prefix = \"model\"\n    supports_gradient_checkpointing = True\n    _no_split_modules = [\"DeepseekV3DecoderLayer\"]\n    _skip_keys_device_placement = \"past_key_values\"\n    _supports_flash_attn_2 = True\n    _supports_cache_class = True\n\n    def _init_weights(self, module):\n        std = self.config.initializer_range\n        if isinstance(module, nn.Linear):\n            module.weight.data.normal_(mean=0.0, std=std)\n            if module.bias is not None:\n                module.bias.data.zero_()\n        elif isinstance(module, nn.Embedding):\n            module.weight.data.normal_(mean=0.0, std=std)\n            if module.padding_idx is not None:\n                module.weight.data[module.padding_idx].zero_()\n\n\nDeepseekV3_INPUTS_DOCSTRING = r\"\"\"\n    Args:\n        input_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`):\n            Indices of input sequence tokens in the vocabulary. Padding will be ignored by default should you provide\n            it.\n\n            Indices can be obtained using [`AutoTokenizer`]. See [`PreTrainedTokenizer.encode`] and\n            [`PreTrainedTokenizer.__call__`] for details.\n\n            [What are input IDs?](../glossary#input-ids)\n        attention_mask (`torch.Tensor` of shape `(batch_size, sequence_length)`, *optional*):\n            Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:\n\n            - 1 for tokens that are **not masked**,\n            - 0 for tokens that are **masked**.\n\n            [What are attention masks?](../glossary#attention-mask)\n\n            Indices can be obtained using [`AutoTokenizer`]. See [`PreTrainedTokenizer.encode`] and\n            [`PreTrainedTokenizer.__call__`] for details.\n\n            If `past_key_values` is used, optionally only the last `input_ids` have to be input (see\n            `past_key_values`).\n\n            If you want to change padding behavior, you should read [`modeling_opt._prepare_decoder_attention_mask`]\n            and modify to your needs. See diagram 1 in [the paper](https://arxiv.org/abs/1910.13461) for more\n            information on the default strategy.\n\n            - 1 indicates the head is **not masked**,\n            - 0 indicates the head is **masked**.\n        position_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n            Indices of positions of each input sequence tokens in the position embeddings. Selected in the range `[0,\n            config.n_positions - 1]`.\n\n            [What are position IDs?](../glossary#position-ids)\n        past_key_values (`Cache` or `tuple(tuple(torch.FloatTensor))`, *optional*):\n            Pre-computed hidden-states (key and values in the self-attention blocks and in the cross-attention\n            blocks) that can be used to speed up sequential decoding. This typically consists in the `past_key_values`\n            returned by the model at a previous stage of decoding, when `use_cache=True` or `config.use_cache=True`.\n\n            Two formats are allowed:\n            - a [`~cache_utils.Cache`] instance;\n            - Tuple of `tuple(torch.FloatTensor)` of length `config.n_layers`, with each tuple having 2 tensors of\n            shape `(batch_size, num_heads, sequence_length, embed_size_per_head)`). This is also known as the legacy\n            cache format.\n\n            The model will output the same cache format that is fed as input. If no `past_key_values` are passed, the\n            legacy cache format will be returned.\n\n            If `past_key_values` are used, the user can optionally input only the last `input_ids` (those that don't\n            have their past key value states given to this model) of shape `(batch_size, 1)` instead of all `input_ids`\n            of shape `(batch_size, sequence_length)`.\n        inputs_embeds (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*):\n            Optionally, instead of passing `input_ids` you can choose to directly pass an embedded representation. This\n            is useful if you want more control over how to convert `input_ids` indices into associated vectors than the\n            model's internal embedding lookup matrix.\n        use_cache (`bool`, *optional*):\n            If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding (see\n            `past_key_values`).\n        output_attentions (`bool`, *optional*):\n            Whether or not to return the attentions tensors of all attention layers. See `attentions` under returned\n            tensors for more detail.\n        output_hidden_states (`bool`, *optional*):\n            Whether or not to return the hidden states of all layers. See `hidden_states` under returned tensors for\n            more detail.\n        return_dict (`bool`, *optional*):\n            Whether or not to return a [`~utils.ModelOutput`] instead of a plain tuple.\n\"\"\"\n\n\n@add_start_docstrings(\n    \"The bare DeepseekV3 Model outputting raw hidden-states without any specific head on top.\",\n    DeepseekV3_START_DOCSTRING,\n)\nclass DeepseekV3Model(DeepseekV3PreTrainedModel):\n    \"\"\"\n    Transformer decoder consisting of *config.num_hidden_layers* layers. Each layer is a [`DeepseekV3DecoderLayer`]\n\n    Args:\n        config: DeepseekV3Config\n    \"\"\"\n\n    def __init__(self, config: DeepseekV3Config):\n        super().__init__(config)\n        self.padding_idx = config.pad_token_id\n        self.vocab_size = config.vocab_size\n\n        self.embed_tokens = nn.Embedding(\n            config.vocab_size, config.hidden_size, self.padding_idx\n        )\n        self.layers = nn.ModuleList(\n            [\n                DeepseekV3DecoderLayer(config, layer_idx)\n                for layer_idx in range(config.num_hidden_layers)\n            ]\n        )\n        self._use_flash_attention_2 = config._attn_implementation == \"flash_attention_2\"\n        self.norm = DeepseekV3RMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n\n        self.gradient_checkpointing = False\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def get_input_embeddings(self):\n        return self.embed_tokens\n\n    def set_input_embeddings(self, value):\n        self.embed_tokens = value\n\n    @add_start_docstrings_to_model_forward(DeepseekV3_INPUTS_DOCSTRING)\n    def forward(\n        self,\n        input_ids: torch.LongTensor = None,\n        attention_mask: Optional[torch.Tensor] = None,\n        position_ids: Optional[torch.LongTensor] = None,\n        past_key_values: Optional[List[torch.FloatTensor]] = None,\n        inputs_embeds: Optional[torch.FloatTensor] = None,\n        use_cache: Optional[bool] = None,\n        output_attentions: Optional[bool] = None,\n        output_hidden_states: Optional[bool] = None,\n        return_dict: Optional[bool] = None,\n    ) -> Union[Tuple, BaseModelOutputWithPast]:\n        output_attentions = (\n            output_attentions\n            if output_attentions is not None\n            else self.config.output_attentions\n        )\n        output_hidden_states = (\n            output_hidden_states\n            if output_hidden_states is not None\n            else self.config.output_hidden_states\n        )\n        use_cache = use_cache if use_cache is not None else self.config.use_cache\n\n        return_dict = (\n            return_dict if return_dict is not None else self.config.use_return_dict\n        )\n\n        # retrieve input_ids and inputs_embeds\n        if input_ids is not None and inputs_embeds is not None:\n            raise ValueError(\n                \"You cannot specify both input_ids and inputs_embeds at the same time\"\n            )\n        elif input_ids is not None:\n            batch_size, seq_length = input_ids.shape[:2]\n        elif inputs_embeds is not None:\n            batch_size, seq_length = inputs_embeds.shape[:2]\n        else:\n            raise ValueError(\"You have to specify either input_ids or inputs_embeds\")\n\n        past_key_values_length = 0\n        if use_cache:\n            use_legacy_cache = not isinstance(past_key_values, Cache)\n            if use_legacy_cache:\n                past_key_values = DynamicCache.from_legacy_cache(past_key_values)\n            past_key_values_length = past_key_values.get_usable_length(seq_length)\n\n        if position_ids is None:\n            device = input_ids.device if input_ids is not None else inputs_embeds.device\n            position_ids = torch.arange(\n                past_key_values_length,\n                seq_length + past_key_values_length,\n                dtype=torch.long,\n                device=device,\n            )\n            position_ids = position_ids.unsqueeze(0)\n\n        if inputs_embeds is None:\n            inputs_embeds = self.embed_tokens(input_ids)\n\n        if self._use_flash_attention_2:\n            # 2d mask is passed through the layers\n            attention_mask = (\n                attention_mask\n                if (attention_mask is not None and 0 in attention_mask)\n                else None\n            )\n        else:\n            # 4d mask is passed through the layers\n            attention_mask = _prepare_4d_causal_attention_mask(\n                attention_mask,\n                (batch_size, seq_length),\n                inputs_embeds,\n                past_key_values_length,\n            )\n\n        # embed positions\n        hidden_states = inputs_embeds\n\n        # decoder layers\n        all_hidden_states = () if output_hidden_states else None\n        all_self_attns = () if output_attentions else None\n        next_decoder_cache = None\n\n        for decoder_layer in self.layers:\n            if output_hidden_states:\n                all_hidden_states += (hidden_states,)\n\n            layer_outputs = decoder_layer(\n                hidden_states,\n                attention_mask=attention_mask,\n                position_ids=position_ids,\n                past_key_value=past_key_values,\n                output_attentions=output_attentions,\n                use_cache=use_cache,\n            )\n\n            hidden_states = layer_outputs[0]\n\n            if use_cache:\n                next_decoder_cache = layer_outputs[2 if output_attentions else 1]\n\n            if output_attentions:\n                all_self_attns += (layer_outputs[1],)\n\n        hidden_states = self.norm(hidden_states)\n\n        # add hidden states from the last decoder layer\n        if output_hidden_states:\n            all_hidden_states += (hidden_states,)\n\n        next_cache = None\n        if use_cache:\n            next_cache = (\n                next_decoder_cache.to_legacy_cache()\n                if use_legacy_cache\n                else next_decoder_cache\n            )\n        if not return_dict:\n            return tuple(\n                v\n                for v in [hidden_states, next_cache, all_hidden_states, all_self_attns]\n                if v is not None\n            )\n        return BaseModelOutputWithPast(\n            last_hidden_state=hidden_states,\n            past_key_values=next_cache,\n            hidden_states=all_hidden_states,\n            attentions=all_self_attns,\n        )\n\n\nclass DeepseekV3ForCausalLM(DeepseekV3PreTrainedModel):\n    _tied_weights_keys = [\"lm_head.weight\"]\n\n    def __init__(self, config):\n        super().__init__(config)\n        self.model = DeepseekV3Model(config)\n        self.vocab_size = config.vocab_size\n        self.lm_head = nn.Linear(config.hidden_size, config.vocab_size, bias=False)\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def get_input_embeddings(self):\n        return self.model.embed_tokens\n\n    def set_input_embeddings(self, value):\n        self.model.embed_tokens = value\n\n    def get_output_embeddings(self):\n        return self.lm_head\n\n    def set_output_embeddings(self, new_embeddings):\n        self.lm_head = new_embeddings\n\n    def set_decoder(self, decoder):\n        self.model = decoder\n\n    def get_decoder(self):\n        return self.model\n\n    @add_start_docstrings_to_model_forward(DeepseekV3_INPUTS_DOCSTRING)\n    @replace_return_docstrings(\n        output_type=CausalLMOutputWithPast, config_class=_CONFIG_FOR_DOC\n    )\n    def forward(\n        self,\n        input_ids: torch.LongTensor = None,\n        attention_mask: Optional[torch.Tensor] = None,\n        position_ids: Optional[torch.LongTensor] = None,\n        past_key_values: Optional[List[torch.FloatTensor]] = None,\n        inputs_embeds: Optional[torch.FloatTensor] = None,\n        labels: Optional[torch.LongTensor] = None,\n        use_cache: Optional[bool] = None,\n        output_attentions: Optional[bool] = None,\n        output_hidden_states: Optional[bool] = None,\n        return_dict: Optional[bool] = None,\n    ) -> Union[Tuple, CausalLMOutputWithPast]:\n        r\"\"\"\n        Args:\n            labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n                Labels for computing the masked language modeling loss. Indices should either be in `[0, transformers.,\n                config.vocab_size]` or -100 (see `input_ids` docstring). Tokens with indices set to `-100` are ignored\n                (masked), the loss is only computed for the tokens with labels in `[0, transformers., config.vocab_size]`.\n\n        Returns:\n\n        Example:\n\n        ```python\n        >>> from transformers import AutoTokenizer, DeepseekV3ForCausalLM\n\n        >>> model = DeepseekV3ForCausalLM.from_pretrained(PATH_TO_CONVERTED_WEIGHTS)\n        >>> tokenizer = AutoTokenizer.from_pretrained(PATH_TO_CONVERTED_TOKENIZER)\n\n        >>> prompt = \"Hey, are you conscious? Can you talk to me?\"\n        >>> inputs = tokenizer(prompt, return_tensors=\"pt\")\n\n        >>> # Generate\n        >>> generate_ids = model.generate(inputs.input_ids, max_length=30)\n        >>> tokenizer.batch_decode(generate_ids, skip_special_tokens=True, clean_up_tokenization_spaces=False)[0]\n        \"Hey, are you conscious? Can you talk to me?\\nI'm not conscious, but I can talk to you.\"\n        ```\"\"\"\n        output_attentions = (\n            output_attentions\n            if output_attentions is not None\n            else self.config.output_attentions\n        )\n        output_hidden_states = (\n            output_hidden_states\n            if output_hidden_states is not None\n            else self.config.output_hidden_states\n        )\n        return_dict = (\n            return_dict if return_dict is not None else self.config.use_return_dict\n        )\n\n        # decoder outputs consists of (dec_features, layer_state, dec_hidden, dec_attn)\n        outputs = self.model(\n            input_ids=input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            past_key_values=past_key_values,\n            inputs_embeds=inputs_embeds,\n            use_cache=use_cache,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n        )\n\n        hidden_states = outputs[0]\n        logits = self.lm_head(hidden_states)\n        logits = logits.float()\n\n        loss = None\n        if labels is not None:\n            # Shift so that tokens < n predict n\n            shift_logits = logits[..., :-1, :].contiguous()\n            shift_labels = labels[..., 1:].contiguous()\n            # Flatten the tokens\n            loss_fct = CrossEntropyLoss()\n            shift_logits = shift_logits.view(-1, self.config.vocab_size)\n            shift_labels = shift_labels.view(-1)\n            # Enable model parallelism\n            shift_labels = shift_labels.to(shift_logits.device)\n            loss = loss_fct(shift_logits, shift_labels)\n\n        if not return_dict:\n            output = (logits,) + outputs[1:]\n            return (loss,) + output if loss is not None else output\n\n        return CausalLMOutputWithPast(\n            loss=loss,\n            logits=logits,\n            past_key_values=outputs.past_key_values,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n\n    def prepare_inputs_for_generation(\n        self,\n        input_ids,\n        past_key_values=None,\n        attention_mask=None,\n        inputs_embeds=None,\n        **kwargs,\n    ):\n        if past_key_values is not None:\n            if isinstance(past_key_values, Cache):\n                cache_length = past_key_values.get_seq_length()\n                past_length = past_key_values.seen_tokens\n                max_cache_length = past_key_values.get_max_length()\n            else:\n                cache_length = past_length = past_key_values[0][0].shape[2]\n                max_cache_length = None\n\n            # Keep only the unprocessed tokens:\n            # 1 - If the length of the attention_mask exceeds the length of input_ids, then we are in a setting where\n            # some of the inputs are exclusivelly passed as part of the cache (e.g. when passing input_embeds as\n            # input)\n            if (\n                attention_mask is not None\n                and attention_mask.shape[1] > input_ids.shape[1]\n            ):\n                input_ids = input_ids[:, -(attention_mask.shape[1] - past_length) :]\n            # 2 - If the past_length is smaller than input_ids', then input_ids holds all input tokens. We can discard\n            # input_ids based on the past_length.\n            elif past_length < input_ids.shape[1]:\n                input_ids = input_ids[:, past_length:]\n            # 3 - Otherwise (past_length >= input_ids.shape[1]), let's assume input_ids only has unprocessed tokens.\n\n            # If we are about to go beyond the maximum cache length, we need to crop the input attention mask.\n            if (\n                max_cache_length is not None\n                and attention_mask is not None\n                and cache_length + input_ids.shape[1] > max_cache_length\n            ):\n                attention_mask = attention_mask[:, -max_cache_length:]\n\n        position_ids = kwargs.get(\"position_ids\", None)\n        if attention_mask is not None and position_ids is None:\n            # create position_ids on the fly for batch generation\n            position_ids = attention_mask.long().cumsum(-1) - 1\n            position_ids.masked_fill_(attention_mask == 0, 1)\n            if past_key_values:\n                position_ids = position_ids[:, -input_ids.shape[1] :]\n\n        # if `inputs_embeds` are passed, we only want to use them in the 1st generation step\n        if inputs_embeds is not None and past_key_values is None:\n            model_inputs = {\"inputs_embeds\": inputs_embeds}\n        else:\n            model_inputs = {\"input_ids\": input_ids}\n\n        model_inputs.update(\n            {\n                \"position_ids\": position_ids,\n                \"past_key_values\": past_key_values,\n                \"use_cache\": kwargs.get(\"use_cache\"),\n                \"attention_mask\": attention_mask,\n            }\n        )\n        return model_inputs\n\n    @staticmethod\n    def _reorder_cache(past_key_values, beam_idx):\n        reordered_past = ()\n        for layer_past in past_key_values:\n            reordered_past += (\n                tuple(\n                    past_state.index_select(0, beam_idx.to(past_state.device))\n                    for past_state in layer_past\n                ),\n            )\n        return reordered_past\n\n\n@add_start_docstrings(\n    \"\"\"\n    The DeepseekV3 Model transformer with a sequence classification head on top (linear layer).\n\n    [`DeepseekV3ForSequenceClassification`] uses the last token in order to do the classification, as other causal models\n    (e.g. GPT-2) do.\n\n    Since it does classification on the last token, it requires to know the position of the last token. If a\n    `pad_token_id` is defined in the configuration, it finds the last token that is not a padding token in each row. If\n    no `pad_token_id` is defined, it simply takes the last value in each row of the batch. Since it cannot guess the\n    padding tokens when `inputs_embeds` are passed instead of `input_ids`, it does the same (take the last value in\n    each row of the batch).\n    \"\"\",\n    DeepseekV3_START_DOCSTRING,\n)\nclass DeepseekV3ForSequenceClassification(DeepseekV3PreTrainedModel):\n    def __init__(self, config):\n        super().__init__(config)\n        self.num_labels = config.num_labels\n        self.model = DeepseekV3Model(config)\n        self.score = nn.Linear(config.hidden_size, self.num_labels, bias=False)\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def get_input_embeddings(self):\n        return self.model.embed_tokens\n\n    def set_input_embeddings(self, value):\n        self.model.embed_tokens = value\n\n    @add_start_docstrings_to_model_forward(DeepseekV3_INPUTS_DOCSTRING)\n    def forward(\n        self,\n        input_ids: torch.LongTensor = None,\n        attention_mask: Optional[torch.Tensor] = None,\n        position_ids: Optional[torch.LongTensor] = None,\n        past_key_values: Optional[List[torch.FloatTensor]] = None,\n        inputs_embeds: Optional[torch.FloatTensor] = None,\n        labels: Optional[torch.LongTensor] = None,\n        use_cache: Optional[bool] = None,\n        output_attentions: Optional[bool] = None,\n        output_hidden_states: Optional[bool] = None,\n        return_dict: Optional[bool] = None,\n    ) -> Union[Tuple, SequenceClassifierOutputWithPast]:\n        r\"\"\"\n        labels (`torch.LongTensor` of shape `(batch_size,)`, *optional*):\n            Labels for computing the sequence classification/regression loss. Indices should be in `[0, transformers.,\n            config.num_labels - 1]`. If `config.num_labels == 1` a regression loss is computed (Mean-Square loss), If\n            `config.num_labels > 1` a classification loss is computed (Cross-Entropy).\n        \"\"\"\n        return_dict = (\n            return_dict if return_dict is not None else self.config.use_return_dict\n        )\n\n        transformer_outputs = self.model(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            past_key_values=past_key_values,\n            inputs_embeds=inputs_embeds,\n            use_cache=use_cache,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n        )\n        hidden_states = transformer_outputs[0]\n        logits = self.score(hidden_states)\n\n        if input_ids is not None:\n            batch_size = input_ids.shape[0]\n        else:\n            batch_size = inputs_embeds.shape[0]\n\n        if self.config.pad_token_id is None and batch_size != 1:\n            raise ValueError(\n                \"Cannot handle batch sizes > 1 if no padding token is defined.\"\n            )\n        if self.config.pad_token_id is None:\n            sequence_lengths = -1\n        else:\n            if input_ids is not None:\n                sequence_lengths = (\n                    torch.eq(input_ids, self.config.pad_token_id).int().argmax(-1) - 1\n                ).to(logits.device)\n            else:\n                sequence_lengths = -1\n\n        pooled_logits = logits[\n            torch.arange(batch_size, device=logits.device), sequence_lengths\n        ]\n\n        loss = None\n        if labels is not None:\n            labels = labels.to(logits.device)\n            if self.config.problem_type is None:\n                if self.num_labels == 1:\n                    self.config.problem_type = \"regression\"\n                elif self.num_labels > 1 and (\n                    labels.dtype == torch.long or labels.dtype == torch.int\n                ):\n                    self.config.problem_type = \"single_label_classification\"\n                else:\n                    self.config.problem_type = \"multi_label_classification\"\n\n            if self.config.problem_type == \"regression\":\n                loss_fct = MSELoss()\n                if self.num_labels == 1:\n                    loss = loss_fct(pooled_logits.squeeze(), labels.squeeze())\n                else:\n                    loss = loss_fct(pooled_logits, labels)\n            elif self.config.problem_type == \"single_label_classification\":\n                loss_fct = CrossEntropyLoss()\n                loss = loss_fct(\n                    pooled_logits.view(-1, self.num_labels), labels.view(-1)\n                )\n            elif self.config.problem_type == \"multi_label_classification\":\n                loss_fct = BCEWithLogitsLoss()\n                loss = loss_fct(pooled_logits, labels)\n        if not return_dict:\n            output = (pooled_logits,) + transformer_outputs[1:]\n            return ((loss,) + output) if loss is not None else output\n\n        return SequenceClassifierOutputWithPast(\n            loss=loss,\n            logits=pooled_logits,\n            past_key_values=transformer_outputs.past_key_values,\n            hidden_states=transformer_outputs.hidden_states,\n            attentions=transformer_outputs.attentions,\n        )\n"
    }
}