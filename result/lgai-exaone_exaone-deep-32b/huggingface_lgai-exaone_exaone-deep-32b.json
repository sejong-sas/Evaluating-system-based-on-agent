{
    "model_id": "lgai-exaone/exaone-deep-32b",
    "files": [
        ".gitattributes",
        "LICENSE",
        "README.md",
        "assets/EXAONE_Symbol+BI_3d.png",
        "assets/exaone_deep_overall_performance.png",
        "config.json",
        "configuration_exaone.py",
        "generation_config.json",
        "merges.txt",
        "model-00001-of-00014.safetensors",
        "model-00002-of-00014.safetensors",
        "model-00003-of-00014.safetensors",
        "model-00004-of-00014.safetensors",
        "model-00005-of-00014.safetensors",
        "model-00006-of-00014.safetensors",
        "model-00007-of-00014.safetensors",
        "model-00008-of-00014.safetensors",
        "model-00009-of-00014.safetensors",
        "model-00010-of-00014.safetensors",
        "model-00011-of-00014.safetensors",
        "model-00012-of-00014.safetensors",
        "model-00013-of-00014.safetensors",
        "model-00014-of-00014.safetensors",
        "model.safetensors.index.json",
        "modeling_exaone.py",
        "special_tokens_map.json",
        "tokenizer.json",
        "tokenizer_config.json",
        "vocab.json"
    ],
    "readme": "---\nbase_model: LGAI-EXAONE/EXAONE-3.5-32B-Instruct\nbase_model_relation: finetune\nlicense: other\nlicense_name: exaone\nlicense_link: LICENSE\nlanguage:\n- en\n- ko\ntags:\n- lg-ai\n- exaone\n- exaone-deep\npipeline_tag: text-generation\nlibrary_name: transformers\n---\n\n<p align=\"center\">\n<img src=\"assets/EXAONE_Symbol+BI_3d.png\", width=\"300\", style=\"margin: 40 auto;\">\n<br>\n\n# EXAONE-Deep-32B\n\n## Introduction\n\nWe introduce EXAONE Deep, which exhibits superior capabilities in various reasoning tasks including math and coding benchmarks, ranging from 2.4B to 32B parameters developed and released by LG AI Research. Evaluation results show that 1) EXAONE Deep **2.4B** outperforms other models of comparable size, 2) EXAONE Deep **7.8B** outperforms not only open-weight models of comparable scale but also a proprietary reasoning model OpenAI o1-mini, and 3) EXAONE Deep **32B** demonstrates competitive performance against leading open-weight models.\n\nFor more details, please refer to our [documentation](https://arxiv.org/abs/2503.12524), [blog](https://www.lgresearch.ai/news/view?seq=543) and [GitHub](https://github.com/LG-AI-EXAONE/EXAONE-Deep).\n\n<p align=\"center\">\n<img src=\"assets/exaone_deep_overall_performance.png\", width=\"100%\", style=\"margin: 40 auto;\">\n\nThis repository contains the reasoning 32B language model with the following features:\n\n- Number of Parameters (without embeddings): 30.95B\n- Number of Layers: 64\n- Number of Attention Heads: GQA with 40 Q-heads and 8 KV-heads\n- Vocab Size: 102,400\n- Context Length: 32,768 tokens\n\n## Quickstart\n\nWe recommend to use `transformers` v4.43.1 or later.\n\nHere is the code snippet to run conversational inference with the model:\n\n```python\nimport torch\nfrom transformers import AutoModelForCausalLM, AutoTokenizer, TextIteratorStreamer\nfrom threading import Thread\n\nmodel_name = \"LGAI-EXAONE/EXAONE-Deep-32B\"\nstreaming = True    # choose the streaming option\n\nmodel = AutoModelForCausalLM.from_pretrained(\n    model_name,\n    torch_dtype=torch.bfloat16,\n    trust_remote_code=True,\n    device_map=\"auto\"\n)\ntokenizer = AutoTokenizer.from_pretrained(model_name)\n\n# Choose your prompt:\n#   Math example (AIME 2024)\nprompt = r\"\"\"Let $x,y$ and $z$ be positive real numbers that satisfy the following system of equations:\n\\[\\log_2\\left({x \\over yz}\\right) = {1 \\over 2}\\]\\[\\log_2\\left({y \\over xz}\\right) = {1 \\over 3}\\]\\[\\log_2\\left({z \\over xy}\\right) = {1 \\over 4}\\]\nThen the value of $\\left|\\log_2(x^4y^3z^2)\\right|$ is $\\tfrac{m}{n}$ where $m$ and $n$ are relatively prime positive integers. Find $m+n$.\n\nPlease reason step by step, and put your final answer within \\boxed{}.\"\"\"\n#   Korean MCQA example (CSAT Math 2025)\nprompt = r\"\"\"Question : $a_1 = 2$인 수열 $\\{a_n\\}$과 $b_1 = 2$인 등차수열 $\\{b_n\\}$이 모든 자연수 $n$에 대하여\\[\\sum_{k=1}^{n} \\frac{a_k}{b_{k+1}} = \\frac{1}{2} n^2\\]을 만족시킬 때, $\\sum_{k=1}^{5} a_k$의 값을 구하여라.\n\nOptions :\nA) 120\nB) 125\nC) 130\nD) 135\nE) 140\n \nPlease reason step by step, and you should write the correct option alphabet (A, B, C, D or E) within \\\\boxed{}.\"\"\"\n\nmessages = [\n    {\"role\": \"user\", \"content\": prompt}\n]\ninput_ids = tokenizer.apply_chat_template(\n    messages,\n    tokenize=True,\n    add_generation_prompt=True,\n    return_tensors=\"pt\"\n)\n\nif streaming:\n    streamer = TextIteratorStreamer(tokenizer)\n    thread = Thread(target=model.generate, kwargs=dict(\n        input_ids=input_ids.to(\"cuda\"),\n        eos_token_id=tokenizer.eos_token_id,\n        max_new_tokens=32768,\n        do_sample=True,\n        temperature=0.6,\n        top_p=0.95,\n        streamer=streamer\n    ))\n    thread.start()\n\n    for text in streamer:\n        print(text, end=\"\", flush=True)\nelse:\n    output = model.generate(\n        input_ids.to(\"cuda\"),\n        eos_token_id=tokenizer.eos_token_id,\n        max_new_tokens=32768,\n        do_sample=True,\n        temperature=0.6,\n        top_p=0.95,\n    )\n    print(tokenizer.decode(output[0]))\n```\n\n> ### Note\n> The EXAONE Deep models are trained with an optimized configuration,\n> so we recommend following the [Usage Guideline](#usage-guideline) section to achieve optimal performance.\n\n## Evaluation\n\nThe following table shows the evaluation results of reasoning tasks such as math and coding. The full evaluation results can be found in the [documentation](https://arxiv.org/abs/2503.12524).\n\n<table>\n    <tr>\n        <th>Models</th>\n        <th>MATH-500 (pass@1)</th>\n        <th>AIME 2024 (pass@1 / cons@64)</th>\n        <th>AIME 2025 (pass@1 / cons@64)</th>\n        <th>CSAT Math 2025 (pass@1)</th>\n        <th>GPQA Diamond (pass@1)</th>\n        <th>Live Code Bench (pass@1)</th>\n    </tr>\n    <tr>\n        <td>EXAONE Deep 32B</td>\n        <td>95.7</td>\n        <td>72.1 / <strong>90.0</strong></td>\n        <td>65.8 / <strong>80.0</strong></td>\n        <td><strong>94.5</strong></td>\n        <td>66.1</td>\n        <td>59.5</td>\n    </tr>\n    <tr>\n        <td>DeepSeek-R1-Distill-Qwen-32B</td>\n        <td>94.3</td>\n        <td>72.6 / 83.3</td>\n        <td>55.2 / 73.3</td>\n        <td>84.1</td>\n        <td>62.1</td>\n        <td>57.2</td>\n    </tr>\n    <tr>\n        <td>QwQ-32B</td>\n        <td>95.5</td>\n        <td>79.5 / 86.7</td>\n        <td><strong>67.1</strong> / 76.7</td>\n        <td>94.4</td>\n        <td>63.3</td>\n        <td>63.4</td>\n    </tr>\n    <tr>\n        <td>DeepSeek-R1-Distill-Llama-70B</td>\n        <td>94.5</td>\n        <td>70.0 / 86.7</td>\n        <td>53.9 / 66.7</td>\n        <td>88.8</td>\n        <td>65.2</td>\n        <td>57.5</td>\n    </tr>\n    <tr>\n        <td>DeepSeek-R1 (671B)</td>\n        <td><strong>97.3</strong></td>\n        <td><strong>79.8</strong> / 86.7</td>\n        <td>66.8 / <strong>80.0</strong></td>\n        <td>89.9</td>\n        <td><strong>71.5</strong></td>\n        <td><strong>65.9</strong></td>\n    </tr>\n    <tr>\n        <th colspan=\"7\" height=\"30px\"></th>\n    </tr>\n    <tr>\n        <td>EXAONE Deep 7.8B</td>\n        <td><strong>94.8</strong></td>\n        <td><strong>70.0</strong> / <strong>83.3</strong></td>\n        <td><strong>59.6</strong> / <strong>76.7</strong></td>\n        <td><strong>89.9</strong></td>\n        <td><strong>62.6</strong></td>\n        <td><strong>55.2</strong></td>\n    </tr>\n    <tr>\n        <td>DeepSeek-R1-Distill-Qwen-7B</td>\n        <td>92.8</td>\n        <td>55.5 / <strong>83.3</strong></td>\n        <td>38.5 / 56.7</td>\n        <td>79.7</td>\n        <td>49.1</td>\n        <td>37.6</td>\n    </tr>\n    <tr>\n        <td>DeepSeek-R1-Distill-Llama-8B</td>\n        <td>89.1</td>\n        <td>50.4 / 80.0</td>\n        <td>33.6 / 53.3</td>\n        <td>74.1</td>\n        <td>49.0</td>\n        <td>39.6</td>\n    </tr>\n    <tr>\n        <td>OpenAI o1-mini</td>\n        <td>90.0</td>\n        <td>63.6 / 80.0</td>\n        <td>54.8 / 66.7</td>\n        <td>84.4</td>\n        <td>60.0</td>\n        <td>53.8</td>\n    </tr>\n    <tr>\n        <th colspan=\"7\" height=\"30px\"></th>\n    </tr>\n    <tr>\n        <td>EXAONE Deep 2.4B</td>\n        <td><strong>92.3</strong></td>\n        <td><strong>52.5</strong> / <strong>76.7</strong></td>\n        <td><strong>47.9</strong> / <strong>73.3</strong></td>\n        <td><strong>79.2</strong></td>\n        <td><strong>54.3</strong></td>\n        <td><strong>46.6</strong></td>\n    </tr>\n    <tr>\n        <td>DeepSeek-R1-Distill-Qwen-1.5B</td>\n        <td>83.9</td>\n        <td>28.9 / 52.7</td>\n        <td>23.9 / 36.7</td>\n        <td>65.6</td>\n        <td>33.8</td>\n        <td>16.9</td>\n    </tr>\n</table>\n\n## Deployment\n\nEXAONE Deep models can be inferred in the various frameworks, such as:\n- `TensorRT-LLM`\n- `vLLM`\n- `SGLang`\n- `llama.cpp`\n- `Ollama`\n- `LM-Studio`\n\nPlease refer to our [EXAONE Deep GitHub](https://github.com/LG-AI-EXAONE/EXAONE-Deep) for more details about the inference frameworks.\n\n## Quantization\n\nWe provide the pre-quantized EXAONE Deep models with **AWQ** and several quantization types in **GGUF** format. Please refer to our [EXAONE Deep collection](https://huggingface.co/collections/LGAI-EXAONE/exaone-deep-67d119918816ec6efa79a4aa) to find corresponding quantized models.\n\n## Usage Guideline\n\nTo achieve the expected performance, we recommend using the following configurations:\n\n1. Ensure the model starts with `<thought>\\n` for reasoning steps. The model's output quality may be degraded when you omit it. You can easily apply this feature by using `tokenizer.apply_chat_template()` with `add_generation_prompt=True`. Please check the example code on [Quickstart](#quickstart) section.\n2. The reasoning steps of EXAONE Deep models enclosed by `<thought>\\n...\\n</thought>` usually have lots of tokens, so previous reasoning steps may be necessary to be removed in multi-turn situation. The provided tokenizer handles this automatically.\n3. Avoid using system prompt, and build the instruction on the user prompt. \n4. Additional instructions help the models reason more deeply, so that the models generate better output.\n    - For math problems, the instructions **\"Please reason step by step, and put your final answer within \\boxed{}.\"** are helpful.\n    - For more information on our evaluation setting including prompts, please refer to our [Documentation](https://arxiv.org/abs/2503.12524).\n5. In our evaluation, we use `temperature=0.6` and `top_p=0.95` for generation. \n6. When evaluating the models, it is recommended to test multiple times to assess the expected performance accurately.\n\n## Limitation\n\nThe EXAONE language model has certain limitations and may occasionally generate inappropriate responses. The language model generates responses based on the output probability of tokens, and it is determined during learning from training data. While we have made every effort to exclude personal, harmful, and biased information from the training data, some problematic content may still be included, potentially leading to undesirable responses. Please note that the text generated by EXAONE language model does not reflects the views of LG AI Research.\n\n- Inappropriate answers may be generated, which contain personal, harmful or other inappropriate information.\n- Biased responses may be generated, which are associated with age, gender, race, and so on.\n- The generated responses rely heavily on statistics from the training data, which can result in the generation of\nsemantically or syntactically incorrect sentences.\n- Since the model does not reflect the latest information, the responses may be false or contradictory.\n\nLG AI Research strives to reduce potential risks that may arise from EXAONE language models. Users are not allowed\nto engage in any malicious activities (e.g., keying in illegal information) that may induce the creation of inappropriate\noutputs violating LG AI’s ethical principles when using EXAONE language models.\n\n## License\n\nThe model is licensed under [EXAONE AI Model License Agreement 1.1 - NC](./LICENSE)\n\n## Citation\n \n```\n@article{exaone-deep,\n  title={EXAONE Deep: Reasoning Enhanced Language Models},\n  author={{LG AI Research}},\n  journal={arXiv preprint arXiv:2503.12524},\n  year={2025}\n}\n```\n\n## Contact\nLG AI Research Technical Support: contact_us@lgresearch.ai",
    "config": "{\n  \"activation_function\": \"silu\",\n  \"architectures\": [\n    \"ExaoneForCausalLM\"\n  ],\n  \"attention_dropout\": 0.0,\n  \"auto_map\": {\n    \"AutoConfig\": \"configuration_exaone.ExaoneConfig\",\n    \"AutoModelForCausalLM\": \"modeling_exaone.ExaoneForCausalLM\",\n    \"AutoModelForSequenceClassification\": \"modeling_exaone.ExaoneForSequenceClassification\"\n  },\n  \"bos_token_id\": 1,\n  \"embed_dropout\": 0.0,\n  \"eos_token_id\": 361,\n  \"head_dim\": 128,\n  \"hidden_size\": 5120,\n  \"initializer_range\": 0.02,\n  \"intermediate_size\": 27392,\n  \"layer_norm_epsilon\": 1e-05,\n  \"ln_no_scale\": false,\n  \"max_position_embeddings\": 32768,\n  \"model_type\": \"exaone\",\n  \"num_attention_heads\": 40,\n  \"num_key_value_heads\": 8,\n  \"num_layers\": 64,\n  \"pad_token_id\": 0,\n  \"rope_scaling\": {\n    \"factor\": 8.0,\n    \"high_freq_factor\": 4.0,\n    \"low_freq_factor\": 1.0,\n    \"original_max_position_embeddings\": 8192,\n    \"rope_type\": \"llama3\"\n  },\n  \"rope_theta\": 1000000.0,\n  \"tie_word_embeddings\": false,\n  \"torch_dtype\": \"bfloat16\",\n  \"transformers_version\": \"4.43.1\",\n  \"use_cache\": true,\n  \"vocab_size\": 102400\n}\n",
    "generation_config": "{\n  \"_from_model_config\": true,\n  \"bos_token_id\": 1,\n  \"do_sample\": true,\n  \"eos_token_id\": 361,\n  \"pad_token_id\": 0,\n  \"repetition_penalty\": 1.0,\n  \"temperature\": 0.6,\n  \"top_p\": 0.95,\n  \"transformers_version\": \"4.43.1\"\n}\n",
    "license_file": "EXAONE AI Model License Agreement 1.1 - NC\n\nThis License Agreement (“Agreement”) is entered into between you (“Licensee”) and LG Management Development \nInstitute Co., Ltd. (“Licensor”), governing the use of the EXAONE AI Model (“Model”). By downloading, \ninstalling, copying, or using the Model, you agree to comply with and be bound by the terms of this Agreement.\nIf you do not agree to all the terms, you must not download, install, copy, or use the Model. This Agreement \nconstitutes a binding legal agreement between the Licensee and Licensor.\n\n1. Definitions\n    1.1 Model: The artificial intelligence model provided by Licensor, which includes any software, \n    algorithms, machine learning models, or related components supplied by Licensor. This definition extends \n    to encompass all updates, enhancements, improvements, bug fixes, patches, or other modifications that may \n    be provided by Licensor from time to time, whether automatically or manually implemented.\n    1.2 Derivatives: Any modifications, alterations, enhancements, improvements, adaptations, or derivative \n    works of the Model created by Licensee or any third party. This includes changes made to the Model's \n    architecture, parameters, data processing methods, or any other aspect of the Model that results in a \n    modification of its functionality or output.\n    1.3 Output: Any data, results, content, predictions, analyses, insights, or other materials generated by \n    the Model or Derivatives, regardless of whether they are in their original form or have been further \n    processed or modified by the Licensee. This includes, but is not limited to, textual or numerical produced \n    directly or indirectly through the use of the Model.\n    1.4 Licensor: LG Management Development Institute Co., Ltd., the owner, developer, and provider of the \n    EXAONE AI Model. The Licensor holds all rights, title, and interest in the Model and is responsible for \n    granting licenses to use the Model under the terms specified in this Agreement.\n    1.5 Licensee: The individual, organization, corporation, academic institution, government agency, or other \n    entity using or intending to use the Model under the terms and conditions of this Agreement. The Licensee \n    is responsible for ensuring compliance with the Agreement by all authorized users who access or utilize \n    the Model on behalf of the Licensee.\n\n2. License Grant\n    2.1 Grant of License: Subject to the terms and conditions outlined in this Agreement, the Licensor hereby \n    grants the Licensee a limited, non-exclusive, non-transferable, worldwide, and revocable license to:\n        a. Access, download, install, and use the Model solely for research purposes. This includes \n        evaluation, testing, academic research, experimentation, and participation in competitions, provided \n        that such participation is in a non-commercial context. Notwithstanding Section 3.1, the Licensee may \n        only provide the Model or Derivatives for a competition if no commercial license is granted to the \n        competition organizer or any third party.\n        b. Publicly disclose research results and findings derived from the use of the Model or Derivatives, \n        including publishing papers or presentations.\n        c. Modify the Model and create Derivatives based on the Model, provided that such modifications and \n        Derivatives are used exclusively for research purposes. The Licensee may conduct experiments, perform \n        analyses, and apply custom modifications to the Model to explore its capabilities and performance \n        under various scenarios. If the Model is modified, the modified Model must include “EXAONE” at the \n        beginning of its name.\n        d. Distribute the Model and Derivatives in each case with a copy of this Agreement.\n    2.2 Scope of License: The license granted herein does not authorize the Licensee to use the Model for any \n    purpose not explicitly permitted under this Agreement. Any use beyond the scope of this license, including \n    any commercial application or external distribution, is strictly prohibited unless explicitly agreed upon \n    in writing by the Licensor.\n\n3. Restrictions\n    3.1 Commercial Use: The Licensee is expressly prohibited from using the Model, Derivatives, or Output for \n    any commercial purposes, including but not limited to, developing or deploying products, services, or \n    applications that generate revenue, whether directly or indirectly. Any commercial exploitation of the \n    Model or its derivatives requires a separate commercial license agreement with the Licensor. Furthermore, \n    the Licensee shall not use the Model, Derivatives or Output to develop or improve other models.\n    3.2 Reverse Engineering: The Licensee shall not decompile, disassemble, reverse engineer, or attempt to \n    derive the source code, underlying ideas, algorithms, or structure of the Model, except to the extent that \n    such activities are expressly permitted by applicable law. Any attempt to bypass or circumvent \n    technological protection measures applied to the Model is strictly prohibited.\n    3.3 Unlawful Use: The Licensee shall not use the Model and Derivatives for any illegal, fraudulent, or \n    unauthorized activities, nor for any purpose that violates applicable laws or regulations. This includes \n    but is not limited to the creation, distribution, or dissemination of malicious, deceptive, or unlawful \n    content.\n    3.4 Ethical Use: The Licensee shall ensure that the Model or Derivatives is used in an ethical and \n    responsible manner, adhering to the following guidelines:\n        a. The Model and Derivatives shall not be used to generate, propagate, or amplify false, misleading, \n        or harmful information, including fake news, misinformation, or disinformation.\n        b. The Model and Derivatives shall not be employed to create, distribute, or promote content that is \n        discriminatory, harassing, defamatory, abusive, or otherwise offensive to individuals or groups based \n        on race, gender, sexual orientation, religion, nationality, or other protected characteristics.\n        c. The Model and Derivatives shall not infringe on the rights of others, including intellectual \n        property rights, privacy rights, or any other rights recognized by law. The Licensee shall obtain all \n        necessary permissions and consents before using the Model and Derivatives in a manner that may impact \n        the rights of third parties.\n        d. The Model and Derivatives shall not be used in a way that causes harm, whether physical, mental, \n        emotional, or financial, to individuals, organizations, or communities. The Licensee shall take all \n        reasonable measures to prevent misuse or abuse of the Model and Derivatives that could result in harm \n        or injury.\n\n4. Ownership\n    4.1 Intellectual Property: All rights, title, and interest in and to the Model, including any \n    modifications, Derivatives, and associated documentation, are and shall remain the exclusive property of \n    the Licensor. The Licensee acknowledges that this Agreement does not transfer any ownership rights to the \n    Licensee. All trademarks, service marks, and logos associated with the Model are the property of the \n    Licensor.\n    4.2 Output: All rights, title, and interest in and to the Output generated by the Model and Derivatives \n    whether in its original form or modified, are and shall remain the exclusive property of the Licensor.\n    Licensee may use, modify, and distribute the Output and its derivatives for research purpose. The Licensee \n    shall not claim ownership of the Output except as expressly provided in this Agreement. The Licensee may \n    use the Output solely for the purposes permitted under this Agreement and shall not exploit the Output for \n    unauthorized or commercial purposes.\n    4.3 Attribution: In any publication or presentation of results obtained using the Model, the Licensee \n    shall provide appropriate attribution to the Licensor, citing the Model's name and version, along with any \n    relevant documentation or references specified by the Licensor.\n\n5. No Warranty\n    5.1 “As-Is” Basis: The Model, Derivatives, and Output are provided on an “as-is” and “as-available” basis, \n    without any warranties or representations of any kind, whether express, implied, or statutory. The \n    Licensor disclaims all warranties, including but not limited to, implied warranties of merchantability, \n    fitness for a particular purpose, accuracy, reliability, non-infringement, or any warranty arising from \n    the course of dealing or usage of trade.\n    5.2 Performance and Reliability: The Licensor does not warrant or guarantee that the Model, Derivatives or \n    Output will meet the Licensee’s requirements, that the operation of the Model, Derivatives or Output will \n    be uninterrupted or error-free, or that defects in the Model will be corrected. The Licensee acknowledges \n    that the use of the Model, Derivatives or Output is at its own risk and that the Model, Derivatives or \n    Output may contain bugs, errors, or other limitations.\n    5.3 No Endorsement: The Licensor does not endorse, approve, or certify any results, conclusions, or \n    recommendations derived from the use of the Model. The Licensee is solely responsible for evaluating the \n    accuracy, reliability, and suitability of the Model for its intended purposes.\n\n6. Limitation of Liability\n    6.1 No Liability for Damages: To the fullest extent permitted by applicable law, in no event shall the \n    Licensor be liable for any special, incidental, indirect, consequential, exemplary, or punitive damages, \n    including but not limited to, damages for loss of business profits, business interruption, loss of \n    business information, loss of data, or any other pecuniary or non-pecuniary loss arising out of or in \n    connection with the use or inability to use the Model, Derivatives or any Output, even if the Licensor has \n    been advised of the possibility of such damages.\n    6.2 Indemnification: The Licensee agrees to indemnify, defend, and hold harmless the Licensor, its \n    affiliates, officers, directors, employees, and agents from and against any claims, liabilities, damages, \n    losses, costs, or expenses (including reasonable attorneys' fees) arising out of or related to the \n    Licensee's use of the Model, any Derivatives, or any Output, including any violation of this Agreement or \n    applicable laws.\n\n7. Termination\n    7.1 Termination by Licensor: The Licensor reserves the right to terminate this Agreement and revoke the \n    Licensee’s rights to use the Model at any time, with or without cause, and without prior notice if the \n    Licensee breaches any of the terms or conditions of this Agreement. Termination shall be effective \n    immediately upon notice.\n    7.2 Effect of Termination: Upon termination of this Agreement, the Licensee must immediately cease all use \n    of the Model, Derivatives, and Output and destroy all copies of the Model, Derivatives, and Output in its \n    possession or control, including any backup or archival copies. The Licensee shall certify in writing to \n    the Licensor that such destruction has been completed.\n    7.3 Survival: The provisions of this Agreement that by their nature should survive termination, including \n    but not limited to, Sections 4 (Ownership), 5 (No Warranty), 6 (Limitation of Liability), and this Section \n    7 (Termination), shall continue to apply after termination.\n\n8. Governing Law\n    8.1 Governing Law: This Agreement shall be governed by and construed in accordance with the laws of the \n    Republic of Korea, without regard to its conflict of laws principles.\n    8.2 Arbitration: Any disputes, controversies, or claims arising out of or relating to this Agreement, \n    including its existence, validity, interpretation, performance, breach, or termination, shall be referred \n    to and finally resolved by arbitration administered by the Korean Commercial Arbitration Board (KCAB) in \n    accordance with the International Arbitration Rules of the Korean Commercial Arbitration Board in force at \n    the time of the commencement of the arbitration. The seat of arbitration shall be Seoul, Republic of \n    Korea. The tribunal shall consist of one arbitrator. The language of the arbitration shall be English.\n\n9. Alterations\n    9.1 Modifications: The Licensor reserves the right to modify or amend this Agreement at any time, in its \n    sole discretion. Any modifications will be effective upon posting the updated Agreement on the Licensor’s \n    website or through other means of communication. The Licensee is responsible for reviewing the Agreement \n    periodically for changes. Continued use of the Model after any modifications have been made constitutes \n    acceptance of the revised Agreement.\n    9.2 Entire Agreement: This Agreement constitutes the entire agreement between the Licensee and Licensor \n    concerning the subject matter hereof and supersedes all prior or contemporaneous oral or written \n    agreements, representations, or understandings. Any terms or conditions of any purchase order or other \n    document submitted by the Licensee in connection with the Model that are in addition to, different from, \n    or inconsistent with the terms and conditions of this Agreement are not binding on the Licensor and are \n    void.\n\nBy downloading, installing, or using the EXAONE AI Model, the Licensee acknowledges that it has read, \nunderstood, and agrees to be bound by the terms and conditions of this Agreement.",
    "py_files": {
        "configuration_exaone.py": "# coding=utf-8\n# Copyright 2021 The LG AI Research EXAONE Lab. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"EXAONE model configuration\"\"\"\n\nfrom transformers.configuration_utils import PretrainedConfig\nfrom transformers.utils import logging\n\n\nlogger = logging.get_logger(__name__)\n\nEXAONE_PRETRAINED_CONFIG_ARCHIVE_MAP = {}\n\n\nclass ExaoneConfig(PretrainedConfig):\n    r\"\"\"\n    This is the configuration class to store the configuration of a [`ExaoneModel`]. It is used to\n    instantiate a EXAONE model according to the specified arguments, defining the model architecture. Instantiating a\n    configuration with the defaults will yield a similar configuration to that of the EXAONE-3.0-7.8B-Instruct [LGAI-EXAONE/EXAONE-3.0-7.8B-Instruct](https://huggingface.co/LGAI-EXAONE/EXAONE-3.0-7.8B-Instruct)\n\n    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model\n    outputs. Read the documentation from [`PretrainedConfig`] for more information.\n\n\n    Args:\n        vocab_size (`int`, *optional*, defaults to 102400):\n            Vocabulary size of the EXAONE model. Defines the number of different tokens that can be represented by the\n            `inputs_ids` passed when calling [`ExaoneModel`]. Vocabulary size of the model.\n            Defines the different tokens that can be represented by the `inputs_ids` passed to the forward method of\n            [`ExaoneModel`].\n        max_position_embeddings (`int`, *optional*, defaults to 2048):\n            The maximum sequence length that this model might ever be used with. Typically set this to something large\n            just in case (e.g., 512 or 1024 or 2048).\n        hidden_size (`int`, *optional*, defaults to 2048):\n            Dimensionality of the encoder layers and the pooler layer.\n        num_layers (`int`, *optional*, defaults to 32):\n            Number of hidden layers in the Transformer encoder.\n        num_attention_heads (`int`, *optional*, defaults to 32):\n            Number of attention heads for each attention layer in the Transformer decoder.\n        num_key_value_heads (`int`, *optional*):\n            This is the number of key_value heads that should be used to implement Grouped Query Attention. If\n            `num_key_value_heads=num_attention_heads`, the model will use Multi Head Attention (MHA), if\n            `num_key_value_heads=1 the model will use Multi Query Attention (MQA) otherwise GQA is used. When\n            converting a multi-head checkpoint to a GQA checkpoint, each group key and value head should be constructed\n            by meanpooling all the original heads within that group. For more details checkout [this\n            paper](https://arxiv.org/pdf/2305.13245.pdf). If it is not specified, will default to\n            `num_attention_heads`.\n        intermediate_size (`int`, *optional*, defaults to `hidden_size * 4`):\n            Dimensionality of the \"intermediate\" (i.e., feed-forward) layer in the Transformer encoder.\n        activation_function (`str` or `function`, *optional*, defaults to `\"silu\"`):\n            The non-linear activation function (function or string) in the decoder.\n        rope_theta (`float`, *optional*, defaults to 10000.0):\n            The base period of the RoPE embeddings.\n        rope_scaling (`Dict`, *optional*):\n            Dictionary containing the scaling configuration for the RoPE embeddings. NOTE: if you apply new rope type\n            and you expect the model to work on longer `max_position_embeddings`, we recommend you to update this value\n            accordingly.\n            Expected contents:\n                `rope_type` (`str`):\n                    The sub-variant of RoPE to use. Can be one of ['default', 'linear', 'dynamic', 'yarn', 'longrope',\n                    'llama3'], with 'default' being the original RoPE implementation.\n                `factor` (`float`, *optional*):\n                    Used with all rope types except 'default'. The scaling factor to apply to the RoPE embeddings. In\n                    most scaling types, a `factor` of x will enable the model to handle sequences of length x *\n                    original maximum pre-trained length.\n                `original_max_position_embeddings` (`int`, *optional*):\n                    Used with 'dynamic', 'longrope' and 'llama3'. The original max position embeddings used during\n                    pretraining.\n                `attention_factor` (`float`, *optional*):\n                    Used with 'yarn' and 'longrope'. The scaling factor to be applied on the attention\n                    computation. If unspecified, it defaults to value recommended by the implementation, using the\n                    `factor` field to infer the suggested value.\n                `beta_fast` (`float`, *optional*):\n                    Only used with 'yarn'. Parameter to set the boundary for extrapolation (only) in the linear\n                    ramp function. If unspecified, it defaults to 32.\n                `beta_slow` (`float`, *optional*):\n                    Only used with 'yarn'. Parameter to set the boundary for interpolation (only) in the linear\n                    ramp function. If unspecified, it defaults to 1.\n                `short_factor` (`List[float]`, *optional*):\n                    Only used with 'longrope'. The scaling factor to be applied to short contexts (<\n                    `original_max_position_embeddings`). Must be a list of numbers with the same length as the hidden\n                    size divided by the number of attention heads divided by 2\n                `long_factor` (`List[float]`, *optional*):\n                    Only used with 'longrope'. The scaling factor to be applied to long contexts (<\n                    `original_max_position_embeddings`). Must be a list of numbers with the same length as the hidden\n                    size divided by the number of attention heads divided by 2\n                `low_freq_factor` (`float`, *optional*):\n                    Only used with 'llama3'. Scaling factor applied to low frequency components of the RoPE\n                `high_freq_factor` (`float`, *optional*):\n                    Only used with 'llama3'. Scaling factor applied to high frequency components of the RoPE\n        embed_dropout (`float`, *optional*, defaults to 0.0):\n            The dropout probabilitiy for all fully connected layers in the embeddings, encoder, and pooler.\n        attention_dropout (`float`, *optional*, defaults to 0.0):\n            The dropout ratio for the attention probabilities.\n        layer_norm_epsilon (`float`, *optional*, defaults to 1e-05):\n            The epsilon used by the layer normalization layers.\n        initializer_range (`float`, *optional*, defaults to 0.02):\n            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n        use_cache (`bool`, *optional*, defaults to `True`):\n            Whether or not the model should return the last key/values attentions (not used by all models). Only\n            relevant if ``config.is_decoder=True``.\n        bos_token_id (`int`, *optional*, defaults to 0):\n            Beginning of stream token id.\n        eos_token_id (`int`, *optional*, defaults to 2):\n            End of stream token id.\n\n    Example:\n\n    ```python\n    >>> from transformers import EXAONEModel, ExaoneConfig\n\n    >>> # Initializing a EXAONE configuration\n    >>> configuration = ExaoneConfig()\n\n    >>> # Initializing a model from configuration\n    >>> model = EXAONEModel(configuration)\n\n    >>> # Accessing the model configuration\n    >>> configuration = model.config\n    ```\"\"\"\n\n    model_type = \"exaone\"\n    keys_to_ignore_at_inference = [\"past_key_values\"]\n    attribute_map = {\"num_hidden_layers\": \"num_layers\"}\n\n    def __init__(\n        self,\n        vocab_size=102400,\n        max_position_embeddings=2048,\n        hidden_size=2048,\n        num_layers=32,\n        num_attention_heads=32,\n        num_key_value_heads=None,\n        intermediate_size=None,\n        activation_function=\"silu\",\n        rope_theta=10000.0,\n        rope_scaling=None,\n        embed_dropout=0.0,\n        attention_dropout=0.0,\n        layer_norm_epsilon=1e-5,\n        initializer_range=0.02,\n        use_cache=True,\n        bos_token_id=0,\n        eos_token_id=2,\n        **kwargs,\n    ):\n        self.vocab_size = vocab_size\n        self.max_position_embeddings = max_position_embeddings\n        self.hidden_size = hidden_size\n        self.num_layers = num_layers\n        self.num_attention_heads = num_attention_heads\n        if num_key_value_heads is None:\n            num_key_value_heads = num_attention_heads\n        self.num_key_value_heads = num_key_value_heads\n        if intermediate_size:\n            self.intermediate_size = intermediate_size\n        else:\n            self.intermediate_size = hidden_size * 4\n        self.activation_function = activation_function\n        self.embed_dropout = embed_dropout\n        self.attention_dropout = attention_dropout\n        self.layer_norm_epsilon = layer_norm_epsilon\n        self.initializer_range = initializer_range\n        self.use_cache = use_cache\n        self.rope_theta = rope_theta\n        self.rope_scaling = rope_scaling\n\n        self.bos_token_id = bos_token_id\n        self.eos_token_id = eos_token_id\n\n        super().__init__(bos_token_id=bos_token_id, eos_token_id=eos_token_id, **kwargs)\n",
        "modeling_exaone.py": "# coding=utf-8\n# Copyright 2021 The LG AI Research EXAONE Lab.\n# Copyright (c) 2018, NVIDIA CORPORATION.  All rights reserved.\n#\n# This code is based on EleutherAI's GPT-NeoX library and the GPT-NeoX\n# and OPT implementations in this library. It has been modified from its\n# original forms to accommodate minor architectural differences compared\n# to GPT-NeoX and OPT used by the Meta AI team that trained the model.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"LG AI Research EXAONE Lab\"\"\"\n\nimport math\nfrom typing import Optional, Tuple, Union\n\nimport torch\nimport torch.utils.checkpoint\nfrom packaging import version\nfrom torch import nn\nfrom torch.nn import BCEWithLogitsLoss, CrossEntropyLoss, MSELoss\n\nfrom transformers.activations import ACT2FN\nfrom transformers.cache_utils import Cache, DynamicCache, StaticCache\nfrom transformers.generation import GenerationMixin\nfrom transformers.modeling_attn_mask_utils import AttentionMaskConverter\nfrom transformers.modeling_flash_attention_utils import _flash_attention_forward\nfrom transformers.modeling_outputs import (\n    BaseModelOutputWithPast,\n    BaseModelOutputWithPastAndCrossAttentions,\n    CausalLMOutputWithPast,\n    QuestionAnsweringModelOutput,\n    SequenceClassifierOutputWithPast,\n)\nfrom transformers.modeling_rope_utils import ROPE_INIT_FUNCTIONS\nfrom transformers.modeling_utils import PreTrainedModel\nfrom transformers.pytorch_utils import ALL_LAYERNORM_LAYERS\nfrom transformers.utils import (\n    add_code_sample_docstrings,\n    add_start_docstrings,\n    add_start_docstrings_to_model_forward,\n    is_flash_attn_2_available,\n    logging,\n)\nfrom .configuration_exaone import ExaoneConfig\n\n\nif is_flash_attn_2_available():\n    try:\n        import flash_attn\n\n        if version.parse(flash_attn.__version__) > version.parse(\"2.4.2\"):\n            from flash_attn.ops.triton.layer_norm import rms_norm_fn\n        else:\n            from flash_attn.ops.triton.layernorm import rms_norm_fn\n    except ImportError:\n        pass\n\n\nlogger = logging.get_logger(__name__)\n\n_CHECKPOINT_FOR_DOC = \"exaone\"\n_CONFIG_FOR_DOC = \"ExaoneConfig\"\n\nEXAONE_PRETRAINED_MODEL_ARCHIVE_LIST = [\n    \"exaone\",\n]\n\n\n@torch.jit.script\ndef repeat_kv(hidden_states: torch.Tensor, n_rep: int) -> torch.Tensor:\n    \"\"\"\n    This is the equivalent of torch.repeat_interleave(x, dim=1, repeats=n_rep). The hidden states go from (batch,\n    num_key_value_heads, seqlen, head_dim) to (batch, num_attention_heads, seqlen, head_dim)\n    \"\"\"\n    batch, num_key_value_heads, slen, head_dim = hidden_states.shape\n    if n_rep == 1:\n        return hidden_states\n    hidden_states = hidden_states[:, :, None, :, :].expand(batch, num_key_value_heads, n_rep, slen, head_dim)\n    return hidden_states.reshape(batch, num_key_value_heads * n_rep, slen, head_dim)\n\n\ndef apply_rotary_pos_emb(q, k, cos, sin, unsqueeze_dim=1):\n    \"\"\"Applies Rotary Position Embedding to the query and key tensors.\n\n    Args:\n        q (`torch.Tensor`): The query tensor.\n        k (`torch.Tensor`): The key tensor.\n        cos (`torch.Tensor`): The cosine part of the rotary embedding.\n        sin (`torch.Tensor`): The sine part of the rotary embedding.\n        unsqueeze_dim (`int`, *optional*, defaults to 1):\n            The 'unsqueeze_dim' argument specifies the dimension along which to unsqueeze cos[position_ids] and\n            sin[position_ids] so that they can be properly broadcasted to the dimensions of q and k. For example, note\n            that cos[position_ids] and sin[position_ids] have the shape [batch_size, seq_len, head_dim]. Then, if q and\n            k have the shape [batch_size, heads, seq_len, head_dim], then setting unsqueeze_dim=1 makes\n            cos[position_ids] and sin[position_ids] broadcastable to the shapes of q and k. Similarly, if q and k have\n            the shape [batch_size, seq_len, heads, head_dim], then set unsqueeze_dim=2.\n    Returns:\n        `tuple(torch.Tensor)` comprising of the query and key tensors rotated using the Rotary Position Embedding.\n    \"\"\"\n    cos = cos.unsqueeze(unsqueeze_dim)\n    sin = sin.unsqueeze(unsqueeze_dim)\n    q_embed = (q * cos) + (rotate_half(q) * sin)\n    k_embed = (k * cos) + (rotate_half(k) * sin)\n    return q_embed, k_embed\n\n\ndef rotate_half(x):\n    \"\"\"Rotates half the hidden dims of the input.\"\"\"\n    x1 = x[..., : x.shape[-1] // 2]\n    x2 = x[..., x.shape[-1] // 2 :]\n    return torch.cat((-x2, x1), dim=-1)\n\n\ndef _prepare_4d_causal_attention_mask_with_cache_position(\n    attention_mask: torch.Tensor,\n    sequence_length: int,\n    target_length: int,\n    dtype: torch.dtype,\n    device: torch.device,\n    min_dtype: float,\n    cache_position: torch.Tensor,\n    batch_size: int,\n):\n    \"\"\"\n    Creates a causal 4D mask of shape `(batch_size, 1, query_length, key_value_length)` from a 2D mask of shape\n    `(batch_size, key_value_length)`, or if the input `attention_mask` is already 4D, do nothing.\n\n    Args:\n        attention_mask (`torch.Tensor`):\n            A 2D attention mask of shape `(batch_size, key_value_length)` or a 4D attention mask of shape `(batch_size, 1, query_length, key_value_length)`.\n        sequence_length (`int`):\n            The sequence length being processed.\n        target_length (`int`):\n            The target length: when generating with static cache, the mask should be as long as the static cache, to account for the 0 padding, the part of the cache that is not filled yet.\n        dtype (`torch.dtype`):\n            The dtype to use for the 4D attention mask.\n        device (`torch.device`):\n            The device to plcae the 4D attention mask on.\n        min_dtype (`float`):\n            The minimum value representable with the dtype `dtype`.\n        cache_position (`torch.Tensor`):\n            Indices depicting the position of the input sequence tokens in the sequence.\n        batch_size (`torch.Tensor`):\n            Batch size.\n    \"\"\"\n    if attention_mask is not None and attention_mask.dim() == 4:\n        # In this case we assume that the mask comes already in inverted form and requires no inversion or slicing.\n        causal_mask = attention_mask\n    else:\n        causal_mask = torch.full((sequence_length, target_length), fill_value=min_dtype, dtype=dtype, device=device)\n        if sequence_length != 1:\n            causal_mask = torch.triu(causal_mask, diagonal=1)\n        causal_mask *= torch.arange(target_length, device=device) > cache_position.reshape(-1, 1)\n        causal_mask = causal_mask[None, None, :, :].expand(batch_size, 1, -1, -1)\n        if attention_mask is not None:\n            causal_mask = causal_mask.clone()  # copy to contiguous memory for in-place edit\n            mask_length = attention_mask.shape[-1]\n            padding_mask = causal_mask[:, :, :, :mask_length] + attention_mask[:, None, None, :]\n            padding_mask = padding_mask == 0\n            causal_mask[:, :, :, :mask_length] = causal_mask[:, :, :, :mask_length].masked_fill(\n                padding_mask, min_dtype\n            )\n\n    return causal_mask\n\n\nclass ExaoneRMSNorm(torch.nn.Module):\n    def __init__(self, hidden_size, eps=1e-6):\n        super().__init__()\n        self.eps = eps\n        self.weight = torch.nn.Parameter(torch.ones(hidden_size))\n\n    def forward(self, hidden_states):\n        input_dtype = hidden_states.dtype\n        hidden_states = hidden_states.to(torch.float32)\n        variance = hidden_states.pow(2).mean(-1, keepdim=True)\n        hidden_states = hidden_states * torch.rsqrt(variance + self.eps)\n        return self.weight * hidden_states.to(input_dtype)\n\n\nclass ExaoneTritonRMSNorm(torch.nn.Module):\n    def __init__(\n        self,\n        hidden_size: int = 0,\n        eps: float = 1e-5,\n    ):\n        super().__init__()\n        self.eps = eps\n        self.drop = None\n        self.weight = torch.nn.Parameter(torch.empty(hidden_size))\n        self.register_parameter(\"bias\", None)\n        self.reset_parameters()\n\n    def reset_parameters(self):\n        torch.nn.init.ones_(self.weight)\n\n    def forward(self, x, residual=None, prenorm=False, residual_in_fp32=False):\n        return rms_norm_fn(\n            x,\n            self.weight,\n            self.bias,\n            residual=residual,\n            eps=self.eps,\n            dropout_p=self.drop.p if self.drop is not None and self.training else 0.0,\n            prenorm=prenorm,\n            residual_in_fp32=residual_in_fp32,\n        )\n\n\nALL_LAYERNORM_LAYERS.append(ExaoneRMSNorm)\nALL_LAYERNORM_LAYERS.append(ExaoneTritonRMSNorm)\n\n\nclass ExaoneRotaryEmbedding(nn.Module):\n    def __init__(self, config: ExaoneConfig, device=None):\n        super().__init__()\n        if config.rope_scaling is not None:\n            self.rope_type = config.rope_scaling.get(\"rope_type\", config.rope_scaling.get(\"type\"))\n        else:\n            self.rope_type = \"default\"\n        self.rope_theta = config.rope_theta\n        self.max_seq_len = config.max_position_embeddings\n        self.original_max_seq_len = config.max_position_embeddings\n\n        self.config = config\n        if self.rope_type not in ROPE_INIT_FUNCTIONS:\n            raise KeyError(f\"The EXAONE model does not support RoPE type: {self.rope_type}\")\n        self.rope_init_fn = ROPE_INIT_FUNCTIONS[self.rope_type]\n\n        inv_freq, self.attention_scaling = self.rope_init_fn(self.config, device)\n        self.register_buffer(\"inv_freq\", inv_freq, persistent=False)\n        self.original_inv_freq = self.inv_freq\n\n    def _update_freq(self, position_ids, device):\n        \"\"\"\n        dynamic RoPE layers should recompute `inv_freq` in the following situations:\n        1 - growing beyond the cached sequence length (allow scaling)\n        2 - the current sequence length is in the original scale (avoid losing precision with small sequences)\n        \"\"\"\n        seq_len = torch.max(position_ids) + 1\n        if seq_len > self.max_seq_len:  # expand to seq_len\n            inv_freq, self.attention_scaling = self.rope_init_fn(self.config, device, seq_len=seq_len)\n            self.register_buffer(\"inv_freq\", inv_freq, persistent=False)\n            self.max_seq_len = seq_len\n\n        if seq_len < self.original_max_seq_len and self.max_seq_len > self.original_max_seq_len:  # reset to original\n            self.register_buffer(\"inv_freq\", self.original_inv_freq, persistent=False)\n            self.max_seq_len = self.original_max_seq_len\n\n    @torch.no_grad()\n    def forward(self, x, position_ids):\n        if \"dynamic\" in self.rope_type:\n            self._update_freq(position_ids, device=x.device)\n\n        inv_freq_expanded = self.inv_freq[None, :, None].float().expand(position_ids.shape[0], -1, 1).to(x.device)\n        position_ids_expanded = position_ids[:, None, :].float()\n\n        device_type = x.device.type\n        device_type = device_type if isinstance(device_type, str) and device_type != \"mps\" else \"cpu\"\n        with torch.autocast(device_type=device_type, enabled=False):\n            freqs = (inv_freq_expanded @ position_ids_expanded).transpose(1, 2)\n            emb = torch.cat((freqs, freqs), dim=-1)\n            cos, sin = emb.cos(), emb.sin()\n\n        cos, sin = cos * self.attention_scaling, sin * self.attention_scaling\n        return cos.to(x.dtype), sin.to(x.dtype)\n\n\nclass ExaoneSelfAttention(nn.Module):\n    def __init__(self, config: ExaoneConfig, layer_idx: Optional[int] = None):\n        super().__init__()\n        self.config = config\n        self.layer_idx = layer_idx\n        self.embed_dim = config.hidden_size\n        self.num_heads = config.num_attention_heads\n        self.head_dim = self.embed_dim // self.num_heads\n        self.num_key_value_heads = config.num_key_value_heads\n        self.num_key_value_groups = self.num_heads // self.num_key_value_heads\n        self.attention_dropout_rate = config.attention_dropout\n\n        if self.head_dim * self.num_heads != self.embed_dim:\n            raise ValueError(\n                f\"embed_dim must be divisible by num_heads (got `embed_dim`: {self.embed_dim} and `num_heads`: {self.num_heads}).\"\n            )\n\n        self.rotary = ExaoneRotaryEmbedding(config)\n\n        self.k_proj = nn.Linear(self.embed_dim, self.num_key_value_heads * self.head_dim, bias=False)\n        self.v_proj = nn.Linear(self.embed_dim, self.num_key_value_heads * self.head_dim, bias=False)\n        self.q_proj = nn.Linear(self.embed_dim, self.num_heads * self.head_dim, bias=False)\n        self.out_proj = nn.Linear(self.embed_dim, self.embed_dim, bias=False)\n\n    def forward(\n        self,\n        hidden_states: torch.Tensor,\n        attention_mask: Optional[torch.Tensor] = None,\n        position_ids: Optional[torch.LongTensor] = None,\n        past_key_value: Optional[Cache] = None,\n        output_attentions: Optional[bool] = False,\n        use_cache: Optional[bool] = False,\n        cache_position: Optional[torch.LongTensor] = None,\n        position_embeddings: Optional[Tuple[torch.Tensor, torch.Tensor]] = None,\n        **kwargs,\n    ) -> Tuple[torch.Tensor, Optional[torch.Tensor], Optional[Tuple[torch.Tensor]]]:\n        bsz, q_len, _ = hidden_states.size()\n        query_states = self.q_proj(hidden_states)\n        key_states = self.k_proj(hidden_states)\n        value_states = self.v_proj(hidden_states)\n\n        query_states = query_states.view(bsz, q_len, self.num_heads, self.head_dim).transpose(1, 2)\n        key_states = key_states.view(bsz, q_len, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n        value_states = value_states.view(bsz, q_len, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n\n        if position_embeddings is None:\n            cos, sin = self.rotary(value_states, position_ids=position_ids)\n        else:\n            cos, sin = position_embeddings\n        query_states, key_states = apply_rotary_pos_emb(query_states, key_states, cos, sin)\n\n        if past_key_value is not None:\n            # sin and cos are specific to RoPE models; cache_position needed for the static cache\n            cache_kwargs = {\"sin\": sin, \"cos\": cos, \"cache_position\": cache_position}\n            key_states, value_states = past_key_value.update(key_states, value_states, self.layer_idx, cache_kwargs)\n\n        key_states = repeat_kv(key_states, self.num_key_value_groups)\n        value_states = repeat_kv(value_states, self.num_key_value_groups)\n\n        attn_weights = torch.matmul(query_states, key_states.transpose(2, 3)) / math.sqrt(self.head_dim)\n\n        if attention_mask is not None:\n            causal_mask = attention_mask[:, :, :, : key_states.shape[-2]]\n            attn_weights = attn_weights + causal_mask\n\n        attn_weights = nn.functional.softmax(attn_weights, dim=-1, dtype=torch.float32).to(query_states.dtype)\n        attn_weights = nn.functional.dropout(attn_weights, p=self.attention_dropout_rate, training=self.training)\n        attn_output = torch.matmul(attn_weights, value_states)\n\n        if attn_output.size() != (bsz, self.num_heads, q_len, self.head_dim):\n            raise ValueError(\n                f\"Attention outputs should be of size {(bsz, self.num_heads, q_len, self.head_dim)}, but is\"\n                f\" {attn_output.size()}\"\n            )\n\n        attn_output = attn_output.transpose(1, 2).contiguous()\n        attn_output = attn_output.reshape(bsz, q_len, self.embed_dim).contiguous()\n\n        attn_output = self.out_proj(attn_output)\n\n        if not output_attentions:\n            attn_weights = None\n\n        return attn_output, attn_weights, past_key_value\n\n\nclass ExaoneFlashAttention(ExaoneSelfAttention):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n    def _shape(self, tensor: torch.Tensor, seq_len: int, bsz: int):\n        return tensor.view(bsz, seq_len, self.num_heads, self.head_dim).transpose(1, 2).contiguous()\n\n    def forward(\n        self,\n        hidden_states: torch.Tensor,\n        attention_mask: Optional[torch.Tensor] = None,\n        position_ids: Optional[torch.LongTensor] = None,\n        past_key_value: Optional[Cache] = None,\n        output_attentions: Optional[bool] = False,\n        use_cache: Optional[bool] = False,\n        cache_position: Optional[torch.LongTensor] = None,\n        position_embeddings: Optional[Tuple[torch.Tensor, torch.Tensor]] = None,\n        **kwargs,\n    ) -> Tuple[torch.Tensor, Optional[torch.Tensor], Optional[Tuple[torch.Tensor]]]:\n        if isinstance(past_key_value, StaticCache):\n            raise ValueError(\n                \"`static` cache implementation is not compatible with `attn_implementation==flash_attention_2` \"\n                \"make sure to use `sdpa` in the mean time, and open an issue at https://github.com/huggingface/transformers\"\n            )\n\n        output_attentions = False\n\n        bsz, q_len, h_size = hidden_states.size()\n\n        query_states = self.q_proj(hidden_states)\n        key_states = self.k_proj(hidden_states)\n        value_states = self.v_proj(hidden_states)\n\n        query_states = query_states.view(bsz, q_len, self.num_heads, self.head_dim).transpose(1, 2)\n        key_states = key_states.view(bsz, q_len, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n        value_states = value_states.view(bsz, q_len, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n\n        if position_embeddings is None:\n            cos, sin = self.rotary(value_states, position_ids=position_ids)\n        else:\n            cos, sin = position_embeddings\n        query_states, key_states = apply_rotary_pos_emb(query_states, key_states, cos, sin)\n\n        if past_key_value is not None:\n            # sin and cos are specific to RoPE models; cache_position needed for the static cache\n            cache_kwargs = {\"sin\": sin, \"cos\": cos, \"cache_position\": cache_position}\n            # Only update cache as shape of [bsz, n_head, q_len, head_dim]\n            # TODO: need to be fixed when transformers' KV cache layout is changed\n            key_states, value_states = past_key_value.update(key_states, value_states, self.layer_idx, cache_kwargs)\n\n        query_states = query_states.transpose(1, 2)\n        key_states = key_states.transpose(1, 2)\n        value_states = value_states.transpose(1, 2)\n\n        # In PEFT, usually we cast the layer norms in float32 for training stability reasons\n        # therefore the input hidden states gets silently casted in float32. Hence, we need\n        # cast them back in the correct dtype just to be sure everything works as expected.\n        input_dtype = query_states.dtype\n        if input_dtype == torch.float32:\n            if torch.is_autocast_enabled():\n                target_dtype = torch.get_autocast_gpu_dtype()\n            # Handle the case where the model is quantized\n            elif hasattr(self.config, \"_pre_quantization_dtype\"):\n                target_dtype = self.config._pre_quantization_dtype\n            else:\n                target_dtype = self.q_proj.weight.dtype\n\n            logger.warning_once(\n                f\"The input hidden states seems to be silently casted in float32, this might be related to\"\n                f\" the fact you have upcasted embedding or layer norm layers in float32. We will cast back the input in\"\n                f\" {target_dtype}.\"\n            )\n\n            query_states = query_states.to(target_dtype)\n            key_states = key_states.to(target_dtype)\n            value_states = value_states.to(target_dtype)\n\n        dropout_rate = self.attention_dropout_rate if self.training else 0.0\n\n        attn_output = _flash_attention_forward(\n            query_states, key_states, value_states, attention_mask, q_len, dropout=dropout_rate, is_causal=True\n        )\n\n        attn_output = attn_output.reshape(bsz, q_len, self.embed_dim).contiguous()\n        attn_output = self.out_proj(attn_output)\n\n        if not output_attentions:\n            attn_weights = None\n\n        return attn_output, attn_weights, past_key_value\n\n\nclass ExaoneSdpaAttention(ExaoneSelfAttention):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n    def forward(\n        self,\n        hidden_states: torch.Tensor,\n        attention_mask: Optional[torch.Tensor] = None,\n        position_ids: Optional[torch.LongTensor] = None,\n        past_key_value: Optional[Cache] = None,\n        output_attentions: Optional[bool] = False,\n        use_cache: Optional[bool] = False,\n        cache_position: Optional[torch.LongTensor] = None,\n        position_embeddings: Optional[Tuple[torch.Tensor, torch.Tensor]] = None,\n        **kwargs,\n    ) -> Tuple[torch.Tensor, Optional[torch.Tensor], Optional[Tuple[torch.Tensor]]]:\n        if output_attentions:\n            logger.warning_once(\n                \"ExaoneModel is using ExaoneSdpaAttention, but `torch.nn.functional.scaled_dot_product_attention` does not support `output_attentions=True`. Falling back to the manual attention implementation, \"\n                'but specifying the manual implementation will be required from Transformers version v5.0.0 onwards. This warning can be removed using the argument `attn_implementation=\"eager\"` when loading the model.'\n            )\n            return super().forward(\n                hidden_states=hidden_states,\n                attention_mask=attention_mask,\n                position_ids=position_ids,\n                past_key_value=past_key_value,\n                output_attentions=output_attentions,\n                use_cache=use_cache,\n                cache_position=cache_position,\n                position_embeddings=position_embeddings,\n                **kwargs,\n            )\n\n        bsz, q_len, _ = hidden_states.size()\n\n        query_states = self.q_proj(hidden_states)\n        key_states = self.k_proj(hidden_states)\n        value_states = self.v_proj(hidden_states)\n\n        query_states = query_states.view(bsz, q_len, self.num_heads, self.head_dim).transpose(1, 2)\n        key_states = key_states.view(bsz, q_len, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n        value_states = value_states.view(bsz, q_len, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n\n        if position_embeddings is None:\n            cos, sin = self.rotary(value_states, position_ids=position_ids)\n        else:\n            cos, sin = position_embeddings\n        query_states, key_states = apply_rotary_pos_emb(query_states, key_states, cos, sin)\n\n        if past_key_value is not None:\n            # sin and cos are specific to RoPE models; cache_position needed for the static cache\n            cache_kwargs = {\"sin\": sin, \"cos\": cos, \"cache_position\": cache_position}\n            key_states, value_states = past_key_value.update(key_states, value_states, self.layer_idx, cache_kwargs)\n\n        key_states = repeat_kv(key_states, self.num_key_value_groups)\n        value_states = repeat_kv(value_states, self.num_key_value_groups)\n\n        causal_mask = attention_mask\n        if attention_mask is not None:\n            causal_mask = causal_mask[:, :, :, : key_states.shape[-2]]\n\n        # SDPA with memory-efficient backend is currently (torch==2.1.2) bugged with non-contiguous inputs with custom attn_mask,\n        # Reference: https://github.com/pytorch/pytorch/issues/112577.\n        if query_states.device.type == \"cuda\" and causal_mask is not None:\n            query_states = query_states.contiguous()\n            key_states = key_states.contiguous()\n            value_states = value_states.contiguous()\n\n        # We dispatch to SDPA's Flash Attention or Efficient kernels via this `is_causal` if statement instead of an inline conditional assignment\n        # in SDPA to support both torch.compile's dynamic shapes and full graph options. An inline conditional prevents dynamic shapes from compiling.\n        is_causal = True if causal_mask is None and q_len > 1 else False\n\n        attn_output = torch.nn.functional.scaled_dot_product_attention(\n            query_states,\n            key_states,\n            value_states,\n            attn_mask=causal_mask,\n            dropout_p=self.attention_dropout_rate if self.training else 0.0,\n            is_causal=is_causal,\n        )\n\n        attn_output = attn_output.transpose(1, 2).contiguous()\n        attn_output = attn_output.reshape(bsz, q_len, self.embed_dim).contiguous()\n\n        attn_output = self.out_proj(attn_output)\n\n        return attn_output, None, past_key_value\n\n\nclass ExaoneAttention(nn.Module):\n    def __init__(self, config, layer_id=0):\n        super().__init__()\n        self.layer_id = layer_id\n        if \"flash\" in config._attn_implementation:\n            self.attention = ExaoneFlashAttention(config, self.layer_id)\n        elif \"sdpa\" in config._attn_implementation:\n            self.attention = ExaoneSdpaAttention(config, self.layer_id)\n        else:\n            self.attention = ExaoneSelfAttention(config, self.layer_id)\n\n    def forward(\n        self,\n        hidden_states: torch.Tensor,\n        attention_mask: Optional[torch.Tensor] = None,\n        position_ids: Optional[torch.LongTensor] = None,\n        past_key_value: Optional[Cache] = None,\n        output_attentions: Optional[bool] = False,\n        use_cache: Optional[bool] = False,\n        cache_position: Optional[torch.LongTensor] = None,\n        position_embeddings: Optional[Tuple[torch.Tensor, torch.Tensor]] = None,\n        **kwargs,\n    ) -> Tuple[torch.Tensor, Optional[torch.Tensor], Optional[Tuple[torch.Tensor]]]:\n        return self.attention(\n            hidden_states=hidden_states,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            past_key_value=past_key_value,\n            output_attentions=output_attentions,\n            use_cache=use_cache,\n            cache_position=cache_position,\n            position_embeddings=position_embeddings,\n            **kwargs,\n        )\n\n\nclass ExaoneGatedMLP(nn.Module):\n    def __init__(self, intermediate_size, config):\n        super().__init__()\n        self.config = config\n        embed_dim = config.hidden_size\n        self.c_fc_0 = nn.Linear(embed_dim, intermediate_size, bias=False)\n        self.c_fc_1 = nn.Linear(embed_dim, intermediate_size, bias=False)\n        self.c_proj = nn.Linear(intermediate_size, embed_dim, bias=False)\n        self.act = ACT2FN[config.activation_function]\n\n    def forward(self, hidden_states):\n        output_proj = self.c_proj(self.act(self.c_fc_0(hidden_states)) * self.c_fc_1(hidden_states))\n        return output_proj\n\n\nclass ExaoneBlock(nn.Module):\n    def __init__(self, config, layer_id):\n        super().__init__()\n        self.config = config\n        hidden_size = config.hidden_size\n        inner_dim = config.intermediate_size if config.intermediate_size is not None else 4 * hidden_size\n        self.ln_1 = ExaoneRMSNorm(hidden_size=hidden_size, eps=config.layer_norm_epsilon)\n        self.attn = ExaoneAttention(config, layer_id)\n        self.ln_2 = ExaoneRMSNorm(hidden_size=hidden_size, eps=config.layer_norm_epsilon)\n        self.mlp = ExaoneGatedMLP(inner_dim, config)\n\n    def forward(\n        self,\n        hidden_states: torch.Tensor,\n        attention_mask: Optional[torch.Tensor] = None,\n        position_ids: Optional[torch.LongTensor] = None,\n        past_key_value: Optional[Cache] = None,\n        output_attentions: Optional[bool] = False,\n        use_cache: Optional[bool] = False,\n        cache_position: Optional[torch.LongTensor] = None,\n        position_embeddings: Optional[Tuple[torch.Tensor, torch.Tensor]] = None,\n        **kwargs,\n    ) -> Tuple[torch.FloatTensor, Optional[Tuple[torch.FloatTensor, torch.FloatTensor]]]:\n        residual = hidden_states\n        hidden_states = self.ln_1(hidden_states)\n\n        hidden_states, self_attn_weights, present_key_value = self.attn(\n            hidden_states=hidden_states,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            past_key_value=past_key_value,\n            output_attentions=output_attentions,\n            use_cache=use_cache,\n            cache_position=cache_position,\n            position_embeddings=position_embeddings,\n            **kwargs,\n        )\n        # residual connection\n        hidden_states = residual + hidden_states\n\n        residual = hidden_states\n        hidden_states = self.ln_2(hidden_states)\n        hidden_states = self.mlp(hidden_states)\n\n        hidden_states = residual + hidden_states\n\n        outputs = (hidden_states,)\n\n        if output_attentions:\n            outputs += (self_attn_weights,)\n\n        if use_cache:\n            outputs += (present_key_value,)\n\n        return outputs\n\n\nclass ExaonePreTrainedModel(PreTrainedModel):\n    \"\"\"\n    An abstract class to handle weights initialization and a simple interface for downloading and loading pretrained\n    models.\n    \"\"\"\n\n    config_class = ExaoneConfig\n    base_model_prefix = \"transformer\"\n    supports_gradient_checkpointing = True\n    _no_split_modules = [\"ExaoneBlock\"]\n    _skip_keys_device_placement = \"past_key_values\"\n    _supports_flash_attn_2 = True\n    _supports_sdpa = True\n    _supports_cache_class = True\n\n    def __init__(self, *inputs, **kwargs):\n        super().__init__(*inputs, **kwargs)\n\n    def _init_weights(self, module):\n        \"\"\"Initialize the weights.\"\"\"\n        if isinstance(module, (nn.Linear,)):\n            # Slightly different from the TF version which uses truncated_normal for initialization\n            # cf https://github.com/pytorch/pytorch/pull/5617\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n            if module.bias is not None:\n                module.bias.data.zero_()\n        elif isinstance(module, nn.Embedding):\n            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n            if module.padding_idx is not None:\n                module.weight.data[module.padding_idx].zero_()\n        elif isinstance(module, ExaoneRMSNorm):\n            module.weight.data.fill_(1.0)\n\n\nEXAONE_START_DOCSTRING = r\"\"\"\n\n    This model inherits from [`PreTrainedModel`]. Check the superclass documentation for the generic methods the\n    library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads\n    etc.)\n\n    This model is also a PyTorch [torch.nn.Module](https://pytorch.org/docs/stable/nn.html#torch.nn.Module) subclass.\n    Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage\n    and behavior.\n\n    Parameters:\n        config ([`ExaoneConfig`]): Model configuration class with all the parameters of the model.\n            Initializing with a config file does not load the weights associated with the model, only the\n            configuration. Check out the `PreTrainedModel.from_pretrained` method to load the model weights.\n\"\"\"\n\nEXAONE_INPUTS_DOCSTRING = r\"\"\"\n    Args:\n        input_ids (`torch.LongTensor` of shape `(batch_size, input_ids_length)`, *optional*):\n            `input_ids_length` = `sequence_length` if `past_key_values` is `None` else\n            `past_key_values.get_seq_length()` (`sequence_length` of input past key value states). Indices of input\n            sequence tokens in the vocabulary.\n\n            If `past_key_values` is used, only `input_ids` that do not have their past calculated should be\n            passed as `input_ids`.\n\n            `What are input IDs? <../glossary.html#input-ids>`__\n        attention_mask (`torch.FloatTensor` of shape `(batch_size, sequence_length)`, *optional*):\n            Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:\n\n            - 1 for tokens that are **not masked**,\n            - 0 for tokens that are **masked**.\n\n            `What are attention masks? <../glossary.html#attention-mask>`__\n        position_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n            Indices of positions of each input sequence tokens in the position embeddings. Selected in the range `[0,\n            config.max_position_embeddings - 1]`.\n\n            `What are position IDs? <../glossary.html#position-ids>`_\n        past_key_values (`Cache`, *optional*):\n            Contains precomputed hidden-states (key and values in the attention blocks) as computed by the model (see\n            `past_key_values` output below). Can be used to speed up sequential decoding. This typically consists\n            in the `past_key_values` returned by the model at a previous stage of decoding, when `use_cache=True` or\n            `config.use_cache=True`.\n        inputs_embeds (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*):\n            Optionally, instead of passing `input_ids` you can choose to directly pass an embedded representation.\n            This is useful if you want more control over how to convert `input_ids` indices into associated\n            vectors than the model's internal embedding lookup matrix.\n\n            If `past_key_values` is used, optionally only the last `inputs_embeds` have to be input (see\n            `past_key_values`).\n        use_cache (`bool`, *optional*):\n            If set to `True`, `past_key_values` key value states are returned and can be used to speed up\n            decoding (see `past_key_values`).\n        output_attentions (`bool`, *optional*):\n            Whether or not to return the attentions tensors of all attention layers. See ``attentions`` under returned\n            tensors for more detail.\n        output_hidden_states (`bool`, *optional*):\n            Whether or not to return the hidden states of all layers. See ``hidden_states`` under returned tensors for\n            more detail.\n        return_dict (`bool`, *optional*):\n            Whether or not to return a [`~utils.ModelOutput`] instead of a plain tuple.\n        cache_position (`torch.LongTensor` of shape `(sequence_length)`, *optional*):\n            Indices depicting the position of the input sequence tokens in the sequence. Contrarily to `position_ids`,\n            this tensor is not affected by padding. It is used to update the cache in the correct position and to infer\n            the complete sequence length.\n\"\"\"\n\n\n@add_start_docstrings(\n    \"The bare EXAONE Model transformer outputting raw hidden-states without any specific head on top.\",\n    EXAONE_START_DOCSTRING,\n)\nclass ExaoneModel(ExaonePreTrainedModel):\n    def __init__(self, config):\n        super().__init__(config)\n        self.config = config\n        self.embed_dim = config.hidden_size\n        self.wte = nn.Embedding(config.vocab_size, self.embed_dim, self.config.pad_token_id)\n        self.drop = nn.Dropout(float(config.embed_dropout))\n        self.h = nn.ModuleList([ExaoneBlock(config, layer_id=i) for i in range(config.num_layers)])\n        self.ln_f = ExaoneRMSNorm(hidden_size=self.embed_dim, eps=config.layer_norm_epsilon)\n        self.rotary = ExaoneRotaryEmbedding(config)\n        self.gradient_checkpointing = False\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def get_input_embeddings(self):\n        return self.wte\n\n    def set_input_embeddings(self, new_embeddings):\n        self.wte = new_embeddings\n\n    @add_start_docstrings_to_model_forward(EXAONE_INPUTS_DOCSTRING)\n    @add_code_sample_docstrings(\n        checkpoint=_CHECKPOINT_FOR_DOC,\n        output_type=BaseModelOutputWithPastAndCrossAttentions,\n        config_class=_CONFIG_FOR_DOC,\n    )\n    def forward(\n        self,\n        input_ids: Optional[torch.Tensor] = None,\n        attention_mask: Optional[torch.Tensor] = None,\n        position_ids: Optional[torch.Tensor] = None,\n        past_key_values: Optional[Cache] = None,\n        inputs_embeds: Optional[torch.Tensor] = None,\n        use_cache: Optional[bool] = None,\n        output_attentions: Optional[bool] = None,\n        output_hidden_states: Optional[bool] = None,\n        return_dict: Optional[bool] = None,\n        cache_position: Optional[torch.LongTensor] = None,\n    ) -> Union[Tuple[torch.Tensor], BaseModelOutputWithPast]:\n        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n        output_hidden_states = (\n            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n        )\n        use_cache = use_cache if use_cache is not None else self.config.use_cache\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n\n        if self.gradient_checkpointing and self.training:\n            if use_cache:\n                logger.warning_once(\n                    \"`use_cache=True` is incompatible with gradient checkpointing. Setting `use_cache=False`...\"\n                )\n                use_cache = False\n\n        if input_ids is not None and inputs_embeds is not None:\n            raise ValueError(\"You cannot specify both input_ids and inputs_embeds at the same time\")\n        elif input_ids is not None:\n            batch_size, seq_length = input_ids.shape[:2]\n        elif inputs_embeds is not None:\n            batch_size, seq_length = inputs_embeds.shape[:2]\n        else:\n            raise ValueError(\"You have to specify either input_ids or inputs_embeds\")\n\n        return_legacy_cache = False\n        if (\n            use_cache and not isinstance(past_key_values, Cache) and not self.training\n        ):  # kept for BC (non `Cache` `past_key_values` inputs)\n            return_legacy_cache = True\n            past_key_values = DynamicCache.from_legacy_cache(past_key_values)\n            logger.warning_once(\n                \"We detected that you are passing `past_key_values` as a tuple and this is deprecated and will be removed in v4.43. \"\n                \"Please use an appropriate `Cache` class (https://huggingface.co/docs/transformers/v4.41.3/en/internal/generation_utils#transformers.Cache)\"\n            )\n\n        if inputs_embeds is None:\n            inputs_embeds = self.wte(input_ids)\n\n        if cache_position is None:\n            past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n            cache_position = torch.arange(\n                past_seen_tokens, past_seen_tokens + inputs_embeds.shape[1], device=inputs_embeds.device\n            )\n        if position_ids is None:\n            position_ids = cache_position.unsqueeze(0)\n\n        causal_mask = self._update_causal_mask(\n            attention_mask, inputs_embeds, cache_position, past_key_values, output_attentions\n        )\n\n        hidden_states = inputs_embeds\n        hidden_states = self.drop(hidden_states)\n\n        position_embeddings = self.rotary(hidden_states, position_ids)\n\n        all_hidden_states = () if output_hidden_states else None\n        all_self_attns = () if output_attentions else None\n        next_decoder_cache = None\n\n        for block in self.h:\n            if output_hidden_states:\n                all_hidden_states = all_hidden_states + (hidden_states,)\n\n            if self.gradient_checkpointing and self.training:\n                outputs = self._gradient_checkpointing_func(\n                    block.__call__,\n                    hidden_states,\n                    causal_mask,\n                    position_ids,\n                    past_key_values,\n                    output_attentions,\n                    use_cache,\n                    cache_position,\n                    position_embeddings,\n                )\n            else:\n                outputs = block(\n                    hidden_states,\n                    attention_mask=causal_mask,\n                    position_ids=position_ids,\n                    past_key_value=past_key_values,\n                    output_attentions=output_attentions,\n                    use_cache=use_cache,\n                    cache_position=cache_position,\n                    position_embeddings=position_embeddings,\n                )\n\n            hidden_states = outputs[0]\n            if use_cache:\n                next_decoder_cache = outputs[2 if output_attentions else 1]\n\n            if output_attentions:\n                all_self_attns += (outputs[1],)\n\n        hidden_states = self.ln_f(hidden_states)\n        # Add last hidden state\n        if output_hidden_states:\n            all_hidden_states += (hidden_states,)\n\n        next_cache = None\n        if use_cache:\n            next_cache = next_decoder_cache.to_legacy_cache() if return_legacy_cache else next_decoder_cache\n        if not return_dict:\n            return tuple(v for v in [hidden_states, next_cache, all_hidden_states, all_self_attns] if v is not None)\n\n        return BaseModelOutputWithPast(\n            last_hidden_state=hidden_states,\n            past_key_values=next_cache,\n            hidden_states=all_hidden_states,\n            attentions=all_self_attns,\n        )\n\n    def _update_causal_mask(\n        self,\n        attention_mask: torch.Tensor,\n        input_tensor: torch.Tensor,\n        cache_position: torch.Tensor,\n        past_key_values: Cache,\n        output_attentions: bool,\n    ):\n        # TODO: As of torch==2.2.0, the `attention_mask` passed to the model in `generate` is 2D and of dynamic length even when the static\n        # KV cache is used. This is an issue for torch.compile which then recaptures cudagraphs at each decode steps due to the dynamic shapes.\n        # (`recording cudagraph tree for symint key 13`, etc.), which is VERY slow. A workaround is `@torch.compiler.disable`, but this prevents using\n        # `fullgraph=True`. See more context in https://github.com/huggingface/transformers/pull/29114\n\n        if self.config._attn_implementation == \"flash_attention_2\":\n            if attention_mask is not None and 0.0 in attention_mask:\n                return attention_mask\n            return None\n\n        # For SDPA, when possible, we will rely on its `is_causal` argument instead of its `attn_mask` argument, in\n        # order to dispatch on Flash Attention 2. This feature is not compatible with static cache, as SDPA will fail\n        # to infer the attention mask.\n        past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n        using_static_cache = isinstance(past_key_values, StaticCache)\n\n        # When output attentions is True, sdpa implementation's forward method calls the eager implementation's forward\n        if self.config._attn_implementation == \"sdpa\" and not using_static_cache and not output_attentions:\n            if AttentionMaskConverter._ignore_causal_mask_sdpa(\n                attention_mask,\n                inputs_embeds=input_tensor,\n                past_key_values_length=past_seen_tokens,\n                is_training=self.training,\n            ):\n                return None\n\n        dtype, device = input_tensor.dtype, input_tensor.device\n        min_dtype = torch.finfo(dtype).min\n        sequence_length = input_tensor.shape[1]\n        if using_static_cache:\n            target_length = past_key_values.get_max_length()\n        else:\n            target_length = (\n                attention_mask.shape[-1]\n                if isinstance(attention_mask, torch.Tensor)\n                else past_seen_tokens + sequence_length + 1\n            )\n\n        # In case the provided `attention` mask is 2D, we generate a causal mask here (4D).\n        causal_mask = _prepare_4d_causal_attention_mask_with_cache_position(\n            attention_mask,\n            sequence_length=sequence_length,\n            target_length=target_length,\n            dtype=dtype,\n            device=device,\n            min_dtype=min_dtype,\n            cache_position=cache_position,\n            batch_size=input_tensor.shape[0],\n        )\n\n        if (\n            self.config._attn_implementation == \"sdpa\"\n            and attention_mask is not None\n            and attention_mask.device.type == \"cuda\"\n            and not output_attentions\n        ):\n            # Attend to all tokens in fully masked rows in the causal_mask, for example the relevant first rows when\n            # using left padding. This is required by F.scaled_dot_product_attention memory-efficient attention path.\n            # Details: https://github.com/pytorch/pytorch/issues/110213\n            causal_mask = AttentionMaskConverter._unmask_unattended(causal_mask, min_dtype)\n\n        return causal_mask\n\n\n@add_start_docstrings(\n    \"\"\"\n    The EXAONE Model transformer with a language modeling head on top (linear layer with weights tied to the input\n    embeddings).\n    \"\"\",\n    EXAONE_START_DOCSTRING,\n)\nclass ExaoneForCausalLM(ExaonePreTrainedModel, GenerationMixin):\n    _tied_weights_keys = [\"lm_head.weight\"]\n\n    def __init__(self, config):\n        super().__init__(config)\n        self.transformer = ExaoneModel(config)\n        self.lm_head = nn.Linear(config.hidden_size, config.vocab_size, bias=False)\n        self.config = config\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def get_output_embeddings(self):\n        return self.lm_head\n\n    def set_output_embeddings(self, new_embeddings):\n        self.lm_head = new_embeddings\n\n    @add_start_docstrings_to_model_forward(EXAONE_INPUTS_DOCSTRING)\n    @add_code_sample_docstrings(\n        checkpoint=_CHECKPOINT_FOR_DOC,\n        output_type=BaseModelOutputWithPast,\n        config_class=_CONFIG_FOR_DOC,\n    )\n    def forward(\n        self,\n        input_ids: Optional[torch.Tensor] = None,\n        attention_mask: Optional[torch.Tensor] = None,\n        position_ids: Optional[torch.Tensor] = None,\n        past_key_values: Optional[Cache] = None,\n        inputs_embeds: Optional[torch.Tensor] = None,\n        labels: Optional[torch.Tensor] = None,\n        use_cache: Optional[bool] = None,\n        output_attentions: Optional[bool] = None,\n        output_hidden_states: Optional[bool] = None,\n        return_dict: Optional[bool] = None,\n        cache_position: Optional[torch.LongTensor] = None,\n    ) -> Union[Tuple[torch.Tensor], BaseModelOutputWithPast]:\n        r\"\"\"\n        Args:\n            labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n                Labels for language modeling. Note that the labels **are shifted** inside the model, i.e. you can set\n                `labels = input_ids` Indices are selected in `[-100, 0, ..., config.vocab_size]` All labels set to `-100`\n                are ignored (masked), the loss is only computed for labels in `[0, ..., config.vocab_size]`\n\n        Example:\n\n        ```python\n        >>> from transformers import AutoModelForCausalLM, AutoTokenizer\n\n        >>> model = AutoModelForCausalLM.from_pretrained(\"LGAI-EXAONE/EXAONE-3.0-7.8B-Instruct\",\n                                                         trust_remote_code=True)\n        >>> tokenizer = AutoTokenizer.from_pretrained(\"LGAI-EXAONE/EXAONE-3.0-7.8B-Instruct\")\n\n        >>> prompt = \"Explain how wonderful you are\"\n        >>> messages = [\n            {\"role\": \"system\", \"content\": \"You are a helpful assistant.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        >>> input_ids = tokenizer.apply_chat_template(\n            messages,\n            tokenize=True,\n            add_generation_prompt=True,\n            return_tensors=\"pt\"\n        )\n\n        >>> output = model.generate(input_ids, max_new_tokens=128)\n        >>> tokenizer.decode(output[0], skip_special_tokens=True)\n        \"[|system|]You are a helpful assistant.\\n[|user|]Explain how wonderful you are\\n[|assistant|]Thank you for your kind words! I'm here to assist you with information, answer questions, and help you in any way I can. My goal is to provide accurate, helpful, and timely responses. Whether you need help with a specific task, want to learn something new, or just need someone to talk to, I'm here for you. How can I assist you today?\"\n        ```\n        \"\"\"\n\n        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n        output_hidden_states = (\n            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n        )\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        transformer_outputs = self.transformer(\n            input_ids,\n            attention_mask=attention_mask,\n            past_key_values=past_key_values,\n            position_ids=position_ids,\n            inputs_embeds=inputs_embeds,\n            use_cache=use_cache,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            cache_position=cache_position,\n        )\n        hidden_states = transformer_outputs[0]\n        lm_logits = self.lm_head(hidden_states)\n        lm_logits = lm_logits.float()\n        loss = None\n        if labels is not None:\n            lm_logits = lm_logits.to(torch.float32)\n\n            # Shift so that tokens < n predict n\n            shift_logits = lm_logits[..., :-1, :].contiguous()\n            shift_labels = labels[..., 1:].contiguous()\n            # Flatten the tokens\n            loss_fct = CrossEntropyLoss()\n            loss = loss_fct(shift_logits.view(-1, shift_logits.size(-1)), shift_labels.view(-1))\n\n            lm_logits = lm_logits.to(hidden_states.dtype)\n            loss = loss.to(hidden_states.dtype)\n\n        if not return_dict:\n            output = (lm_logits,) + transformer_outputs[1:]\n            return ((loss,) + output) if loss is not None else output\n\n        return CausalLMOutputWithPast(\n            loss=loss,\n            logits=lm_logits,\n            past_key_values=transformer_outputs.past_key_values,\n            hidden_states=transformer_outputs.hidden_states,\n            attentions=transformer_outputs.attentions,\n        )\n\n    def prepare_inputs_for_generation(\n        self,\n        input_ids,\n        past_key_values=None,\n        attention_mask=None,\n        inputs_embeds=None,\n        cache_position=None,\n        position_ids=None,\n        use_cache=True,\n        **kwargs,\n    ):\n        # If we have cache: let's slice `input_ids` through `cache_position`, to keep only the unprocessed tokens\n        # Exception 1: when passing input_embeds, input_ids may be missing entries\n        # Exception 2: some generation methods do special slicing of input_ids, so we don't need to do it here\n        if past_key_values is not None:\n            if inputs_embeds is not None:  # Exception 1\n                input_ids = input_ids[:, -cache_position.shape[0] :]\n            elif input_ids.shape[1] != cache_position.shape[0]:  # Default case (the \"else\", a no op, is Exception 2)\n                input_ids = input_ids[:, cache_position]\n\n        if attention_mask is not None and position_ids is None:\n            # create position_ids on the fly for batch generation\n            position_ids = attention_mask.long().cumsum(-1) - 1\n            position_ids.masked_fill_(attention_mask == 0, 1)\n            if past_key_values:\n                position_ids = position_ids[:, -input_ids.shape[1] :]\n\n                # This `clone` call is needed to avoid recapturing cuda graphs with `torch.compile`'s  `mode=\"reduce-overhead`, as otherwise the input `position_ids` would have various stride during the decoding. Here, simply using `.contiguous()` is not sufficient as in the batch size = 1 case, `position_ids` is already contiguous but with varying stride which retriggers a capture.\n                position_ids = position_ids.clone(memory_format=torch.contiguous_format)\n\n        # if `inputs_embeds` are passed, we only want to use them in the 1st generation step\n        if inputs_embeds is not None and cache_position[0] == 0:\n            model_inputs = {\"inputs_embeds\": inputs_embeds, \"input_ids\": None}\n        else:\n            model_inputs = {\"input_ids\": input_ids, \"inputs_embeds\": None}\n\n        if isinstance(past_key_values, StaticCache) and attention_mask.ndim == 2:\n            if inputs_embeds is not None:\n                batch_size, sequence_length, _ = inputs_embeds.shape\n                device = inputs_embeds.device\n            else:\n                batch_size, sequence_length = input_ids.shape\n                device = input_ids.device\n\n            dtype = self.lm_head.weight.dtype\n            min_dtype = torch.finfo(dtype).min\n\n            attention_mask = _prepare_4d_causal_attention_mask_with_cache_position(\n                attention_mask,\n                sequence_length=sequence_length,\n                target_length=past_key_values.get_max_length(),\n                dtype=dtype,\n                device=device,\n                min_dtype=min_dtype,\n                cache_position=cache_position,\n                batch_size=batch_size,\n            )\n\n        model_inputs.update(\n            {\n                \"position_ids\": position_ids,\n                \"cache_position\": cache_position,\n                \"past_key_values\": past_key_values,\n                \"use_cache\": use_cache,\n                \"attention_mask\": attention_mask,\n            }\n        )\n        return model_inputs\n\n\n@add_start_docstrings(\n    \"\"\"\n    The EXAONE Model transformer with a sequence classification head on top (linear layer).\n\n    [`ExaoneForSequenceClassification`] uses the last token in order to do the classification, as\n    other causal models (e.g. GPT-1) do.\n\n    Since it does classification on the last token, it requires to know the position of the last token. If a\n    `pad_token_id` is defined in the configuration, it finds the last token that is not a padding token in each\n    row. If no `pad_token_id` is defined, it simply takes the last value in each row of the batch. Since it cannot\n    guess the padding tokens when `inputs_embeds` are passed instead of `input_ids`, it does the same (take\n    the last value in each row of the batch).\n    \"\"\",\n    EXAONE_START_DOCSTRING,\n)\nclass ExaoneForSequenceClassification(ExaonePreTrainedModel):\n    def __init__(self, config):\n        super().__init__(config)\n        self.num_labels = config.num_labels\n        self.transformer = ExaoneModel(config)\n        self.score = nn.Linear(config.hidden_size, self.num_labels, bias=False)\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    @add_start_docstrings_to_model_forward(EXAONE_INPUTS_DOCSTRING)\n    @add_code_sample_docstrings(\n        checkpoint=_CHECKPOINT_FOR_DOC,\n        output_type=SequenceClassifierOutputWithPast,\n        config_class=_CONFIG_FOR_DOC,\n    )\n    def forward(\n        self,\n        input_ids: Optional[torch.Tensor] = None,\n        attention_mask: Optional[torch.Tensor] = None,\n        position_ids: Optional[torch.Tensor] = None,\n        past_key_values: Optional[Cache] = None,\n        inputs_embeds: Optional[torch.Tensor] = None,\n        labels: Optional[torch.Tensor] = None,\n        use_cache: Optional[bool] = None,\n        output_attentions: Optional[bool] = None,\n        output_hidden_states: Optional[bool] = None,\n        return_dict: Optional[bool] = None,\n    ) -> Union[Tuple[torch.Tensor], SequenceClassifierOutputWithPast]:\n        r\"\"\"\n        labels (`torch.LongTensor` of shape `(batch_size,)`, *optional*):\n            Labels for computing the sequence classification/regression loss. Indices should be in `[0, ...,\n            config.num_labels - 1]`. If `config.num_labels == 1` a regression loss is computed (Mean-Square loss), If\n            `config.num_labels > 1` a classification loss is computed (Cross-Entropy).\n        \"\"\"\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n\n        transformer_outputs = self.transformer(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            past_key_values=past_key_values,\n            inputs_embeds=inputs_embeds,\n            use_cache=use_cache,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n        )\n        hidden_states = transformer_outputs[0]\n        logits = self.score(hidden_states)\n\n        if input_ids is not None:\n            batch_size, sequence_length = input_ids.shape[:2]\n        else:\n            batch_size, sequence_length = inputs_embeds.shape[:2]\n\n        if self.config.pad_token_id is None and batch_size != 1:\n            raise ValueError(\"Cannot handle batch sizes > 1 if no padding token is defined.\")\n        if self.config.pad_token_id is None:\n            sequence_lengths = -1\n        else:\n            if input_ids is not None:\n                # if no pad token found, use modulo instead of reverse indexing for ONNX compatibility\n                sequence_lengths = torch.ne(input_ids, self.config.pad_token_id).sum(-1) - 1\n                sequence_lengths = sequence_lengths % input_ids.shape[-1]\n                sequence_lengths = sequence_lengths.to(logits.device)\n            else:\n                sequence_lengths = -1\n                logger.warning(\n                    f\"{self.__class__.__name__} will not detect padding tokens in `inputs_embeds`. Results may be \"\n                    \"unexpected if using padding tokens in conjunction with `inputs_embeds.`\"\n                )\n\n        pooled_logits = logits[torch.arange(batch_size, device=logits.device), sequence_lengths]\n\n        loss = None\n        if labels is not None:\n            labels = labels.to(logits.device)\n            if self.config.problem_type is None:\n                if self.num_labels == 1:\n                    self.config.problem_type = \"regression\"\n                elif self.num_labels > 1 and (labels.dtype == torch.long or labels.dtype == torch.int):\n                    self.config.problem_type = \"single_label_classification\"\n                else:\n                    self.config.problem_type = \"multi_label_classification\"\n\n            if self.config.problem_type == \"regression\":\n                loss_fct = MSELoss()\n                if self.num_labels == 1:\n                    loss = loss_fct(pooled_logits.squeeze(), labels.squeeze())\n                else:\n                    loss = loss_fct(pooled_logits, labels)\n            elif self.config.problem_type == \"single_label_classification\":\n                loss_fct = CrossEntropyLoss()\n                loss = loss_fct(pooled_logits.view(-1, self.num_labels), labels.view(-1))\n            elif self.config.problem_type == \"multi_label_classification\":\n                loss_fct = BCEWithLogitsLoss()\n                loss = loss_fct(pooled_logits, labels)\n        if not return_dict:\n            output = (pooled_logits,) + transformer_outputs[1:]\n            return ((loss,) + output) if loss is not None else output\n\n        return SequenceClassifierOutputWithPast(\n            loss=loss,\n            logits=pooled_logits,\n            past_key_values=transformer_outputs.past_key_values,\n            hidden_states=transformer_outputs.hidden_states,\n            attentions=transformer_outputs.attentions,\n        )\n\n\n@add_start_docstrings(\n    \"\"\"\n    The EXAONE Model transformer with a span classification head on top for extractive question-answering tasks like\n    SQuAD (a linear layers on top of the hidden-states output to compute `span start logits` and `span end logits`).\n    \"\"\",\n    EXAONE_START_DOCSTRING,\n)\nclass ExaoneForQuestionAnswering(ExaonePreTrainedModel):\n    def __init__(self, config):\n        super().__init__(config)\n        self.num_labels = config.num_labels\n        self.transformer = ExaoneModel(config)\n        self.qa_outputs = nn.Linear(config.hidden_size, config.num_labels)\n\n        # Model parallel\n        self.model_parallel = False\n        self.device_map = None\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def forward(\n        self,\n        input_ids: Optional[torch.LongTensor] = None,\n        attention_mask: Optional[torch.FloatTensor] = None,\n        position_ids: Optional[torch.LongTensor] = None,\n        past_key_values: Optional[Cache] = None,\n        inputs_embeds: Optional[torch.FloatTensor] = None,\n        start_positions: Optional[torch.LongTensor] = None,\n        end_positions: Optional[torch.LongTensor] = None,\n        output_attentions: Optional[bool] = None,\n        output_hidden_states: Optional[bool] = None,\n        return_dict: Optional[bool] = None,\n    ) -> Union[Tuple[torch.Tensor], QuestionAnsweringModelOutput]:\n        r\"\"\"\n        start_positions (`torch.LongTensor` of shape `(batch_size,)`, *optional*):\n            Labels for position (index) of the start of the labelled span for computing the token classification loss.\n            Positions are clamped to the length of the sequence (`sequence_length`). Position outside of the\n            sequence are not taken into account for computing the loss.\n        end_positions (`torch.LongTensor` of shape `(batch_size,)`, *optional*):\n            Labels for position (index) of the end of the labelled span for computing the token classification loss.\n            Positions are clamped to the length of the sequence (`sequence_length`). Position outside of the\n            sequence are not taken into account for computing the loss.\n        \"\"\"\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n\n        outputs = self.transformer(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            past_key_values=past_key_values,\n            inputs_embeds=inputs_embeds,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n        )\n\n        sequence_output = outputs[0]\n\n        logits = self.qa_outputs(sequence_output)\n        start_logits, end_logits = logits.split(1, dim=-1)\n        start_logits = start_logits.squeeze(-1).contiguous()\n        end_logits = end_logits.squeeze(-1).contiguous()\n\n        total_loss = None\n        if start_positions is not None and end_positions is not None:\n            # If we are on multi-GPU, split add a dimension\n            if len(start_positions.size()) > 1:\n                start_positions = start_positions.squeeze(-1).to(start_logits.device)\n            if len(end_positions.size()) > 1:\n                end_positions = end_positions.squeeze(-1).to(end_logits.device)\n            # sometimes the start/end positions are outside our model inputs, we ignore these terms\n            ignored_index = start_logits.size(1)\n            start_positions = start_positions.clamp(0, ignored_index)\n            end_positions = end_positions.clamp(0, ignored_index)\n\n            loss_fct = CrossEntropyLoss(ignore_index=ignored_index)\n            start_loss = loss_fct(start_logits, start_positions)\n            end_loss = loss_fct(end_logits, end_positions)\n            total_loss = (start_loss + end_loss) / 2\n\n        if not return_dict:\n            output = (start_logits, end_logits) + outputs[2:]\n            return ((total_loss,) + output) if total_loss is not None else output\n\n        return QuestionAnsweringModelOutput(\n            loss=total_loss,\n            start_logits=start_logits,\n            end_logits=end_logits,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n"
    }
}