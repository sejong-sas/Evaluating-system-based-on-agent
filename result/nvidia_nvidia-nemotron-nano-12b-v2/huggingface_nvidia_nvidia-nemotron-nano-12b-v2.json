{
    "model_id": "nvidia/nvidia-nemotron-nano-12b-v2",
    "files": [
        ".gitattributes",
        "README.md",
        "acc-vs-budget.png",
        "bias.md",
        "config.json",
        "configuration_nemotron_h.py",
        "explainability.md",
        "generation_config.json",
        "model-00001-of-00006.safetensors",
        "model-00002-of-00006.safetensors",
        "model-00003-of-00006.safetensors",
        "model-00004-of-00006.safetensors",
        "model-00005-of-00006.safetensors",
        "model-00006-of-00006.safetensors",
        "model.safetensors.index.json",
        "modeling_nemotron_h.py",
        "nemotron_toolcall_parser_no_streaming.py",
        "privacy.md",
        "safety.md",
        "special_tokens_map.json",
        "tokenizer.json",
        "tokenizer_config.json"
    ],
    "readme": "---\nlicense: other\nlicense_name: nvidia-open-model-license\nlicense_link: >-\n  https://www.nvidia.com/en-us/agreements/enterprise-software/nvidia-open-model-license/\npipeline_tag: text-generation\ndatasets:\n- nvidia/Nemotron-Post-Training-Dataset-v1\n- nvidia/Nemotron-Post-Training-Dataset-v2\n- nvidia/Nemotron-Pretraining-Dataset-sample\n- nvidia/Nemotron-CC-v2\n- nvidia/Nemotron-CC-Math-v1\n- nvidia/Nemotron-Pretraining-SFT-v1\nlanguage:\n- en\n- es\n- fr\n- de\n- it\n- ja\nlibrary_name: transformers\ntags:\n- nvidia\n- pytorch\ntrack_downloads: true\nbase_model:\n- nvidia/NVIDIA-Nemotron-Nano-12B-v2-Base\n---\n# NVIDIA-Nemotron-Nano-12B-v2\n\n**Model Developer:** NVIDIA Corporation\n\n**Model Dates:**\n\nJune 2025 \\- August 2025\n\n**Data Freshness:**\n\nSeptember 2024\n\nThe pretraining data has a cutoff date of September 2024.\n\n## Model Overview\n\nNVIDIA-Nemotron-Nano-12B-v2 is a large language model (LLM) trained from scratch by NVIDIA, and designed as a unified model for both reasoning and non-reasoning tasks. It responds to user queries and tasks by first generating a reasoning trace and then concluding with a final response. The model's reasoning capabilities can be controlled via a system prompt. If the user prefers the model to provide its final answer without intermediate reasoning traces, it can be configured to do so, albeit with a slight decrease in accuracy for harder prompts that require reasoning. Conversely, allowing the model to generate reasoning traces first generally results in higher-quality final solutions to queries and tasks. The model was fine-tuned from [NVIDIA-Nemotron-Nano-12B-v2-Base](https://huggingface.co/nvidia/NVIDIA-Nemotron-Nano-12B-v2-Base) was further compressed into [NVIDIA-Nemotron-Nano-9B-v2](https://huggingface.co/nvidia/NVIDIA-Nemotron-Nano-9B-v2).\n\nThe model uses a hybrid architecture consisting primarily of Mamba-2 and MLP layers combined with just six Attention layers. For the architecture, please refer to the [Nemotron-H tech report](https://arxiv.org/abs/2504.03624).\nThe model was trained using [Megatron-LM](https://github.com/NVIDIA/Megatron-LM) and [NeMo-RL](https://github.com/NVIDIA-NeMo/RL).\n\nThe supported languages include: English, German, Spanish, French, Italian, and Japanese. Improved using Qwen.\n\nThis model is ready for commercial use.\n\n\n## License/Terms of Use\n\nGOVERNING TERMS: Use of this model is governed by the [NVIDIA Open Model License Agreement](https://www.nvidia.com/en-us/agreements/enterprise-software/nvidia-open-model-license/).\n\n\n## Evaluation Results\n\n### Benchmark Results (Reasoning On)\n\nWe evaluated our model in **Reasoning-On** mode across all benchmarks, except RULER, which is evaluated in **Reasoning-Off** mode.\n\n\n| Benchmark | NVIDIA-Nemotron-Nano-12B-v2 |\n| :---- | ----- |\n| AIME25 | 76.25% |\n| MATH500 | 97.75% |\n| GPQA | 64.48% |\n| LCB | 70.79% |\n| BFCL v3 | 66.98% |\n| IFEVAL-Prompt | 84.70% |\n| IFEVAL-Instruction | 89.81% |\n\n\nAll evaluations were done using [NeMo-Skills](https://github.com/NVIDIA/NeMo-Skills).\nWe published a [tutorial](https://nvidia.github.io/NeMo-Skills/tutorials/2025/08/22/reproducing-nvidia-nemotron-nano-9b-v2-evals/) with all details necessary to reproduce our evaluation results.\n\n## Reasoning Budget Control\n\nThis model supports runtime “thinking” budget control. During inference, the user can specify how many tokens the model is allowed to \"think\".\n\n![](./acc-vs-budget.png)\n\n## Model Architecture\n\n- Architecture Type: Mamba2-Transformer Hybrid\n- Network Architecture: Nemotron-Hybrid\n\n### Deployment Geography: Global\n\n### Use Case\n\nNVIDIA-Nemotron-Nano-12B-v2 is a general purpose reasoning and chat model intended to be used in English and coding languages. Other non-English languages (German, French, Italian, Spanish and Japanese) are also supported. Developers designing AI Agent systems, chatbots, RAG systems, and other AI-powered applications. Also suitable for typical instruction-following tasks.\n\n### Release Date: 08/29/2025\n\n- Huggingface 08/29/2025 via https://huggingface.co/nvidia/NVIDIA-Nemotron-Nano-12B-v2\n\n## References\n\n- [NVIDIA Nemotron Nano 2: An Accurate and Efficient Hybrid Mamba-Transformer Reasoning Model](https://arxiv.org/abs/2508.14444)\n\n\n## Input\n\n- Input Type(s): Text\n- Input Format(s): String\n- Input Parameters: One-Dimensional (1D): Sequences\n- Other Properties Related to Input: Context length up to 128K. Supported languages include German, Spanish, French, Italian, Korean, Portuguese, Russian, Japanese, Chinese and English.\n\n## Output\n\n- Output Type(s): Text\n- Output Format: String\n- Output Parameters: One-Dimensional (1D): Sequences up to 128K\n\nOur models are designed and optimized to run on NVIDIA GPU-accelerated systems. By leveraging NVIDIA’s hardware (e.g. GPU cores) and software frameworks (e.g., CUDA libraries), the model achieves faster training and inference times compared to CPU-only solutions.\n\n## Software Integration\n\n- Runtime Engine(s): NeMo 25.07.nemotron-nano-v2\n- Supported Hardware Microarchitecture Compatibility: NVIDIA A10G, NVIDIA H100-80GB, NVIDIA A100\n- Operating System(s): Linux\n\n### **Use it with Transformers**\n\nThe snippet below shows how to use this model with Huggingface Transformers (tested on version 4.48.3).\n\n```\nimport torch\nfrom transformers import AutoTokenizer, AutoModelForCausalLM\n\n# Load tokenizer and model\ntokenizer = AutoTokenizer.from_pretrained(\"nvidia/NVIDIA-Nemotron-Nano-12B-v2\")\nmodel = AutoModelForCausalLM.from_pretrained(\n    \"nvidia/NVIDIA-Nemotron-Nano-12B-v2\",\n    torch_dtype=torch.bfloat16,\n    trust_remote_code=True,\n    device_map=\"auto\"\n)\n```\n\nCase 1: `/think` or no reasoning signal is provided in the system prompt, reasoning will be set to `True`\n\n```\nmessages = [\n    {\"role\": \"system\", \"content\": \"/think\"},\n    {\"role\": \"user\", \"content\": \"Write a haiku about GPUs\"},\n]\n```\n\nCase 2: `/no_think` is provided, reasoning will be set to `False`\n\n```\nmessages = [\n    {\"role\": \"system\", \"content\": \"/no_think\"},\n    {\"role\": \"user\", \"content\": \"Write a haiku about GPUs\"},\n]\n```\n\nNote: `/think` or `/no_think` keywords can also be provided in “user” messages for turn-level reasoning control.\n\nThe rest of the inference snippet remains the same\n\n```\ntokenized_chat = tokenizer.apply_chat_template(\n    messages,\n    tokenize=True,\n    add_generation_prompt=True,\n    return_tensors=\"pt\"\n).to(model.device)\n\noutputs = model.generate(\n    tokenized_chat,\n    max_new_tokens=32,\n    eos_token_id=tokenizer.eos_token_id\n)\nprint(tokenizer.decode(outputs[0]))\n```\n\nWe recommend setting `temperature` to `0.6`, `top_p` to `0.95` for reasoning True and greedy search for reasoning False, and increase `max_new_tokens` to `1024` or higher for reasoning True. \n\n### **Use it with TRT-LLM**\n\nThe snippet below shows how to use this model with TRT-LLM. We tested this on the following [commit](https://github.com/NVIDIA/TensorRT-LLM/tree/46c5a564446673cdd0f56bcda938d53025b6d04e) and followed these [instructions](https://github.com/NVIDIA/TensorRT-LLM/blob/46c5a564446673cdd0f56bcda938d53025b6d04e/docs/source/installation/build-from-source-linux.md#option-2-build-tensorrt-llm-step-by-step) to build and install TRT-LLM in a docker container.\n\n```\nfrom tensorrt_llm import SamplingParams\nfrom tensorrt_llm._torch import LLM\nfrom tensorrt_llm._torch.pyexecutor.config import PyTorchConfig\nfrom tensorrt_llm.llmapi import KvCacheConfig\nfrom transformers import AutoTokenizer\npytorch_config = PyTorchConfig(\n    disable_overlap_scheduler=True, enable_trtllm_decoder=True\n)\nkv_cache_config = KvCacheConfig(\n    enable_block_reuse=False,\n)\n```\n\n```\nmodel_id = \"nvidia/NVIDIA-Nemotron-Nano-12B-v2\"\ntokenizer = AutoTokenizer.from_pretrained(model_id)\n\nllm = LLM(\n    model=model_id,\n    max_seq_len=32678,\n    max_batch_size=4,\n    pytorch_backend_config=pytorch_config,\n    kv_cache_config=kv_cache_config,\n    tensor_parallel_size=8,\n)\nmessages = [\n    {\"role\": \"system\",  \"content\": \"/think\"},\n    {\"role\": \"user\", \"content\": \"Write a haiku about GPUs\"},\n]\nprompt = tokenizer.apply_chat_template(messages, tokenize=False, add_generation_prompt=True)\nsampling_params = SamplingParams(\n    max_tokens=512,\n    temperature=0.6,\n    top_p=0.95,\n    add_special_tokens=False,\n)\noutputs = llm.generate([prompt], sampling_params)\nprint(outputs[0].outputs[0].text)\n```\n\n### **Use it with vLLM**\n\nThe snippet below shows how to use this model with vLLM. Use the latest version of vLLM and follow these instructions to build and install vLLM.\n\n```shell\npip install -U \"vllm>=0.10.1\"\n```\n\nNow you can run run the server with:\n\n```shell\nvllm serve nvidia/NVIDIA-Nemotron-Nano-12B-v2 \\\n    --trust-remote-code \\\n    --max-num-seqs 64 \\\n    --mamba_ssm_cache_dtype float32\n```\n\nNote:\n- Remember to add \\`--mamba\\_ssm\\_cache\\_dtype float32\\` for accurate quality. Without this option, the model’s accuracy may degrade.\n- If you encounter a CUDA OOM issue, try `--max-num-seqs 64` and consider lower the value further if the error persists.\n\n\n\nAlternativly, you can use Docker to launch a vLLM server.\n\n```\nexport TP_SIZE=1  # Adjust this value based on the number of GPUs you want to use\ndocker run --runtime nvidia --gpus all \\\n           -v ~/.cache/huggingface:/root/.cache/huggingface \\\n           --env \"HUGGING_FACE_HUB_TOKEN=$HF_TOKEN\" \\\n           -p 8000:8000 \\\n           --ipc=host \\\n           vllm/vllm-openai:v0.10.1 \\\n           --model nvidia/NVIDIA-Nemotron-Nano-12B-v2 \\\n           --tensor-parallel-size ${TP_SIZE} \\\n           --max-num-seqs 64 \\\n           --max-model-len 131072 \\\n           --trust-remote-code \\\n           --mamba_ssm_cache_dtype float32\n```\n\n#### Using Budget Control with a vLLM Server\n\nThe thinking budget allows developers to keep accuracy high and meet response‑time targets \\- which is especially crucial for customer support, autonomous agent steps, and edge devices where every millisecond counts.\n\nWith budget control, you can set a limit for internal reasoning:\n\n* `max_thinking_tokens`: This is a threshold that will attempt to end the reasoning trace at the next newline encountered in the reasoning trace. If no newline is encountered within 500 tokens, it will abruptly end the reasoning trace at \\`max\\_thinking\\_tokens \\+ 500\\`.\n\nStart a vLLM server:\n\n```shell\nvllm serve nvidia/NVIDIA-Nemotron-Nano-12B-v2 \\\n    --trust-remote-code \\\n    --mamba_ssm_cache_dtype float32\n```\n\nClient for supporting budget control:\n\n```py\nfrom typing import Any, Dict, List\n\nimport openai\nfrom transformers import AutoTokenizer\n\n\nclass ThinkingBudgetClient:\n   def __init__(self, base_url: str, api_key: str, tokenizer_name_or_path: str):\n       self.base_url = base_url\n       self.api_key = api_key\n       self.tokenizer = AutoTokenizer.from_pretrained(tokenizer_name_or_path)\n       self.client = openai.OpenAI(base_url=self.base_url, api_key=self.api_key)\n\n\n   def chat_completion(\n       self,\n       model: str,\n       messages: List[Dict[str, Any]],\n       max_thinking_budget: int = 512,\n       max_tokens: int = 1024,\n       **kwargs,\n   ) -> Dict[str, Any]:\n       assert (\n           max_tokens > max_thinking_budget\n       ), f\"thinking budget must be smaller than maximum new tokens. Given {max_tokens=} and {max_thinking_budget=}\"\n\n\n       # 1. first call chat completion to get reasoning content\n       response = self.client.chat.completions.create(\n           model=model, messages=messages, max_tokens=max_thinking_budget, **kwargs\n       )\n       content = response.choices[0].message.content\n\n\n       reasoning_content = content\n       if not \"</think>\" in reasoning_content:\n           # reasoning content is too long, closed with a period (.)\n           reasoning_content = f\"{reasoning_content}.\\n</think>\\n\\n\"\n       reasoning_tokens_len = len(\n           self.tokenizer.encode(reasoning_content, add_special_tokens=False)\n       )\n       remaining_tokens = max_tokens - reasoning_tokens_len\n       assert (\n           remaining_tokens > 0\n       ), f\"remaining tokens must be positive. Given {remaining_tokens=}. Increase the max_tokens or lower the max_thinking_budget.\"\n\n\n       # 2. append reasoning content to messages and call completion\n       messages.append({\"role\": \"assistant\", \"content\": reasoning_content})\n       prompt = self.tokenizer.apply_chat_template(\n           messages,\n           tokenize=False,\n           continue_final_message=True,\n       )\n       response = self.client.completions.create(\n           model=model, prompt=prompt, max_tokens=remaining_tokens, **kwargs\n       )\n\n\n       response_data = {\n           \"reasoning_content\": reasoning_content.strip().strip(\"</think>\").strip(),\n           \"content\": response.choices[0].text,\n           \"finish_reason\": response.choices[0].finish_reason,\n       }\n       return response_data\n```\n\nCalling the server with a budget (Restricted to 32 tokens here as an example)\n\n```py\ntokenizer_name_or_path = \"nvidia/NVIDIA-Nemotron-Nano-12B-v2\"\nclient = ThinkingBudgetClient(\n   base_url=\"http://localhost:8000/v1\",  # Nano 12B v2 deployed in thinking mode\n   api_key=\"EMPTY\",\n   tokenizer_name_or_path=tokenizer_name_or_path,\n)\n\n\nresult = client.chat_completion(\n   model=\"nvidia/NVIDIA-Nemotron-Nano-12B-v2\",\n   messages=[\n       {\"role\": \"system\", \"content\": \"You are a helpful assistant. /think\"},\n       {\"role\": \"user\", \"content\": \"What is 2+2?\"},\n   ],\n   max_thinking_budget=32,\n   max_tokens=512,\n   temperature=0.6,\n   top_p=0.95,\n)\nprint(result)\n```\n\nYou should see output similar to the following:\n\n```\n{'reasoning_content': \"Okay, the user asked, What is 2+2? Let me think. Well, 2 plus 2 equals 4. That's a basic.\", 'content': '2 + 2 equals **4**.\\n', 'finish_reason': 'stop'}\n```\n\n#### Using Tool-Calling with a vLLM Server\n\nStart a vLLM server with native tool-calling:\n\n```shell\ngit clone https://huggingface.co/nvidia/NVIDIA-Nemotron-Nano-12B-v2\n\nvllm serve nvidia/NVIDIA-Nemotron-Nano-12B-v2 \\\n  --trust-remote-code \\\n  --mamba_ssm_cache_dtype float32 \\\n  --enable-auto-tool-choice \\\n  --tool-parser-plugin \"NVIDIA-Nemotron-Nano-12B-v2/nemotron_toolcall_parser_no_streaming.py\" \\\n  --tool-call-parser \"nemotron_json\"\n```\n\n## After launching a vLLM server, you can call the server with tool-call support using a Python script like below:\n\n```py\nfrom openai import OpenAI\n\nclient = OpenAI(\n    base_url=\"http://0.0.0.0:5000/v1\",\n    api_key=\"dummy\",\n)\n\ncompletion = client.chat.completions.create(\n    model=\"nvidia/NVIDIA-Nemotron-Nano-12B-v2\",\n    messages=[\n        {\"role\": \"system\", \"content\": \"\"},\n        {\"role\": \"user\", \"content\": \"My bill is $100. What will be the amount for 18% tip?\"}\n    ],\n    tools=[\n        {\n            \"type\": \"function\",\n            \"function\": {\n                \"name\": \"calculate_tip\",\n                \"parameters\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"bill_total\": {\n                            \"type\": \"integer\",\n                            \"description\": \"The total amount of the bill\"\n                        },\n                        \"tip_percentage\": {\n                            \"type\": \"integer\",\n                            \"description\": \"The percentage of tip to be applied\"\n                        }\n                    },\n                    \"required\": [\"bill_total\", \"tip_percentage\"]\n                }\n            }\n        },\n        {\n            \"type\": \"function\",\n            \"function\": {\n                \"name\": \"convert_currency\",\n                \"parameters\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"amount\": {\n                            \"type\": \"integer\",\n                            \"description\": \"The amount to be converted\"\n                        },\n                        \"from_currency\": {\n                            \"type\": \"string\",\n                            \"description\": \"The currency code to convert from\"\n                        },\n                        \"to_currency\": {\n                            \"type\": \"string\",\n                            \"description\": \"The currency code to convert to\"\n                        }\n                    },\n                    \"required\": [\"from_currency\", \"amount\", \"to_currency\"]\n                }\n            }\n        }\n    ],\n    temperature=0.6,\n    top_p=0.95,\n    max_tokens=32768,\n    stream=False\n)\n\nprint(completion.choices[0].message.content)\nprint(completion.choices[0].message.tool_calls)\n```\n\nYou should see output similar to the following:\n\n```\n<think>\nOkay, let's see. The user has a bill of $100 and wants to know the amount for an 18% tip. Hmm, I need to calculate the tip based on the bill total and the percentage. The tools provided include calculate_tip, which takes bill_total and tip_percentage as parameters. So the bill_total here is 100, and the tip_percentage is 18. I should call the calculate_tip function with these values. Wait, do I need to check if the parameters are integers? The bill is $100, which is an integer, and 18% is also an integer. So that fits the function's requirements. I don't need to convert any currency here because the user is asking about a tip in the same currency. So the correct tool to use is calculate_tip with those parameters.\n</think>\n\n[ChatCompletionMessageToolCall(id='chatcmpl-tool-e341c6954d2c48c2a0e9071c7bdefd8b', function=Function(arguments='{\"bill_total\": 100, \"tip_percentage\": 18}', name='calculate_tip'), type='function')]\n```\n\n## Model Version\n\n- v1.0\n\n## Prompt Format\n\nWe follow the jinja chat template provided below. This template conditionally adds `<think>\\n` to the start of the Assistant response if `/think` is found in either the system prompt or any user message. If no reasoning signal is added, the model defaults to reasoning \"on\" mode. The chat template adds `<think></think>` to the start of the Assistant response if `/no_think` is found in the system prompt. Thus enforcing reasoning on/off behavior.\n\n```\n{%- set ns = namespace(enable_thinking = true) %}\n\n{%- for message in messages -%}\n    {%- set content = message['content'] -%}\n    {%- if message['role'] == 'user' or message['role'] == 'system' -%}\n        {%- if '/think' in content -%}\n            {%- set ns.enable_thinking = true -%}\n        {%- elif '/no_think' in content -%}\n            {%- set ns.enable_thinking = false -%}\n        {%- endif -%}\n    {%- endif -%}\n{%- endfor -%}\n\n{%- if messages[0]['role'] != 'system' -%}\n    {%- set ns.non_tool_system_content = '' -%}\n    {{- '<SPECIAL_10>System\\n' -}}\n{%- else -%}\n    {%- set ns.non_tool_system_content = messages[0]['content']\n        .replace('/think', '')\n        .replace('/no_think', '')\n        .strip()\n    -%}\n    {{- '<SPECIAL_10>System\\n' + ns.non_tool_system_content }}\n{%- endif -%}\n\n{%- if tools -%}\n    {%- if ns.non_tool_system_content is defined and ns.non_tool_system_content != '' -%}\n        {{- '\\n\\n' -}}\n    {%- endif -%}\n\n    {{- 'You can use the following tools to assist the user if required:' -}}\n    {{- '\\n<AVAILABLE_TOOLS>[' -}}\n    {%- for tool in tools -%}\n        {{- (tool.function if tool.function is defined else tool) | tojson -}}\n        {{- ', ' if not loop.last else '' -}}\n    {%- endfor -%}\n    {{- ']</AVAILABLE_TOOLS>\\n\\n' -}}\n\n    {{- 'If you decide to call any tool(s), use the following format:\\n' -}}\n    {{- '<TOOLCALL>[{{\"name\": \"tool_name1\", \"arguments\": \"tool_args1\"}}, ' -}}\n    {{- '{{\"name\": \"tool_name2\", \"arguments\": \"tool_args2\"}}]</TOOLCALL>\\n\\n' -}}\n\n    {{- 'The user will execute tool-calls and return responses from tool(s) in this format:\\n' -}}\n    {{- '<TOOL_RESPONSE>[{{\"tool_response1\"}}, {{\"tool_response2\"}}]</TOOL_RESPONSE>\\n\\n' -}}\n\n    {{- 'Based on the tool responses, you can call additional tools if needed, correct tool calls if any errors are found, or just respond to the user.' -}}\n{%- endif -%}\n\n{{- '\\n' -}}\n\n{%- set messages = messages[1:] if messages[0]['role'] == 'system' else messages -%}\n\n{%- if messages[-1]['role'] == 'assistant' -%}\n    {%- set ns.last_turn_assistant_content = messages[-1]['content'].strip() -%}\n    {%- set messages = messages[:-1] -%}\n{%- endif -%}\n\n{%- for message in messages -%}\n    {%- set content = message['content'] -%}\n\n    {%- if message['role'] == 'user' -%}\n        {{- '<SPECIAL_11>User\\n' + content.replace('/think', '').replace('/no_think', '').strip() + '\\n' }}\n\n    {%- elif message['role'] == 'tool' -%}\n        {%- if loop.first or (messages[loop.index0 - 1].role != 'tool') -%}\n            {{- '<SPECIAL_11>User\\n' + '<TOOL_RESPONSE>[' }}\n        {%- endif -%}\n        {{- message['content'] -}}\n        {{- ', ' if not loop.last and (messages[loop.index0 + 1].role == 'tool') else '' -}}\n        {%- if loop.last or (messages[loop.index0 + 1].role != 'tool') -%}\n            {{- ']</TOOL_RESPONSE>\\n' -}}\n        {%- endif -%}\n\n    {%- elif message['role'] == 'assistant' -%}\n        {%- if '</think>' in content -%}\n            {%- set content = content.split('</think>')[1].strip() %}\n        {%- endif -%}\n\n        {{- '<SPECIAL_11>Assistant\\n' + content.strip() }}\n\n        {%- if message.tool_calls -%}\n            {%- if content.strip() != '' -%}\n                {{- '\\n\\n' -}}\n            {%- endif -%}\n            {{- '<TOOLCALL>[' -}}\n            {%- for call in message.tool_calls -%}\n                {%- set fn = call.function if call.function is defined else call -%}\n                {{- '{\"name\": \"' + fn.name + '\", \"arguments\": ' -}}\n                {%- if fn.arguments is string -%}\n                    {{- fn.arguments -}}\n                {%- else -%}\n                    {{- fn.arguments | tojson -}}\n                {%- endif -%}\n                {{- '}' + (', ' if not loop.last else '') -}}\n            {%- endfor -%}\n            {{- ']</TOOLCALL>' -}}\n        {%- endif -%}\n\n        {{- '\\n<SPECIAL_12>\\n' -}}\n    {%- endif -%}\n{%- endfor -%}\n\n{%- if add_generation_prompt -%}\n    {{- '<SPECIAL_11>Assistant\\n' -}}\n    {%- if ns.enable_thinking is defined and ns.enable_thinking is false -%}\n        {{- '<think></think>' -}}\n    {%- else -%}\n        {{- '<think>\\n' -}}\n    {%- endif -%}\n    {%- if ns.last_turn_assistant_content is defined and ns.last_turn_assistant_content != '' -%}\n        {{- ns.last_turn_assistant_content -}}\n    {%- endif -%}\n\n{%- else -%}\n    {%- if ns.last_turn_assistant_content is defined and ns.last_turn_assistant_content != '' -%}\n        {{- '<SPECIAL_11>Assistant\\n' -}}\n        {%- if ns.enable_thinking is defined and ns.enable_thinking is false -%}\n            {{- '<think></think>' -}}\n        {%- else -%}\n            {{- '<think>\\n' -}}\n        {%- endif -%}\n        {{- ns.last_turn_assistant_content -}}\n\n        {%- if continue_final_message is defined -%}\n            {%- if continue_final_message is false -%}\n                {{- '\\n<SPECIAL_12>\\n' -}}\n            {%- endif -%}\n        {%- else -%}\n            {{- '\\n<SPECIAL_12>\\n' -}}\n        {%- endif -%}\n    {%- endif -%}\n{%- endif -%}\n```\n\n## \n\n## Training, Testing, and Evaluation Datasets\n\n### Training datasets\n\n* Data Modality: Text  \n* Text Training Data Size: More than 10 Trillion Tokens  \n* Train/Test/Valid Split: We used 100% of the corpus for pre-training and relied on external benchmarks for testing.  \n* Data Collection Method by dataset: Hybrid: Automated, Human, Synthetic  \n* Labeling Method by dataset: Hybrid: Automated, Human, Synthetic\n\n\n**Properties:** The post-training corpus for NVIDIA-Nemotron-Nano-12B-v2 consists of English and multilingual text (German, Spanish, French, Italian, Korean, Portuguese, Russian, Japanese, Chinese and English). Our sources cover a variety of document types such as: webpages, dialogue, articles, and other written materials. The corpus spans domains including code, legal, math, science, finance, and more. We also include a small portion of question-answering, and alignment style data to improve model accuracies. For several of the domains listed above we used synthetic data, specifically reasoning traces, from DeepSeek R1/R1-0528, Qwen3-235B-A22B, Nemotron 4 340B, Qwen2.5-32B-Instruct-AWQ, Qwen2.5-14B-Instruct, Qwen 2.5 72B.\n\nThe pre-training corpus for NVIDIA-Nemotron-Nano-12B-v2 consists of high-quality curated and synthetically-generated data. It is trained in the English language, as well as 15 multilingual languages and 43 programming languages. Our sources cover a variety of document types such as: webpages, dialogue, articles, and other written materials. The corpus spans domains including legal, math, science, finance, and more. We also include a small portion of question-answering, and alignment style data to improve model accuracy. The model was pre-trained for approximately twenty trillion tokens.\n\nAlongside the model, we release our [final pretraining data](https://huggingface.co/collections/nvidia/nemotron-pre-training-dataset-689d9de36f84279d83786b35), as outlined in this section. For ease of analysis, there is a sample set that is ungated. For all remaining code, math and multilingual data, gating and approval is required, and the dataset is permissively licensed for model training purposes.\n\nMore details on the datasets and synthetic data generation methods can be found in the technical report [NVIDIA Nemotron Nano 2: An Accurate and Efficient Hybrid Mamba-Transformer Reasoning Model](https://research.nvidia.com/labs/adlr/files/NVIDIA-Nemotron-Nano-2-Technical-Report.pdf) .\n\n\n## Public Datasets\n\n| Dataset | Collection Period |\n| :---- | :---- |\n| [Problems in Elementary Mathematics for Home Study](https://archive.org/details/AntonovVygodskyNikitinSankinProblemsInElementaryMathematicsForHomeStudyMir1982) | 4/23/2025 |\n| [GSM8K](https://github.com/openai/grade-school-math) | 4/23/2025 |\n| [PRM800K](https://github.com/openai/prm800k) | 4/23/2025 |\n| [CC-NEWS](https://commoncrawl.org/blog/news-dataset-available) | 4/23/2025 |\n| [Common Crawl](https://commoncrawl.org/) | 4/23/2025 |\n| [Wikimedia](https://dumps.wikimedia.org/) | 4/23/2025 |\n| [Bespoke-Stratos-17k](https://huggingface.co/datasets/bespokelabs/Bespoke-Stratos-17k) | 4/23/2025 |\n| [tigerbot-kaggle-leetcodesolutions-en-2k](https://huggingface.co/datasets/TigerResearch/tigerbot-kaggle-leetcodesolutions-en-2k) | 4/23/2025 |\n| [glaive-function-calling-v2](https://huggingface.co/datasets/glaiveai/glaive-function-calling-v2) | 4/23/2025 |\n| [APIGen Function-Calling](https://huggingface.co/datasets/Salesforce/xlam-function-calling-60k) | 4/23/2025 |\n| [LMSYS-Chat-1M](https://huggingface.co/datasets/lmsys/lmsys-chat-1m) | 4/23/2025 |\n| [Open Textbook Library \\- CC BY-SA & GNU subset](https://open.umn.edu/opentextbooks/textbooks/) and [OpenStax \\- CC BY-SA subset](https://openstax.org/) | 4/23/2025 |\n| [Advanced Reasoning Benchmark](https://github.com/TheDuckAI/arb), [tigerbot-kaggle-leetcodesolutions-en-2k](https://huggingface.co/datasets/TigerResearch/tigerbot-kaggle-leetcodesolutions-en-2k), [PRM800K](https://github.com/openai/prm800k), and [SciBench](https://github.com/mandyyyyii/scibench) | 4/23/2025 |\n| [FineWeb-2](https://huggingface.co/datasets/HuggingFaceFW/fineweb-2) | 4/23/2025 |\n| [Court Listener](https://www.courtlistener.com/help/api/bulk-data/) | Legacy Download |\n| [peS2o](https://huggingface.co/datasets/allenai/peS2o) | Legacy Download |\n| [OpenWebMath](https://huggingface.co/datasets/open-web-math/open-web-math) | Legacy Download |\n| [BioRxiv](https://www.biorxiv.org/tdm) | Legacy Download |\n| [PMC Open Access Subset](https://pmc.ncbi.nlm.nih.gov/tools/openftlist/) | Legacy Download |\n| [OpenWebText2](https://openwebtext2.readthedocs.io/en/latest/) | Legacy Download |\n| [Stack Exchange Data Dump](https://archive.org/details/stackexchange) | Legacy Download |\n| [PubMed Abstracts](https://github.com/thoppe/The-Pile-PubMed) | Legacy Download |\n| [NIH ExPorter](https://exporter.nih.gov/ExPORTER_Catalog.aspx) | Legacy Download |\n| [arXiv](https://info.arxiv.org/help/bulk_data/index.html) | Legacy Download |\n| [BigScience Workshop Datasets](https://github.com/bigscience-workshop/bigscience/tree/master/train/tr11-176B-ml#datasets) | Legacy Download |\n| [Reddit Dataset](https://files.pushshift.io/reddit/) | Legacy Download |\n| [SEC's Electronic Data Gathering, Analysis, and Retrieval (EDGAR)](https://www.sec.gov/search-filings) | Legacy Download |\n| [Public Software Heritage S3](https://docs.softwareheritage.org/devel/swh-export/graph/dataset.html#summary-of-dataset-versions) | Legacy Download |\n| [The Stack](https://huggingface.co/datasets/bigcode/the-stack) | Legacy Download |\n| [mC4](https://huggingface.co/datasets/legacy-datasets/mc4) | Legacy Download |\n| [Advanced Mathematical Problem Solving](https://github.com/hendrycks/math?tab=readme-ov-file) | Legacy Download |\n| [MathPile](https://github.com/GAIR-NLP/MathPile/) | Legacy Download |\n| [NuminaMath CoT](https://huggingface.co/datasets/AI-MO/NuminaMath-CoT) | Legacy Download |\n| [PMC Article](https://pmc.ncbi.nlm.nih.gov/tools/textmining/) | Legacy Download |\n| [FLAN](https://github.com/google-research/FLAN) | Legacy Download |\n| [Advanced Reasoning Benchmark](https://github.com/TheDuckAI/arb) | Legacy Download |\n| [SciBench](https://github.com/mandyyyyii/scibench) | Legacy Download |\n| [WikiTableQuestions](https://huggingface.co/datasets/wikitablequestions) | Legacy Download |\n| [FinQA](https://finqasite.github.io/) | Legacy Download |\n| [Riddles](https://github.com/crawsome/riddles) | Legacy Download |\n| [Problems in Elementary Mathematics for Home Study](https://archive.org/details/AntonovVygodskyNikitinSankinProblemsInElementaryMathematicsForHomeStudyMir1982) | Legacy Download |\n| [MedMCQA](https://huggingface.co/datasets/openlifescienceai/medmcqa) | Legacy Download |\n| [Cosmos QA](https://huggingface.co/datasets/allenai/cosmos_qa) | Legacy Download |\n| [MCTest](https://huggingface.co/datasets/sagnikrayc/mctest) | Legacy Download |\n| [AI2's Reasoning Challenge](https://huggingface.co/datasets/ai2_arc) | Legacy Download |\n| [OpenBookQA](https://github.com/allenai/OpenBookQA) | Legacy Download |\n| [MMLU Auxiliary Train](https://huggingface.co/datasets/cais/mmlu/viewer/all/auxiliary_train) | Legacy Download |\n| [social-chemestry-101](https://huggingface.co/datasets/tasksource/social-chemestry-101) | Legacy Download |\n| [Moral Stories](https://huggingface.co/datasets/demelin/moral_stories) | Legacy Download |\n| [The Common Pile v0.1](https://huggingface.co/common-pile) | Legacy Download |\n| [FineMath](https://huggingface.co/datasets/HuggingFaceTB/finemath) | Legacy Download |\n| [MegaMath](https://huggingface.co/datasets/LLM360/MegaMath) | Legacy Download |\n| [FastChat](https://github.com/lm-sys/FastChat) | 6/30/2025 |\n\n## Private Non-publicly Accessible Datasets of Third Parties\n\n| Dataset |\n| :---- |\n| Global Regulation |\n| Workbench |\n\n## Online Dataset Sources\n\nThe English Common Crawl data was downloaded from the Common Crawl Foundation (see their [FAQ](https://commoncrawl.org/faq) for details on their crawling) and includes the snapshots CC-MAIN-2013-20 through CC-MAIN-2025-13. The data was subsequently deduplicated and filtered in various ways described in the [Nemotron-CC paper](https://arxiv.org/abs/2412.02595).\n\nAdditionally, we extracted data for fifteen languages from the following three Common Crawl snapshots: CC-MAIN-2024-51, CC-MAIN-2025-08, CC-MAIN-2025-18. The fifteen languages included were Arabic, Chinese, Danish, Dutch, French, German, Italian, Japanese, Korean, Polish, Portuguese, Russian, Spanish, Swedish, and Thai. As we did not have reliable multilingual model-based quality classifiers available, we applied just heuristic filtering instead—similar to what we did for lower quality English data in the Nemotron-CC pipeline, but selectively removing some filters for some languages that did not work well. Deduplication was done in the same way as for Nemotron-CC.\n\nThe GitHub Crawl was collected using the GitHub REST API and the Amazon S3 API. Each crawl was operated in accordance with the rate limits set by its respective source, either GitHub or S3. We collect raw source code and subsequently remove any having a license which does not exist in our permissive-license set (for additional details, refer to the technical report).\n\n| Dataset | Modality | Dataset Size (Tokens) | Collection Period |\n| :---- | :---- | :---- | :---- |\n| English Common Crawl | Text | 3.360T | 4/8/2025 |\n| Multilingual Common Crawl | Text | 812.7B | 5/1/2025 |\n| GitHub Crawl | Text | 747.4B | 4/29/2025 |\n\n## NVIDIA-Sourced Synthetic Datasets\n\n| Dataset | Modality | Dataset Size (Tokens) | Seed Dataset | Model(s) used for generation |\n| :---- | :---- | :---- | :---- | :---- |\n| Synthetic Art of Problem Solving from DeepSeek-R1 | Text | 25.5B | [Art of Problem Solving](https://artofproblemsolving.com/company); [American Mathematics Competitions 8](https://artofproblemsolving.com/wiki/index.php/AMC_8_Problems_and_Solutions); [American Mathematics Competitions 10](https://artofproblemsolving.com/wiki/index.php/AMC_10_Problems_and_Solutions); | [DeepSeek-R1](https://huggingface.co/deepseek-ai/DeepSeek-R1) |\n| Synthetic Moral Stories and Social Chemistry from Mixtral-8x22B-v0.1 | Text | 327M | [social-chemestry-101](https://huggingface.co/datasets/tasksource/social-chemestry-101); [Moral Stories](https://huggingface.co/datasets/demelin/moral_stories) | [Mixtral-8x22B-v0.1](https://huggingface.co/mistralai/Mixtral-8x22B-v0.1) |\n| Synthetic Social Sciences seeded with OpenStax from DeepSeek-V3, Mixtral-8x22B-v0.1, and Qwen2.5-72B | Text | 83.6M | [OpenStax \\- CC BY-SA subset](https://openstax.org/) | [DeepSeek-V3](https://huggingface.co/deepseek-ai/DeepSeek-V3); [Mixtral-8x22B-v0.1](https://huggingface.co/mistralai/Mixtral-8x22B-v0.1); [Qwen2.5-72B](https://huggingface.co/Qwen/Qwen2.5-72B) |\n| Synthetic Health Sciences seeded with OpenStax from DeepSeek-V3, Mixtral-8x22B-v0.1, and Qwen2.5-72B | Text | 9.7M | [OpenStax \\- CC BY-SA subset](https://openstax.org/) | [DeepSeek-V3](https://huggingface.co/deepseek-ai/DeepSeek-V3); [Mixtral-8x22B-v0.1](https://huggingface.co/mistralai/Mixtral-8x22B-v0.1); [Qwen2.5-72B](https://huggingface.co/Qwen/Qwen2.5-72B) |\n| Synthetic STEM seeded with OpenStax, Open Textbook Library, and GSM8K from DeepSeek-R1, DeepSeek-V3, DeepSeek-V3-0324, and Qwen2.5-72B | Text | 175M | [OpenStax \\- CC BY-SA subset](https://openstax.org/); [GSM8K](https://github.com/openai/grade-school-math); [Open Textbook Library \\- CC BY-SA & GNU subset](https://open.umn.edu/opentextbooks/textbooks/) | [DeepSeek-R1](https://huggingface.co/deepseek-ai/DeepSeek-R1), [DeepSeek-V3](https://huggingface.co/deepseek-ai/DeepSeek-V3); [DeepSeek-V3-0324](https://huggingface.co/deepseek-ai/DeepSeek-V3-0324); [Qwen2.5-72B](https://huggingface.co/Qwen/Qwen2.5-72B) |\n| [Nemotron-PrismMath](https://huggingface.co/datasets/nvidia/Nemotron-PrismMath) | Text | 4.6B | [Big-Math-RL-Verified](https://huggingface.co/datasets/SynthLabsAI/Big-Math-RL-Verified); [OpenR1-Math-220k](https://huggingface.co/datasets/open-r1/OpenR1-Math-220k) | [Qwen2.5-0.5B-instruct](https://huggingface.co/Qwen/Qwen2.5-0.5B-Instruct), [Qwen2.5-72B-Instruct](https://huggingface.co/Qwen/Qwen2.5-72B-Instruct); [DeepSeek-R1-Distill-Qwen-32B](https://huggingface.co/deepseek-ai/DeepSeek-R1-Distill-Qwen-32B) |\n| Synthetic Question Answering Data from Papers and Permissible Books from Qwen2.5-72B-Instruct | Text | 350M | [arXiv](https://info.arxiv.org/help/bulk_data/index.html); [National Institutes of Health ExPorter](https://www.nih.gov/); [BioRxiv](https://www.biorxiv.org/tdm); [PMC Article](https://pmc.ncbi.nlm.nih.gov/tools/textmining/); [USPTO Backgrounds](https://data.uspto.gov/apis/transition-guide/bdss#pats); [peS2o](https://huggingface.co/datasets/allenai/peS2o); Global Regulation; [CORE](https://core.ac.uk/documentation/dataset); [PG-19](https://github.com/google-deepmind/pg19); [DOAB CC BY & CC BY-SA subset](https://www.doabooks.org/en); [NDLTD](https://ndltd.org/thesis-resources/global-etd-search/) | [Qwen2.5-72B-Instruct](https://huggingface.co/Qwen/Qwen2.5-72B-Instruct) |\n| Synthetic FineMath-4+ Reprocessed from DeepSeek-V3 | Text | 9.2B | [Common Crawl](https://commoncrawl.org/latest-crawl) | [DeepSeek-V3](https://huggingface.co/deepseek-ai/DeepSeek-V3) |\n| Synthetic FineMath-3+ Reprocessed from phi-4 | Text | 27.6B | [Common Crawl](https://commoncrawl.org/latest-crawl) | [phi-4](https://huggingface.co/microsoft/phi-4) |\n| Synthetic Union-3+ Reprocessed from phi-4 | Text | 93.1B | [Common Crawl](https://commoncrawl.org/latest-crawl) | [phi-4](https://huggingface.co/microsoft/phi-4) |\n| Refreshed [Nemotron-MIND](https://huggingface.co/datasets/nvidia/Nemotron-MIND) from phi-4 | Text | 73B | [Common Crawl](https://commoncrawl.org/latest-crawl) | [phi-4](https://huggingface.co/microsoft/phi-4) |\n| Synthetic Union-4+ Reprocessed from phi-4 | Text | 14.12B | [Common Crawl](https://commoncrawl.org/latest-crawl) | [phi-4](https://huggingface.co/microsoft/phi-4) |\n| Synthetic Union-3+ minus 4+ Reprocessed from phi-4 | Text | 78.95B | [Common Crawl](https://commoncrawl.org/latest-crawl) | [phi-4](https://huggingface.co/microsoft/phi-4) |\n| Synthetic Union-3 Refreshed from phi-4 | Text | 80.94B | [Common Crawl](https://commoncrawl.org/latest-crawl) | [phi-4](https://huggingface.co/microsoft/phi-4) |\n| Synthetic Union-4+ Refreshed from phi-4 | Text | 52.32B | [Common Crawl](https://commoncrawl.org/latest-crawl) | [phi-4](https://huggingface.co/microsoft/phi-4) |\n| Synthetic AGIEval seeded with AQUA-RAT, LogiQA, and AR-LSAT from DeepSeek-V3 and DeepSeek-V3-0324 | Text | 4.0B | [AQUA-RAT](https://huggingface.co/datasets/deepmind/aqua_rat); [LogiQA](https://huggingface.co/datasets/lucasmccabe/logiqa); [AR-LSAT](https://github.com/zhongwanjun/AR-LSAT) | [DeepSeek-V3](https://huggingface.co/deepseek-ai/DeepSeek-V3); [DeepSeek-V3-0324](https://huggingface.co/deepseek-ai/DeepSeek-V3-0324) |\n| Synthetic AGIEval seeded with AQUA-RAT, LogiQA, and AR-LSAT from Qwen3-30B-A3B | Text | 4.2B | [AQUA-RAT](https://huggingface.co/datasets/deepmind/aqua_rat); [LogiQA](https://huggingface.co/datasets/lucasmccabe/logiqa); [AR-LSAT](https://github.com/zhongwanjun/AR-LSAT) | [Qwen3-30B-A3B](https://huggingface.co/Qwen/Qwen3-30B-A3B) |\n| Synthetic Art of Problem Solving from Qwen2.5-32B-Instruct, Qwen2.5-Math-72B, Qwen2.5-Math-7B, and Qwen2.5-72B-Instruct | Text | 83.1B | [Art of Problem Solving](https://artofproblemsolving.com/company); [American Mathematics Competitions 8](https://artofproblemsolving.com/wiki/index.php/AMC_8_Problems_and_Solutions); [American Mathematics Competitions 10](https://artofproblemsolving.com/wiki/index.php/AMC_10_Problems_and_Solutions); [GSM8K](https://github.com/openai/grade-school-math); [PRM800K](https://github.com/openai/prm800k) | [Qwen2.5-32B-Instruct](https://huggingface.co/Qwen/Qwen2.5-32B-Instruct); [Qwen2.5-Math-72B](https://huggingface.co/Qwen/Qwen2.5-Math-72B); [Qwen2.5-Math-7B](https://huggingface.co/Qwen/Qwen2.5-Math-7B); [Qwen2.5-72B-Instruct](https://huggingface.co/Qwen/Qwen2.5-72B-Instruct) |\n| Synthetic MMLU Auxiliary Train from DeepSeek-R1 | Text | 0.5B | [MMLU Auxiliary Train](https://huggingface.co/datasets/cais/mmlu/viewer/all/auxiliary_train) | [DeepSeek-R1](https://huggingface.co/deepseek-ai/DeepSeek-R1) |\n| Synthetic Long Context Continued Post-Training Data from Papers and Permissible Books from Qwen2.5-72B-Instruct | Text | 5.4B  | [arXiv](https://info.arxiv.org/help/bulk_data/index.html); [National Institutes of Health ExPorter](https://www.nih.gov/); [BioRxiv](https://www.biorxiv.org/tdm); [PMC Article](https://pmc.ncbi.nlm.nih.gov/tools/textmining/); [USPTO Backgrounds](https://data.uspto.gov/apis/transition-guide/bdss#pats); [peS2o](https://huggingface.co/datasets/allenai/peS2o); Global Regulation; [CORE](https://core.ac.uk/documentation/dataset); [PG-19](https://github.com/google-deepmind/pg19); [DOAB CC BY & CC BY-SA subset](https://www.doabooks.org/en); [NDLTD](https://ndltd.org/thesis-resources/global-etd-search/) | [Qwen2.5-72B-Instruct](https://huggingface.co/Qwen/Qwen2.5-72B-Instruct) |\n| Synthetic Common Crawl from Qwen3-30B-A3B and Mistral-Nemo-12B-Instruct | Text | 1.949T | [Common Crawl](https://commoncrawl.org/) | [Qwen3-30B-A3B](https://huggingface.co/Qwen/Qwen3-30B-A3B); [Mistral-NeMo-12B-Instruct](https://huggingface.co/nvidia/Mistral-NeMo-12B-Instruct) |\n| Synthetic Multilingual Data from Common Crawl from Qwen3-30B-A3B | Text | 997.3B | [Common Crawl](https://commoncrawl.org/) | [Qwen3-30B-A3B](https://huggingface.co/Qwen/Qwen3-30B-A3B) |\n| Synthetic Multilingual Data from Wikimedia from Qwen3-30B-A3B | Text | 55.1B | [Wikimedia](https://dumps.wikimedia.org/) | [Qwen3-30B-A3B](https://huggingface.co/Qwen/Qwen3-30B-A3B) |\n| Synthetic OpenMathReasoning from DeepSeek-R1-0528 | Text | 1.5M | [OpenMathReasoning](https://huggingface.co/datasets/nvidia/OpenMathReasoning) | [DeepSeek-R1-0528](https://huggingface.co/deepseek-ai/DeepSeek-R1-0528) |\n| Synthetic OpenCodeReasoning from DeepSeek-R1-0528 | Text | 1.1M | [OpenCodeReasoning](https://huggingface.co/datasets/nvidia/OpenCodeReasoning) | [DeepSeek-R1-0528](https://huggingface.co/deepseek-ai/DeepSeek-R1-0528) |\n| Synthetic Science Data from DeepSeek-R1-0528 | Text | 1.5M | \\- | [DeepSeek-R1-0528](https://huggingface.co/deepseek-ai/DeepSeek-R1-0528) |\n| Synthetic Humanity's Last Exam from DeepSeek-R1-0528 | Text | 460K | [Humanity's Last Exam](https://huggingface.co/datasets/cais/hle) | [DeepSeek-R1-0528](https://huggingface.co/deepseek-ai/DeepSeek-R1-0528) |\n| Synthetic ToolBench from Qwen3-235B-A22B | Text | 400K | [ToolBench](https://github.com/OpenBMB/ToolBench) | [Qwen3-235B-A22B](https://huggingface.co/Qwen/Qwen3-235B-A22B) |\n| Synthetic Nemotron Content Safety Dataset V2, eval-safety, Gretel Synthetic Safety Alignment, and RedTeam\\_2K from DeepSeek-R1-0528 | Text | 52K | [Nemotron Content Safety Dataset V2](https://huggingface.co/datasets/nvidia/Aegis-AI-Content-Safety-Dataset-2.0); [eval-safety](https://github.com/CrystalEye42/eval-safety/blob/main/malicious_tasks_dataset.yaml); [Gretel Synthetic Safety Alignment](https://huggingface.co/datasets/gretelai/gretel-safety-alignment-en-v1); [RedTeam\\_2K](https://huggingface.co/datasets/JailbreakV-28K/JailBreakV-28k/viewer/RedTeam_2K) | [DeepSeek-R1-0528](https://huggingface.co/deepseek-ai/DeepSeek-R1-0528) |\n| Synthetic HelpSteer from Qwen3-235B-A22B | Text | 120K | [HelpSteer3](https://huggingface.co/datasets/nvidia/HelpSteer3); [HelpSteer2](https://huggingface.co/datasets/nvidia/HelpSteer2) | [Qwen3-235B-A22B](https://huggingface.co/Qwen/Qwen3-235B-A22B) |\n| Synthetic Alignment data from Mixtral-8x22B-Instruct-v0.1, Mixtral-8x7B-Instruct-v0.1, and Nemotron-4 Family | Text | 400K | [HelpSteer2](https://huggingface.co/datasets/nvidia/HelpSteer2); [C4](https://huggingface.co/datasets/allenai/c4); [LMSYS-Chat-1M](https://huggingface.co/datasets/lmsys/lmsys-chat-1m); [ShareGPT52K](https://huggingface.co/datasets/RyokoAI/ShareGPT52K); [tigerbot-kaggle-leetcodesolutions-en-2k](https://huggingface.co/datasets/TigerResearch/tigerbot-kaggle-leetcodesolutions-en-2k); [GSM8K](https://github.com/openai/grade-school-math); [PRM800K](https://github.com/openai/prm800k); lm\\_identity (NVIDIA internal); [FinQA](https://finqasite.github.io/); [WikiTableQuestions](https://huggingface.co/datasets/wikitablequestions); [Riddles](https://github.com/crawsome/riddles); ChatQA nvolve-multiturn (NVIDIA internal); [glaive-function-calling-v2](https://huggingface.co/datasets/glaiveai/glaive-function-calling-v2); [SciBench](https://github.com/mandyyyyii/scibench); [OpenBookQA](https://github.com/allenai/OpenBookQA); [Advanced Reasoning Benchmark](https://github.com/TheDuckAI/arb); [Public Software Heritage S3](https://docs.softwareheritage.org/devel/swh-export/graph/dataset.html#summary-of-dataset-versions); [Khan Academy Math Keywords](https://www.khanacademy.org/math) | Nemotron-4-15B-Base (NVIDIA internal); Nemotron-4-15B-Instruct (NVIDIA internal); [Nemotron-4-340B-Base](https://huggingface.co/nvidia/Nemotron-4-340B-Base); [Nemotron-4-340B-Instruct](https://huggingface.co/nvidia/Nemotron-4-340B-Instruct); [Nemotron-4-340B-Reward](https://huggingface.co/nvidia/Nemotron-4-340B-Reward);  [Mixtral-8x7B-Instruct-v0.1](https://huggingface.co/mistralai/Mixtral-8x7B-Instruct-v0.1);  [Mixtral-8x22B-Instruct-v0.1](https://huggingface.co/mistralai/Mixtral-8x22B-Instruct-v0.1) |\n| Synthetic LMSYS-Chat-1M from Qwen3-235B-A22B | Text | 1M | [LMSYS-Chat-1M](https://huggingface.co/datasets/lmsys/lmsys-chat-1m) | [Qwen3-235B-A22B](https://huggingface.co/Qwen/Qwen3-235B-A22B) |\n| Synthetic Multilingual Reasoning data from DeepSeek-R1-0528, Qwen2.5-32B-Instruct-AWQ, and Qwen2.5-14B-Instruct | Text | 25M | [OpenMathReasoning](https://huggingface.co/datasets/nvidia/OpenMathReasoning); [OpenCodeReasoning](https://huggingface.co/datasets/nvidia/OpenCodeReasoning) | [DeepSeek-R1-0528](https://huggingface.co/deepseek-ai/DeepSeek-R1-0528); [Qwen2.5-32B-Instruct-AWQ](https://huggingface.co/Qwen/Qwen2.5-32B-Instruct-AWQ) (translation); [Qwen2.5-14B-Instruct](https://huggingface.co/Qwen/Qwen2.5-14B-Instruct) (translation); |\n| Synthetic Multilingual Reasoning data from Qwen3-235B-A22B and Gemma 3 Post-Trained models | Text | 5M | [WildChat](https://huggingface.co/datasets/allenai/WildChat-1M) | [Qwen3-235B-A22B](https://huggingface.co/Qwen/Qwen3-235B-A22B); [Gemma 3 PT 12B](https://huggingface.co/google/gemma-3-12b-it); [Gemma 3 PT 27B](https://huggingface.co/google/gemma-3-27b-it) |\n\n### Evaluation Dataset:\n\n* Data Collection Method by dataset: Hybrid: Human, Synthetic  \n* Labeling Method by dataset: Hybrid: Automated, Human, Synthetic\n\n## Inference\n\n- ## Engines: HF, vLLM, TRT-LLM\n\n- ## Test Hardware NVIDIA A10G 24GB, H100 80GB\n\n## Ethical Considerations\n\nNVIDIA believes Trustworthy AI is a shared responsibility and we have established policies and practices to enable development for a wide array of AI applications.  When downloaded or used in accordance with our [Trustworthy AI terms of service](https://www.nvidia.com/en-us/agreements/trustworthy-ai/terms/), developers should work with their internal model team to ensure this model meets requirements for the relevant industry and use case and addresses unforeseen product misuse.\n\nFor more detailed information on ethical considerations for this model, please see the Model Card++ [Bias](./bias.md), [Explainability](./explainability.md), [Safety & Security](./safety.md), and [Privacy](./privacy.md) Subcards.\n\nPlease report security vulnerabilities or NVIDIA AI Concerns [here](https://www.nvidia.com/en-us/support/submit-security-vulnerability/).\n\n\n## Citation\n\n```\n@misc{nvidia2025nvidianemotronnano2,\n      title={NVIDIA Nemotron Nano 2: An Accurate and Efficient Hybrid Mamba-Transformer Reasoning Model},\n      author={NVIDIA},\n      year={2025},\n      eprint={2508.14444},\n      archivePrefix={arXiv},\n      primaryClass={cs.CL},\n      url={https://arxiv.org/abs/2508.14444},\n}\n```",
    "config": "{\n  \"architectures\": [\n    \"NemotronHForCausalLM\"\n  ],\n  \"attention_bias\": false,\n  \"attention_dropout\": 0.0,\n  \"head_dim\": 128,\n  \"auto_map\": {\n    \"AutoConfig\": \"configuration_nemotron_h.NemotronHConfig\",\n    \"AutoModelForCausalLM\": \"modeling_nemotron_h.NemotronHForCausalLM\"\n  },\n  \"bos_token_id\": 1,\n  \"chunk_size\": 128,\n  \"conv_kernel\": 4,\n  \"eos_token_id\": 12,\n  \"hidden_dropout\": 0.0,\n  \"hidden_size\": 5120,\n  \"hybrid_override_pattern\": \"M-M-M-M*-M-M-M-M*-M-M-M-M*-M-M-M-M*-M-M-M-M*-M-M-M-M*-M-M-M-M-\",\n  \"initializer_range\": 0.02,\n  \"intermediate_size\": 20480,\n  \"layer_norm_epsilon\": 1e-05,\n  \"mamba_head_dim\": 80,\n  \"mamba_hidden_act\": \"silu\",\n  \"mamba_num_heads\": 128,\n  \"mamba_proj_bias\": false,\n  \"max_position_embeddings\": 131072,\n  \"mlp_bias\": false,\n  \"mlp_hidden_act\": \"relu2\",\n  \"model_type\": \"nemotron_h\",\n  \"n_groups\": 8,\n  \"num_attention_heads\": 40,\n  \"num_hidden_layers\": 62,\n  \"num_key_value_heads\": 8,\n  \"num_logits_to_keep\": 1,\n  \"pad_token_id\": 0,\n  \"rescale_prenorm_residual\": true,\n  \"residual_in_fp32\": false,\n  \"rms_norm_eps\": 1e-05,\n  \"sliding_window\": null,\n  \"ssm_state_size\": 128,\n  \"tie_word_embeddings\": false,\n  \"time_step_floor\": 0.0001,\n  \"time_step_limit\": [\n    0.0,\n    Infinity\n  ],\n  \"time_step_max\": 0.1,\n  \"time_step_min\": 0.001,\n  \"time_step_rank\": 256,\n  \"torch_dtype\": \"bfloat16\",\n  \"transformers_version\": \"4.51.3\",\n  \"use_bias\": false,\n  \"use_cache\": true,\n  \"use_conv_bias\": true,\n  \"use_mamba_kernels\": true,\n  \"vocab_size\": 131072\n}\n",
    "generation_config": "{\n  \"_from_model_config\": true,\n  \"bos_token_id\": 1,\n  \"eos_token_id\": [\n    2,\n    11,\n    12\n  ],\n  \"pad_token_id\": 0,\n  \"transformers_version\": \"4.51.3\"\n}\n",
    "license_file": "",
    "py_files": {
        "configuration_nemotron_h.py": "# coding=utf-8\n# Copyright 2024 AI21 Labs Ltd. and the HuggingFace Inc. team. All rights reserved.\n# Copyright (c) 2025, NVIDIA CORPORATION. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"NemotronH model configuration\"\"\"\n\nimport re\n\nfrom transformers.configuration_utils import PretrainedConfig\nfrom transformers.utils import logging\n\n\nlogger = logging.get_logger(__name__)\n\n\nclass NemotronHConfig(PretrainedConfig):\n    r\"\"\"\n    This is the configuration class to store the configuration of a [`NemotronHModel`]. It is used to instantiate a\n    NemotronH model according to the specified arguments, defining the model architecture. Instantiating a configuration\n    with the defaults will yield a similar configuration to that of the NemotronH-v0.1 model.\n\n    [todo](todo)\n\n    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n    documentation from [`PretrainedConfig`] for more information.\n\n\n    Args:\n        vocab_size (`int`, *optional*, defaults to 131072):\n            Vocabulary size of the NemotronH model. Defines the number of different tokens that can be represented by the\n            `inputs_ids` passed when calling [`NemotronHModel`]\n        tie_word_embeddings (`bool`, *optional*, defaults to `False`):\n            Whether the model's input and output word embeddings should be tied. Note that this is only relevant if the\n            model has a output word embedding layer.\n        hidden_size (`int`, *optional*, defaults to 4096):\n            Dimension of the hidden representations.\n        intermediate_size (`int`, *optional*, defaults to 21504):\n            Dimension of the MLP representations.\n        num_hidden_layers (`int`, *optional*, defaults to 52):\n            Number of hidden layers in the Transformer encoder.\n        hybrid_override_pattern (`str`, *optional*, defaults to `\"M-M-M-M*-M-M-M-M-M*-M-M-M-M-M*-M-M-M-M-M*-M-M-M-M-M-\"`):\n            The pattern of the hybrid model. The pattern is a string of characters where each character represents M: Mamba2, *: Attention, -: MLP\n        num_attention_heads (`int`, *optional*, defaults to 32):\n            Number of attention heads for each attention layer in the Transformer encoder.\n        attention_head_dim (`int`, *optional*, defaults to 128):\n            Dimension of each attention head.\n        num_key_value_heads (`int`, *optional*, defaults to 8):\n            This is the number of key_value heads that should be used to implement Grouped Query Attention. If\n            `num_key_value_heads=num_attention_heads`, the model will use Multi Head Attention (MHA), if\n            `num_key_value_heads=1` the model will use Multi Query Attention (MQA) otherwise GQA is used.\n        mlp_hidden_act (`str`, *optional*, defaults to \"relu2\"):\n            The non-linear activation function in the MLP layers.\n        attention_bias (`bool`, *optional*, defaults to `False`):\n            Whether to use bias in attention layers.\n        mlp_bias (`bool`, *optional*, defaults to `False`):\n            Whether to use bias in MLP layers.\n        use_bias (`bool`, *optional*, defaults to `False`):\n            Whether to use bias in the model.\n        initializer_range (`float`, *optional*, defaults to 0.02):\n            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n        layer_norm_epsilon (`float`, *optional*, defaults to 1e-5):\n            The epsilon used by the layer normalization layers.\n        residual_in_fp32 (`bool`, *optional*, defaults to `False`):\n            Whether or not residuals should be in `float32`. If set to `False` residuals will keep the same `dtype` as the rest of the model.\n        use_cache (`bool`, *optional*, defaults to `True`):\n            Whether or not the model should return the last key/values attentions (not used by all models). Only\n            relevant if `config.is_decoder=True`.\n        num_logits_to_keep (`int` or `None`, *optional*, defaults to 1):\n            Number of prompt logits to calculate during generation. If `None`, all logits will be calculated. If an\n            integer value, only last `num_logits_to_keep` logits will be calculated.\n        pad_token_id (`int`, *optional*, defaults to 0):\n            The id of the padding token.\n        bos_token_id (`int`, *optional*, defaults to 1):\n            The id of the \"beginning-of-sequence\" token.\n        eos_token_id (`int`, *optional*, defaults to 2):\n            The id of the \"end-of-sequence\" token.\n        sliding_window (`int`, *optional*, defaults to None):\n            Sliding window attention window size.\n        max_position_embeddings (`int`, *optional*, defaults to 4096):\n            The maximum sequence length that this model might ever be used with.\n        attention_dropout (`float`, *optional*, defaults to 0.0):\n            The dropout ratio for the attention probabilities.\n        hidden_dropout (`float`, *optional*, defaults to 0.0):\n            The dropout ratio for the hidden states.\n        use_mamba_kernels (`bool`, *optional*, defaults to `True`):\n            Flag indicating whether or not to use the fast mamba kernels. These are available only if `mamba-ssm` and\n            `causal-conv1d` are installed, and the mamba modules are running on a CUDA device.\n        ssm_state_size (`int`, *optional*, defaults to 128):\n            The dimension of the mamba state space latents.\n        mamba_num_heads (`int`, *optional*, defaults to 128):\n            Number of heads in Mamba layers.\n        mamba_n_groups (`int`, *optional*, defaults to 8):\n            Number of groups in Mamba layers.\n        mamba_head_dim (`int`, *optional*, defaults to 64):\n            Dimension of each Mamba head.\n        mamba_d_conv (`int`, *optional*, defaults to 4):\n            The size of the mamba convolution kernel.\n        mamba_expand (`int`, *optional*, defaults to 2):\n            Expanding factor used to determine the mamba intermediate size.\n        mamba_hidden_act (`str`, *optional*, defaults to \"silu\"):\n            The non-linear activation function in the Mamba layers.\n        mamba_dt_min (`float`, *optional*, defaults to 0.001):\n            Minimum value for the time step in Mamba.\n        mamba_dt_max (`float`, *optional*, defaults to 0.1):\n            Maximum value for the time step in Mamba.\n        mamba_dt_limit (`tuple`, *optional*, defaults to (0.0, float(\"inf\"))):\n            Limits for the time step in Mamba.\n        mamba_dt_init_floor (`float`, *optional*, defaults to 1e-4):\n            Floor value for time step initialization in Mamba.\n        mamba_conv_bias (`bool`, *optional*, defaults to `True`):\n            Whether to use bias in the convolution layer of the mamba mixer block.\n        mamba_proj_bias (`bool`, *optional*, defaults to `False`):\n            Whether to use bias in the input and output projections of the mamba mixer block.\n        mamba_chunk_size (`int`, *optional*, defaults to 256):\n            Size of chunks for Mamba processing.\n        rescale_prenorm_residual (`bool`, *optional*, defaults to `True`):\n            Whether to rescale the pre-normalization residual connections.\n    \"\"\"\n\n    model_type = \"nemotron_h\"\n    keys_to_ignore_at_inference = [\"past_key_values\"]\n\n    def __init__(\n        self,\n        vocab_size=131072,\n        tie_word_embeddings=False,\n        hidden_size=4096,\n        intermediate_size=21504,\n        num_hidden_layers=52,\n        hybrid_override_pattern=\"M-M-M-M*-M-M-M-M-M*-M-M-M-M-M*-M-M-M-M-M*-M-M-M-M-M-\",\n        num_attention_heads=32,\n        #attention_head_dim=128,\n        head_dim=128,\n        num_key_value_heads=8,  # nemo: num_query_groups\n        mlp_hidden_act=\"relu2\",\n        attention_bias=False,\n        mlp_bias=False,\n        use_bias=False,\n        initializer_range=0.02, # nemo: init_method_std\n        layer_norm_epsilon=1e-5, # nemo: layernorm_epsilon\n        residual_in_fp32=False,  #  Megatron Core default value\n        use_cache=True,\n        num_logits_to_keep=1,\n        pad_token_id=0,\n        bos_token_id=1,\n        eos_token_id=2,\n        sliding_window=None,\n        max_position_embeddings=4096,\n        attention_dropout=0.0,\n        hidden_dropout=0.0, # * ADDED\n        use_mamba_kernels=True,\n        ssm_state_size=128, # mamba_state_size\n        mamba_num_heads=128,\n        mamba_n_groups=8,  # nemo: mamba_ssm_ngroups = num_heads\n        mamba_head_dim=64,\n        mamba_d_conv=4,\n        mamba_expand=2,\n        mamba_hidden_act=\"silu\",\n        mamba_dt_min=0.001,\n        mamba_dt_max=0.1,\n        mamba_dt_limit=(0.0, float(\"inf\")),\n        mamba_dt_init_floor=1e-4,\n        mamba_conv_bias=True,\n        mamba_proj_bias=False,\n        mamba_chunk_size=256,\n        rescale_prenorm_residual=True,\n        **kwargs,\n    ):\n        self.vocab_size = vocab_size\n        self.tie_word_embeddings = tie_word_embeddings\n        self.hidden_size = hidden_size\n        self.intermediate_size = intermediate_size\n        self.num_hidden_layers = num_hidden_layers\n        self.hybrid_override_pattern = hybrid_override_pattern\n        self.num_attention_heads = num_attention_heads\n        #self.attention_head_dim = attention_head_dim\n        self.head_dim = head_dim\n        self.sliding_window = sliding_window\n        self.max_position_embeddings = max_position_embeddings\n        self.attention_dropout = attention_dropout\n        self.hidden_dropout = hidden_dropout\n\n        # Validate hybrid_override_pattern\n        # M: Mamba2, *: Attention, -: MLP\n        assert len(self.hybrid_override_pattern) == self.num_hidden_layers, \"hybrid_override_pattern must have the same length as num_hidden_layers\"\n        assert re.match(r\"^[*-M]+$\", self.hybrid_override_pattern), \"hybrid_override_pattern must only contain characters 'M', '*', or '-'\"\n\n        # for backward compatibility\n        if num_key_value_heads is None:\n            num_key_value_heads = num_attention_heads\n\n        self.num_key_value_heads = num_key_value_heads\n        self.mlp_hidden_act = mlp_hidden_act\n        self.attention_bias = attention_bias\n        self.mlp_bias = mlp_bias\n        self.use_bias = use_bias\n        self.initializer_range = initializer_range\n        self.layer_norm_epsilon = layer_norm_epsilon\n        self.residual_in_fp32 = residual_in_fp32\n\n        self.use_cache = use_cache\n        self.num_logits_to_keep = num_logits_to_keep\n\n        self.use_mamba_kernels = use_mamba_kernels\n        self.n_groups = mamba_n_groups\n        self.mamba_head_dim = mamba_head_dim\n        self.ssm_state_size = ssm_state_size\n        self.mamba_num_heads = mamba_num_heads\n        self.conv_kernel = mamba_d_conv\n        self.expand = mamba_expand\n        self.mamba_hidden_act = mamba_hidden_act\n        self.time_step_min = mamba_dt_min\n        self.time_step_max = mamba_dt_max\n        self.time_step_limit = mamba_dt_limit\n        self.time_step_floor = mamba_dt_init_floor\n        self.use_conv_bias = mamba_conv_bias\n        self.mamba_proj_bias = mamba_proj_bias\n        self.chunk_size = mamba_chunk_size\n        self.rescale_prenorm_residual = rescale_prenorm_residual\n\n        super().__init__(\n            pad_token_id=pad_token_id,\n            bos_token_id=bos_token_id,\n            eos_token_id=eos_token_id,\n            tie_word_embeddings=tie_word_embeddings,\n            **kwargs,\n        )\n\n    @property\n    def layers_block_type(self):\n        return [\n            \"mamba\" if self.hybrid_override_pattern[i] == \"M\" else\n            \"attention\" if self.hybrid_override_pattern[i] == \"*\" else \"mlp\"\n            for i in range(self.num_hidden_layers)]",
        "modeling_nemotron_h.py": "# coding=utf-8\n# Copyright 2024 HuggingFace Inc. team.\n# Copyright (c) 2025, NVIDIA CORPORATION. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"PyTorch NemotronH model.\"\"\"\n\nimport math\nfrom dataclasses import dataclass\nfrom typing import Any, Dict, Optional, Tuple, Union\n\nimport torch\nimport torch.utils.checkpoint\nfrom torch import nn\nfrom torch.nn import CrossEntropyLoss\n\nfrom transformers.activations import ACT2FN\nfrom transformers.cache_utils import DynamicCache  # we need __iter__ and __len__ of pkv\nfrom transformers.generation import GenerationMixin\nfrom transformers.modeling_attn_mask_utils import (\n    AttentionMaskConverter,\n)\nfrom transformers.modeling_utils import PreTrainedModel\nfrom transformers.utils import (\n    ModelOutput,\n    add_code_sample_docstrings,\n    add_start_docstrings,\n    add_start_docstrings_to_model_forward,\n    logging,\n)\nfrom transformers.utils.import_utils import (\n    is_causal_conv1d_available,\n    is_flash_attn_2_available,\n    is_flash_attn_greater_or_equal_2_10,\n    is_mamba_2_ssm_available,\n)\nfrom .configuration_nemotron_h import NemotronHConfig\n\n\nlogger = logging.get_logger(__name__)\n\n\n# Copied from transformers.models.mamba.modeling_mamba2.modeling_mamba2.py with MAMBA2->NEMOTRONH,Mamba2->NemotronH\n# For Mamba2 components Mamba2->NemotronHMamba2\nif is_mamba_2_ssm_available():\n    from mamba_ssm.ops.triton.selective_state_update import selective_state_update\n    from mamba_ssm.ops.triton.ssd_combined import mamba_chunk_scan_combined, mamba_split_conv1d_scan_combined\nelse:\n    mamba_chunk_scan_combined, mamba_split_conv1d_scan_combined, selective_state_update = None, None, None\n\ntry:\n    #from mamba_ssm.ops.triton.layernorm_gated import RMSNorm as RMSNormGated\n    from mamba_ssm.ops.triton.layernorm_gated import rmsnorm_fn\nexcept ImportError:\n    raise ImportError(\"mamba-ssm is required by the Mamba model but cannot be imported\")\n\nif is_causal_conv1d_available():\n    from causal_conv1d import causal_conv1d_fn, causal_conv1d_update\nelse:\n    causal_conv1d_update, causal_conv1d_fn = None, None\n\nif is_flash_attn_2_available():\n    from transformers.modeling_flash_attention_utils import _flash_attention_forward\n\nis_fast_path_available = all(\n    (\n        selective_state_update,\n        mamba_chunk_scan_combined,\n        mamba_split_conv1d_scan_combined,\n        causal_conv1d_fn,\n        causal_conv1d_update,\n    )\n)\n\n\n_CHECKPOINT_FOR_DOC = \"nvidia/Nemotron-H-56B-Base-8K\"\n_CONFIG_FOR_DOC = \"NemotronHConfig\"\n\n\n# Helper methods for segment sum computation\n\n\ndef pad_tensor_by_size(input_tensor: torch.Tensor, pad_size: int):\n    \"\"\"\n    Padding x tensor with `pad_size` on the seq_len dim (dim=1)\n\n    Assumes that we only have tensors of either size 4 or 3\n    \"\"\"\n    pad_shape = (0, 0, 0, 0, 0, pad_size, 0, 0) if len(input_tensor.shape) == 4 else (0, 0, 0, pad_size, 0, 0)\n\n    return torch.nn.functional.pad(input_tensor, pad_shape, mode=\"constant\", value=0)\n\n\ndef reshape_into_chunks(input_tensor, pad_size, chunk_size):\n    \"\"\"\n    Padding input_tensor with `pad_size` on the seq_len dim (dim=1) and\n    simultaneously splitting it into chunk sequences.\n\n    Assumes that we only have tensors of either size 4 or 3\n    \"\"\"\n    # [bsz, seq_len, ...] -> [bsz, seq_len multiple of chunk_size, ...]\n    input_tensor = pad_tensor_by_size(input_tensor, pad_size)\n\n    if len(input_tensor.shape) == 3:\n        # [bsz, seq_len multiple of chunk_size, num_heads] -> [bsz, -1, chunk_size, num_heads]\n        return input_tensor.reshape(input_tensor.shape[0], -1, chunk_size, input_tensor.shape[2])\n    else:\n        # [bsz, seq_len multiple of chunk_size, num_heads, head_dim or state_size] -> [bsz, -1, chunk_size, num_heads, head_dim or state_size]\n        return input_tensor.reshape(\n            input_tensor.shape[0], -1, chunk_size, input_tensor.shape[2], input_tensor.shape[3]\n        )\n\n\ndef segment_sum(input_tensor):\n    \"\"\"\n    More stable segment sum calculation. Uses cumulative sums and masking instead of direct subtractions.\n    \"\"\"\n    chunk_size = input_tensor.size(-1)\n    # 1. expand input tensor to have an additional dimension and repeat along that dimension\n    # [..., chunk_size] -> [..., chunk_size, chunk_size]\n    input_tensor = input_tensor[..., None].expand(*input_tensor.size(), chunk_size)\n    # 2. create a lower triangular mask with the diagonal set to 0 to 0 out elements above diag\n    mask = torch.tril(torch.ones(chunk_size, chunk_size, device=input_tensor.device, dtype=torch.bool), diagonal=-1)\n    input_tensor = input_tensor.masked_fill(~mask, 0)\n    # 3. compute actual cumsum\n    tensor_segsum = torch.cumsum(input_tensor, dim=-2)\n\n    # 4. apply mask to keep only the lower triangular part of the cumulative sum result (incl diagonal this time)\n    mask = torch.tril(torch.ones(chunk_size, chunk_size, device=input_tensor.device, dtype=torch.bool), diagonal=0)\n    tensor_segsum = tensor_segsum.masked_fill(~mask, -torch.inf)\n    return tensor_segsum\n\n\ndef apply_mask_to_padding_states(hidden_states, attention_mask):\n    \"\"\"\n    Tunes out the hidden states for padding tokens, see https://github.com/state-spaces/mamba/issues/66\n    \"\"\"\n    if attention_mask is not None and attention_mask.shape[1] > 1 and attention_mask.shape[0] > 1:\n        dtype = hidden_states.dtype\n        hidden_states = (hidden_states * attention_mask[:, :, None]).to(dtype)\n\n    return hidden_states\n\n# Copied from https://github.com/huggingface/transformers/blob/main/src/transformers/models/jamba/modeling_jamba.py\nclass HybridMambaAttentionDynamicCache(DynamicCache):\n    \"\"\"\n    A dynamic cache that can handle both the attention cache (which has a seq_len dimension) and the mamba cache\n    (which has a constant shape regardless of seq_len).\n\n    This cache has two sets of lists of tensors: `key_cache` and `value_cache` for attention cache and `conv_states`\n    and `ssm_states` for mamba cache. Each of these lists has `num_layers` tensors. The expected shape for each tensor\n    For attention layers, `key_cache` and `value_cache` have a shape of `(batch_size, num_heads, seq_len, head_dim)`,\n    while `conv_states` and `ssm_states` have a shape of `(batch_size, 0)` (empty tensors).\n    For mamba layers, `key_cache` and `value_cache` have a shape of `(batch_size, 0)` (empty tensors),\n    while `conv_states` represents the convolution state and has a shape of `(batch_size, d_inner, d_conv)`,\n    and `ssm_states` represents the ssm state and has a shape of `(batch_size, d_inner, d_state)`.\n    \"\"\"\n\n    def __init__(self, config, batch_size, dtype=torch.float16, device=None):\n        super().__init__()\n        self.dtype = dtype\n        self.hybrid_override_pattern = config.hybrid_override_pattern\n        self.has_previous_state = False  # only used by mamba\n        #intermediate_size = config.expand * config.hidden_size\n        intermediate_size = config.mamba_num_heads * config.mamba_head_dim\n        ssm_state_size = config.ssm_state_size\n        conv_kernel_size = config.conv_kernel\n        self.conv_states = []\n        self.ssm_states = []\n        self.transformer_layers = []\n        for i in range(config.num_hidden_layers):\n            if self.hybrid_override_pattern[i] == \"M\":\n                # Mamba layer\n                self.conv_states += [\n                    torch.zeros(batch_size, intermediate_size, conv_kernel_size, device=device, dtype=dtype)\n                ]\n                self.ssm_states += [\n                    torch.zeros(batch_size, intermediate_size, ssm_state_size, device=device, dtype=dtype)\n                ]\n            else:\n                # Attention or MLP layer\n                self.conv_states += [torch.tensor([[]] * batch_size, device=device)]\n                self.ssm_states += [torch.tensor([[]] * batch_size, device=device)]\n                self.transformer_layers.append(i)\n\n        self.key_cache = [torch.tensor([[]] * batch_size, device=device) for _ in range(config.num_hidden_layers)]\n        self.value_cache = [torch.tensor([[]] * batch_size, device=device) for _ in range(config.num_hidden_layers)]\n\n    def update(\n        self,\n        key_states: torch.Tensor,\n        value_states: torch.Tensor,\n        layer_idx: int,\n        cache_kwargs: Optional[Dict[str, Any]] = None,\n    ) -> Tuple[torch.Tensor, torch.Tensor]:\n        # Update the cache\n        if self.key_cache[layer_idx].shape[-1] == 0:\n            self.key_cache[layer_idx] = key_states\n            self.value_cache[layer_idx] = value_states\n        else:\n            self.key_cache[layer_idx] = torch.cat([self.key_cache[layer_idx], key_states], dim=2)\n            self.value_cache[layer_idx] = torch.cat([self.value_cache[layer_idx], value_states], dim=2)\n\n        return self.key_cache[layer_idx], self.value_cache[layer_idx]\n\n    def reorder_cache(self, beam_idx: torch.LongTensor):\n        \"\"\"Reorders the cache for beam search, given the selected beam indices.\"\"\"\n        for layer_idx in range(len(self.key_cache)):\n            device = self.key_cache[layer_idx].device\n            self.key_cache[layer_idx] = self.key_cache[layer_idx].index_select(0, beam_idx.to(device))\n            device = self.value_cache[layer_idx].device\n            self.value_cache[layer_idx] = self.value_cache[layer_idx].index_select(0, beam_idx.to(device))\n\n            device = self.conv_states[layer_idx].device\n            self.conv_states[layer_idx] = self.conv_states[layer_idx].index_select(0, beam_idx.to(device))\n            device = self.ssm_states[layer_idx].device\n            self.ssm_states[layer_idx] = self.ssm_states[layer_idx].index_select(0, beam_idx.to(device))\n\n    def get_seq_length(self, layer_idx: Optional[int] = 0) -> int:\n        \"\"\"Returns the sequence length of the cached states. A layer index can be optionally passed.\"\"\"\n        # take any layer that contains cache and not empty tensor\n        layer_idx = self.transformer_layers[0] if layer_idx not in self.transformer_layers else layer_idx\n        if len(self.key_cache) <= layer_idx:\n            return 0\n        return self.key_cache[layer_idx].shape[-2]\n\n    def to_legacy_cache(self) -> Tuple[Tuple[torch.Tensor], Tuple[torch.Tensor]]:\n        raise NotImplementedError(\"HybridMambaAttentionDynamicCache does not have a legacy cache equivalent.\")\n\n    @classmethod\n    def from_legacy_cache(cls, past_key_values: Optional[Tuple[Tuple[torch.FloatTensor]]] = None) -> \"DynamicCache\":\n        raise NotImplementedError(\"HybridMambaAttentionDynamicCache does not have a legacy cache equivalent.\")\n\n    # Copied from modeling_mamba2.py\n    def update_conv_state(\n        self, layer_idx: int, new_conv_state: torch.Tensor, cache_init: bool = False\n    ) -> torch.Tensor:\n        if cache_init:\n            self.conv_states[layer_idx] = new_conv_state.to(self.conv_states.device)\n        else:\n            self.conv_states[layer_idx] = self.conv_states[layer_idx].roll(shifts=-1, dims=-1)\n            self.conv_states[layer_idx][:, :, -1] = new_conv_state[:, 0, :].to(self.conv_states.device)\n        return self.conv_states[layer_idx]\n\n    def update_ssm_state(self, layer_idx: int, new_ssm_state: torch.Tensor):\n        self.ssm_states[layer_idx] = new_ssm_state.to(self.ssm_states.device)\n        return self.ssm_states[layer_idx]\n\n    def reset(self):\n        self.conv_states.zero_()\n        self.ssm_states.zero_()\n\nclass MambaRMSNormGated(torch.nn.Module):\n    def __init__(self, hidden_size, group_size, eps=1e-5):\n        super().__init__()\n        self.weight = nn.Parameter(torch.ones(hidden_size))\n        self.variance_epsilon = eps\n        self.group_size = group_size\n\n    # jan28b version\n    def forward(self, hidden_states, gate=None):\n        return rmsnorm_fn(x=hidden_states,\n                          weight=self.weight,\n                          bias=None, # No bias\n                          z=gate,\n                          eps=self.variance_epsilon,\n                          group_size=self.group_size,\n                          norm_before_gate=False\n        )\n\nclass NemotronHMamba2Mixer(nn.Module):\n    \"\"\"\n    Compute ∆, A, B, C, and D the state space parameters and compute the `contextualized_states`.\n    A, D are input independent (see Mamba paper [1] Section 3.5.2 \"Interpretation of A\" for why A isn't selective)\n    ∆, B, C are input-dependent (this is a key difference between Mamba and the linear time invariant S4,\n    and is why Mamba is called **selective** state spaces)\n    \"\"\"\n\n    def __init__(self, config: NemotronHConfig, layer_idx: int):\n        super().__init__()\n        self.num_heads = config.mamba_num_heads\n        self.hidden_size = config.hidden_size\n        self.ssm_state_size = config.ssm_state_size\n        self.conv_kernel_size = config.conv_kernel\n        self.intermediate_size = config.mamba_num_heads * config.mamba_head_dim\n        self.layer_idx = layer_idx\n        self.use_conv_bias = config.use_conv_bias\n        self.activation = config.mamba_hidden_act\n        self.act = ACT2FN[config.mamba_hidden_act]\n\n        self.layer_norm_epsilon = config.layer_norm_epsilon\n\n        self.n_groups = config.n_groups\n        self.head_dim = config.mamba_head_dim\n        self.chunk_size = config.chunk_size\n\n        self.time_step_limit = config.time_step_limit\n        self.time_step_min = config.time_step_min\n        self.time_step_max = config.time_step_max\n\n        self.conv_dim = self.intermediate_size + 2 * self.n_groups * self.ssm_state_size\n        self.conv1d = nn.Conv1d(\n            in_channels=self.conv_dim,\n            out_channels=self.conv_dim,\n            bias=config.use_conv_bias,\n            kernel_size=config.conv_kernel,\n            groups=self.conv_dim,\n            padding=config.conv_kernel - 1,\n        )\n\n        # projection of the input hidden states\n        projection_size = self.intermediate_size + self.conv_dim + self.num_heads\n        self.in_proj = nn.Linear(\n            self.hidden_size,\n            projection_size,\n            bias=config.use_bias,\n        )\n        # selective projection used to make dt, B and C input dependant\n\n        # time step projection (discretization)\n        # instantiate once and copy inv_dt in init_weights of PretrainedModel\n        self.dt_bias = nn.Parameter(torch.ones(self.num_heads))\n\n        # S4D real initialization. These are not discretized!\n        # The core is to load them, compute the discrete states, then write the updated state. Keeps the memory bounded\n        A = torch.arange(1, self.num_heads + 1)\n        self.A_log = nn.Parameter(torch.log(A))\n        self.A_log._no_weight_decay = True\n        self.norm = MambaRMSNormGated(self.intermediate_size, eps=self.layer_norm_epsilon, group_size=self.intermediate_size // self.n_groups)\n        self.D = nn.Parameter(torch.ones(self.num_heads))\n        self.D._no_weight_decay = True\n\n        self.out_proj = nn.Linear(self.intermediate_size, self.hidden_size, bias=config.use_bias)\n        self.use_bias = config.use_bias\n\n        if not is_fast_path_available:\n            logger.warning_once(\n                \"The fast path is not available because on of `(selective_state_update, causal_conv1d_fn, causal_conv1d_update)`\"\n                \" is None. Falling back to the naive implementation. To install follow https://github.com/state-spaces/mamba/#installation and\"\n                \" https://github.com/Dao-AILab/causal-conv1d\"\n            )\n\n    def cuda_kernels_forward(\n        self,\n        hidden_states: torch.Tensor,\n        cache_params: Optional[HybridMambaAttentionDynamicCache] = None,\n        cache_position: Optional[torch.LongTensor] = None,\n        attention_mask: Optional[torch.Tensor] = None,\n    ):\n        # 1. Gated MLP's linear projection\n        hidden_states = apply_mask_to_padding_states(hidden_states, attention_mask)\n        projected_states = self.in_proj(hidden_states)\n\n        # Set up dimensions for reshapes later\n        batch_size, seq_len, _ = hidden_states.shape\n        groups_time_state_size = self.n_groups * self.ssm_state_size\n        d_mlp = (\n            projected_states.shape[-1]\n            - 2 * self.intermediate_size\n            - 2 * self.n_groups * self.ssm_state_size\n            - self.num_heads\n        ) // 2\n\n        # Single step calculations via cache\n        if cache_params is not None and cache_position is not None and cache_position[0] > 0:\n            _, _, gate, hidden_states_B_C, dt = projected_states.squeeze(1).split(\n                [d_mlp, d_mlp, self.intermediate_size, self.conv_dim, self.num_heads], dim=-1\n            )\n\n            # 2. Convolution sequence transformation\n            hidden_states_B_C = causal_conv1d_update(\n                hidden_states_B_C,\n                cache_params.conv_states[self.layer_idx],\n                self.conv1d.weight.squeeze(1),\n                self.conv1d.bias,\n                self.activation,\n            )\n\n            hidden_states, B, C = torch.split(\n                hidden_states_B_C,\n                [self.intermediate_size, groups_time_state_size, groups_time_state_size],\n                dim=-1,\n            )\n\n            # 3. SSM transformation\n            A = -torch.exp(self.A_log.float())  # (nheads,)\n            A = A[:, None, ...][:, :, None].expand(-1, self.head_dim, self.ssm_state_size).to(dtype=torch.float32)\n            dt = dt[:, :, None].expand(-1, -1, self.head_dim)\n            dt_bias = self.dt_bias[:, None, ...].expand(-1, self.head_dim)\n            D = self.D[:, None, ...].expand(-1, self.head_dim)\n            B = B.view(batch_size, self.n_groups, B.shape[1] // self.n_groups)\n            C = C.view(batch_size, self.n_groups, C.shape[1] // self.n_groups)\n            hidden_states_reshaped = hidden_states.view(batch_size, self.num_heads, self.head_dim)\n            hidden_states = selective_state_update(\n                cache_params.ssm_states[self.layer_idx],\n                hidden_states_reshaped,\n                dt,\n                A,\n                B,\n                C,\n                D,\n                z=None,\n                dt_bias=dt_bias,\n                dt_softplus=True,\n            )\n            hidden_states = hidden_states.view(batch_size, self.num_heads * self.head_dim)\n            hidden_states = self.norm(hidden_states, gate)\n\n            # 4. Final linear projection\n            out = self.out_proj(hidden_states)[:, None, ...]\n\n        # Fused calculations or step by step if no initialized cache is found\n        else:\n            A = -torch.exp(self.A_log.float())  # (num_heads) or (intermediate_size, state_size)\n            dt_limit_kwargs = {} if self.time_step_limit == (0.0, float(\"inf\")) else {\"dt_limit\": self.time_step_limit}\n\n            # 2-4. Fused kernel for conv1d, SSM, and the final projection\n            if self.training and cache_params is None:\n                out = mamba_split_conv1d_scan_combined(\n                    projected_states,\n                    self.conv1d.weight.squeeze(1),\n                    self.conv1d.bias,\n                    self.dt_bias,\n                    A,\n                    D=self.D,\n                    chunk_size=self.chunk_size,\n                    seq_idx=None,  # was seq_idx\n                    activation=self.activation,\n                    rmsnorm_weight=self.norm.weight,\n                    rmsnorm_eps=self.norm.variance_epsilon,\n                    outproj_weight=self.out_proj.weight,\n                    outproj_bias=self.out_proj.bias,\n                    headdim=self.head_dim,\n                    ngroups=self.n_groups,\n                    norm_before_gate=False,\n                    return_final_states=False,\n                    **dt_limit_kwargs,\n                )\n\n            else:\n                _, _, gate, hidden_states_B_C, dt = projected_states.split(\n                    [d_mlp, d_mlp, self.intermediate_size, self.conv_dim, self.num_heads], dim=-1\n                )\n\n                # 2. Convolution sequence transformation\n                # Init cache\n                if cache_params is not None:\n                    hidden_states_B_C_transposed = hidden_states_B_C.transpose(1, 2)\n                    conv_states = nn.functional.pad(\n                        hidden_states_B_C_transposed,\n                        (cache_params.conv_kernel_size - hidden_states_B_C_transposed.shape[-1], 0),\n                    )\n                    cache_params.update_conv_state(\n                        layer_idx=self.layer_idx, new_conv_state=conv_states, cache_init=True\n                    )\n\n                if self.activation not in [\"silu\", \"swish\"]:\n                    hidden_states_B_C = self.act(\n                        self.conv1d(hidden_states_B_C.transpose(1, 2))[..., :seq_len].transpose(1, 2)\n                    )\n                else:\n                    hidden_states_B_C = causal_conv1d_fn(\n                        x=hidden_states_B_C.transpose(1, 2),\n                        weight=self.conv1d.weight.squeeze(1),\n                        bias=self.conv1d.bias,\n                        activation=self.activation,\n                    ).transpose(1, 2)\n                hidden_states_B_C = apply_mask_to_padding_states(hidden_states_B_C, attention_mask)\n                hidden_states, B, C = torch.split(\n                    hidden_states_B_C,\n                    [self.intermediate_size, groups_time_state_size, groups_time_state_size],\n                    dim=-1,\n                )\n\n                # 3. SSM transformation\n                scan_output, ssm_state = mamba_chunk_scan_combined(\n                    hidden_states.view(batch_size, seq_len, -1, self.head_dim),\n                    dt,\n                    A,\n                    B.view(batch_size, seq_len, self.n_groups, -1),\n                    C.view(batch_size, seq_len, self.n_groups, -1),\n                    chunk_size=self.chunk_size,\n                    D=self.D,\n                    z=None,\n                    seq_idx=None,\n                    return_final_states=True,\n                    dt_bias=self.dt_bias,\n                    dt_softplus=True,\n                    **dt_limit_kwargs,\n                )\n\n                # Init cache\n                if ssm_state is not None and cache_params is not None:\n                    cache_params.update_ssm_state(layer_idx=self.layer_idx, new_ssm_state=ssm_state)\n\n                scan_output = scan_output.view(batch_size, seq_len, -1)\n\n                # Multiply \"gate\" branch and apply extra normalization layer\n                scan_output = self.norm(scan_output, gate)\n\n                # 4. Final linear projection\n                out = self.out_proj(scan_output)\n        return out\n\n    # fmt: off\n    def torch_forward(self, input_states, cache_params: Optional[HybridMambaAttentionDynamicCache]=None, cache_position:Optional[torch.LongTensor]=None, attention_mask: Optional[torch.Tensor]=None):\n        batch_size, seq_len, _ = input_states.shape\n        dtype = input_states.dtype\n\n        # 1. Gated MLP's linear projection\n        input_states = apply_mask_to_padding_states(input_states, attention_mask)\n        projected_states = self.in_proj(input_states)\n        d_mlp = (projected_states.shape[-1] - 2 * self.intermediate_size - 2 * self.n_groups * self.ssm_state_size-self.num_heads) // 2\n        _, _, gate, hidden_states_B_C, dt = projected_states.split(\n                [d_mlp, d_mlp, self.intermediate_size,  self.conv_dim, self.num_heads], dim=-1\n        )\n\n        # 2. Convolution sequence transformation\n        if cache_params is not None and cache_position is not None and cache_position[0] > 0:\n            cache_params.update_conv_state(layer_idx=self.layer_idx, new_conv_state=hidden_states_B_C, cache_init=False)\n\n            # We need to guarantee that anything regarding the cache is on the same device\n            conv_states = cache_params.conv_states[self.layer_idx].to(device=self.conv1d.weight.device)\n\n            hidden_states_B_C = torch.sum(\n                conv_states * self.conv1d.weight.squeeze(1), dim=-1\n            )\n            if self.use_conv_bias:\n                hidden_states_B_C = hidden_states_B_C + self.conv1d.bias\n            hidden_states_B_C = self.act(hidden_states_B_C)\n        else:\n            # Init cache\n            if cache_params is not None:\n                hidden_states_B_C_transposed = hidden_states_B_C.transpose(1, 2)\n                conv_states = nn.functional.pad(\n                    hidden_states_B_C_transposed, (cache_params.conv_kernel_size - hidden_states_B_C_transposed.shape[-1], 0)\n                )\n                cache_params.update_conv_state(layer_idx=self.layer_idx, new_conv_state=conv_states, cache_init=True)\n\n            hidden_states_B_C = self.act(self.conv1d(hidden_states_B_C.transpose(1, 2))[..., :seq_len].transpose(1, 2))\n\n        hidden_states_B_C = apply_mask_to_padding_states(hidden_states_B_C, attention_mask)\n        hidden_states, B, C = torch.split(\n            hidden_states_B_C,\n            [self.intermediate_size, self.n_groups * self.ssm_state_size, self.n_groups * self.ssm_state_size],\n            dim=-1\n        )\n\n        # 3. SSM transformation\n        A = -torch.exp(self.A_log.float())                            # [num_heads]\n        if cache_params is not None and cache_position is not None and cache_position[0] > 0:\n            # We need to guarantee that anything regarding the cache is on the same device\n            cache_device = cache_params.ssm_states.device\n\n            # Note: there is no need to pad parameter matrices here, as there is just one new token\n            # for batched generation\n            dt = dt[:, 0, :][:, None, ...]\n            dt = dt.transpose(1, 2).expand(batch_size, dt.shape[-1], self.head_dim)\n            # [num_heads] -> [num_heads, head_dim]\n            dt_bias = self.dt_bias[..., None].expand(self.dt_bias.shape[0], self.head_dim)\n\n            dt = torch.nn.functional.softplus(dt + dt_bias.to(dt.dtype))\n            dt = torch.clamp(dt, self.time_step_limit[0], self.time_step_limit[1])\n            A = A[..., None, None].expand(self.num_heads, self.head_dim, self.ssm_state_size).to(dtype=torch.float32)\n            # [bsz, num_heads, head_dim, state_size]\n            dA = (torch.exp(dt[..., None] * A)).to(device=cache_device)\n\n            # Discretize B\n            # [bsz, n_groups * state_size] -> [bsz, n_groups, 1, state_size] ->\n            # -> [bsz, n_groups, group to head repetition factor, state_size] -> [bsz, num_heads, state_size]\n            B = B.reshape(batch_size, self.n_groups, -1)[..., None, :]\n            B = B.expand(batch_size, self.n_groups, self.num_heads // self.n_groups, B.shape[-1]).contiguous()\n            B = B.reshape(batch_size, -1, B.shape[-1])\n            # [bsz, num_heads, head_dim, state_size]\n            dB = dt[..., None] * B[..., None, :]\n\n            # Discretize x into dB\n            # [bsz, intermediate_size] -> [bsz, num_heads, head_dim]\n            hidden_states = hidden_states.reshape(batch_size, -1, self.head_dim)\n            dBx = (dB * hidden_states[..., None]).to(device=cache_device)\n\n            # State calculation\n            cache_params.update_ssm_state(\n                layer_idx=self.layer_idx,\n                new_ssm_state=cache_params.ssm_states[self.layer_idx] * dA + dBx\n            )\n\n            # Subsequent output\n            # [bsz, n_groups * state_size] -> [bsz, num_heads, state_size]\n            C = C.reshape(batch_size, self.n_groups, -1)[..., None, :]\n            C = C.expand(batch_size, self.n_groups, self.num_heads // self.n_groups, C.shape[-1]).contiguous()\n            C = C.reshape(batch_size, -1, C.shape[-1])\n            # [bsz, num_heads, head_dim]\n\n            ssm_states = cache_params.ssm_states[self.layer_idx].to(device=C.device, dtype=C.dtype)  # Shape: [b, h, d, n]\n            # Reshape ssm_states to merge the first two dimensions\n            ssm_states_reshaped = ssm_states.view(batch_size * self.num_heads, self.head_dim, self.ssm_state_size)  # Shape: [b*h, d, n]\n            C_reshaped = C.view(batch_size * self.num_heads, self.ssm_state_size, 1)  # Shape: [b*h, n, 1]\n            y = torch.bmm(ssm_states_reshaped, C_reshaped)\n            y = y.view(batch_size, self.num_heads, self.head_dim)\n\n            # D skip connection\n            # [num_heads] -> [num_heads, head_dim]\n            D = self.D[..., None].expand(self.D.shape[0], self.head_dim)\n            y = (y + hidden_states * D).to(y.dtype)\n\n            # [bsz, num_heads, head_dim] -> [bsz, 1, intermediate_size]\n            y = y.reshape(batch_size, -1)[:, None, ...]\n        else:\n            # begin ssd naive implementation without einsums\n            dt = nn.functional.softplus(dt + self.dt_bias)\n            dt = torch.clamp(dt, self.time_step_limit[0], self.time_step_limit[1])\n            hidden_states = hidden_states.reshape(batch_size, seq_len, -1, self.head_dim).float()\n            B = B.reshape(batch_size, seq_len, -1, self.ssm_state_size).float()\n            C = C.reshape(batch_size, seq_len, -1, self.ssm_state_size).float()\n            B = B.repeat(1, 1, self.num_heads // self.n_groups, 1)\n            C = C.repeat(1, 1, self.num_heads // self.n_groups, 1)\n            pad_size = (self.chunk_size - seq_len % self.chunk_size) % self.chunk_size\n\n            D_residual = self.D[..., None] * pad_tensor_by_size(hidden_states, pad_size)\n\n            # Discretize x and A\n            hidden_states = hidden_states * dt[..., None]\n            A = A.to(hidden_states.dtype) * dt\n\n            # Rearrange into blocks/chunks\n            hidden_states, A, B, C = [reshape_into_chunks(t, pad_size, self.chunk_size) for t in (hidden_states, A, B, C)]\n\n            # [bsz, -1, chunk_size, num_heads] -> [bsz, num_heads, -1, chunk_size]\n            A = A.permute(0, 3, 1, 2)\n            A_cumsum = torch.cumsum(A, dim=-1)\n\n            # 1. Compute the output for each intra-chunk (diagonal blocks)\n            # This is the analog of a causal mask\n            L = torch.exp(segment_sum(A))\n\n            # Contraction of C and B to get G (attention-weights like)\n            G_intermediate = C[:, :, :, None, :, :] * B[:, :, None, :, :, :]  # shape: (b, c, l, s, h, n)\n            G = G_intermediate.sum(dim=-1)  # shape: (b, c, l, s, h)\n\n            # Compute M, equivalent to applying attention mask to weights\n            M_intermediate = G[..., None] * L.permute(0, 2, 3, 4, 1)[..., None]\n            M = M_intermediate.sum(dim=-1)\n\n            # Compute Y_diag (apply to values)\n            Y_diag = (M[..., None] * hidden_states[:, :, None]).sum(dim=3)\n\n            # 2. Compute the state for each intra-chunk\n            # (right term of low-rank factorization of off-diagonal blocks; B terms)\n            decay_states = torch.exp((A_cumsum[:, :, :, -1:] - A_cumsum))\n            B_decay = B * decay_states.permute(0, -2, -1, 1)[..., None]\n            states = (B_decay[..., None, :] * hidden_states[..., None]).sum(dim=2)\n\n            # 3. Compute the inter-chunk SSM recurrence; produces correct SSM states at chunk boundaries\n            # (middle term of factorization of off-diag blocks; A terms)\n            if cache_params is not None and cache_position is not None and cache_position[0] > 0:\n                previous_states = cache_params.ssm_states[self.layer_idx][:, None, ...].to(device=states.device)\n            else:\n                previous_states = torch.zeros_like(states[:, :1])\n            states = torch.cat([previous_states, states], dim=1)\n            decay_chunk = torch.exp(segment_sum(nn.functional.pad(A_cumsum[:, :, :, -1], (1, 0))))\n            decay_chunk = decay_chunk.transpose(1, 3)\n            new_states = (decay_chunk[..., None, None] * states[:, :, None, ...]).sum(dim=1)\n            states, ssm_state = new_states[:, :-1], new_states[:, -1]\n\n            # 4. Compute state -> output conversion per chunk\n            # (left term of low-rank factorization of off-diagonal blocks; C terms)\n            state_decay_out = torch.exp(A_cumsum)\n            C_times_states = (C[..., None, :] * states[:, :, None, ...])\n            state_decay_out_permuted = state_decay_out.permute(0, 2, 3, 1)\n            Y_off = (C_times_states.sum(-1) * state_decay_out_permuted[..., None])\n\n            # Add output of intra-chunk and inter-chunk terms (diagonal and off-diagonal blocks)\n            y = Y_diag + Y_off\n            # [bsz, -1, self.chunk_size, num_heads, head_dim] -> [bsz, (padded) seq_len, num_heads, head_dim]\n            y = y.reshape(batch_size, -1, self.num_heads, self.head_dim)\n\n            y = y + D_residual\n            # Cutting off padded chunks\n            if pad_size > 0:\n                y = y[:, :seq_len, :, :]\n            y = y.reshape(batch_size, seq_len, -1)\n\n            # Init cache\n            if ssm_state is not None and cache_params is not None:\n                cache_params.update_ssm_state(layer_idx=self.layer_idx, new_ssm_state=ssm_state)\n\n        scan_output = self.norm(y, gate)\n\n        # end ssd naive\n\n        # 4. Final linear projection\n        contextualized_states = self.out_proj(scan_output.to(dtype))  # [batch, seq_len, hidden_size]\n        return contextualized_states\n    # fmt: on\n\n    def forward(\n        self,\n        hidden_states,\n        cache_params: Optional[HybridMambaAttentionDynamicCache] = None,\n        cache_position: Optional[torch.LongTensor] = None,\n        attention_mask: Optional[torch.Tensor] = None,\n    ):\n        if is_fast_path_available and \"cuda\" in self.in_proj.weight.device.type:\n            return self.cuda_kernels_forward(hidden_states, cache_params, cache_position, attention_mask)\n        dtype = hidden_states.dtype\n        if attention_mask is not None and attention_mask.shape[1] > 1 and attention_mask.shape[0] > 1:\n            # tune out hidden states for pad tokens, see https://github.com/state-spaces/mamba/issues/66\n            hidden_states = (hidden_states * attention_mask[:, :, None]).to(dtype)\n\n        return self.torch_forward(hidden_states, cache_params, cache_position, attention_mask)\n\n\nclass NemotronHRMSNorm(nn.Module):\n    def __init__(self, hidden_size, eps=1e-6):\n        \"\"\"\n        NemotronHRMSNorm is equivalent to T5LayerNorm and LlamaRMSNorm\n        \"\"\"\n        super().__init__()\n        self.weight = nn.Parameter(torch.ones(hidden_size))\n        self.variance_epsilon = eps\n\n    def forward(self, hidden_states):\n        input_dtype = hidden_states.dtype\n        hidden_states = hidden_states.to(torch.float32)\n        variance = hidden_states.pow(2).mean(-1, keepdim=True)\n        hidden_states = hidden_states * torch.rsqrt(variance + self.variance_epsilon)\n        # Weights are in float32\n        return (self.weight.to(torch.float32) * hidden_states).to(input_dtype)\n\nclass NemotronHBlock(nn.Module):\n    def __init__(self, config, layer_idx):\n        super().__init__()\n        self.config = config\n        self.layer_idx = layer_idx\n        self.residual_in_fp32 = config.residual_in_fp32\n        self.norm = NemotronHRMSNorm(config.hidden_size, eps=config.layer_norm_epsilon)\n\n        # M: Mamba2, *: Attention, -: MLP\n        self.block_type = config.layers_block_type[layer_idx]\n        if self.block_type == \"mamba\":\n            self.mixer = NemotronHMamba2Mixer(config, layer_idx=layer_idx)\n        elif self.block_type == \"attention\":\n            self.mixer = NEMOTRONH_ATTENTION_CLASSES[config._attn_implementation](config, layer_idx=layer_idx)\n        elif self.block_type == \"mlp\":\n            self.mixer = NemotronHMLP(config, layer_idx=layer_idx)\n        else:\n            raise ValueError(f\"Invalid layer pattern {config.hybrid_override_pattern[layer_idx]}\")\n\n    def forward(\n        self,\n        hidden_states,\n        cache_params: Optional[HybridMambaAttentionDynamicCache] = None,\n        cache_position: Optional[torch.LongTensor] = None,\n        attention_mask: Optional[torch.Tensor] = None,\n    ):\n        with torch.cuda.stream(torch.cuda.default_stream(hidden_states.device)):\n            # * Use torch.cuda.stream() to avoid NaN issues when using multiple GPUs\n            residual = hidden_states\n            hidden_states = self.norm(hidden_states.to(dtype=self.norm.weight.dtype))\n            if self.residual_in_fp32:\n                residual = residual.to(torch.float32)\n\n            if self.block_type == \"mamba\":\n                hidden_states = self.mixer(\n                    hidden_states, cache_params=cache_params, cache_position=cache_position\n                )\n            elif self.block_type == \"attention\":\n                hidden_states = self.mixer(\n                    hidden_states, cache_position=cache_position\n                )\n                hidden_states = hidden_states[0]\n            elif self.block_type == \"mlp\":\n                hidden_states = self.mixer(\n                    hidden_states\n                )\n            else:\n                raise ValueError(f\"Invalid block_type: {self.block_type}\")\n\n            hidden_states = residual + hidden_states\n            return hidden_states\n\n\n# Copied from transformers.models.nemotron.modeling_nemotron Nemotron->NemotronH\nclass NemotronHMLP(nn.Module):\n    def __init__(self, config, layer_idx: Optional[int] = None):\n        super().__init__()\n        self.config = config\n        self.layer_idx = layer_idx\n        if layer_idx is None:\n            logger.warning_once(\n                f\"Instantiating {self.__class__.__name__} without passing a `layer_idx` is not recommended and will \"\n                \"lead to errors during the forward call if caching is used. Please make sure to provide a `layer_idx` \"\n                \"when creating this class.\"\n            )\n        self.hidden_size = config.hidden_size\n        #intermediate_size = config.expand * config.hidden_size\n        self.intermediate_size = config.intermediate_size\n        self.up_proj = nn.Linear(self.hidden_size, self.intermediate_size, bias=config.mlp_bias)\n        self.down_proj = nn.Linear(self.intermediate_size, self.hidden_size, bias=config.mlp_bias)\n        self.act_fn = ACT2FN[config.mlp_hidden_act]\n\n    def forward(self, x):\n        return self.down_proj(self.act_fn(self.up_proj(x)))\n\n\n# Copied from transformers.models.llama.modeling_llama.repeat_kv\ndef repeat_kv(hidden_states: torch.Tensor, n_rep: int) -> torch.Tensor:\n    \"\"\"\n    This is the equivalent of torch.repeat_interleave(x, dim=1, repeats=n_rep). The hidden states go from (batch,\n    num_key_value_heads, seqlen, head_dim) to (batch, num_attention_heads, seqlen, head_dim)\n    \"\"\"\n    batch, num_key_value_heads, slen, head_dim = hidden_states.shape\n    if n_rep == 1:\n        return hidden_states\n    hidden_states = hidden_states[:, :, None, :, :].expand(batch, num_key_value_heads, n_rep, slen, head_dim)\n    return hidden_states.reshape(batch, num_key_value_heads * n_rep, slen, head_dim)\n\n\nclass NemotronHAttention(nn.Module):\n    \"\"\"Multi-headed attention from 'Attention Is All You Need' paper\"\"\"\n\n    def __init__(self, config: NemotronHConfig, layer_idx: Optional[int] = None):\n        super().__init__()\n        self.config = config\n        self.layer_idx = layer_idx\n        if layer_idx is None:\n            logger.warning_once(\n                f\"Instantiating {self.__class__.__name__} without passing a `layer_idx` is not recommended and will \"\n                \"lead to errors during the forward call if caching is used. Please make sure to provide a `layer_idx` \"\n                \"when creating this class.\"\n            )\n\n        self.attention_dropout = config.attention_dropout\n        self.hidden_size = config.hidden_size\n        self.num_heads = config.num_attention_heads\n        if config.head_dim is not None:\n            self.head_dim = config.head_dim\n        else:\n            self.head_dim = config.hidden_size // config.num_attention_heads\n        self.num_key_value_heads = config.num_key_value_heads\n        self.num_key_value_groups = self.num_heads // self.num_key_value_heads\n        self.max_position_embeddings = config.max_position_embeddings\n        self.is_causal = True\n\n        self.q_proj = nn.Linear(self.hidden_size, self.num_heads * self.head_dim, bias=config.attention_bias)\n        self.k_proj = nn.Linear(self.hidden_size, self.num_key_value_heads * self.head_dim, bias=config.attention_bias)\n        self.v_proj = nn.Linear(self.hidden_size, self.num_key_value_heads * self.head_dim, bias=config.attention_bias)\n        self.o_proj = nn.Linear(self.head_dim * self.num_heads, self.hidden_size, bias=config.attention_bias)\n\n    def forward(\n        self,\n        hidden_states: torch.Tensor,\n        # position_embeddings: Tuple[torch.Tensor, torch.Tensor], #TODO\n        attention_mask: Optional[torch.Tensor] = None,\n        position_ids: Optional[torch.LongTensor] = None,\n        past_key_value: Optional[HybridMambaAttentionDynamicCache] = None,\n        output_attentions: bool = False,\n        use_cache: bool = False,\n        cache_position: Optional[torch.LongTensor] = None,\n    ) -> Tuple[torch.Tensor, Optional[torch.Tensor], Optional[Tuple[torch.Tensor]]]:\n        bsz, q_len, _ = hidden_states.size()\n\n        query_states = self.q_proj(hidden_states)\n        key_states = self.k_proj(hidden_states)\n        value_states = self.v_proj(hidden_states)\n\n        query_states = query_states.view(bsz, q_len, self.num_heads, self.head_dim).transpose(1, 2)\n        key_states = key_states.view(bsz, q_len, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n        value_states = value_states.view(bsz, q_len, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n\n        if past_key_value is not None:\n            key_states, value_states = past_key_value.update(key_states, value_states, self.layer_idx)\n\n        key_states = repeat_kv(key_states, self.num_key_value_groups)\n        value_states = repeat_kv(value_states, self.num_key_value_groups)\n\n        causal_mask = attention_mask\n        if attention_mask is not None:  # no matter the length, we just slice it\n            causal_mask = attention_mask[:, :, :, : key_states.shape[-2]]\n\n        if query_states.device.type == \"cuda\" and attention_mask is not None:\n            query_states = query_states.contiguous()\n            key_states = key_states.contiguous()\n            value_states = value_states.contiguous()\n\n        is_causal = True if causal_mask is None and q_len > 1 else False\n\n        attn_output = torch.nn.functional.scaled_dot_product_attention(\n            query_states,\n            key_states,\n            value_states,\n            attn_mask=causal_mask,\n            dropout_p=self.attention_dropout if self.training else 0.0,\n            is_causal=is_causal,\n        )\n        attn_output = attn_output.transpose(1, 2).contiguous()\n        #attn_output = attn_output.view(bsz, q_len, self.hidden_size)\n        attn_output = attn_output.view(bsz, q_len, self.num_heads * self.head_dim)\n\n        attn_output = self.o_proj(attn_output)\n\n        return attn_output, None, past_key_value\n\n\n# Adapted from transformers.models.mistral.modeling_mistral.MistralFlashAttention2 with Mistral->Jamba\n#class JambaFlashAttention2(JambaAttention):\nclass NemotronHFlashAttention2(NemotronHAttention):\n    \"\"\"\n    Jamba flash attention module. This module inherits from `JambaAttention` as the weights of the module stays\n    untouched. The only required change would be on the forward pass where it needs to correctly call the public API of\n    flash attention and deal with padding tokens in case the input contains any of them.\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        # TODO: Should be removed once Flash Attention for RoCm is bumped to 2.1.\n        # flash_attn<2.1 generates top-left aligned causal mask, while what is needed here is bottom-right alignement, that was made default for flash_attn>=2.1. This attribute is used to handle this difference. Reference: https://github.com/Dao-AILab/flash-attention/releases/tag/v2.1.0.\n        # Beware that with flash_attn<2.1, using q_seqlen != k_seqlen (except for the case q_seqlen == 1) produces a wrong mask (top-left).\n        self._flash_attn_uses_top_left_mask = not is_flash_attn_greater_or_equal_2_10()\n\n    def forward(\n        self,\n        hidden_states: torch.Tensor,\n        attention_mask: Optional[torch.Tensor] = None,\n        position_ids: Optional[torch.LongTensor] = None,\n        past_key_value: Optional[HybridMambaAttentionDynamicCache] = None,\n        output_attentions: bool = False,\n        use_cache: bool = False,\n        cache_position: Optional[torch.LongTensor] = None,\n        **kwargs,\n    ):\n        bsz, q_len, _ = hidden_states.size()\n\n        query_states = self.q_proj(hidden_states)\n        key_states = self.k_proj(hidden_states)\n        value_states = self.v_proj(hidden_states)\n\n        # Flash attention requires the input to have the shape\n        # batch_size x seq_length x head_dim x hidden_dim\n        # therefore we just need to keep the original shape\n        query_states = query_states.view(bsz, q_len, self.num_heads, self.head_dim)\n        key_states = key_states.view(bsz, q_len, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n        value_states = value_states.view(bsz, q_len, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n\n        if past_key_value is not None:\n            key_states, value_states = past_key_value.update(key_states, value_states, self.layer_idx)\n\n        # repeat k/v heads if n_kv_heads < n_heads\n        key_states = repeat_kv(key_states, self.num_key_value_groups)\n        value_states = repeat_kv(value_states, self.num_key_value_groups)\n        dropout_rate = 0.0 if not self.training else self.attention_dropout\n\n        # In PEFT, usually we cast the layer norms in float32 for training stability reasons\n        # therefore the input hidden states gets silently casted in float32. Hence, we need\n        # cast them back in float16 just to be sure everything works as expected.\n        input_dtype = query_states.dtype\n        if input_dtype == torch.float32:\n            if torch.is_autocast_enabled():\n                target_dtype = torch.get_autocast_gpu_dtype()\n            # Handle the case where the model is quantized\n            elif hasattr(self.config, \"_pre_quantization_dtype\"):\n                target_dtype = self.config._pre_quantization_dtype\n            else:\n                target_dtype = self.q_proj.weight.dtype\n\n            logger.warning_once(\n                f\"The input hidden states seems to be silently casted in float32, this might be related to\"\n                f\" the fact you have upcasted embedding or layer norm layers in float32. We will cast back the input in\"\n                f\" {target_dtype}.\"\n            )\n\n            query_states = query_states.to(target_dtype)\n            key_states = key_states.to(target_dtype)\n            value_states = value_states.to(target_dtype)\n\n        # Reashape to the expected shape for Flash Attention\n        key_states = key_states.transpose(1, 2)\n        value_states = value_states.transpose(1, 2)\n\n        attn_output = _flash_attention_forward(\n            query_states,\n            key_states,\n            value_states,\n            attention_mask,\n            q_len,\n            dropout=dropout_rate,\n            sliding_window=getattr(self.config, \"sliding_window\", None),\n            is_causal=self.is_causal,\n            use_top_left_mask=self._flash_attn_uses_top_left_mask,\n        )\n\n        #attn_output = attn_output.reshape(bsz, q_len, self.hidden_size).contiguous()\n        attn_output = attn_output.reshape(bsz, q_len, self.num_heads * self.head_dim).contiguous()\n        attn_output = self.o_proj(attn_output)\n\n        if not output_attentions:\n            attn_weights = None\n\n        return attn_output, attn_weights, past_key_value\n\n\n# Adapted from transformers.models.mistral.modeling_mistral.MistralSdpaAttention with Mistral->Jamba\n#class JambaSdpaAttention(JambaAttention):\nclass NemotronHSdpaAttention(NemotronHAttention):\n    \"\"\"\n    Jamba attention module using torch.nn.functional.scaled_dot_product_attention. This module inherits from\n    `JambaAttention` as the weights of the module stays untouched. The only changes are on the forward pass to adapt to\n    SDPA API.\n    \"\"\"\n\n    # Adapted from NemotronHAttention.forward\n    def forward(\n        self,\n        hidden_states: torch.Tensor,\n        attention_mask: Optional[torch.Tensor] = None,\n        position_ids: Optional[torch.LongTensor] = None,\n        past_key_value: Optional[HybridMambaAttentionDynamicCache] = None,\n        output_attentions: bool = False,\n        use_cache: bool = False,\n        cache_position: Optional[torch.LongTensor] = None,\n    ) -> Tuple[torch.Tensor, Optional[torch.Tensor], Optional[Tuple[torch.Tensor]]]:\n        if output_attentions:\n            # TODO: Improve this warning with e.g. `model.config.attn_implementation = \"manual\"` once this is implemented.\n            logger.warning_once(\n                \"NemotronHModel is using NemotronHSdpaAttention, but `torch.nn.functional.scaled_dot_product_attention` does not support `output_attentions=True`. Falling back to the manual attention implementation, \"\n                'but specifying the manual implementation will be required from Transformers version v5.0.0 onwards. This warning can be removed using the argument `attn_implementation=\"eager\"` when loading the model.'\n            )\n            return super().forward(\n                hidden_states=hidden_states,\n                attention_mask=attention_mask,\n                position_ids=position_ids,\n                past_key_value=past_key_value,\n                output_attentions=output_attentions,\n                use_cache=use_cache,\n            )\n\n        bsz, q_len, _ = hidden_states.size()\n\n        query_states = self.q_proj(hidden_states)\n        key_states = self.k_proj(hidden_states)\n        value_states = self.v_proj(hidden_states)\n\n        query_states = query_states.view(bsz, q_len, self.num_heads, self.head_dim).transpose(1, 2)\n        key_states = key_states.view(bsz, q_len, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n        value_states = value_states.view(bsz, q_len, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n\n        if past_key_value is not None:\n            key_states, value_states = past_key_value.update(key_states, value_states, self.layer_idx)\n\n        key_states = repeat_kv(key_states, self.num_key_value_groups)\n        value_states = repeat_kv(value_states, self.num_key_value_groups)\n\n        causal_mask = attention_mask\n        if attention_mask is not None:\n            causal_mask = causal_mask[:, :, :, : key_states.shape[-2]]\n\n        # SDPA with memory-efficient backend is currently (torch==2.1.2) bugged with non-contiguous inputs with custom attn_mask,\n        # Reference: https://github.com/pytorch/pytorch/issues/112577.\n        if query_states.device.type == \"cuda\" and attention_mask is not None:\n            query_states = query_states.contiguous()\n            key_states = key_states.contiguous()\n            value_states = value_states.contiguous()\n\n        # We dispatch to SDPA's Flash Attention or Efficient kernels via this `is_causal` if statement instead of an inline conditional assignment\n        # in SDPA to support both torch.compile's dynamic shapes and full graph options. An inline conditional prevents dynamic shapes from compiling.\n        # The q_len > 1 is necessary to match with AttentionMaskConverter.to_causal_4d that does not create a causal mask in case q_len == 1.\n        is_causal = True if self.is_causal and causal_mask is None and q_len > 1 else False\n\n        attn_output = torch.nn.functional.scaled_dot_product_attention(\n            query_states,\n            key_states,\n            value_states,\n            attn_mask=causal_mask,\n            dropout_p=self.attention_dropout if self.training else 0.0,\n            is_causal=is_causal,\n        )\n\n        attn_output = attn_output.transpose(1, 2).contiguous()\n        attn_output = attn_output.view(bsz, q_len, self.hidden_size)\n\n        attn_output = self.o_proj(attn_output)\n\n        return attn_output, None, past_key_value\n\n\nNEMOTRONH_ATTENTION_CLASSES = {\n    \"eager\": NemotronHAttention,\n    \"flash_attention_2\": NemotronHFlashAttention2,\n    \"sdpa\": NemotronHSdpaAttention,\n}\n\n# Copied from transformers.models.mamba.modeling_mamba2.Mamba2PreTrainedModel\nclass NemotronHPreTrainedModel(PreTrainedModel):\n    \"\"\"\n    An abstract class to handle weights initialization and a simple interface for downloading and loading pretrained\n    models.\n    \"\"\"\n\n    config_class = NemotronHConfig\n    base_model_prefix = \"backbone\"\n    _no_split_modules = [\"NemotronHBlock\"]\n    supports_gradient_checkpointing = True\n    _is_stateful = True\n\n    def _init_weights(self, module):\n        \"\"\"Initialize the weights.\"\"\"\n        if isinstance(module, NemotronHMamba2Mixer):\n            module.A_log._no_weight_decay = True\n            module.D._no_weight_decay = True\n\n            dt = torch.exp(\n                torch.rand(self.config.mamba_num_heads)\n                * (math.log(self.config.time_step_max) - math.log(self.config.time_step_min))\n                + math.log(self.config.time_step_min)\n            ).clamp(min=self.config.time_step_floor)\n\n            # # Inverse of softplus: https://github.com/pytorch/pytorch/issues/72759\n            inv_dt = dt + torch.log(-torch.expm1(-dt))\n            with torch.no_grad():\n                module.dt_bias.copy_(inv_dt)\n            module.dt_bias._no_reinit = True\n\n        if isinstance(module, nn.Linear):\n            if module.bias is not None:\n                if not getattr(module.bias, \"_no_reinit\", False):\n                    nn.init.zeros_(module.bias)\n        elif isinstance(module, nn.Embedding):\n            nn.init.normal_(module.weight, std=self.config.initializer_range)\n\n        # TODO: Check\n        if self.config.rescale_prenorm_residual:\n            # Reinitialize selected weights subject to the OpenAI GPT-2 Paper Scheme:\n            #   > A modified initialization which accounts for the accumulation on the residual path with model depth. Scale\n            #   > the weights of residual layers at initialization by a factor of 1/√N where N is the # of residual layers.\n            #   >   -- GPT-2 :: https://openai.com/blog/better-language-models/\n            #\n            # Reference (Megatron-LM): https://github.com/NVIDIA/Megatron-LM/blob/main/megatron/model/gpt_model.py\n            for name, p in module.named_parameters():\n                if name in [\"out_proj.weight\"]:\n                    # Special Scaled Initialization --> There are 2 Layer Norms per Transformer Block\n                    # Following Pytorch init, except scale by 1/sqrt(2 * n_layer)\n                    # We need to reinit p since this code could be called multiple times\n                    # Having just p *= scale would repeatedly scale it down\n                    nn.init.kaiming_uniform_(p, a=math.sqrt(5))\n                    with torch.no_grad():\n                        p /= math.sqrt(self.config.num_hidden_layers)\n\n\n@dataclass\n# Copied from transformers.models.mamba.modeling_mamba2.Mamba2Output with MAMBA2->NemotronH,Mamba2->NemotronH\nclass NemotronHOutput(ModelOutput):\n    \"\"\"\n    Class for the NemotronH model outputs.\n\n    Args:\n        last_hidden_state (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`):\n            Sequence of hidden-states at the output of the last layer of the model.\n        cache_params (`HybridMambaAttentionDynamicCache`):\n            The state of the model at the last time step. Can be used in a forward method with the next `input_ids` to\n            avoid providing the old `input_ids`.\n\n            Includes both the State space model state matrices after the selective scan, and the Convolutional states\n        hidden_states (`tuple(torch.FloatTensor)`, *optional*, returned when `output_hidden_states=True` is passed or when `config.output_hidden_states=True`):\n            Tuple of `torch.FloatTensor` (one for the output of the embeddings, if the model has an embedding layer, +\n            one for the output of each layer) of shape `(batch_size, sequence_length, hidden_size)`.\n\n            Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.\n    \"\"\"\n\n    last_hidden_state: Optional[torch.FloatTensor] = None\n    cache_params: Optional[HybridMambaAttentionDynamicCache] = None\n    hidden_states: Optional[Tuple[torch.FloatTensor]] = None\n    attentions: Optional[Tuple[torch.FloatTensor]] = None\n\n\n@dataclass\n# Copied from transformers.models.mamba2.modeling_mamba2.MambaCausalLMOutput with Mamba2->NemotronH\nclass NemotronHCausalLMOutput(ModelOutput):\n    \"\"\"\n    Base class for causal language model (or autoregressive) outputs.\n\n    Args:\n        loss (`torch.FloatTensor` of shape `(1,)`, *optional*, returned when `labels` is provided):\n            Language modeling loss (for next-token prediction).\n        logits (`torch.FloatTensor` of shape `(batch_size, sequence_length, config.vocab_size)`):\n            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n        cache_params (`HybridMambaAttentionDynamicCache`):\n            The state of the model at the last time step. Can be used in a forward method with the next `input_ids` to\n            avoid providing the old `input_ids`.\n\n            Includes both the State space model state matrices after the selective scan, and the Convolutional states\n        hidden_states (`tuple(torch.FloatTensor)`, *optional*, returned when `output_hidden_states=True` is passed or when `config.output_hidden_states=True`):\n            Tuple of `torch.FloatTensor` (one for the output of the embeddings, if the model has an embedding layer, +\n            one for the output of each layer) of shape `(batch_size, sequence_length, hidden_size)`.\n\n            Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.\n    \"\"\"\n\n    loss: Optional[torch.FloatTensor] = None\n    logits: Optional[torch.FloatTensor] = None\n    cache_params: Optional[HybridMambaAttentionDynamicCache] = None\n    hidden_states: Optional[Tuple[torch.FloatTensor]] = None\n    attentions: Optional[Tuple[torch.FloatTensor]] = None\n\n\nNEMOTRONH_START_DOCSTRING = r\"\"\"\n\n    This model inherits from [`PreTrainedModel`]. Check the superclass documentation for the generic methods the\n    library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads\n    etc.)\n\n    This model is also a PyTorch [torch.nn.Module](https://pytorch.org/docs/stable/nn.html#torch.nn.Module) subclass.\n    Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage\n    and behavior.\n\n    Parameters:\n        config ([`NemotronHConfig`]): Model configuration class with all the parameters of the model.\n            Initializing with a config file does not load the weights associated with the model, only the\n            configuration. Check out the [`~PreTrainedModel.from_pretrained`] method to load the model weights.\n\"\"\"\n\nNEMOTRONH_INPUTS_DOCSTRING = r\"\"\"\n    Args:\n        input_ids (`torch.LongTensor` of shape `(batch_size, input_ids_length)`, *optional*):\n            Indices of input sequence tokens in the vocabulary.\n\n            If `cache_params.seqlen_offset>0`, only `input_ids` that do not have their past calculated should be passed as\n            `input_ids`.\n\n            Indices can be obtained using [`AutoTokenizer`]. See [`PreTrainedTokenizer.encode`] and\n            [`PreTrainedTokenizer.__call__`] for details.\n\n            [What are input IDs?](../glossary#input-ids)\n        inputs_embeds (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*):\n            Optionally, instead of passing `input_ids` you can choose to directly pass an embedded representation. This\n            is useful if you want more control over how to convert `input_ids` indices into associated vectors than the\n            model's internal embedding lookup matrix.\n        position_ids (`torch.LongTensor` of shape `(batch_size,)`, *optional*):\n            Indices of positions of each input sequence tokens in the position embeddings.\n        cache_params (`HybridMambaAttentionDynamicCache`, *optional*):\n            If passed along, the model uses the previous state in all the blocks (which will give the output for the\n            `input_ids` provided as if the model add `state_input_ids + input_ids` as context).\n        use_cache (`bool`, *optional*):\n            If set to `True`, the `cache_params` is returned and can be used to quickly generate the next logits.\n        output_attentions (`bool`, *optional*):\n            Whether or not to return the attentions tensors of all attention layers.\n        output_hidden_states (`bool`, *optional*):\n            Whether or not to return the hidden states of all layers. See `hidden_states` under returned tensors for\n            more detail.\n        return_dict (`bool`, *optional*):\n            Whether or not to return a [`~utils.ModelOutput`] instead of a plain tuple.\n        cache_position (`torch.LongTensor` of shape `(batch_size,)`, *optional*):\n            The position of the current input in the cache. This is used to ensure that the cache is correctly updated.\n            If `cache_params` is passed, `cache_position` should also be passed.\n        attention_mask (`torch.FloatTensor` of shape `(batch_size, sequence_length)`, *optional*):\n            Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:\n\n            - 1 for tokens that are **not masked**,\n            - 0 for tokens that are **masked**.\n\n            [What are attention masks?](../glossary#attention-mask)\n\"\"\"\n\n\n@add_start_docstrings(\n    \"The bare NemotronH Model transformer outputting raw hidden-states without any specific head on top.\",\n    NEMOTRONH_START_DOCSTRING,\n)\nclass NemotronHModel(NemotronHPreTrainedModel):\n    def __init__(self, config):\n        super().__init__(config)\n\n        self.embeddings = nn.Embedding(config.vocab_size, config.hidden_size)\n        self.layers = nn.ModuleList([NemotronHBlock(config, layer_idx=idx) for idx in range(config.num_hidden_layers)])\n\n        self.gradient_checkpointing = False\n        self.norm_f = NemotronHRMSNorm(config.hidden_size, eps=config.layer_norm_epsilon)\n        # Initialize weights and apply final processing\n        self._register_load_state_dict_pre_hook(self.load_hook)\n        self.post_init()\n\n    def load_hook(self, state_dict, prefix, *args):\n        for k in state_dict:\n            if \"embedding.\" in k:\n                state_dict[k.replace(\"embedding.\", \"embeddings.\")] = state_dict.pop(k)\n                break\n\n    def get_input_embeddings(self):\n        return self.embeddings\n\n    def set_input_embeddings(self, new_embeddings):\n        self.embeddings = new_embeddings\n\n    @add_start_docstrings_to_model_forward(NEMOTRONH_INPUTS_DOCSTRING)\n    @add_code_sample_docstrings(\n        checkpoint=_CHECKPOINT_FOR_DOC,\n        output_type=NemotronHOutput,\n        config_class=_CONFIG_FOR_DOC,\n    )\n    def forward(\n        self,\n        input_ids: Optional[torch.LongTensor] = None,\n        inputs_embeds: Optional[torch.LongTensor] = None,\n        position_ids: Optional[torch.LongTensor] = None,\n        cache_params: Optional[HybridMambaAttentionDynamicCache] = None,\n        use_cache: Optional[bool] = None,\n        output_attentions: Optional[bool] = None,\n        output_hidden_states: Optional[bool] = None,\n        return_dict: Optional[bool] = None,\n        cache_position: Optional[torch.LongTensor] = None,\n        attention_mask: Optional[torch.Tensor] = None,\n        **kwargs,\n    ) -> Union[Tuple, NemotronHOutput]:\n        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n        output_hidden_states = (\n            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n        )\n        # use_cache = use_cache if use_cache is not None else self.config.use_cache\n        use_cache = use_cache if use_cache is not None else (self.config.use_cache if not self.training else False)\n\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n\n        if (input_ids is None) ^ (inputs_embeds is not None):  # ^ is python for xor\n            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n\n        if inputs_embeds is None:\n            inputs_embeds = self.embeddings(input_ids)\n\n        if self.gradient_checkpointing and self.training and use_cache:\n            logger.warning_once(\n                \"`use_cache=True` is incompatible with gradient checkpointing. Setting `use_cache=False`.\"\n            )\n            use_cache = False\n\n        # From zamba_modeling.py\n        if use_cache and cache_params is None:\n            logger.warning_once(\n                \"NemotronH requires an initialized `NemotronHHybridDynamicCache` to return a cache. None was \"\n                \"provided, so no cache will be returned.\"\n            )\n\n        hidden_states = inputs_embeds\n\n        if cache_position is None:\n            cache_position = torch.arange(hidden_states.shape[1], device=hidden_states.device)\n        if position_ids is None:\n            position_ids = cache_position.unsqueeze(0)\n\n        causal_mask = self._update_causal_mask(attention_mask, inputs_embeds, cache_position)\n        mamba_mask = self._update_mamba_mask(attention_mask, cache_position)\n\n        all_hidden_states = () if output_hidden_states else None\n        all_self_attns = () if output_attentions else None\n        # Until HERE\n\n        for layer_idx, mixer_block in enumerate(self.layers):\n            # Depending on the layer type we opt for 2D base attention mask (Mamba) or 4D causal mask (Attention)\n            if mixer_block.block_type == \"mamba\":\n                layer_mask = mamba_mask\n            elif mixer_block.block_type == \"attention\":\n                layer_mask = causal_mask\n            elif mixer_block.block_type == \"mlp\":\n                layer_mask = None\n            else:\n                raise ValueError(f\"Invalid block_type: {self.block_type}\")\n\n            if output_hidden_states:\n                all_hidden_states += (hidden_states,)\n\n            if self.gradient_checkpointing and self.training:\n                hidden_states = self._gradient_checkpointing_func(\n                    mixer_block.__call__, hidden_states, cache_params, cache_position, layer_mask\n                )\n            else:\n                hidden_states = mixer_block(\n                    hidden_states,\n                    cache_params=cache_params,\n                    cache_position=cache_position,\n                    attention_mask=layer_mask,\n                )\n\n            # TODO: Store attentions\n            # if output_attentions:\n            #     if layer_outputs[1] is not None:\n            #         # append attentions only of attention layers. Mamba layers return `None` as the attention weights\n            #         all_self_attns += (layer_outputs[1],)\n\n            # TODO (Check): should it happen before the forward pass?\n            # if output_hidden_states:\n            #     all_hidden_states = all_hidden_states + (hidden_states,)\n\n        hidden_states = self.norm_f(hidden_states)\n\n        if output_hidden_states:\n            all_hidden_states = all_hidden_states + (hidden_states,)\n\n        if not return_dict:\n            return tuple(v for v in [hidden_states, cache_params, all_hidden_states] if v is not None)\n\n        return NemotronHOutput(\n            last_hidden_state=hidden_states,\n            cache_params=cache_params if use_cache else None,\n            hidden_states=all_hidden_states,\n            attentions=all_self_attns,\n        )\n\n    # Copied from transformers.models.jamba.modeling_jamba.JambaModel._update_causal_mask\n    def _update_causal_mask(self, attention_mask, input_tensor, cache_position):\n        if self.config._attn_implementation == \"flash_attention_2\":\n            if attention_mask is not None and 0.0 in attention_mask:\n                return attention_mask\n            return None\n\n        dtype, device = input_tensor.dtype, input_tensor.device\n        min_dtype = torch.finfo(dtype).min\n        sequence_length = input_tensor.shape[1]\n        target_length = cache_position[-1] + 1\n\n        causal_mask = torch.full((sequence_length, target_length), fill_value=min_dtype, dtype=dtype, device=device)\n        if sequence_length != 1:\n            causal_mask = torch.triu(causal_mask, diagonal=1)\n        causal_mask *= torch.arange(target_length, device=device) > cache_position.reshape(-1, 1)\n        causal_mask = causal_mask[None, None, :, :].expand(input_tensor.shape[0], 1, -1, -1)\n        if attention_mask is not None:\n            causal_mask = causal_mask.clone()  # copy to contiguous memory for in-place edit\n            if attention_mask.dim() == 2:\n                mask_length = attention_mask.shape[-1]\n                padding_mask = causal_mask[..., :mask_length].eq(0.0) * attention_mask[:, None, None, :].eq(0.0)\n                causal_mask[..., :mask_length] = causal_mask[..., :mask_length].masked_fill(padding_mask, min_dtype)\n\n        if (\n            self.config._attn_implementation == \"sdpa\"\n            and attention_mask is not None\n            and attention_mask.device.type == \"cuda\"\n        ):\n            # Attend to all tokens in fully masked rows in the causal_mask, for example the relevant first rows when\n            # using left padding. This is required by F.scaled_dot_product_attention memory-efficient attention path.\n            # Details: https://github.com/pytorch/pytorch/issues/110213\n            causal_mask = AttentionMaskConverter._unmask_unattended(causal_mask, min_dtype)\n\n        return causal_mask\n\n    def _update_mamba_mask(self, attention_mask, cache_position):\n        \"\"\"\n        No need for zeroing states when\n            1. Cached forward\n            2. Attending to all inputs\n        \"\"\"\n        mamba_mask = attention_mask\n        if cache_position[0] > 0 or (attention_mask is not None and torch.all(attention_mask == 1)):\n            mamba_mask = None\n        return mamba_mask\n\n\n@add_start_docstrings(\n    \"\"\"\n    The NEMOTRONH Model transformer with a language modeling head on top (linear layer with weights not tied to the input\n    embeddings).\n    \"\"\",\n    NEMOTRONH_START_DOCSTRING,\n)\nclass NemotronHForCausalLM(NemotronHPreTrainedModel, GenerationMixin):\n    _tied_weights_keys = [\"lm_head.weight\"]\n\n    def __init__(self, config):\n        super().__init__(config)\n        self.backbone = NemotronHModel(config)\n        self.vocab_size = config.vocab_size\n        self.lm_head = nn.Linear(config.hidden_size, config.vocab_size, bias=False)\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def get_input_embeddings(self):\n        return self.backbone.get_input_embeddings()\n\n    def set_input_embeddings(self, new_embeddings):\n        return self.backbone.set_input_embeddings(new_embeddings)\n\n    def get_output_embeddings(self):\n        return self.lm_head\n\n    def set_output_embeddings(self, new_embeddings):\n        self.lm_head = new_embeddings\n\n    def get_decoder(self):\n        return self.model\n\n    def set_decoder(self, decoder):\n        self.model = decoder\n\n    def prepare_inputs_for_generation(\n        self,\n        input_ids,\n        past_key_values=None,\n        attention_mask=None,\n        inputs_embeds=None,\n        cache_position=None,\n        position_ids=None,\n        use_cache=True,\n        **kwargs,\n    ):\n        # Copy from https://github.com/huggingface/transformers/blob/main/src/transformers/models/jamba/modeling_jamba.py\n        # Overwitten -- uses `cache_params` as opposed to `past_key_values`\n        empty_past_kv = past_key_values is None\n\n        # If we have cache: let's slice `input_ids` through `cache_position`, to keep only the unprocessed tokens\n        # Exception 1: when passing input_embeds, input_ids may be missing entries\n        # Exception 2: some generation methods do special slicing of input_ids, so we don't need to do it here\n        # Exception 3: with synced GPUs cache_position may go out of bounds, but we only want dummy token in that case.\n        #              (we can't check exception 3 while compiling)\n        if not empty_past_kv:\n            if (\n                inputs_embeds is not None  # Exception 1\n                or cache_position[-1] >= input_ids.shape[1]  # Exception 3\n            ):\n                input_ids = input_ids[:, -cache_position.shape[0] :]\n            elif input_ids.shape[1] != cache_position.shape[0]:  # Default case (the \"else\", a no op, is Exception 2)\n                input_ids = input_ids[:, cache_position]\n        else:\n            past_key_values = HybridMambaAttentionDynamicCache(\n                self.config, input_ids.shape[0], self.dtype, device=self.device\n            )\n\n        if attention_mask is not None and position_ids is None:\n            # create position_ids on the fly for batch generation\n            position_ids = attention_mask.long().cumsum(-1) - 1\n            position_ids.masked_fill_(attention_mask == 0, 1)\n            if not empty_past_kv:\n                position_ids = position_ids[:, -input_ids.shape[1] :]\n\n        # if `inputs_embeds` are passed, we only want to use them in the 1st generation step\n        if inputs_embeds is not None and empty_past_kv:\n            # TODO(pjin): workaround fix for properly extending inputs_embeds;\n            # longer term, may be better handled elsewhere in .generate().\n            if input_ids is not None and inputs_embeds.shape[1] < input_ids.shape[1]:\n                new_token_embeds = self.get_input_embeddings()(input_ids[:,inputs_embeds.shape[1]:])\n                inputs_embeds = torch.cat([inputs_embeds, new_token_embeds], dim=1)\n            model_inputs = {\"inputs_embeds\": inputs_embeds}\n        else:\n            model_inputs = {\"input_ids\": input_ids.contiguous()}  # `contiguous()` needed for compilation use cases\n\n        model_inputs.update(\n            {\n                \"position_ids\": position_ids,\n                \"past_key_values\": past_key_values,\n                \"use_cache\": use_cache,\n                \"attention_mask\": attention_mask,\n                \"logits_to_keep\": self.config.num_logits_to_keep,\n                \"cache_position\": cache_position,\n            }\n        )\n        return model_inputs\n\n    @add_start_docstrings_to_model_forward(NEMOTRONH_INPUTS_DOCSTRING)\n    @add_code_sample_docstrings(\n        checkpoint=_CHECKPOINT_FOR_DOC,\n        output_type=NemotronHCausalLMOutput,\n        config_class=_CONFIG_FOR_DOC,\n    )\n    def forward(\n        self,\n        input_ids: Optional[torch.LongTensor] = None,\n        inputs_embeds: Optional[torch.FloatTensor] = None,\n        position_ids: Optional[torch.LongTensor] = None,\n        cache_params: Optional[HybridMambaAttentionDynamicCache] = None,\n        labels: Optional[torch.LongTensor] = None,\n        output_attentions: Optional[bool] = None,\n        output_hidden_states: Optional[bool] = None,\n        return_dict: Optional[bool] = None,\n        use_cache: Optional[bool] = None,\n        cache_position: Optional[torch.Tensor] = None,\n        attention_mask: Optional[torch.Tensor] = None,\n        **kwargs,  # for now we need this for generation\n    ) -> Union[Tuple, NemotronHCausalLMOutput]:\n        r\"\"\"\n        labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n            Labels for language modeling. Note that the labels **are shifted** inside the model, i.e. you can set\n            `labels = input_ids` Indices are selected in `[-100, 0, ..., config.vocab_size]` All labels set to `-100`\n            are ignored (masked), the loss is only computed for labels in `[0, ..., config.vocab_size]`\n        \"\"\"\n        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n\n        output_hidden_states = (\n            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n        )\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n\n        nemotron_h_outputs = self.backbone(\n            input_ids,\n            cache_params=cache_params,\n            inputs_embeds=inputs_embeds,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n            use_cache=use_cache,\n            cache_position=cache_position,\n            attention_mask=attention_mask,\n        )\n        hidden_states = nemotron_h_outputs[0]\n\n        # TODO: Check zamba_modeling.py: https://github.com/huggingface/transformers/blob/d7188ba600e36d3fd191b12e19f1b3bb81a8404f/src/transformers/models/zamba/modeling_zamba.py#L1284C1-L1286C2\n        #logits = self.lm_head(hidden_states.to(self.lm_head.weight.dtype)).float()\n        logits = self.lm_head(hidden_states.to(self.lm_head.weight.dtype)).float()\n\n        loss = None\n        if labels is not None:\n            # move labels to correct device to enable model parallelism\n            labels = labels.to(logits.device)\n            # Shift so that tokens < n predict n\n            shift_logits = logits[..., :-1, :].contiguous()\n            shift_labels = labels[..., 1:].contiguous()\n            # Flatten the tokens\n            loss_fct = CrossEntropyLoss()\n            loss = loss_fct(shift_logits.view(-1, shift_logits.size(-1)), shift_labels.view(-1))\n\n        if not return_dict:\n            output = (logits,) + nemotron_h_outputs[1:]\n            return ((loss,) + output) if loss is not None else output\n\n        return NemotronHCausalLMOutput(\n            loss=loss,\n            logits=logits,\n            cache_params=nemotron_h_outputs.cache_params,\n            hidden_states=nemotron_h_outputs.hidden_states,\n            attentions=nemotron_h_outputs.attentions,\n        )\n",
        "nemotron_toolcall_parser_no_streaming.py": "# SPDX-License-Identifier: Apache-2.0\n\nimport ast\nimport json\nimport re\nfrom collections.abc import Sequence\nfrom typing import Union\n\nimport partial_json_parser\nfrom partial_json_parser.core.options import Allow\n\nfrom vllm.entrypoints.openai.protocol import (\n    ChatCompletionRequest,\n    DeltaFunctionCall, DeltaMessage,\n    DeltaToolCall,\n    ExtractedToolCallInformation,\n    FunctionCall,\n    ToolCall,\n)\nfrom vllm.entrypoints.openai.tool_parsers.abstract_tool_parser import (\n    ToolParser,\n    ToolParserManager,\n)\nfrom vllm.logger import init_logger\nfrom vllm.transformers_utils.tokenizer import AnyTokenizer\nfrom vllm.utils import random_uuid\n\nlogger = init_logger(__name__)\n\n\n@ToolParserManager.register_module(\"nemotron_json\")\nclass NemotronJSONToolParser(ToolParser):\n\n    def __init__(self, tokenizer: AnyTokenizer):\n        super().__init__(tokenizer)\n\n        self.current_tool_name_sent: bool = False\n        self.prev_tool_call_arr: list[dict] = []\n        self.current_tool_id: int = -1\n        self.streamed_args_for_tool: list[str] = []\n\n        self.tool_call_start_token: str = \"<TOOLCALL>\"\n        self.tool_call_end_token: str = \"</TOOLCALL>\"\n\n        self.tool_call_regex = re.compile(r\"<TOOLCALL>(.*?)</TOOLCALL>\", re.DOTALL)\n\n    def extract_tool_calls(\n        self,\n        model_output: str,\n        request: ChatCompletionRequest,\n    ) -> ExtractedToolCallInformation:\n\n        if self.tool_call_start_token not in model_output:\n            return ExtractedToolCallInformation(\n                tools_called=False,\n                tool_calls=[],\n                content=model_output,\n            )\n\n        else:\n\n            try:\n                str_tool_calls = self.tool_call_regex.findall(model_output)[0].strip()\n                if not str_tool_calls.startswith(\"[\"):\n                    str_tool_calls = \"[\" + str_tool_calls\n                if not str_tool_calls.endswith(\"]\"):\n                    str_tool_calls = \"]\" + str_tool_calls\n                json_tool_calls = json.loads(str_tool_calls)\n                tool_calls = []\n                for tool_call in json_tool_calls:\n                    try:\n                        tool_calls.append(ToolCall(\n                            type=\"function\",\n                            function=FunctionCall(\n                                name=tool_call[\"name\"],\n                                arguments=json.dumps(tool_call[\"arguments\"], ensure_ascii=False) \\\n                                    if isinstance(tool_call[\"arguments\"], dict) else tool_call[\"arguments\"],\n                            ),\n                        ))\n                    except:\n                        continue\n\n                content = model_output[:model_output.rfind(self.tool_call_start_token)]\n\n                return ExtractedToolCallInformation(\n                    tools_called=True,\n                    tool_calls=tool_calls,\n                    content=content if content else None,\n                )\n\n            except Exception:\n                logger.exception(f\"Error in extracting tool call from response. Response: {model_output}\")\n                return ExtractedToolCallInformation(\n                    tools_called=False,\n                    tool_calls=[],\n                    content=model_output,\n                )\n\n    def extract_tool_calls_streaming(\n        self,\n        previous_text: str,\n        current_text: str,\n        delta_text: str,\n        previous_token_ids: Sequence[int],\n        current_token_ids: Sequence[int],\n        delta_token_ids: Sequence[int],\n        request: ChatCompletionRequest,\n    ) -> Union[DeltaMessage, None]:\n\n        raise NotImplementedError(\"Tool calling is not supported in streaming mode!\")\n"
    }
}