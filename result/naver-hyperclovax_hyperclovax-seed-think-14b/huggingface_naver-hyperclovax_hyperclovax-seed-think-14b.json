{
    "model_id": "naver-hyperclovax/hyperclovax-seed-think-14b",
    "files": [
        ".gitattributes",
        "LICENSE",
        "README.md",
        "added_tokens.json",
        "config.json",
        "configuration_hyperclovax.py",
        "generation_config.json",
        "merges.txt",
        "model-00001-of-00012.safetensors",
        "model-00002-of-00012.safetensors",
        "model-00003-of-00012.safetensors",
        "model-00004-of-00012.safetensors",
        "model-00005-of-00012.safetensors",
        "model-00006-of-00012.safetensors",
        "model-00007-of-00012.safetensors",
        "model-00008-of-00012.safetensors",
        "model-00009-of-00012.safetensors",
        "model-00010-of-00012.safetensors",
        "model-00011-of-00012.safetensors",
        "model-00012-of-00012.safetensors",
        "model.safetensors.index.json",
        "modeling_hyperclovax.py",
        "special_tokens_map.json",
        "tokenizer.json",
        "tokenizer_config.json",
        "vocab.json"
    ],
    "readme": "---\nlicense: other\nlicense_name: hyperclovax-seed\nlicense_link: LICENSE\nlibrary_name: transformers\n---\n\n![image/png](https://cdn-uploads.huggingface.co/production/uploads/6512d9827fccffe1e9e28fa7/7BT1W9eHLQjRCCENwcXmE.png)\n\n## Overview\n\nHyperCLOVA X SEED 14B Think is a next-generation language model that moves beyond the conventional approach of simply increasing model size to improve performance. It combines [HyperCLOVA X’s lightweighting technology](https://tinyurl.com/y3hrfz67) for building high-efficiency LLMs with advanced reasoning capabilities. Its development relied on two key technologies: (1) Pruning & Knowledge Distillation, which achieves both compactness and high performance, and (2) a Reinforcement Learning (RL) pipeline, which maximizes reasoning ability. By pruning low-importance parameters and distilling knowledge from a large model into a smaller one, training costs have been significantly reduced. On top of this, [the latest RL recipe validated in HyperCLOVA X Think](https://arxiv.org/pdf/2506.22403) is applied in a multi-stage process: (1) Supervised Fine-Tuning (SFT), (2) Reinforcement Learning with Verifiable Rewards (RLVR), (3) Length Controllability (LC) for reasoning path optimization, and (4) a joint training of Reinforcement Learning from Human Feedback (RLHF) and RLVR.\n\nIt is a considerable challenge to equip a pruned, knowledge-distilled model with reasoning capabilities, since reductions in training costs and model size often degrade reasoning performance. However, through extensive research experience and persistent trial and error, the HyperCLOVA X team has succeeded in lowering training costs while maintaining reasoning performance comparable to that of larger, resource-intensive models.\n\n\n## Basic Information\n\n- **Architecture** : Transformer-based architecture with Peri-Layer Normalization and Maximal Update Parameterization(μP) (Dense Model)\n- **Parameters** : 14.74B\n- **Input/Output Format** (Input/Output) : Text / Text\n- **Context Length** : 32k\n\n## Training Cost\n\n`HyperCLOVA X SEED 14B Think` was trained at a significantly lower cost compared to high-performance external models of similar scale. By utilizing HCX’s lightweight training pipeline, it was trained at approximately **52.60×** lower cost than `Qwen2.5-14B` and **91.38×** lower cost than `Qwen3-14B`.\n\n| Model (Base)                    | GPU Hours (A100-80GB, MFU 50%)     |\n| ------------------------------- | ---------------------------------- |\n| **HyperCLOVA X SEED 14B Think** | **68,049**                         |\n| Qwen2.5-0.5B                    | 169,257                            |\n| Qwen2.5-1.5B                    | 449,643                            |\n| Qwen3-0.6B                      | 602,460                            |\n| Qwen3-1.7B                      | 1,063,991                          |\n| HyperCLOVA X Think              | 2,197,732                          |\n| **Qwen2.5-14B**                 | **3,603,432**                      |\n| Qwen3-8B                        | 3,993,607                          |\n| **Qwen3-14B**                   | **6,267,077**                      |\n| Qwen3-32B                       | 14,108,748                         |\n\n## Benchmarks\n\nCompared to global models of a similar scale, such as Qwen3 14B, HyperCLOVA X SEED 14B Think demonstrates superior performance in Korean language and cultural understanding, while showing competitive performance in math and coding tasks, which are directly or indirectly related to agent capabilities. This trend remains consistent even when compared with larger models like Qwen3 32B and LG Exaone-Deep 32B.\n\n### Backbone Benchmarks Performance Comparison (Non-think)\n\n**Korean/Korea Culture**\n\n| Model                           | Average | CLIcK  | HAERAE-Bench | KOBEST | KorMedMCQA | KMMLU  | KoBigBench | KoCommonGEN-v2 | \n| ------------------------------- | ------- | ------ | ------------ | ------ | ---------- | ------ | ---------- | -------------- | \n| **HyperCLOVA X SEED 14B Think** | 0.7269  | 0.7208 | 0.8506       | 0.8570 | 0.6411     | 0.5428 | 0.7482     | 0.6682         | \n| QWEN3-8B                        | 0.6759  | 0.6206 | 0.6618       | 0.7919 | 0.6471     | 0.5543 | 0.7186     | 0.5773         |\n| QWEN3-14B                       | 0.7079  | 0.6707 | 0.6975       | 0.8174 | 0.6979     | 0.5864 | 0.7507     | 0.5927         |\n\n\n**English/American Culture**\n| Model                           | Average | MMLU   | BigBench-Hard | Hellaswag | Winogrande | PIQA   | ARC-challenge | Social IQa |\n| ------------------------------- | ------- | ------ | ------------- | --------- | ---------- | ------ | ------------- | ---------- |\n| **HyperCLOVA X SEED 14B Think** | 0.6614  | 0.7121 | 0.6216        | 0.6125    | 0.7593     | 0.7791 | 0.6246        | 0.5205     |\n| QWEN3-8B                        | 0.6548  | 0.7490 | 0.6072        | 0.5817    | 0.7198     | 0.7666 | 0.6433        | 0.5159     |\n| QWEN3-14B                       | 0.6807  | 0.7885 | 0.6325        | 0.6143    | 0.7356     | 0.8025 | 0.6698        | 0.5215     |\n\n\n### Reasoning Performance Comparison\n\n**Korean/Korea Culture**\n| Model | KMMLU | CSAT-ko-2025 | KorMedMCQA | KoBALT | HAERAE | CLIcK | KoBigBench | LogicKor |\n|-----------------------------------------|--------|--------|--------|--------|--------|--------|--------|------|\n| HyperCLOVA X SEED 14B Think **(Think)** | 0.6649 | 0.7516 | 0.6933 | 0.4500 | 0.8537 | 0.7280 | 0.7974 | 8.74 |\n| QWEN3-8B                                | 0.5543 | 0.7200 | 0.6782 | 0.3060 | 0.6618 | 0.6690 | 0.7850 | 8.92 |\n| QWEN3-14B                               | 0.4930 | 0.7710 | 0.6850 | 0.3840 | 0.7410 | 0.6880 | 0.8380 | 9.15 |\n\n**Coding/Math**\n| Model | GSM8k | MATH500 | HumanEval | MBPP |\n|-----------------------------------------|--------|--------|--------|--------|\n| HyperCLOVA X SEED 14B Think | 0.9553 | 0.9380 | 0.9451 | 0.8759 |\n| QWEN3-14B                   | 0.9590 | 0.9680 | 0.9570 | 0.9080 |\n\n\n### Non-Think / Think Performance Comparison\n\n| Model | GSM8k | GPT4Eval | MT Bench | Arena-Hard-v0.1 |\n|---------------------------------------------|--------|--------|--------|--------|\n| HyperCLOVA X SEED 14B Think **(Non-think)** | 0.9348 | 0.6741 | 8.2063 | 0.2733 |\n| HyperCLOVA X SEED 14B Think **(Think)**     | 0.9553 | 0.8200 | 8.8313 | 0.5826 |\n\n\n## ChatML Block\n\nThe chat template for HyperCLOVA X consists of the following elements.\n\n- **tool_list** : A list of tools available to the model (in JSON format). If no tools are available, an empty block should be provided.\n- **system** : System prompt. If not are available, an empty block should be provided.\n- **user** : User input.\n- **assistant** : Assistant output.\n\nThe basic configuration of ChatML block is as follows.\n\n```\n<|im_start|>{tool_list/system/user/assistant}\n{content}<|im_end|>\n```\n\n- `<|im_start|>` : Start token of ChatML block\n- `<|im_end|>` : End token of ChatML block\n\n## (ChatML) General Conversation\n\n### First turn\n\nGiven a two-turn conversation between the user and the assistant (`user_query_1`, `assistant_answer_1`, `user_query_2`, `assistant_answer_2`), the prompt for the first-turn can be constructed in its simplest form as follows:\n\n```\n<|im_start|>tool_list\n<|im_end|>\n<|im_start|>system\n- You are \"CLOVA X,\" an AI language model developed by NAVER.  \n- The current date is {day of the week}, {month} {dd}, {yyyy}.<|im_end|>\n<|im_start|>user\n{user_query_1}<|im_end|>\n<|im_start|>assistant\n```\n\nAfter the `<|im_end|>` token (indicating the end of the ChatML block), the model generates text up to the `<|endofturn|>` token. This output corresponds to the assistant's first response (`assistant_answer_1`).\n\n### Second turn\n\nBased on the assistant's first response (`assistant_answer_1`), when the user asks an additional question (`user_query_2`), the prompt input to the model is constructed as follows:\n\n```\n{following the previous context}\n{assistant_answer_1}<|im_end|><|endofturn|>\n<|im_start|>user\n{user_query_2}<|im_end|>\n<|im_start|>assistant\n```\n\nAs in the previous turn, generation continues until the `<|endofturn|>` token appears after `<|im_end|>`. This corresponds to the assistant's second response (`assistant_answer_2`).\n\n## (ChatML) Function Call (Using Tools)\n\nInsert the list of tools available into the tool_list block as a JSON list. For example, the following is a case where the only available tool is `get_weather`.\n\n```\n<|im_start|>tool_list\n[{\"name\": \"get_weather\", \"description\": \"Check the current weather at the requested location.\", \"parameters\": {\"type\": \"object\", \"properties\": {\"location\": {\"type\": \"string\", \"description\": \"Name of the city\"}}, \"required\": [\"location\"]}}]<|im_end|>\n```\n\nAdditional instructions can be included in the system prompt if needed, and it is recommended to format them as `- {content}`. For example:\n\n```\n<|im_start|>system\n- In this environment, various tools can be used to answer users' questions.\n- You are \"CLOVA X,\" an AI language model developed by NAVER.  \n- Begin by creating a plan for solving the problem, and then utilize the tools accordingly to address the problem.\n- The current date is {day of the week}, {month} {dd}, {yyyy}.\n- Latest information such as news, stock prices, and shopping is retrieved through the tool_list.\n- If external tools are required, the assistant should not answer directly but must first obtain the necessary information via the assistant -> tool/function_call role, and then respond.<|im_end|>\n```\n\n### First turn\n\nSuppose the user gives the instruction, 'Tell me the weather in Seoul.' The prompt input to the model would then be as follows:\n\n```\n<|im_start|>tool_list\n[{\"name\": \"get_weather\", \"description\": \"Check the current weather at the requested location.\", \"parameters\": {\"type\": \"object\", \"properties\": {\"location\": {\"type\": \"string\", \"description\": \"Name of the city\"}}, \"required\": [\"location\"]}}]<|im_end|>\n<|im_start|>system\n- In this environment, various tools can be used to answer users' questions.\n- You are \"CLOVA X,\" an AI language model developed by NAVER.  \n- Begin by creating a plan for solving the problem, and then utilize the tools accordingly to address the problem.\n- The current date is {day of the week}, {month} {dd}, {yyyy}.\n- Latest information such as news, stock prices, and shopping is retrieved through the tool_list.\n- If external tools are required, the assistant should not answer directly but must first obtain the necessary information via the assistant -> tool/function_call role, and then respond.<|im_end|>\n<|im_start|>user\nTell me the weather in Seoul<|im_end|>\n<|im_start|>assistant\n```\n\nGeneration continues until either the `<|stop|>` or `<|endofturn|>` token appears immediately after `<|im_end|>`. An example of the model’s output is shown below. HyperCLOVA X checks the list of available tools (tool_list), selects the appropriate tool (`get_weather`), and returns the necessary information for the tool call in JSON format.\n\n```\n{following the previous context}\nLet's check the weather using the get_weather tool.<|im_end|>\n<|im_start|>assistant -> tool/function_call\n{\"name\": \"get_weather\",\"input\": {\"location\":\"Seoul\"}}<|im_end|><|stop|>\n```\n\n- `assistant -> tool/function_call` means that the assistant(model) invokes a function call.\n\n### Second turn\n\nThe model stopped generating because `<|stop|>` token appeared immediately after `<|im_end|>`. Based on the information generated, `get_weather`should now be called. Calling an external function and parsing the result must be implemented additionally. For explanation, let's assume that the result of calling and parsing an external function is `{\"result\":{\"location\": \"Seoul\", \"weather\": \"Sunny\", \"temperature\": 25}}`.\n\nThe model is now ready to respond to the second turn. Using all the information gathered so far, input the following prompt into the model and have it follow accordingly.\n\n```\n{following the previous context}\n<|im_start|>tool/function_call\n{\"result\":{\"location\": \"Seoul\", \"weather\": \"Sunny\", \"temperature\": 25}}<|im_end|>\n<|im_start|>assistant\n```\n\n- `tool/function_call` means it should pass the result of the function call to the assistant(model).\n\nJust like in the previous turn, generation continues until the `<|stop|>` or `<|endofturn|>` token appears immediately after `<|im_end|>`. If the model behaves as expected, the output will look like this.\n\n```\n{following the previous context}\nThe weather in Seoul is clear and the temperature is 25 degrees.<|im_end|><|endofturn|>\n```\n\n## (ChatML) Inducing reasoning/non-reasoning\n\n\nHyperCLOVA X can handle both reasoning and non-reasoning tasks. There is a difference depending on whether the assistant is prompted to 'think' before responding. Based on the previous example, to make HyperCLOVA X respond in reasoning mode, you can input the prompt into the model as follows (excluding the tool_list and system)\n\n```\n<|im_start|>user\nTell me the weather in Seoul<|im_end|>\n<|im_start|>assistant/think\n\n```\n\n- Note that the prompt ends with `assistant/think\\n`(think + `\\n).\n- Generation continues until either the <|stop|> or <|endofturn|> token appears immediately after `<|im_end|>`.\n\nTo have the assistant respond in non-reasoning mode (i.e., answer directly), you can input the following prompt.\n\n```\n<|im_start|>user\nTell me the weather in Seoul<|im_end|>\n<|im_start|>assistant\n\n```\n\n- Note that the prompt ends with `assistant\\n`(assistant + `\\n`).\n- Generation continues until either the <|stop|> or <|endofturn|> token appears immediately after `<|im_end|>`.\n\n\n### Adjusting inference length\nThe length of reasoning can be controlled by appending \"\\nThink for maximum {N} tokens\" at the end of the user's utterance.\n\nExample\nSuppose the user says, \"Tell me the prime number closest to 1000.\"\nIf you want the model to reason for approximately 1024 tokens before answering, you would construct the prompt as follows:\n\n\n```\n<|im_start|>tool_list\n<|im_end|>\n<|im_start|>system\n- You are \"CLOVA X,\" an AI language model developed by NAVER.  \n- The current date is {day of the week}, {month} {dd}, {yyyy}.<|im_end|>\n<|im_start|>user\nTell me the prime number closest to 1000.\nThink for maximum 1024 tokens.<|im_end|>\n<|im_start|>assistant/think\n\n```\n- Adjusting the reasoning length means guiding the model to reason for approximately the specified number of tokens; it does not always generate for exact number of tokens given.\n\n\n### Multiturn inference\n\nWhen engaging in multi-turn conversations with reasoning enabled, the reasoning content from previous turns (`<|im_start|>assistant/think\\n...<|im_end|>`) is not included in the next turn's prompt. Instead, as in the standard multi-turn dialogue format, only the final assistant response is included in the prompt passed to the model.\n\nThe same applies when a function call is made during reasoning: the reasoning content is excluded, and only the function call block (`<|im_start|>assistant -> tool/function_call\\n...<|im_end|><|stop|>`) is included in the prompt provided to the model.\n\nExample: Solving a simple math problem\nSuppose the user sends a request: \"Calculate the sum of odd numbers from 1 to 10.\"\nThe following explains step-by-step how this is processed as a multi-turn reasoning interaction.\n\n1. First Turn\nInput Prompt\n```\n<|im_start|>tool_list\n<|im_end|>\n<|im_start|>system\n<|im_end|>\n<|im_start|>user\nCalculate the sum of odd numbers from 1 to 10\n<|im_end|>\n<|im_start|>assistant/think\n\n```\nThe model begins to generate inference contents.\n```\n{following the previous context}\nThe user wants me to find the sum of the odd numbers from 1 to 10. First, I need to clearly understand the problem. I should identify which numbers between 1 and 10 are odd. Going through the numbers in order, the odd numbers are 1, 3, 5, 7, and 9. Since 10 is even, it is excluded. Now, I need to add these numbers together. Adding them step by step: 1+3=4, plus 5 gives 9, plus 7 gives 16, and finally adding 9 gives 25. But is there another way to calculate this? For example, I could use the formula for the sum of an arithmetic sequence. The odd numbers here form an arithmetic sequence with the first term 1 and a common difference of 2. I need to count the number of terms first—there are 5 odd numbers between 1 and 10. The formula for the sum of an arithmetic sequence is n*(a₁ + aₙ)/2, where n is 5, a₁ is 1, and aₙ is 9. Plugging these in, we get 5*(1 + 9)/2 = 5*10/2 = 25, which matches the previous result. Since both methods give 25, I’ll double-check that this is the answer the user expects, and then provide a concise explanation.<|im_end|>\n<|im_start|>assistant\nThe odd numbers from 1 to 10 are **1, 3, 5, 7, 9**.\nThe sum of these numbers is calculated as follows:\n\n\\[\n1 + 3 + 5 + 7 + 9 = 25\n\\]\n\nAlternatively, the sum can be easily calculated using **the formula for the sum of an arithmetic sequence**:\n- First term (\\(a_1\\)) = 1\n- Last term (\\(a_n\\)) = 9\n- Number of terms (\\(n\\)) = 5\n\n\\[\n\\text{Sum} = \\frac{n(a_1 + a_n)}{2} = \\frac{5 \\times (1 + 9)}{2} = \\frac{5 \\times 10}{2} = 25\n\\]\n\n**Result:** The answer is **25**.<|im_end|><|endofturn|>\n```\nAs the `<|endofturn|>` token has been generated, the model concludes the current turn and awaits the next user input.\n\n2. Second Turn\nSuppose you want to follow up with: \"What is the result of adding 10 to that sum?\" Here, the prompt is created by excluding the reasoning content (assistant/think) from the first turn and including only the final response (assistant).\n\n- Input Prompt\n\n```\n<|im_start|>tool_list\n<|im_end|>\n<|im_start|>system\n<|im_end|>\n<|im_start|>user\nCalculate the sum of odd numbers from 1 to 10\n<|im_end|>\n<|im_start|>assistant\nThe odd numbers from 1 to 10 are **1, 3, 5, 7, 9**.\nThe sum of these numbers is calculated as follows:\n\n\\[\n1 + 3 + 5 + 7 + 9 = 25\n\\]\n\nAlternatively, the sum can be easily calculated using **the formula for the sum of an arithmetic sequence**:\n- First term (\\(a_1\\)) = 1\n- Last term (\\(a_n\\)) = 9\n- Number of terms (\\(n\\)) = 5\n\n\\[\n\\text{Sum} = \\frac{n(a_1 + a_n)}{2} = \\frac{5 \\times (1 + 9)}{2} = \\frac{5 \\times 10}{2} = 25\n\\]\n\n**Result:** The answer is **25**.<|im_end|><|endofturn|>\n<|im_end|>\n<|im_start|>user\nWhat is the result of adding 10 to that sum?\n<|im_end|>\n<|im_start|>assistant/think\n\n```\n\n- Excluded contents in the second turn input\n```\n<|im_start|>assistant/think\n{following the previous context}\nThe user wants me to find the sum of the odd numbers from 1 to 10. First, I need to clearly understand the problem. I should identify which numbers between 1 and 10 are odd. Going through the numbers in order, the odd numbers are 1, 3, 5, 7, and 9. Since 10 is even, it is excluded. Now, I need to add these numbers together. Adding them step by step: 1+3=4, plus 5 gives 9, plus 7 gives 16, and finally adding 9 gives 25. But is there another way to calculate this? For example, I could use the formula for the sum of an arithmetic sequence. The odd numbers here form an arithmetic sequence with the first term 1 and a common difference of 2. I need to count the number of terms first—there are 5 odd numbers between 1 and 10. The formula for the sum of an arithmetic sequence is n*(a₁ + aₙ)/2, where n is 5, a₁ is 1, and aₙ is 9. Plugging these in, we get 5*(1 + 9)/2 = 5*10/2 = 25, which matches the previous result. Since both methods give 25, I’ll double-check that this is the answer the user expects, and then provide a concise explanation.<|im_end|>\n```\n\nFor all later turns, the reasoning (think) content from previous turns is not added to the prompt as well.\n\n### Difference between <|stop|> and <|endofturn|>\n\n- **Similarity**\n    - They both act as signals to stop the model from generating further responses.\n\n- **Difference**\n    - <|stop|>: After the response generation is halted and the tool_invoke results are processed, the AI turn resumes.\n    - <|endofturn|>: After the response generation is halted, the AI turn is fully terminated, and the model waits for the user's next input.\n\n\n## **Huggingface Usage Example**\n\nAfter downloading the model binaries, including the configuration files, to a local path(`/path/to/hyperclova-x-seed-think-14b`), you can run the following in a Python environment with the [Huggingface library](https://huggingface.co/docs/transformers/installation)(verified to work with version >= 4.53.0) and [timm(pytorch-image-models)](https://github.com/huggingface/pytorch-image-models) installed.\n\nYou can use the `apply_chat_template` parameter to explicitly enable or disable the reasoning feature.\n\n- The default value for both options is `None`, in which case the model decides on its own whether to reason before answering or to answer directly without reasoning.\n- `force_reasoning=True`: Forces the model to always reason before answering.\n- `skip_reasoning=True`: Forces the model to answer directly without reasoning.\n- Passing `None` or `False` has the same effect.\n- If both are set to True, `force_reasoning=True` takes precedence.\n\n```python\n# Default example\ninputs = tokenizer.apply_chat_template(chat, add_generation_prompt=True, return_dict=True, return_tensors=\"pt\")\n\n# By adding force_reasoning=True, the model is forced to always reason before responding\ninputs = tokenizer.apply_chat_template(chat, add_generation_prompt=True, force_reasoning=True, return_dict=True, return_tensors=\"pt\")\n\n# By adding skip_reasoning=True, the model is forced to always answer directly without reasoning\ninputs = tokenizer.apply_chat_template(chat, add_generation_prompt=True, skip_reasoning=True, return_dict=True, return_tensors=\"pt\")\n```\n\n### Non-think Example Code\n```python\nfrom transformers import AutoModelForCausalLM, AutoTokenizer\n\nmodel_name = \"naver-hyperclovax/HyperCLOVAX-SEED-Think-14B\"\nmodel = AutoModelForCausalLM.from_pretrained(model_name, trust_remote_code=True, device_map=\"auto\")\ntokenizer = AutoTokenizer.from_pretrained(model_name)\n\nchat = [\n  {\"role\": \"system\", \"content\": \"- In this environment, various tools can be used to answer users' questions.\\n- You are \\\"CLOVA X,\\\" an AI language model developed by NAVER.\\n- Begin by creating a plan for solving the problem, and then utilize the tools accordingly to address the problem.\\n- The current date is Monday, July 21, 2025.\\n- Latest information such as news, stock prices, and shopping is retrieved through the tool_list.\\n- If external tools are required, the assistant should not answer directly but must first obtain the necessary information via the assistant -> tool/function_call role, and then respond.\"},\n  {\"role\": \"user\", \"content\": \"Explain in as much detail as possible the relationship between the Schrödinger equation and quantum mechanics.\"},\n]\n\n# By adding skip_reasoning=True, the model is forced to always answer directly without reasoning\ninputs = tokenizer.apply_chat_template(chat, add_generation_prompt=True, skip_reasoning=True, return_dict=True, return_tensors=\"pt\")\ninputs = inputs.to(\"cuda\")\n\noutput_ids = model.generate(\n    **inputs,\n    max_length=1024,\n    stop_strings=[\"<|endofturn|>\", \"<|stop|>\"],\n    temperature=0.5,\n    top_p=0.6,\n    repetition_penalty=1.05,\n    tokenizer=tokenizer\n)\nprint(tokenizer.batch_decode(output_ids))\n```\n\n### Think Example Code\n```python\nfrom transformers import AutoModelForCausalLM, AutoTokenizer\n\nmodel_name = \"naver-hyperclovax/HyperCLOVAX-SEED-Think-14B\"\nmodel = AutoModelForCausalLM.from_pretrained(model_name, trust_remote_code=True, device_map=\"auto\")\ntokenizer = AutoTokenizer.from_pretrained(model_name)\n\nchat = [\n  {\"role\": \"system\", \"content\": \"- In this environment, various tools can be used to answer users' questions.\\n- You are \\\"CLOVA X,\\\" an AI language model developed by NAVER.\\n- Begin by creating a plan for solving the problem, and then utilize the tools accordingly to address the problem.\\n- The current date is Monday, July 21, 2025.\\n- Latest information such as news, stock prices, and shopping is retrieved through the tool_list.\\n- If external tools are required, the assistant should not answer directly but must first obtain the necessary information via the assistant -> tool/function_call role, and then respond.\"},\n  {\"role\": \"user\", \"content\": \"Explain in as much detail as possible the relationship between the Schrödinger equation and quantum mechanics.\"},\n]\n\n# By adding force_reasoning=True, the model is forced to always reason before responding\ninputs = tokenizer.apply_chat_template(chat, add_generation_prompt=True, force_reasoning=True, return_dict=True, return_tensors=\"pt\")\ninputs = inputs.to(\"cuda\")\n\noutput_ids = model.generate(\n    **inputs,\n    max_length=1024,\n    stop_strings=[\"<|endofturn|>\", \"<|stop|>\"],\n    temperature=0.5,\n    top_p=0.6,\n    repetition_penalty=1.05,\n    tokenizer=tokenizer\n)\nprint(tokenizer.batch_decode(output_ids))\n```\n\n### Hybrid(the model decides whether to use think or non-think mode) Example Code\n```python\nfrom transformers import AutoModelForCausalLM, AutoTokenizer\n\nmodel_name = \"naver-hyperclovax/HyperCLOVAX-SEED-Think-14B\"\nmodel = AutoModelForCausalLM.from_pretrained(model_name, trust_remote_code=True, device_map=\"auto\")\ntokenizer = AutoTokenizer.from_pretrained(model_name)\n\nchat = [\n  {\"role\": \"system\", \"content\": \"- In this environment, various tools can be used to answer users' questions.\\n- You are \\\"CLOVA X,\\\" an AI language model developed by NAVER.\\n- Begin by creating a plan for solving the problem, and then utilize the tools accordingly to address the problem.\\n- The current date is Monday, July 21, 2025.\\n- Latest information such as news, stock prices, and shopping is retrieved through the tool_list.\\n- If external tools are required, the assistant should not answer directly but must first obtain the necessary information via the assistant -> tool/function_call role, and then respond.\"},\n  {\"role\": \"user\", \"content\": \"Explain in as much detail as possible the relationship between the Schrödinger equation and quantum mechanics.\"},\n]\n\n# The model decides whether to answer after reasoning or to respond immediately without reasoning\ninputs = tokenizer.apply_chat_template(chat, add_generation_prompt=True, return_dict=True, return_tensors=\"pt\")\ninputs = inputs.to(\"cuda\")\n\noutput_ids = model.generate(\n    **inputs,\n    max_length=1024,\n    stop_strings=[\"<|endofturn|>\", \"<|stop|>\"],\n    temperature=0.5,\n    top_p=0.6,\n    repetition_penalty=1.05,\n    tokenizer=tokenizer\n)\nprint(tokenizer.batch_decode(output_ids))\n```\n\n### Example code for function calls (tool usage)\nFor a scenario involving tool usage, you can execute it as follows.\n\n```python\nimport json\nfrom transformers import AutoModelForCausalLM, AutoTokenizer\n\nmodel_name = \"naver-hyperclovax/HyperCLOVAX-SEED-Think-14B\"\nmodel = AutoModelForCausalLM.from_pretrained(model_name, trust_remote_code=True, device_map=\"auto\")\ntokenizer = AutoTokenizer.from_pretrained(model_name)\n\n# 1) The name of the tool should be written as function_call.{{ name }}.\n# 2) Parameters follow the specifications described at https://platform.openai.com/docs/guides/function-calling?api-mode=responses.\ntool_list = [\n    {   \n        \"type\": \"function\",\n        \"function\": {\n            \"name\": \"add\",\n            \"description\": \"Add two numbers.\",\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"x\": {\"type\": \"number\", \"description\": \"First number\"},\n                    \"y\": {\"type\": \"number\", \"description\": \"Second number\"}\n                },\n                \"required\": [\"x\", \"y\"]\n            }\n        }\n    }, {\n        \"type\": \"function\",\n        \"function\": {\n            \"name\": \"subtract\",\n            \"description\": \"Subtract two numbers.\",\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"x\": {\"type\": \"number\", \"description\": \"First number\"},\n                    \"y\": {\"type\": \"number\", \"description\": \"Second number\"}\n                },\n                \"required\": [\"x\", \"y\"]\n            }\n        }\n    }\n]   \n\n\nchat = [\n  {\"role\": \"system\", \"content\": \"- In this environment, various tools can be used to answer users' questions.\\n- You are \\\"CLOVA X,\\\" an AI language model developed by NAVER.\\n- Begin by creating a plan for solving the problem, and then utilize the tools accordingly to address the problem.\\n- The current date is Monday, July 21, 2025.\\n- Latest information such as news, stock prices, and shopping is retrieved through the tool_list.\\n- If external tools are required, the assistant should not answer directly but must first obtain the necessary information via the assistant -> tool/function_call role, and then respond.\"},\n  {\"role\": \"user\", \"content\": \"What is 1588 + 1234? Please calculate it using the provided tool.\"},\n]\n\ninputs = tokenizer.apply_chat_template(chat, tools=tool_list, add_generation_prompt=True, return_dict=True, return_tensors=\"pt\")\ninputs = inputs.to(\"cuda\")\n\noutput_ids = model.generate(\n    **inputs,\n    max_length=1024,\n    stop_strings=[\"<|endofturn|>\", \"<|stop|>\"],\n    temperature=0.5,\n    top_p=0.6,\n    repetition_penalty=1.05,\n    tokenizer=tokenizer\n)\nprint(tokenizer.batch_decode(output_ids))\n```\n\n- If you have any questions or issues regarding usage, please leave them as an issue in the Discussions section of this page.\n\n## **vLLM Usage Example**\n\nThe HyperCLOVA X SEED Think model is built on a custom LLM architecture based on the LLaMA architecture, incorporating μP and Peri-LN techniques. For convenient use with vLLM, it is available as a dedicated vLLM plugin that can be installed and used with ease once vLLM is set up.\n\n1. Download vLLM plugin source code\n\n    ```bash\n    git clone https://github.com/NAVER-Cloud-HyperCLOVA-X/hcx-vllm-plugin\n    ```\n\n2. vLLM Plugin Build & Installation: While keeping the NAVER-Cloud-HyperCLOVA-X/hcx-vllm-plugin path downloaded in step 1, refer to the commands below.\n\n    ```bash\n    pip install -e .\n    ```\n\nAfter downloading the model checkpoint to a local path (`/path/to/hyperclova-x-seed-think-14b`), you can perform text inference by running the following commands on a GPU environment with A100 or higher.\n\n```bash\npython -m vllm.entrypoints.openai.api_server --model=/path/to/hyperclova-x-seed-think-14b --trust_remote_code --port=8000\n\ncurl http://localhost:8000/v1/completions \\\n-H \"Content-Type: application/json\" \\\n-d '{\n\"prompt\": \"<|im_start|>tool_list\\n<|im_end|>\\n<|im_start|>system\\n- The AI language model is named \\\"CLOVA X\\\" and was developed by NAVER.\\n- Today is Friday, July 18, 2025.<|im_end|>\\n<|im_start|>user\\nExplain in as much detail as possible the relationship between the Schrödinger equation and quantum mechanics.<|im_end|>\\n<|im_start|>assistant/think\\n\",\n\"top_k\":-1,\n\"temperature\":0.5,\n\"top_p\":0.6,\n\"repetition_penalty\":1.05,\n\"stop\":[\"<|im_end|><|endofturn|>\", \"<|im_end|><|stop|>\"],\n\"max_tokens\":8192,\n\"skip_special_tokens\":false\n}'\n```\n\n### Chat Completions Usage Example\n\n1.  Using the Chat completions endpoint\n\n<!-- end list -->\n\n  - Basic serving script (same as completions)\n\n    `vllm serve naver-hyperclovax/HyperCLOVAX-SEED-Think-14B --trust_remote_code`\n\n  - Sampling parameters such as `top_k`, `temperature`, `top_p`, `repetition_penalty`, and `max_tokens` can be set freely.\n\n  - However, the `skip_special_tokens` and `stop` options must be set as below for vLLM to recognize the model's token generation stop signal and cease generation.\n\n  - request example\n\n    ```bash\n    curl -X POST http://localhost:8000/v1/chat/completions \\\n    -H \"Content-Type: application/json\" \\\n    -d '{\n        \"model\": \"naver-hyperclovax/HyperCLOVAX-SEED-Think-14B\",\n        \"messages\": [\n            {\"role\": \"system\", \"content\": \"- The AI language model is named \\\"CLOVA X\\\" and was developed by NAVER.\\n- Today is Friday, July 18, 2025.\"},\n            {\"role\": \"user\", \"content\": \"Explain in as much detail as possible the relationship between the Schrödinger equation and quantum mechanics.\"}\n        ],\n        \"skip_special_tokens\":false,\n        \"stop\": [\n            \"<|im_end|><|endofturn|>\",\n            \"<|im_end|><|stop|>\"\n        ],\n        \"top_k\": -1,\n        \"temperature\": 0.5,\n        \"top_p\": 0.6,\n        \"repetition_penalty\": 1.05,\n        \"max_tokens\": 8192\n    }'\n    ```\n\n<!-- end list -->\n\n2.  tool call usage example\n\n<!-- end list -->\n\n  - Serving script\n\n      - You need to add `--enable-auto-tool-choice --tool-call-parser hcx` to the existing script.\n\n        `vllm serve naver-hyperclovax/HyperCLOVAX-SEED-Think-14B --trust_remote_code --enable-auto-tool-choice --tool-call-parser hcx`\n\n  - request example\n\n      - If you put the available tools in `tools`, they will be applied to the `tool_list` part passed to the model.\n\n        ```bash\n        curl -X POST http://localhost:8000/v1/chat/completions \\\n        -H \"Content-Type: application/json\" \\\n        -d '{\n            \"model\": \"naver-hyperclovax/HyperCLOVAX-SEED-Think-14B\",\n            \"messages\": [\n            {\"role\": \"user\", \"content\": \"Could you please tell me the current weather conditions in Boston, MA in Celsius?\"}\n            ],\n            \"stop\": [\"<|im_end|><|stop|>\", \"<|im_end|><|endofturn|>\"],\n            \"max_tokens\": 8192,\n            \"skip_special_tokens\": false,\n            \"tools\": [\n            {\n                \"type\": \"function\",\n                \"function\": {\n                \"name\": \"get_current_weather\",\n                \"description\": \"Retrieves the current weather conditions for a specified city and state.\",\n                \"parameters\": {\n                    \"type\": \"object\",\n                    \"required\": [\"location\"],\n                    \"properties\": {\n                    \"location\": {\n                        \"type\": \"string\",\n                        \"description\": \"The location for which to get the weather, in the format of \\'\\\\'City, State\\\\'', such as \\'\\\\'San Francisco, CA\\\\'' if State for the city exists. \\'\\\\'City, Country\\\\'' if State for the city does not exist. Use short form for state.\"\n                    },\n                    \"unit\": {\n                        \"type\": \"string\",\n                        \"description\": \"The unit of temperature for the weather report.\",\n                        \"enum\": [\"celsius\", \"fahrenheit\"],\n                        \"default\": \"fahrenheit\"\n                    }\n                }\n                }\n            }\n            }\n        ]\n        }'\n        ```\n\n  - response example\n\n      - Parsed tool calls are returned in the `tool_calls` field.\n      - If there is a response generated by the model other than the tool call, it is returned in the `content` field. Otherwise, `null` is returned.\n        ```bash\n        {\n            \"id\": \"chatcmpl-b9aad45639464c0ebf71861df13b4eb2\",\n            \"object\": \"chat.completion\",\n            \"created\": 1753358351,\n            \"model\": \"naver-hyperclovax/HyperCLOVAX-SEED-Think-14B\",\n            \"choices\": [\n                {\n                    \"index\": 0,\n                    \"message\": {\n                        \"role\": \"assistant\",\n                        \"reasoning_content\": null,\n                        \"content\": null,\n                        \"tool_calls\": [\n                            {\n                                \"id\": \"chatcmpl-tool-b9513352e4c64065a315e495b2613753\",\n                                \"type\": \"function\",\n                                \"function\": {\n                                    \"name\": \"get_current_weather\",\n                                    \"arguments\": \"{\\\"location\\\": \\\"Boston, MA\\\", \\\"unit\\\": \\\"celsius\\\"}\"\n                                }\n                            }\n                        ]\n                    },\n                    \"logprobs\": null,\n                    \"finish_reason\": \"tool_calls\",\n                    \"stop_reason\": \"<|im_end|><|stop|>\"\n                }\n            ],\n            \"usage\": {\n                \"prompt_tokens\": 189,\n                \"total_tokens\": 224,\n                \"completion_tokens\": 35,\n                \"prompt_tokens_details\": null\n            },\n            \"prompt_logprobs\": null,\n            \"kv_transfer_params\": null\n        }\n        ```\n\n<!-- end list -->\n\n3.  reasoning usage example\n\n<!-- end list -->\n\n  - Serving script\n      - You need to add `--enable-reasoning --reasoning-parser hcx` to the existing script.\n\n        `vllm serve naver-hyperclovax/HyperCLOVAX-SEED-Think-14B --trust_remote_code --enable-reasoning --reasoning-parser hcx`\n\n      - The `--enable-reasoning` option has been deprecated since vLLM v0.9.0.\n\n          - If you are using vLLM v0.9.0 or higher, you only need to add `--reasoning-parser hcx` without `--enable-reasoning`.\n\n      - The reasoning parser extracts the reasoning content from responses generated in reasoning mode. This option does not always make the model operate in reasoning mode, nor does excluding the parser necessarily force non-reasoning operation.\n\n      - request example\n\n          - `\"chat_template_kwargs\": {\"force_reasoning\": true}` forces reasoning.\n          - `\"chat_template_kwargs\": {\"skip_reasoning\": true}` forces non-reasoning.\n          - If both are set to `true`, `force_reasoning: true` has higher priority.\n          - If neither is given, the model decides whether to reason or not.\n\n        <!-- end list -->\n\n        ```bash\n        curl -X POST http://localhost:8000/v1/chat/completions \\\n        -H \"Content-Type: application/json\" \\\n        -d '{\n            \"model\": \"naver-hyperclovax/HyperCLOVAX-SEED-Think-14B\",\n            \"messages\": [\n                {\"role\": \"system\", \"content\": \"You are a helpful assistant.\"},\n                {\"role\": \"user\", \"content\": \"Tell me the prime number closest to 1000.\"}\n            ],\n            \"stop\": [\"<|im_end|><|stop|>\", \"<|im_end|><|endofturn|>\"],\n            \"max_tokens\": 8192,\n            \"skip_special_tokens\": false,\n            \"chat_template_kwargs\": {\"force_reasoning\": true}\n        }'\n        ```\n\n      - response example\n\n          - The reasoning part is returned in the `reasoning_content` field, and the assistant's final response is returned in the `content` field separately.\n\n        <!-- end list -->\n\n        ```bash\n        {\n            \"id\": \"chatcmpl-157d282ebaca4333a9f04b1bdfa7eb8b\",\n            \"object\": \"chat.completion\",\n            \"created\": 1753361336,\n            \"model\": \"naver-hyperclovax/HyperCLOVAX-SEED-Think-14B\",\n            \"choices\": [\n                {\n                    \"index\": 0,\n                    \"message\": {\n                        \"role\": \"assistant\",\n                        \"reasoning_content\": \"Okay, so I need to find the prime number closest to 1000. Hmm, let's start by recalling what a prime number is. ... (중략) ... But in this case, at least for the nearest, 3 versus9, which gives997 as the answer.\\n\\nTherefore, the correct answer would be997.\",\n                        \"content\": \"\\nThe prime number closest to 1000 is **997**. \\n\\nHere's the reasoning:\\n1. **Check if 1000 is prime:** It's even, so not prime.\\n2. **Find primes near 1000:**\\n   - **Below 1000:** Check numbers downward. \\n     - Upon verifying, 997 is prime (no divisors up to its square root).\\n   - **Above 1000:** Next prime after 997 is 1009, which is 9 units away from 1000.\\n3. **Compare distances:**\\n   - \\\\( |1000 - 997| = 3 \\\\)\\n   - \\\\( |1009 - 1000| = 9 \\\\)\\n   \\nSince 3 < 9, **997** is the closest prime. \\n\\n\\\\boxed{997}\",\n                        \"tool_calls\": []\n                    },\n                    \"logprobs\": null,\n                    \"finish_reason\": \"stop\",\n                    \"stop_reason\": \"<|im_end|><|endofturn|>\"\n                }\n            ],\n            \"usage\": {\n                \"prompt_tokens\": 38,\n                \"total_tokens\": 3254,\n                \"completion_tokens\": 3216,\n                \"prompt_tokens_details\": null\n            },\n            \"prompt_logprobs\": null,\n            \"kv_transfer_params\": null\n        }\n        ```\n\n<!-- end list -->\n\n4.  reasoning + tool call usage example\n\n<!-- end list -->\n\n  - Serving script\n      - If you want to use both the reasoning parser and the tool call parser, you can combine the reasoning serving script and the tool call serving script.\n\n        `vllm serve naver-hyperclovax/HyperCLOVAX-SEED-Think-14B --trust_remote_code --enable-auto-tool-choice --tool-call-parser hcx --enable-reasoning --reasoning-parser hcx`\n\n\n## License\n\nThe model is licensed under [HyperCLOVA X SEED Model License Agreement](./LICENSE)\n\n## Citation\n\n```\n@misc{navercloudhyperclovaxteam2025hyperclovaxthinktechnical,\n      title={HyperCLOVA X THINK Technical Report}, \n      author={NAVER Cloud HyperCLOVA X Team},\n      year={2025},\n      eprint={2506.22403},\n      archivePrefix={arXiv},\n      primaryClass={cs.CL},\n      url={https://arxiv.org/abs/2506.22403}, \n}\n```\n\n## Questions\n\nFor any other questions, please feel free to contact us at [dl_hcxopensource@navercorp.com](mailto:dl_hcxopensource@navercorp.com).\n",
    "config": "{\n  \"architectures\": [\n    \"HyperCLOVAXForCausalLM\"\n  ],\n  \"attention_bias\": false,\n  \"attention_dropout\": 0.0,\n  \"attention_multiplier\": 0.0078125,\n  \"attn_pdrop\": 0.0,\n  \"auto_map\": {\n    \"AutoConfig\": \"configuration_hyperclovax.HyperCLOVAXConfig\",\n    \"AutoModel\": \"modeling_hyperclovax.HyperCLOVAXModel\",\n    \"AutoModelForCausalLM\": \"modeling_hyperclovax.HyperCLOVAXForCausalLM\"\n  },\n  \"bos_token_id\": 100257,\n  \"embd_pdrop\": 0.0,\n  \"embedding_multiplier\": 10.0,\n  \"end_token_id\": 100257,\n  \"eos_token_id\": 100257,\n  \"head_dim\": 128,\n  \"hidden_act\": \"silu\",\n  \"hidden_size\": 6144,\n  \"initializer_range\": 0.012727922061357854,\n  \"intermediate_size\": 14336,\n  \"logits_scaling\": 0.125,\n  \"max_position_embeddings\": 131072,\n  \"mlp_bias\": false,\n  \"model_type\": \"hyperclovax\",\n  \"num_attention_heads\": 48,\n  \"num_hidden_layers\": 38,\n  \"num_key_value_heads\": 8,\n  \"pad_token_id\": 100257,\n  \"pretraining_tp\": 1,\n  \"resid_pdrop\": 0.0,\n  \"residual_multiplier\": 1.0,\n  \"rms_norm_eps\": 1e-05,\n  \"rope_scaling\": null,\n  \"rope_theta\": 100000000,\n  \"summary_first_dropout\": 0.0,\n  \"tie_word_embeddings\": false,\n  \"torch_dtype\": \"float32\",\n  \"transformers_version\": \"4.52.4\",\n  \"use_cache\": false,\n  \"use_post_norm\": true,\n  \"vocab_size\": 110592\n}\n",
    "generation_config": "{\n  \"_from_model_config\": true,\n  \"bos_token_id\": 100257,\n  \"eos_token_id\": 100257,\n  \"pad_token_id\": 100257,\n  \"transformers_version\": \"4.52.4\",\n  \"use_cache\": false\n}\n",
    "license_file": "HyperCLOVA X SEED 14B Think Model License Agreement\n\nModel Release Date: July 22, 2025\n \nThis HyperCLOVA X SEED 14B Think Model License Agreement (the “Agreement”) is a legal agreement between you and NAVER Corporation (“Naver Corp.”) and NAVER Cloud Corporation (“Naver Cloud Corp.”) (Naver Corp. and Naver Cloud Corp. are collectively referred to as “NAVER”) and governs your use of the Models that NAVER provides to You under this Agreement. \n\nNAVER Corp., as the holder of the intellectual property of the Model, and its affiliate, NAVER Cloud Corp., as the exclusive business operator of HyperCLOVA X, enter into this Agreement with you. NAVER and you are each a “party” and collectively the “parties.”\n\nBy using, reproducing, modifying, distributing, performing or displaying any portion or element of the Model or Derivative Model, or otherwise accepting the terms of this Agreement, you agree to be bound by this Agreement. You represent to us that you are lawfully able to enter into contracts, and if you are entering into this Agreement for an entity, that you have legal authority to bind that entity. \n\n1. Definitions. \n\n1.1. \"Affiliate” means any entity directly or indirectly controlling, controlled by or under common control with either party, where “control” means the possession, directly or indirectly, of the power to independently direct or cause the direction of the management and policies of an entity, whether through ownership of more than fifty percent (50%) of the stock or other equity interests entitled to vote for representation on its board of directors, or body performing similar functions, by contract or otherwise.\n\n1.2. “Derivative Model” means all (i) modifications to the Model, (ii) works based on the Model, or (iii) any other machine learning model which is created by transfer of patterns of the weights, parameters, operations, or Output of the Model, to that model in order to cause that model to perform similarly to the Model, including distillation methods that use intermediate data representations or methods based on the generation of synthetic data Outputs by the Model for training that Model. For clarity, Outputs are not deemed Derivative Model. \n\n1.3. “Licensee” or “you” means you, or your employer or any other person or entity (if you are entering into this Agreement on such person or entity’s behalf), of the age required under applicable laws, rules or regulations to provide legal consent and that has legal authority to bind your employer or such other person or entity if you are entering in this Agreement on their behalf.\n\n1.4. “Model” means the foundational large language models and software and algorithms, including machine-learning model code and trained model weights distributed by NAVER. \n\n\n1.5. “Output” means the information content output of the Model or a Derivative Model that results from operating or otherwise using the Model or Derivative Model. \n\n2. Conditions for Use, License Grant and Restrictions\n\n2.1. Conditions for Use. The Model and any Derivative Model are subject to the terms of this Agreement and govern your use. If You institute copyright or patent litigation against any entity (including a crossclaim or counterclaim in a lawsuit) alleging that the Model or Derivative Model constitutes direct or contributory copyright or patent infringement, then any license granted to you under this Agreement for that Model or Derivative Model will terminate as of the date such litigation is filed. NAVER may update this Agreement to comply with legal and regulatory requirements any time and You agree to either comply with any updated license or cease your copying, use, and distribution of the Model and any Derivative Model.\n\n2.2. License Grant. Subject to the terms and conditions of this Agreement, NAVER hereby grants to you a non-exclusive, worldwide, non-transferable, revocable and royalty-free limited license under NAVER’s intellectual property or other rights owned by NAVER embodied in the Model to access, download, install, copy, use, reproduce, distribute, create derivative works of, and make modifications to the Model. \n\n2.3. Prohibited Use Policy. NAVER is committed to ensuring safety trust, and transparency in the development and use of AI technologies. Accordingly, your use of the Model and any Derivative Models is subject to the following conditions:\n(i) You must ensure that any product or service you develop, use, offer as a service, or distribute complies with all applicable laws and regulations, and is operated appropriately for the relevant industry or use case.\n(ii) You must comply with the Acceptable Use Policy applicable to the Model and any Derivative Models, which is attached hereto as Addendum A and incorporated by reference into this Agreement. \n(iii) NAVER expressly prohibits the use of its products or services for any purpose in violation of applicable law and regulation, including but not limited to:\n(a) illegal surveillance,\n(b) illegal collection or processing of biometric information without the consent of the subject which is required under applicable law, or\n(c) illegal harassment, abuse, threatening or bullying of individuals or groups of individuals or intentionally misleading or deceiving others.\n(iv) You must take reasonable measures to address unintended bias and to mitigate harm to others, including underrepresented or vulnerable groups.\n\n\n3. Redistribution. \n\n3.1. You may reproduce, distribute or make available the Model or Derivative Models thereof, or a product or service (including another AI model) that contains any of them, if you meet all of the following conditions: you must (i) include the Prohibited Use Policy referenced in Section 2.3. as an enforceable provision in any agreement (e.g., license agreement, terms of use, etc.) governing the use and/or distribution of the Model or Derivative Model and you must provide notice to subsequence users you distribute to the Model or Derivative Models are subject to the use restrictions in Section 2.3., (ii) provide all third party recipients of the Model or Derivative Models a copy of this Agreement, (iii) cause any modified files to carry prominent notices stating that you modified the files; (iv) include the following attribution notice within a “Notice” text file distributed as part of such copies: “HyperCLOVA X SEED 14B Think Model is licensed under the HyperCLOVA X SEED 14B Think Model License Agreement, Copyright © NAVER Corp. All Rights Reserved.”, and (v) prominently display “Powered by HyperCLOVA X” on a related website, user interface, blogpost, about page, or product documentation. If you use the Model or any Outputs of the Model to create, train, fine tune, or otherwise improve an AI model, which is distributed or made available, you shall also include “HyperCLOVA X” at the beginning of any such AI model name.\n3.2. You may add your own copyright statement to your modifications and, except as set forth in this Section, may provide additional or different license terms and conditions for use, reproduction, or distribution of your modifications, or for any such Derivative Models as a whole, provided your use, reproduction, and distribution of the Model or Derivative Models otherwise comply with the terms and conditions stated in this Agreement. Any additional or different terms and conditions you impose must not conflict with the terms of this Agreement. \n\n4. Additional Commercial Terms. If (i) as of the Model Release Date, the monthly active users of the products or services made available by or for Licensee, or Licensee’s Affiliates, is greater than 10 million monthly active users in the preceding calendar month, or (ii) the Licensee or its Affiliate distributes or makes available any product or service, which is substantially similar to or directly competes with any product and service provided by NAVER, then the Licensee must request a license from NAVER. Such a license may be granted by NAVER at its sole discretion, and the Licensee is not authorized to exercise any rights under this Agreement unless and until NAVER expressly grants you such rights.\n\n5. Generated Output. NAVER claims no rights in Outputs you generate using the Model. You and your use are solely responsible for Outputs and their subsequent uses. \n\n6. DISCLAIMER OF WARRANTY. UNLESS REQUIRED BY APPLICABLE LAW, THE MODEL AND ANY OUTPUT AND RESULTS THEREFROM ARE PROVIDED ON AN “AS IS” BASIS, WITHOUT WARRANTIES OR ANY KIND, AND NAVER DISCLAIMS ALL WARRANTIES OF ANY KIND, BOTH EXPRESS AND IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF TITLE, NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. YOU ARE SOLELY RESPONSIBLE FOR DETERMINING THE APPROPRIATENESS OF USING OR REDISTRIBUTING THE MODEL, DERIVATIVE MODELS, OUTPUTS AND ASSUME ANY RISKS ASSOCIATED WITH YOUR USE OF THE MODEL AND ANY OUTPUTS AND RESULTS AND YOUR EXERCISE OF PERMISSION UNDER THIS AGREEMENT. \n\n7. LIMITATION OF LIABILITY. IN NO EVENT AND UNDER NO LEGAL THEORY, WHETHER IN TORT (INCLUDING NEGLIGENCE), CONTRACT, OR OTHERWISE, UNLESS REQUIRED BY APPLICABLE LAW (SUCH AS IN CASES OF DELIBERATE AND GROSSLY NEGLIGENT ACTS), WILL NAVER BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY DIRECT, INDIRECT, SPECIAL, CONSEQUENTIAL, INCIDENTAL, EXEMPLARY, OR PUNITIVE DAMAGES, OR LOST PROFITS OF ANY KIND, ARISING FROM OR RELATED TO THIS AGREEMENT, OR RESULTING FROM THE USE OR INABILITY TO USE THE MODEL, DERIVATIVE MODELS OR, OUTPUTS (INCLUDING, BUT NOT LIMITED TO, DAMAGES FOR LOSS OF GOODWILL, WORK STOPPAGES, COMPUTER FAILURE OR MALFUNCTION, OR ANY AND ALL OTHER COMMERCIAL DAMAGES OR LOSSES), EVEN IF NAVER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. \n\n8. Indemnity. You will indemnify and hold harmless NAVER from and against any claim by any third party arising out of or related to your use or distribution of the Model, Derivative Model or Outputs. \n\n9. Intellectual Property.\n\n9.1. This Agreement does not grant permission to use the trade names, trademarks, service marks, or product names of NAVER, except as required for reasonable and customary use in describing the origin of the Model and reproducing the content of the “Notice” text file. \n\n9.2. NAVER Corp. owns the Model and any Derivative Model created by NAVER Corp. Except as expressively granted in this Agreement, NAVER Corp. reserves all rights, interests and remedies in connection with the Model and Derivative Model created by NAVER Corp. and no other license or right is granted to you by implication, estoppel or otherwise. Subject to NAVER Corp.’s ownership of the Model and any Derivative Model made by or for NAVER Corp., with respect to any derivative works and modifications of the Model that are made by you, as between you and NAVER Corp., you are and will be the owner of such derivative works and modifications.\n\n10. Term and Termination. The term of this Agreement will commence upon your acceptance of this Agreement or access to the Model and will continue in full force and effect until terminated in accordance with the terms and conditions of this Agreement. NAVER may terminate this Agreement if you breach any of the terms or conditions of this Agreement. Upon termination of this Agreement, you shall delete and cease use of the Model and Derivative Model. Section 5, 6, 7 and 10 shall survive the termination of this Agreement. \n\n11. Governing Law and Jurisdiction. \n\n11.1. This Agreement will be governed by and construed in accordance with the laws of the Republic of Korea, without regard to its conflicts of laws principles. \n\n11.2. Any disputes, controversies, or claims arising out of or relating to this Agreement, including its existence, validity, interpretation, performance, breach, or termination, shall be referred to and finally resolved by arbitration administered by the Korean Commercial Arbitration Board (KCAB) in accordance with the International Arbitration Rules of the Korean Commercial Arbitration Board in force at the time of the commencement of the arbitration. The seat of arbitration shall be Seoul, Republic of Korea. The tribunal shall consist of one arbitrator. The language of the arbitration shall be English. Either party may seek interim or provisional relief from a court of competent jurisdiction and doing so shall not be considered a waiver of any provision in this section. The arbitral tribunal also has the authority to issue orders for interim or provisional relief.\n\n12. Modifications. NAVER reserves the right to modify or amend this Agreement at any time, in its sole discretion. Any modifications will be effective upon posting the updated Agreement on our website or through other means of communication. You are responsible for reviewing the Agreement periodically for changes. \n\n13. No Waiver. NAVER will not be treated as having waived any rights by not exercising (or delaying the exercise of) any rights under this Agreement.\n\n\n\n\nAddendum A – Acceptable Use Policy\n\nNAVER is committed to promoting safe and responsible use of its AI technologies, including the HyperCLOVA X SEED 14B Think Model (the “Model”). By accessing or using the Model and Derivative Model (Defined in the Model License Agreement) (the Model and Derivative Model are collectively referred to as the “Models”), you agree to this Acceptable Use Policy (“Policy”).\n\nWe want everyone to use the Models safely, legally, and ethically. You agree that you will not use, or allow others to use, the Models to:\n\n1. Violate applicable laws or the rights of others, including by:\na. Engaging in, promoting, contributing to, encouraging, planning, inciting, or furthering illegal or unlawful activity or content, such as:\n* Violence or terrorism\n* Exploitation or harm to children, including the creation or dissemination of child exploitative content\n* Human trafficking, exploitation, or sexual violence\n* The unlawful distribution of obscene or harmful material to minors, or failure to apply legally required age restrictions\n* Sexual solicitation or sexually exploitative behavior\n* Any other criminal activity\nb. Engaging in, promoting, inciting, or facilitating the harassment, abuse, threatening, or bullying of individuals or groups\nc. Engaging in, promoting, inciting, or facilitating discrimination or other unlawful or harmful conduct in the provision of employment, credit, housing, or access to essential goods and services\nd. Providing unauthorized or unlicensed professional services, including but not limited to financial, legal, medical/health, or related services\ne. Collecting, processing, disclosing, generating, or inferring private or sensitive personal information, including identity, health, or demographic data, unless lawfully permitted under applicable laws\nf. Infringing, misappropriating, or otherwise violating third-party rights, including through the generation or use of outputs derived from the Models\ng. Creating, generating, or facilitating malicious code, malware, or computer viruses, or interfering with the functioning, security, or integrity of a website, application, or system\nh. Intentionally bypassing or disabling usage restrictions, safety measures, or access controls imposed by NAVER\n\n2. Engage in or promote use cases that may pose a risk of death, bodily harm, or significant safety hazard to individuals, including use of the Models in connection with:\na. Military, warfare, nuclear technology or espionage\nb. The development or distribution of firearms or illegal weapons\nc. Illegal drugs or regulated controlled substances\nd. Operation of critical infrastructure, transportation systems, or heavy machinery\ne. Content promoting self-harm, including suicide, or eating disorders\nf. Any other use intended to incite or cause physical harm\n\n3. Intentionally deceive or mislead others, including by:\na. Generating, promoting, or disseminating fraudulent or misleading content\nb. Creating or sharing defamatory content\nc. Generating or distributing spam\nd. Impersonating another individual or entity without proper authorization\ne. Representing Model output as human-generated\nf. Generating or enabling fake online engagement, such as fake reviews or fake users\n\n4. Fail to disclose to end users any known risks or limitations of an AI system that incorporates the Models.\n\n5. Use the Models in conjunction with third-party tools, models, or software designed to generate unlawful content or conduct, or falsely represent outputs from such tools as associated with NAVER or HyperCLOVA X.\n\nIf you become aware of a violation of this Policy, a bug, or any behavior that could result in a breach of this Policy, please report it to us:\n\nReporting risky outputs: dl_hcxopensource@navercorp.com\nReporting policy violations or unauthorized use: dl_037xs@navercorp.com\n\n",
    "py_files": {
        "configuration_hyperclovax.py": "# coding=utf-8\n# This file was created for the HyperCLOVA X SEED 14B Think architecture.\n# partially copied and modified from https://github.com/huggingface/transformers\n# Copyright 2022 EleutherAI and the HuggingFace Inc. team. All rights reserved.\n#\n# This code is based on EleutherAI's GPT-NeoX library and the GPT-NeoX\n# and OPT implementations in this library. It has been modified from its\n# original forms to accommodate minor architectural differences compared\n# to GPT-NeoX and OPT used by the Meta AI team that trained the model.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"HyperCLOVAX model configuration\"\"\"\n\nfrom transformers.configuration_utils import PretrainedConfig\n\nclass HyperCLOVAXConfig(PretrainedConfig):\n    r\"\"\"\n    This is the configuration class to store the configuration of a [`HyperCLOVAXModel`]. It is used to instantiate an HyperCLOVAX\n    model according to the specified arguments, defining the model architecture. Instantiating a configuration with the\n    defaults will yield a similar configuration to that of the HyperCLOVAX.\n\n    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n    documentation from [`PretrainedConfig`] for more information.\n\n\n    Args:\n        vocab_size (`int`, *optional*, defaults to 32000):\n            Vocabulary size of the HyperCLOVAX model. Defines the number of different tokens that can be represented by the\n            `inputs_ids` passed when calling [`HyperCLOVAXModel`]\n        hidden_size (`int`, *optional*, defaults to 4096):\n            Dimension of the hidden representations.\n        intermediate_size (`int`, *optional*, defaults to 11008):\n            Dimension of the MLP representations.\n        num_hidden_layers (`int`, *optional*, defaults to 32):\n            Number of hidden layers in the Transformer decoder.\n        num_attention_heads (`int`, *optional*, defaults to 32):\n            Number of attention heads for each attention layer in the Transformer decoder.\n        num_key_value_heads (`int`, *optional*):\n            This is the number of key_value heads that should be used to implement Grouped Query Attention. If\n            `num_key_value_heads=num_attention_heads`, the model will use Multi Head Attention (MHA), if\n            `num_key_value_heads=1` the model will use Multi Query Attention (MQA) otherwise GQA is used. When\n            converting a multi-head checkpoint to a GQA checkpoint, each group key and value head should be constructed\n            by meanpooling all the original heads within that group. For more details checkout [this\n            paper](https://arxiv.org/pdf/2305.13245.pdf). If it is not specified, will default to\n            `num_attention_heads`.\n        hidden_act (`str` or `function`, *optional*, defaults to `\"silu\"`):\n            The non-linear activation function (function or string) in the decoder.\n        max_position_embeddings (`int`, *optional*, defaults to 2048):\n            The maximum sequence length that this model might ever be used with.\n        initializer_range (`float`, *optional*, defaults to 0.02):\n            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n        rms_norm_eps (`float`, *optional*, defaults to 1e-06):\n            The epsilon used by the rms normalization layers.\n        use_cache (`bool`, *optional*, defaults to `True`):\n            Whether or not the model should return the last key/values attentions (not used by all models). Only\n            relevant if `config.is_decoder=True`.\n        pad_token_id (`int`, *optional*):\n            Padding token id.\n        bos_token_id (`int`, *optional*, defaults to 1):\n            Beginning of stream token id.\n        eos_token_id (`int`, *optional*, defaults to 2):\n            End of stream token id.\n        pretraining_tp (`int`, *optional*, defaults to 1):\n            Experimental feature. Tensor parallelism rank used during pretraining. Please refer to [this\n            document](https://huggingface.co/docs/transformers/main/perf_train_gpu_many#tensor-parallelism) to\n            understand more about it. This value is necessary to ensure exact reproducibility of the pretraining\n            results. Please refer to [this issue](https://github.com/pytorch/pytorch/issues/76232).\n        tie_word_embeddings (`bool`, *optional*, defaults to `False`):\n            Whether to tie weight embeddings\n        rope_theta (`float`, *optional*, defaults to 10000.0):\n            The base period of the RoPE embeddings.\n        rope_scaling (`Dict`, *optional*):\n            Dictionary containing the scaling configuration for the RoPE embeddings. NOTE: if you apply new rope type\n            and you expect the model to work on longer `max_position_embeddings`, we recommend you to update this value\n            accordingly.\n            Expected contents:\n                `rope_type` (`str`):\n                    The sub-variant of RoPE to use. Can be one of ['default', 'linear', 'dynamic', 'yarn', 'longrope',\n                    'llama3'], with 'default' being the original RoPE implementation.\n                `factor` (`float`, *optional*):\n                    Used with all rope types except 'default'. The scaling factor to apply to the RoPE embeddings. In\n                    most scaling types, a `factor` of x will enable the model to handle sequences of length x *\n                    original maximum pre-trained length.\n                `original_max_position_embeddings` (`int`, *optional*):\n                    Used with 'dynamic', 'longrope' and 'llama3'. The original max position embeddings used during\n                    pretraining.\n                `attention_factor` (`float`, *optional*):\n                    Used with 'yarn' and 'longrope'. The scaling factor to be applied on the attention\n                    computation. If unspecified, it defaults to value recommended by the implementation, using the\n                    `factor` field to infer the suggested value.\n                `beta_fast` (`float`, *optional*):\n                    Only used with 'yarn'. Parameter to set the boundary for extrapolation (only) in the linear\n                    ramp function. If unspecified, it defaults to 32.\n                `beta_slow` (`float`, *optional*):\n                    Only used with 'yarn'. Parameter to set the boundary for interpolation (only) in the linear\n                    ramp function. If unspecified, it defaults to 1.\n                `short_factor` (`List[float]`, *optional*):\n                    Only used with 'longrope'. The scaling factor to be applied to short contexts (<\n                    `original_max_position_embeddings`). Must be a list of numbers with the same length as the hidden\n                    size divided by the number of attention heads divided by 2\n                `long_factor` (`List[float]`, *optional*):\n                    Only used with 'longrope'. The scaling factor to be applied to long contexts (<\n                    `original_max_position_embeddings`). Must be a list of numbers with the same length as the hidden\n                    size divided by the number of attention heads divided by 2\n                `low_freq_factor` (`float`, *optional*):\n                    Only used with 'llama3'. Scaling factor applied to low frequency components of the RoPE\n                `high_freq_factor` (`float`, *optional*):\n                    Only used with 'llama3'. Scaling factor applied to high frequency components of the RoPE\n        attention_bias (`bool`, *optional*, defaults to `False`):\n            Whether to use a bias in the query, key, value and output projection layers during self-attention.\n        attention_dropout (`float`, *optional*, defaults to 0.0):\n            The dropout ratio for the attention probabilities.\n        mlp_bias (`bool`, *optional*, defaults to `False`):\n            Whether to use a bias in up_proj, down_proj and gate_proj layers in the MLP layers.\n        head_dim (`int`, *optional*):\n            The attention head dimension. If None, it will default to hidden_size // num_heads\n        embedding_multiplier (`float, *optional*, defaults to `None`):\n            Multiplier applied to the embedding weights. If `None`, it is equivalent to `1.0`.\n        logits_scaling (`float, *optional*, defaults to `None`):\n            Scaling factor for logits. If `None`, it is equivalent to `1.0`.\n        attention_multiplier (`float, *optional*, defaults to `None`):\n            Multiplier applied to the attention weights. If `None`, it is equivalent to `self.head_dim ** -0.5`.\n        residual_multiplier (`float, *optional*, defaults to `None`):\n            Scaling factor for residual connections. If `None`, it is equivalent to `1.0`.\n        use_post_norm (`bool`, *optional*, defaults to `False`):\n            Determines whether to apply Peri-Layer Normalization. Set to True to enable this feature.\n\n    ```python\n    >>> from transformers import HyperCLOVAXModel, HyperCLOVAXConfig\n\n    >>> # Initializing a HyperCLOVAX HyperCLOVAX style configuration\n    >>> configuration = HyperCLOVAXConfig()\n\n    >>> # Initializing a model from the HyperCLOVAX style configuration\n    >>> model = HyperCLOVAXModel(configuration)\n\n    >>> # Accessing the model configuration\n    >>> configuration = model.config\n    ```\"\"\"\n\n    model_type = \"hyperclovax\"\n    keys_to_ignore_at_inference = [\"past_key_values\"]\n\n    def __init__(\n        self,\n        vocab_size=32000,\n        hidden_size=4096,\n        intermediate_size=11008,\n        num_hidden_layers=32,\n        num_attention_heads=32,\n        num_key_value_heads=None,\n        hidden_act=\"silu\",\n        max_position_embeddings=2048,\n        initializer_range=0.02,\n        rms_norm_eps=1e-6,\n        use_cache=True,\n        pad_token_id=None,\n        bos_token_id=1,\n        eos_token_id=2,\n        pretraining_tp=1,\n        tie_word_embeddings=False,\n        rope_theta=10000.0,\n        rope_scaling=None,\n        attention_bias=False,\n        attention_dropout=0.0,\n        mlp_bias=False,\n        head_dim=None,\n        embedding_multiplier=None, # MuP\n        logits_scaling=None, # MuP\n        attention_multiplier=None, # MuP\n        residual_multiplier=None, # MuP\n        use_post_norm=False, # Peri-LN (post-norm)\n        auto_map={\n            \"AutoConfig\": \"configuration_hyperclovax.HyperCLOVAXConfig\",\n            \"AutoModel\": \"modeling_hyperclovax.HyperCLOVAXModel\",\n            \"AutoModelForCausalLM\": \"modeling_hyperclovax.HyperCLOVAXForCausalLM\"\n        },\n        **kwargs,\n    ):\n        self.vocab_size = vocab_size\n        self.max_position_embeddings = max_position_embeddings\n        self.hidden_size = hidden_size\n        self.intermediate_size = intermediate_size\n        self.num_hidden_layers = num_hidden_layers\n        self.num_attention_heads = num_attention_heads\n\n        # for backward compatibility\n        if num_key_value_heads is None:\n            num_key_value_heads = num_attention_heads\n\n        self.num_key_value_heads = num_key_value_heads\n        self.hidden_act = hidden_act\n        self.initializer_range = initializer_range\n        self.rms_norm_eps = rms_norm_eps\n        self.pretraining_tp = pretraining_tp\n        self.use_cache = use_cache\n        self.rope_theta = rope_theta\n        self.rope_scaling = rope_scaling\n        self.attention_bias = attention_bias\n        self.attention_dropout = attention_dropout\n        self.mlp_bias = mlp_bias\n        self.head_dim = head_dim if head_dim is not None else self.hidden_size // self.num_attention_heads\n        # Validate the correctness of rotary position embeddings parameters\n        # BC: if there is a 'type' field, copy it it to 'rope_type'.\n        if self.rope_scaling is not None and \"type\" in self.rope_scaling:\n            self.rope_scaling[\"rope_type\"] = self.rope_scaling[\"type\"]\n        # rope_config_validation(self)\n\n        # MuP\n        self.embedding_multiplier = embedding_multiplier if embedding_multiplier is not None else 1.0\n        self.logits_scaling = logits_scaling if logits_scaling is not None else 1.0\n        self.attention_multiplier = attention_multiplier if attention_multiplier is not None else self.head_dim ** -0.5\n        self.residual_multiplier = residual_multiplier if residual_multiplier is not None else 1.0\n\n        # Peri-LN (post-norm)\n        self.use_post_norm = use_post_norm\n\n        super().__init__(\n            pad_token_id=pad_token_id,\n            bos_token_id=bos_token_id,\n            eos_token_id=eos_token_id,\n            tie_word_embeddings=tie_word_embeddings,\n            auto_map=auto_map,\n            **kwargs,\n        )\n",
        "modeling_hyperclovax.py": "# coding=utf-8\n# This file was created for the HyperCLOVA X SEED 14B Think architecture.\n# partially copied and modified from\n# https://github.com/huggingface/transformers/blob/v4.52.4/src/transformers/models/llama/modeling_llama.py\n# Copyright 2022 EleutherAI and the HuggingFace Inc. team. All rights reserved.\n#\n# This code is based on EleutherAI's GPT-NeoX library and the GPT-NeoX\n# and OPT implementations in this library. It has been modified from its\n# original forms to accommodate minor architectural differences compared\n# to GPT-NeoX and OPT used by the Meta AI team that trained the model.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom typing import Callable, Optional, Union\n\nimport torch\nimport torch.utils.checkpoint\nfrom torch import nn\n\nfrom transformers.activations import ACT2FN\nfrom transformers.cache_utils import Cache, DynamicCache\nfrom transformers.generation import GenerationMixin\nfrom transformers.modeling_attn_mask_utils import AttentionMaskConverter\nfrom transformers.integrations import use_kernel_forward_from_hub\nfrom transformers.modeling_flash_attention_utils import FlashAttentionKwargs\nfrom transformers.modeling_layers import GradientCheckpointingLayer\nfrom transformers.modeling_outputs import (\n    BaseModelOutputWithPast,\n    CausalLMOutputWithPast,\n    QuestionAnsweringModelOutput,\n    SequenceClassifierOutputWithPast,\n    TokenClassifierOutput,\n)\nfrom transformers.modeling_rope_utils import ROPE_INIT_FUNCTIONS, dynamic_rope_update\nfrom transformers.modeling_utils import ALL_ATTENTION_FUNCTIONS, PreTrainedModel\nfrom transformers.processing_utils import Unpack\nfrom transformers.pytorch_utils import ALL_LAYERNORM_LAYERS\nfrom transformers.utils import auto_docstring, can_return_tuple, is_torch_flex_attn_available, logging\ntry:\n    from transformers.utils import LossKwargs\n    loss_kwargs_class = LossKwargs\nexcept ImportError:\n    from transformers.utils import TransformersKwargs\n    loss_kwargs_class = TransformersKwargs\n\nfrom .configuration_hyperclovax import HyperCLOVAXConfig\nif is_torch_flex_attn_available():\n    from torch.nn.attention.flex_attention import BlockMask\n\n    from transformers.integrations.flex_attention import make_flex_block_causal_mask\n\nlogger = logging.get_logger(__name__)\n\n\n@use_kernel_forward_from_hub(\"RMSNorm\")\nclass HyperCLOVAXRMSNorm(nn.Module):\n    def __init__(self, hidden_size, eps=1e-6):\n        \"\"\"\n        HyperCLOVAXRMSNorm is equivalent to T5LayerNorm\n        \"\"\"\n        super().__init__()\n        self.weight = nn.Parameter(torch.ones(hidden_size))\n        self.variance_epsilon = eps\n\n    def forward(self, hidden_states):\n        input_dtype = hidden_states.dtype\n        hidden_states = hidden_states.to(torch.float32)\n        variance = hidden_states.pow(2).mean(-1, keepdim=True)\n        hidden_states = hidden_states * torch.rsqrt(variance + self.variance_epsilon)\n        return self.weight * hidden_states.to(input_dtype)\n\n    def extra_repr(self):\n        return f\"{tuple(self.weight.shape)}, eps={self.variance_epsilon}\"\n\nALL_LAYERNORM_LAYERS.append(HyperCLOVAXRMSNorm)\nclass HyperCLOVAXRotaryEmbedding(nn.Module):\n    def __init__(self, config: HyperCLOVAXConfig, device=None):\n        super().__init__()\n        # BC: \"rope_type\" was originally \"type\"\n        if hasattr(config, \"rope_scaling\") and config.rope_scaling is not None:\n            self.rope_type = config.rope_scaling.get(\"rope_type\", config.rope_scaling.get(\"type\"))\n        else:\n            self.rope_type = \"default\"\n        self.max_seq_len_cached = config.max_position_embeddings\n        self.original_max_seq_len = config.max_position_embeddings\n\n        self.config = config\n        self.rope_init_fn = ROPE_INIT_FUNCTIONS[self.rope_type]\n\n        inv_freq, self.attention_scaling = self.rope_init_fn(self.config, device)\n        self.register_buffer(\"inv_freq\", inv_freq, persistent=False)\n        self.original_inv_freq = self.inv_freq\n\n    @torch.no_grad()\n    @dynamic_rope_update  # power user: used with advanced RoPE types (e.g. dynamic rope)\n    def forward(self, x, position_ids):\n        inv_freq_expanded = self.inv_freq[None, :, None].float().expand(position_ids.shape[0], -1, 1).to(x.device)\n        position_ids_expanded = position_ids[:, None, :].float()\n\n        device_type = x.device.type if isinstance(x.device.type, str) and x.device.type != \"mps\" else \"cpu\"\n        with torch.autocast(device_type=device_type, enabled=False):  # Force float32\n            freqs = (inv_freq_expanded.float() @ position_ids_expanded.float()).transpose(1, 2)\n            emb = torch.cat((freqs, freqs), dim=-1)\n            cos = emb.cos() * self.attention_scaling\n            sin = emb.sin() * self.attention_scaling\n\n        return cos.to(dtype=x.dtype), sin.to(dtype=x.dtype)\n\n\ndef rotate_half(x):\n    \"\"\"Rotates half the hidden dims of the input.\"\"\"\n    x1 = x[..., : x.shape[-1] // 2]\n    x2 = x[..., x.shape[-1] // 2 :]\n    return torch.cat((-x2, x1), dim=-1)\n\n\ndef apply_rotary_pos_emb(q, k, cos, sin, position_ids=None, unsqueeze_dim=1):\n    \"\"\"Applies Rotary Position Embedding to the query and key tensors.\n\n    Args:\n        q (`torch.Tensor`): The query tensor.\n        k (`torch.Tensor`): The key tensor.\n        cos (`torch.Tensor`): The cosine part of the rotary embedding.\n        sin (`torch.Tensor`): The sine part of the rotary embedding.\n        position_ids (`torch.Tensor`, *optional*):\n            Deprecated and unused.\n        unsqueeze_dim (`int`, *optional*, defaults to 1):\n            The 'unsqueeze_dim' argument specifies the dimension along which to unsqueeze cos[position_ids] and\n            sin[position_ids] so that they can be properly broadcasted to the dimensions of q and k. For example, note\n            that cos[position_ids] and sin[position_ids] have the shape [batch_size, seq_len, head_dim]. Then, if q and\n            k have the shape [batch_size, heads, seq_len, head_dim], then setting unsqueeze_dim=1 makes\n            cos[position_ids] and sin[position_ids] broadcastable to the shapes of q and k. Similarly, if q and k have\n            the shape [batch_size, seq_len, heads, head_dim], then set unsqueeze_dim=2.\n    Returns:\n        `tuple(torch.Tensor)` comprising of the query and key tensors rotated using the Rotary Position Embedding.\n    \"\"\"\n    cos = cos.unsqueeze(unsqueeze_dim)\n    sin = sin.unsqueeze(unsqueeze_dim)\n    q_embed = (q * cos) + (rotate_half(q) * sin)\n    k_embed = (k * cos) + (rotate_half(k) * sin)\n    return q_embed, k_embed\n\n\nclass HyperCLOVAXMLP(nn.Module):\n    def __init__(self, config):\n        super().__init__()\n        self.config = config\n        self.hidden_size = config.hidden_size\n        self.intermediate_size = config.intermediate_size\n        self.gate_proj = nn.Linear(self.hidden_size, self.intermediate_size, bias=config.mlp_bias)\n        self.up_proj = nn.Linear(self.hidden_size, self.intermediate_size, bias=config.mlp_bias)\n        self.down_proj = nn.Linear(self.intermediate_size, self.hidden_size, bias=config.mlp_bias)\n        self.act_fn = ACT2FN[config.hidden_act]\n\n    def forward(self, x):\n        down_proj = self.down_proj(self.act_fn(self.gate_proj(x)) * self.up_proj(x))\n        return down_proj\n\n\ndef repeat_kv(hidden_states: torch.Tensor, n_rep: int) -> torch.Tensor:\n    \"\"\"\n    This is the equivalent of torch.repeat_interleave(x, dim=1, repeats=n_rep). The hidden states go from (batch,\n    num_key_value_heads, seqlen, head_dim) to (batch, num_attention_heads, seqlen, head_dim)\n    \"\"\"\n    batch, num_key_value_heads, slen, head_dim = hidden_states.shape\n    if n_rep == 1:\n        return hidden_states\n    hidden_states = hidden_states[:, :, None, :, :].expand(batch, num_key_value_heads, n_rep, slen, head_dim)\n    return hidden_states.reshape(batch, num_key_value_heads * n_rep, slen, head_dim)\n\n\ndef eager_attention_forward(\n    module: nn.Module,\n    query: torch.Tensor,\n    key: torch.Tensor,\n    value: torch.Tensor,\n    attention_mask: Optional[torch.Tensor],\n    scaling: float,\n    dropout: float = 0.0,\n    **kwargs,\n):\n    key_states = repeat_kv(key, module.num_key_value_groups)\n    value_states = repeat_kv(value, module.num_key_value_groups)\n\n    attn_weights = torch.matmul(query, key_states.transpose(2, 3)) * scaling\n    if attention_mask is not None:\n        causal_mask = attention_mask[:, :, :, : key_states.shape[-2]]\n        attn_weights = attn_weights + causal_mask\n\n    attn_weights = nn.functional.softmax(attn_weights, dim=-1, dtype=torch.float32).to(query.dtype)\n    attn_weights = nn.functional.dropout(attn_weights, p=dropout, training=module.training)\n    attn_output = torch.matmul(attn_weights, value_states)\n    attn_output = attn_output.transpose(1, 2).contiguous()\n\n    return attn_output, attn_weights\n\n\nclass HyperCLOVAXAttention(nn.Module):\n    \"\"\"Multi-headed attention from 'Attention Is All You Need' paper\"\"\"\n\n    def __init__(self, config: HyperCLOVAXConfig, layer_idx: int):\n        super().__init__()\n        self.config = config\n        self.layer_idx = layer_idx\n        self.head_dim = getattr(config, \"head_dim\", config.hidden_size // config.num_attention_heads)\n        self.num_key_value_groups = config.num_attention_heads // config.num_key_value_heads\n        self.scaling = getattr(config, \"attention_multiplier\", self.head_dim**-0.5) # MuP\n        self.attention_dropout = config.attention_dropout\n        self.is_causal = True\n\n        self.q_proj = nn.Linear(\n            config.hidden_size, config.num_attention_heads * self.head_dim, bias=config.attention_bias\n        )\n        self.k_proj = nn.Linear(\n            config.hidden_size, config.num_key_value_heads * self.head_dim, bias=config.attention_bias\n        )\n        self.v_proj = nn.Linear(\n            config.hidden_size, config.num_key_value_heads * self.head_dim, bias=config.attention_bias\n        )\n        self.o_proj = nn.Linear(\n            config.num_attention_heads * self.head_dim, config.hidden_size, bias=config.attention_bias\n        )\n\n    def forward(\n        self,\n        hidden_states: torch.Tensor,\n        position_embeddings: tuple[torch.Tensor, torch.Tensor],\n        attention_mask: Optional[torch.Tensor],\n        past_key_value: Optional[Cache] = None,\n        cache_position: Optional[torch.LongTensor] = None,\n        **kwargs: Unpack[FlashAttentionKwargs],\n    ) -> tuple[torch.Tensor, Optional[torch.Tensor], Optional[tuple[torch.Tensor]]]:\n        input_shape = hidden_states.shape[:-1]\n        hidden_shape = (*input_shape, -1, self.head_dim)\n\n        query_states = self.q_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n        key_states = self.k_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n        value_states = self.v_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n\n        cos, sin = position_embeddings\n        query_states, key_states = apply_rotary_pos_emb(query_states, key_states, cos, sin)\n\n        if past_key_value is not None:\n            # sin and cos are specific to RoPE models; cache_position needed for the static cache\n            cache_kwargs = {\"sin\": sin, \"cos\": cos, \"cache_position\": cache_position}\n            key_states, value_states = past_key_value.update(key_states, value_states, self.layer_idx, cache_kwargs)\n\n        attention_interface: Callable = eager_attention_forward\n\n        if self.config._attn_implementation != \"eager\":\n            if self.config._attn_implementation == \"sdpa\" and kwargs.get(\"output_attentions\", False):\n                logger.warning_once(\n                    \"`torch.nn.functional.scaled_dot_product_attention` does not support `output_attentions=True`. Falling back to \"\n                    'eager attention. This warning can be removed using the argument `attn_implementation=\"eager\"` when loading the model.'\n                )\n            else:\n                attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n\n        attn_output, attn_weights = attention_interface(\n            self,\n            query_states,\n            key_states,\n            value_states,\n            attention_mask,\n            dropout=0.0 if not self.training else self.attention_dropout,\n            scaling=self.scaling,\n            **kwargs,\n        )\n\n        attn_output = attn_output.reshape(*input_shape, -1).contiguous()\n        attn_output = self.o_proj(attn_output)\n        return attn_output, attn_weights\n\n\nclass HyperCLOVAXDecoderLayer(GradientCheckpointingLayer):\n    def __init__(self, config: HyperCLOVAXConfig, layer_idx: int):\n        super().__init__()\n        self.hidden_size = config.hidden_size\n\n        self.self_attn = HyperCLOVAXAttention(config=config, layer_idx=layer_idx)\n\n        self.mlp = HyperCLOVAXMLP(config)\n        self.input_layernorm = HyperCLOVAXRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n        self.post_attention_layernorm = HyperCLOVAXRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n        self.use_post_norm = getattr(config, \"use_post_norm\", False)\n\n        # Peri-LN (post-norm)\n        if self.use_post_norm:\n            self.post_norm1 = HyperCLOVAXRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n            self.post_norm2 = HyperCLOVAXRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n\n        self.residual_multiplier = getattr(config, \"residual_multiplier\", 1.0) # MuP\n\n    def forward(\n        self,\n        hidden_states: torch.Tensor,\n        attention_mask: Optional[torch.Tensor] = None,\n        position_ids: Optional[torch.LongTensor] = None,\n        past_key_value: Optional[Cache] = None,\n        output_attentions: Optional[bool] = False,\n        use_cache: Optional[bool] = False,\n        cache_position: Optional[torch.LongTensor] = None,\n        position_embeddings: Optional[tuple[torch.Tensor, torch.Tensor]] = None,  # necessary, but kept here for BC\n        **kwargs: Unpack[FlashAttentionKwargs],\n    ) -> tuple[torch.FloatTensor, Optional[tuple[torch.FloatTensor, torch.FloatTensor]]]:\n        residual = hidden_states\n        hidden_states = self.input_layernorm(hidden_states)\n\n        # Self Attention\n        hidden_states, self_attn_weights = self.self_attn(\n            hidden_states=hidden_states,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            past_key_value=past_key_value,\n            output_attentions=output_attentions,\n            use_cache=use_cache,\n            cache_position=cache_position,\n            position_embeddings=position_embeddings,\n            **kwargs,\n        )\n\n        if self.use_post_norm: # Peri-LN\n            hidden_states = self.post_norm1(hidden_states)\n\n        hidden_states = residual + hidden_states * self.residual_multiplier # MuP\n\n        # Fully Connected\n        residual = hidden_states\n        hidden_states = self.post_attention_layernorm(hidden_states)\n        hidden_states = self.mlp(hidden_states)\n\n        if self.use_post_norm: # Peri-LN\n            hidden_states = self.post_norm2(hidden_states)\n\n        hidden_states = residual + hidden_states * self.residual_multiplier # MuP\n\n        outputs = (hidden_states,)\n        if output_attentions:\n            outputs += (self_attn_weights,)\n\n        return outputs\n\n\n@auto_docstring\nclass HyperCLOVAXPreTrainedModel(PreTrainedModel):\n    config_class = HyperCLOVAXConfig\n    base_model_prefix = \"model\"\n    supports_gradient_checkpointing = True\n    _no_split_modules = [\"HyperCLOVAXDecoderLayer\"]\n    _skip_keys_device_placement = [\"past_key_values\"]\n    _supports_flash_attn_2 = True\n    _supports_sdpa = True\n    _supports_flex_attn = True\n    _supports_cache_class = True\n    _supports_quantized_cache = True\n    _supports_static_cache = True\n    _supports_attention_backend = True\n\n    def _init_weights(self, module):\n        std = self.config.initializer_range\n        if isinstance(module, nn.Linear):\n            module.weight.data.normal_(mean=0.0, std=std)\n            if module.bias is not None:\n                module.bias.data.zero_()\n        elif isinstance(module, nn.Embedding):\n            module.weight.data.normal_(mean=0.0, std=std)\n            if module.padding_idx is not None:\n                module.weight.data[module.padding_idx].zero_()\n        elif isinstance(module, HyperCLOVAXRMSNorm):\n            module.weight.data.fill_(1.0)\n\n\n@auto_docstring\nclass HyperCLOVAXModel(HyperCLOVAXPreTrainedModel):\n    def __init__(self, config: HyperCLOVAXConfig):\n        super().__init__(config)\n        self.padding_idx = config.pad_token_id\n        self.vocab_size = config.vocab_size\n\n        self.embed_tokens = nn.Embedding(config.vocab_size, config.hidden_size, self.padding_idx)\n        self.layers = nn.ModuleList(\n            [HyperCLOVAXDecoderLayer(config, layer_idx) for layer_idx in range(config.num_hidden_layers)]\n        )\n        self.norm = HyperCLOVAXRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n        self.rotary_emb = HyperCLOVAXRotaryEmbedding(config=config)\n        self.gradient_checkpointing = False\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n        # MuP\n        self.embedding_multiplier = getattr(config, \"embedding_multiplier\", 1.0)\n\n    def get_input_embeddings(self):\n        return self.embed_tokens\n\n    def set_input_embeddings(self, value):\n        self.embed_tokens = value\n\n    @can_return_tuple\n    @auto_docstring\n    def forward(\n        self,\n        input_ids: Optional[torch.LongTensor] = None,\n        attention_mask: Optional[torch.Tensor] = None,\n        position_ids: Optional[torch.LongTensor] = None,\n        past_key_values: Optional[Cache] = None,\n        inputs_embeds: Optional[torch.FloatTensor] = None,\n        use_cache: Optional[bool] = None,\n        output_attentions: Optional[bool] = None,\n        output_hidden_states: Optional[bool] = None,\n        cache_position: Optional[torch.LongTensor] = None,\n        **flash_attn_kwargs: Unpack[FlashAttentionKwargs],\n    ) -> BaseModelOutputWithPast:\n        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n        output_hidden_states = (\n            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n        )\n        use_cache = use_cache if use_cache is not None else self.config.use_cache\n\n        if (input_ids is None) ^ (inputs_embeds is not None):\n            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n\n        if self.gradient_checkpointing and self.training and use_cache:\n            logger.warning_once(\n                \"`use_cache=True` is incompatible with gradient checkpointing. Setting `use_cache=False`.\"\n            )\n            use_cache = False\n\n        # TODO (joao): remove this exception in v4.56 -- it exists for users that try to pass a legacy cache\n        if not isinstance(past_key_values, (type(None), Cache)):\n            raise ValueError(\"The `past_key_values` should be either a `Cache` object or `None`.\")\n\n        if inputs_embeds is None:\n            inputs_embeds = self.embed_tokens(input_ids)\n\n        inputs_embeds = inputs_embeds * self.embedding_multiplier # MuP\n\n        if use_cache and past_key_values is None:\n            past_key_values = DynamicCache()\n\n        if cache_position is None:\n            past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n            cache_position = torch.arange(\n                past_seen_tokens, past_seen_tokens + inputs_embeds.shape[1], device=inputs_embeds.device\n            )\n\n        if position_ids is None:\n            position_ids = cache_position.unsqueeze(0)\n\n        causal_mask = self._update_causal_mask(\n            attention_mask, inputs_embeds, cache_position, past_key_values, output_attentions\n        )\n\n        hidden_states = inputs_embeds\n\n        # create position embeddings to be shared across the decoder layers\n        position_embeddings = self.rotary_emb(hidden_states, position_ids)\n\n        # decoder layers\n        all_hidden_states = () if output_hidden_states else None\n        all_self_attns = () if output_attentions else None\n\n        for decoder_layer in self.layers[: self.config.num_hidden_layers]:\n            if output_hidden_states:\n                all_hidden_states += (hidden_states,)\n\n            layer_outputs = decoder_layer(\n                hidden_states,\n                attention_mask=causal_mask,\n                position_ids=position_ids,\n                past_key_value=past_key_values,\n                output_attentions=output_attentions,\n                use_cache=use_cache,\n                cache_position=cache_position,\n                position_embeddings=position_embeddings,\n                **flash_attn_kwargs,\n            )\n\n            hidden_states = layer_outputs[0]\n\n            if output_attentions:\n                all_self_attns += (layer_outputs[1],)\n\n        hidden_states = self.norm(hidden_states)\n\n        # add hidden states from the last decoder layer\n        if output_hidden_states:\n            all_hidden_states += (hidden_states,)\n\n        return BaseModelOutputWithPast(\n            last_hidden_state=hidden_states,\n            past_key_values=past_key_values if use_cache else None,\n            hidden_states=all_hidden_states,\n            attentions=all_self_attns,\n        )\n\n    def _update_causal_mask(\n        self,\n        attention_mask: Union[torch.Tensor, \"BlockMask\"],\n        input_tensor: torch.Tensor,\n        cache_position: torch.Tensor,\n        past_key_values: Cache,\n        output_attentions: bool = False,\n    ):\n        if self.config._attn_implementation == \"flash_attention_2\":\n            if attention_mask is not None and (attention_mask == 0.0).any():\n                return attention_mask\n            return None\n        if self.config._attn_implementation == \"flex_attention\":\n            if isinstance(attention_mask, torch.Tensor):\n                attention_mask = make_flex_block_causal_mask(attention_mask)\n            return attention_mask\n\n        # For SDPA, when possible, we will rely on its `is_causal` argument instead of its `attn_mask` argument, in\n        # order to dispatch on Flash Attention 2. This feature is not compatible with static cache, as SDPA will fail\n        # to infer the attention mask.\n        past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n        using_compilable_cache = past_key_values.is_compileable if past_key_values is not None else False\n\n        # When output attentions is True, sdpa implementation's forward method calls the eager implementation's forward\n        if self.config._attn_implementation == \"sdpa\" and not using_compilable_cache and not output_attentions:\n            if AttentionMaskConverter._ignore_causal_mask_sdpa(\n                attention_mask,\n                inputs_embeds=input_tensor,\n                past_key_values_length=past_seen_tokens,\n                is_training=self.training,\n            ):\n                return None\n\n        dtype = input_tensor.dtype\n        sequence_length = input_tensor.shape[1]\n        if using_compilable_cache:\n            target_length = past_key_values.get_max_cache_shape()\n        else:\n            target_length = (\n                attention_mask.shape[-1]\n                if isinstance(attention_mask, torch.Tensor)\n                else past_seen_tokens + sequence_length + 1\n            )\n\n        # In case the provided `attention` mask is 2D, we generate a causal mask here (4D).\n        causal_mask = self._prepare_4d_causal_attention_mask_with_cache_position(\n            attention_mask,\n            sequence_length=sequence_length,\n            target_length=target_length,\n            dtype=dtype,\n            cache_position=cache_position,\n            batch_size=input_tensor.shape[0],\n        )\n\n        if (\n            self.config._attn_implementation == \"sdpa\"\n            and attention_mask is not None\n            and attention_mask.device.type in [\"cuda\", \"xpu\", \"npu\"]\n            and not output_attentions\n        ):\n            # Attend to all tokens in fully masked rows in the causal_mask, for example the relevant first rows when\n            # using left padding. This is required by F.scaled_dot_product_attention memory-efficient attention path.\n            # Details: https://github.com/pytorch/pytorch/issues/110213\n            min_dtype = torch.finfo(dtype).min\n            causal_mask = AttentionMaskConverter._unmask_unattended(causal_mask, min_dtype)\n\n        return causal_mask\n\n    @staticmethod\n    def _prepare_4d_causal_attention_mask_with_cache_position(\n        attention_mask: torch.Tensor,\n        sequence_length: int,\n        target_length: int,\n        dtype: torch.dtype,\n        cache_position: torch.Tensor,\n        batch_size: int,\n        **kwargs,\n    ):\n        \"\"\"\n        Creates a causal 4D mask of shape `(batch_size, 1, query_length, key_value_length)` from a 2D mask of shape\n        `(batch_size, key_value_length)`, or if the input `attention_mask` is already 4D, do nothing.\n\n        Args:\n            attention_mask (`torch.Tensor`):\n                A 2D attention mask of shape `(batch_size, key_value_length)` or a 4D attention mask of shape\n                `(batch_size, 1, query_length, key_value_length)`.\n            sequence_length (`int`):\n                The sequence length being processed.\n            target_length (`int`):\n                The target length: when generating with static cache, the mask should be as long as the static cache,\n                to account for the 0 padding, the part of the cache that is not filled yet.\n            dtype (`torch.dtype`):\n                The dtype to use for the 4D attention mask.\n            cache_position (`torch.Tensor`):\n                Indices depicting the position of the input sequence tokens in the sequence.\n            batch_size (`torch.Tensor`):\n                Batch size.\n        \"\"\"\n        if attention_mask is not None and attention_mask.dim() == 4:\n            # In this case we assume that the mask comes already in inverted form and requires no inversion or slicing.\n            causal_mask = attention_mask\n        else:\n            min_dtype = torch.finfo(dtype).min\n            causal_mask = torch.full(\n                (sequence_length, target_length), fill_value=min_dtype, dtype=dtype, device=cache_position.device\n            )\n            if sequence_length != 1:\n                causal_mask = torch.triu(causal_mask, diagonal=1)\n            causal_mask *= torch.arange(target_length, device=cache_position.device) > cache_position.reshape(-1, 1)\n            causal_mask = causal_mask[None, None, :, :].expand(batch_size, 1, -1, -1)\n            if attention_mask is not None:\n                causal_mask = causal_mask.clone()  # copy to contiguous memory for in-place edit\n                mask_length = attention_mask.shape[-1]\n                padding_mask = causal_mask[:, :, :, :mask_length] + attention_mask[:, None, None, :].to(\n                    causal_mask.device\n                )\n                padding_mask = padding_mask == 0\n                causal_mask[:, :, :, :mask_length] = causal_mask[:, :, :, :mask_length].masked_fill(\n                    padding_mask, min_dtype\n                )\n\n        return causal_mask\n\n\nclass KwargsForCausalLM(FlashAttentionKwargs, loss_kwargs_class): ...\n\n\n@auto_docstring\nclass HyperCLOVAXForCausalLM(HyperCLOVAXPreTrainedModel, GenerationMixin):\n    _tied_weights_keys = [\"lm_head.weight\"]\n    _tp_plan = {\"lm_head\": \"colwise_rep\"}\n    _pp_plan = {\"lm_head\": ([\"hidden_states\"], [\"logits\"])}\n\n    def __init__(self, config):\n        super().__init__(config)\n        self.model = HyperCLOVAXModel(config)\n        self.vocab_size = config.vocab_size\n        self.lm_head = nn.Linear(config.hidden_size, config.vocab_size, bias=False)\n        self.logits_scaling = getattr(config, \"logits_scaling\", 1.0)\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def get_input_embeddings(self):\n        return self.model.embed_tokens\n\n    def set_input_embeddings(self, value):\n        self.model.embed_tokens = value\n\n    def get_output_embeddings(self):\n        return self.lm_head\n\n    def set_output_embeddings(self, new_embeddings):\n        self.lm_head = new_embeddings\n\n    def set_decoder(self, decoder):\n        self.model = decoder\n\n    def get_decoder(self):\n        return self.model\n\n    @can_return_tuple\n    @auto_docstring\n    def forward(\n        self,\n        input_ids: Optional[torch.LongTensor] = None,\n        attention_mask: Optional[torch.Tensor] = None,\n        position_ids: Optional[torch.LongTensor] = None,\n        past_key_values: Optional[Cache] = None,\n        inputs_embeds: Optional[torch.FloatTensor] = None,\n        labels: Optional[torch.LongTensor] = None,\n        use_cache: Optional[bool] = None,\n        output_attentions: Optional[bool] = None,\n        output_hidden_states: Optional[bool] = None,\n        cache_position: Optional[torch.LongTensor] = None,\n        logits_to_keep: Union[int, torch.Tensor] = 0,\n        **kwargs: Unpack[KwargsForCausalLM],\n    ) -> CausalLMOutputWithPast:\n        r\"\"\"\n        labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n            Labels for computing the masked language modeling loss. Indices should either be in `[0, ...,\n            config.vocab_size]` or -100 (see `input_ids` docstring). Tokens with indices set to `-100` are ignored\n            (masked), the loss is only computed for the tokens with labels in `[0, ..., config.vocab_size]`.\n\n        Example:\n\n        ```python\n        >>> from transformers import AutoTokenizer, HyperCLOVAXForCausalLM\n\n        >>> model = HyperCLOVAXForCausalLM.from_pretrained(\"naver-hyperclovax/{model_name}\")\n        >>> tokenizer = AutoTokenizer.from_pretrained(\"naver-hyperclovax/{model_name}\")\n\n        >>> prompt = \"Hey, are you conscious? Can you talk to me?\"\n        >>> inputs = tokenizer(prompt, return_tensors=\"pt\")\n\n        >>> # Generate\n        >>> generate_ids = model.generate(inputs.input_ids, max_length=30)\n        >>> tokenizer.batch_decode(generate_ids, skip_special_tokens=True, clean_up_tokenization_spaces=False)[0]\n        \"Hey, are you conscious? Can you talk to me?\\nI'm not conscious, but I can talk to you.\"\n        ```\"\"\"\n        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n        output_hidden_states = (\n            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n        )\n\n        # decoder outputs consists of (dec_features, layer_state, dec_hidden, dec_attn)\n        outputs: BaseModelOutputWithPast = self.model(\n            input_ids=input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            past_key_values=past_key_values,\n            inputs_embeds=inputs_embeds,\n            use_cache=use_cache,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            cache_position=cache_position,\n            **kwargs,\n        )\n\n        hidden_states = outputs.last_hidden_state\n        # Only compute necessary logits, and do not upcast them to float if we are not computing the loss\n        slice_indices = slice(-logits_to_keep, None) if isinstance(logits_to_keep, int) else logits_to_keep\n        # MuP\n        logits = self.lm_head(hidden_states[:, slice_indices, :]) * self.logits_scaling\n\n        loss = None\n        if labels is not None:\n            loss = self.loss_function(logits=logits, labels=labels, vocab_size=self.config.vocab_size, **kwargs)\n\n        return CausalLMOutputWithPast(\n            loss=loss,\n            logits=logits,\n            past_key_values=outputs.past_key_values,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n\n\n@auto_docstring(\n    custom_intro=\"\"\"\n    The HyperCLOVAX Model transformer with a sequence classification head on top (linear layer).\n\n    [`HyperCLOVAXForSequenceClassification`] uses the last token in order to do the classification, as other causal models\n    (e.g. GPT-2) do.\n\n    Since it does classification on the last token, it requires to know the position of the last token. If a\n    `pad_token_id` is defined in the configuration, it finds the last token that is not a padding token in each row. If\n    no `pad_token_id` is defined, it simply takes the last value in each row of the batch. Since it cannot guess the\n    padding tokens when `inputs_embeds` are passed instead of `input_ids`, it does the same (take the last value in\n    each row of the batch).\n    \"\"\"\n)\nclass HyperCLOVAXForSequenceClassification(HyperCLOVAXPreTrainedModel):\n    def __init__(self, config):\n        super().__init__(config)\n        self.num_labels = config.num_labels\n        self.model = HyperCLOVAXModel(config)\n        self.score = nn.Linear(config.hidden_size, self.num_labels, bias=False)\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def get_input_embeddings(self):\n        return self.model.embed_tokens\n\n    def set_input_embeddings(self, value):\n        self.model.embed_tokens = value\n\n    @can_return_tuple\n    @auto_docstring\n    def forward(\n        self,\n        input_ids: Optional[torch.LongTensor] = None,\n        attention_mask: Optional[torch.Tensor] = None,\n        position_ids: Optional[torch.LongTensor] = None,\n        past_key_values: Optional[Cache] = None,\n        inputs_embeds: Optional[torch.FloatTensor] = None,\n        labels: Optional[torch.LongTensor] = None,\n        use_cache: Optional[bool] = None,\n        output_attentions: Optional[bool] = None,\n        output_hidden_states: Optional[bool] = None,\n    ) -> SequenceClassifierOutputWithPast:\n        r\"\"\"\n        labels (`torch.LongTensor` of shape `(batch_size,)`, *optional*):\n            Labels for computing the sequence classification/regression loss. Indices should be in `[0, ...,\n            config.num_labels - 1]`. If `config.num_labels == 1` a regression loss is computed (Mean-Square loss), If\n            `config.num_labels > 1` a classification loss is computed (Cross-Entropy).\n        \"\"\"\n\n        transformer_outputs: BaseModelOutputWithPast = self.model(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            past_key_values=past_key_values,\n            inputs_embeds=inputs_embeds,\n            use_cache=use_cache,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n        )\n        hidden_states = transformer_outputs.last_hidden_state\n        logits = self.score(hidden_states)\n\n        if input_ids is not None:\n            batch_size = input_ids.shape[0]\n        else:\n            batch_size = inputs_embeds.shape[0]\n\n        if self.config.pad_token_id is None and batch_size != 1:\n            raise ValueError(\"Cannot handle batch sizes > 1 if no padding token is defined.\")\n        if self.config.pad_token_id is None:\n            last_non_pad_token = -1\n        elif input_ids is not None:\n            # To handle both left- and right- padding, we take the rightmost token that is not equal to pad_token_id\n            non_pad_mask = (input_ids != self.config.pad_token_id).to(logits.device, torch.int32)\n            token_indices = torch.arange(input_ids.shape[-1], device=logits.device, dtype=torch.int32)\n            last_non_pad_token = (token_indices * non_pad_mask).argmax(-1)\n        else:\n            last_non_pad_token = -1\n            logger.warning_once(\n                f\"{self.__class__.__name__} will not detect padding tokens in `inputs_embeds`. Results may be \"\n                \"unexpected if using padding tokens in conjunction with `inputs_embeds.`\"\n            )\n\n        pooled_logits = logits[torch.arange(batch_size, device=logits.device), last_non_pad_token]\n\n        loss = None\n        if labels is not None:\n            loss = self.loss_function(logits=logits, labels=labels, pooled_logits=pooled_logits, config=self.config)\n\n        return SequenceClassifierOutputWithPast(\n            loss=loss,\n            logits=pooled_logits,\n            past_key_values=transformer_outputs.past_key_values,\n            hidden_states=transformer_outputs.hidden_states,\n            attentions=transformer_outputs.attentions,\n        )\n\n\n@auto_docstring\nclass HyperCLOVAXForQuestionAnswering(HyperCLOVAXPreTrainedModel):\n    base_model_prefix = \"transformer\"\n\n    # Copied from transformers.models.bloom.modeling_bloom.BloomForQuestionAnswering.__init__ with Bloom->HyperCLOVAX\n    def __init__(self, config):\n        super().__init__(config)\n        self.transformer = HyperCLOVAXModel(config)\n        self.qa_outputs = nn.Linear(config.hidden_size, 2)\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def get_input_embeddings(self):\n        return self.transformer.embed_tokens\n\n    def set_input_embeddings(self, value):\n        self.transformer.embed_tokens = value\n\n    @can_return_tuple\n    @auto_docstring\n    def forward(\n        self,\n        input_ids: Optional[torch.LongTensor] = None,\n        attention_mask: Optional[torch.Tensor] = None,\n        position_ids: Optional[torch.LongTensor] = None,\n        past_key_values: Optional[Cache] = None,\n        inputs_embeds: Optional[torch.FloatTensor] = None,\n        start_positions: Optional[torch.LongTensor] = None,\n        end_positions: Optional[torch.LongTensor] = None,\n        output_attentions: Optional[bool] = None,\n        output_hidden_states: Optional[bool] = None,\n        **kwargs,\n    ) -> QuestionAnsweringModelOutput:\n        outputs: BaseModelOutputWithPast = self.transformer(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            past_key_values=past_key_values,\n            inputs_embeds=inputs_embeds,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n        )\n\n        sequence_output = outputs.last_hidden_state\n\n        logits = self.qa_outputs(sequence_output)\n        start_logits, end_logits = logits.split(1, dim=-1)\n        start_logits = start_logits.squeeze(-1).contiguous()\n        end_logits = end_logits.squeeze(-1).contiguous()\n\n        loss = None\n        if start_positions is not None and end_positions is not None:\n            loss = self.loss_function(start_logits, end_logits, start_positions, end_positions, **kwargs)\n\n        return QuestionAnsweringModelOutput(\n            loss=loss,\n            start_logits=start_logits,\n            end_logits=end_logits,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n\n\n@auto_docstring\nclass HyperCLOVAXForTokenClassification(HyperCLOVAXPreTrainedModel):\n    def __init__(self, config):\n        super().__init__(config)\n        self.num_labels = config.num_labels\n        self.model = HyperCLOVAXModel(config)\n        if getattr(config, \"classifier_dropout\", None) is not None:\n            classifier_dropout = config.classifier_dropout\n        elif getattr(config, \"hidden_dropout\", None) is not None:\n            classifier_dropout = config.hidden_dropout\n        else:\n            classifier_dropout = 0.1\n        self.dropout = nn.Dropout(classifier_dropout)\n        self.score = nn.Linear(config.hidden_size, config.num_labels)\n\n        # Initialize weights and apply final processing\n        self.post_init()\n\n    def get_input_embeddings(self):\n        return self.model.embed_tokens\n\n    def set_input_embeddings(self, value):\n        self.model.embed_tokens = value\n\n    @can_return_tuple\n    @auto_docstring\n    def forward(\n        self,\n        input_ids: Optional[torch.LongTensor] = None,\n        attention_mask: Optional[torch.Tensor] = None,\n        position_ids: Optional[torch.LongTensor] = None,\n        past_key_values: Optional[Cache] = None,\n        inputs_embeds: Optional[torch.FloatTensor] = None,\n        labels: Optional[torch.LongTensor] = None,\n        use_cache: Optional[bool] = None,\n        output_attentions: Optional[bool] = None,\n        output_hidden_states: Optional[bool] = None,\n    ) -> TokenClassifierOutput:\n        r\"\"\"\n        labels (`torch.LongTensor` of shape `(batch_size,)`, *optional*):\n            Labels for computing the sequence classification/regression loss. Indices should be in `[0, ...,\n            config.num_labels - 1]`. If `config.num_labels == 1` a regression loss is computed (Mean-Square loss), If\n            `config.num_labels > 1` a classification loss is computed (Cross-Entropy).\n        \"\"\"\n\n        outputs: BaseModelOutputWithPast = self.model(\n            input_ids,\n            attention_mask=attention_mask,\n            position_ids=position_ids,\n            past_key_values=past_key_values,\n            inputs_embeds=inputs_embeds,\n            use_cache=use_cache,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n        )\n        sequence_output = outputs.last_hidden_state\n        sequence_output = self.dropout(sequence_output)\n        logits = self.score(sequence_output)\n\n        loss = None\n        if labels is not None:\n            loss = self.loss_function(logits, labels, self.config)\n\n        return TokenClassifierOutput(\n            loss=loss,\n            logits=logits,\n            hidden_states=outputs.hidden_states,\n            attentions=outputs.attentions,\n        )\n\n\n__all__ = [\n    \"HyperCLOVAXForCausalLM\",\n    \"HyperCLOVAXModel\",\n    \"HyperCLOVAXPreTrainedModel\",\n    \"HyperCLOVAXForSequenceClassification\",\n    \"HyperCLOVAXForQuestionAnswering\",\n    \"HyperCLOVAXForTokenClassification\",\n]"
    }
}