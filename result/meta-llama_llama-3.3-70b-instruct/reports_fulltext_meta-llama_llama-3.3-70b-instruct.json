{
  "model_id": "meta-llama/llama-3.3-70b-instruct",
  "full_texts": [
    {
      "arxiv_id": "https://r.jina.ai/https://www.llama.com/docs/overview",
      "full_text": "Title: Docs & Resources | Llama AI\n\nURL Source: https://www.llama.com/docs/overview\n\nMarkdown Content:\nDocs & Resources | Llama AI\n\n===============\n\n[Skip to main content](https://www.llama.com/docs/overview#mdc-main-content)\n\n[![Image 5: Meta](https://static.xx.fbcdn.net/rsrc.php/y9/r/tL_v571NdZ0.svg)](https://www.llama.com/)\n\nModels & Products\n\nDocs\n\nCommunity\n\nResources\n\n[Llama API](https://llama.developer.meta.com/join_waitlist)\n\n[Download models](https://www.llama.com/llama-downloads/)\n\n### Table Of Contents\n\nOverview\n\n[Overview](https://www.llama.com/docs/overview/)\n\n[Models](https://www.llama.com/docs/model-cards-and-prompt-formats/)[Llama 4](https://www.llama.com/docs/model-cards-and-prompt-formats/llama4/)[Llama Guard 4 (New)](https://www.llama.com/docs/model-cards-and-prompt-formats/llama-guard-4/)[Llama 3.3](https://www.llama.com/docs/model-cards-and-prompt-formats/llama3_3/)[Llama 3.2](https://www.llama.com/docs/model-cards-and-prompt-formats/llama3_2/)[Llama 3.1](https://www.llama.com/docs/model-cards-and-prompt-formats/llama3_1/)[Llama Guard 3](https://www.llama.com/docs/model-cards-and-prompt-formats/llama-guard-3/)[Llama Prompt Guard 2 (New)](https://www.llama.com/docs/model-cards-and-prompt-formats/prompt-guard/)[Other models](https://www.llama.com/docs/model-cards-and-prompt-formats/other-models/)\n\n[Getting the Models](https://www.llama.com/docs/getting_the_models/)[Meta](https://www.llama.com/docs/getting_the_models/meta/)[Hugging Face](https://www.llama.com/docs/getting-the-models/hugging-face/)[Kaggle](https://www.llama.com/docs/getting-the-models/kaggle/)[1B/3B Partners](https://www.llama.com/docs/getting-the-models/1b3b-partners/)[405B Partners](https://www.llama.com/docs/getting-the-models/405b-partners/)\n\n[Running Llama](https://www.llama.com/docs/llama-everywhere/)[Linux](https://www.llama.com/docs/llama-everywhere/running-meta-llama-on-linux/)[Windows](https://www.llama.com/docs/llama-everywhere/running-meta-llama-on-windows/)[Mac](https://www.llama.com/docs/llama-everywhere/running-meta-llama-on-mac/)[Cloud](https://www.llama.com/docs/llama-everywhere/running-meta-llama-in-the-cloud/)[Migration (New)](https://www.llama.com/docs/llama-everywhere/migration/)[Deployment (New)](https://www.llama.com/docs/llama-everywhere/deployment-patterns/)\n\n[How-To Guides](https://www.llama.com/docs/how-to-guides/)[Fine-tuning](https://www.llama.com/docs/how-to-guides/fine-tuning/)[Quantization (Updated)](https://www.llama.com/docs/how-to-guides/quantization/)[Prompting](https://www.llama.com/docs/how-to-guides/prompting/)[Validation](https://www.llama.com/docs/how-to-guides/validation/)[Vision Capabilities](https://www.llama.com/docs/how-to-guides/vision-capabilities/)[Responsible Use](https://www.llama.com/docs/how-to-guides/responsible-use-guide-resources/)\n\n[Integration Guides](https://www.llama.com/docs/integration-guides/)[LangChain](https://www.llama.com/docs/integration-guides/langchain/)[Llamalndex](https://www.llama.com/docs/integration-guides/llamaindex/)\n\n[Community Support](https://www.llama.com/docs/community-support-and-resources/)[Resources](https://www.llama.com/docs/community-support-and-resources/)\n\n* * *\n\n[Overview](https://www.llama.com/docs/overview/)\n\n[Models](https://www.llama.com/docs/model-cards-and-prompt-formats/)[Llama 4](https://www.llama.com/docs/model-cards-and-prompt-formats/llama4/)[Llama Guard 4 (New)](https://www.llama.com/docs/model-cards-and-prompt-formats/llama-guard-4/)[Llama 3.3](https://www.llama.com/docs/model-cards-and-prompt-formats/llama3_3/)[Llama 3.2](https://www.llama.com/docs/model-cards-and-prompt-formats/llama3_2/)[Llama 3.1](https://www.llama.com/docs/model-cards-and-prompt-formats/llama3_1/)[Llama Guard 3](https://www.llama.com/docs/model-cards-and-prompt-formats/llama-guard-3/)[Llama Prompt Guard 2 (New)](https://www.llama.com/docs/model-cards-and-prompt-formats/prompt-guard/)[Other models](https://www.llama.com/docs/model-cards-and-prompt-formats/other-models/)\n\n[Getting the Models](https://www.llama.com/docs/getting_the_models/)[Meta](https://www.llama.com/docs/getting_the_models/meta/)[Hugging Face](https://www.llama.com/docs/getting-the-models/hugging-face/)[Kaggle](https://www.llama.com/docs/getting-the-models/kaggle/)[1B/3B Partners](https://www.llama.com/docs/getting-the-models/1b3b-partners/)[405B Partners](https://www.llama.com/docs/getting-the-models/405b-partners/)\n\n[Running Llama](https://www.llama.com/docs/llama-everywhere/)[Linux](https://www.llama.com/docs/llama-everywhere/running-meta-llama-on-linux/)[Windows](https://www.llama.com/docs/llama-everywhere/running-meta-llama-on-windows/)[Mac](https://www.llama.com/docs/llama-everywhere/running-meta-llama-on-mac/)[Cloud](https://www.llama.com/docs/llama-everywhere/running-meta-llama-in-the-cloud/)[Migration (New)](https://www.llama.com/docs/llama-everywhere/migration/)[Deployment (New)](https://www.llama.com/docs/llama-everywhere/deployment-patterns/)\n\n[How-To Guides](https://www.llama.com/docs/how-to-guides/)[Fine-tuning](https://www.llama.com/docs/how-to-guides/fine-tuning/)[Quantization (Updated)](https://www.llama.com/docs/how-to-guides/quantization/)[Prompting](https://www.llama.com/docs/how-to-guides/prompting/)[Validation](https://www.llama.com/docs/how-to-guides/validation/)[Vision Capabilities](https://www.llama.com/docs/how-to-guides/vision-capabilities/)[Responsible Use](https://www.llama.com/docs/how-to-guides/responsible-use-guide-resources/)\n\n[Integration Guides](https://www.llama.com/docs/integration-guides/)[LangChain](https://www.llama.com/docs/integration-guides/langchain/)[Llamalndex](https://www.llama.com/docs/integration-guides/llamaindex/)\n\n[Community Support](https://www.llama.com/docs/community-support-and-resources/)[Resources](https://www.llama.com/docs/community-support-and-resources/)\n\nDocumentation\n\nGet started with Llama\n======================\n\nThis guide provides information and resources to help you set up Llama including how to access the model, hosting, how-to and integration guides. Additionally, you will find supplemental materials to further assist you while building with Llama.\n\nWhat's new:\n-----------\n\n**Llama 4 Scout**\n\nNatively multimodal model that offers single H100 GPU efficiency and a 10M context window \n\n[_Learn more_](https://www.llama.com/docs/model-cards-and-prompt-formats/llama4_omni)\n\n**Llama 4 Maverick**\n\nNatively multimodal model for image and text understanding and fast responses at a low cost\n\n[_Learn more_](https://www.llama.com/docs/model-cards-and-prompt-formats/llama4_omni)\n\n**Llama Guard 4\n\nLlama Prompt Guard 2**\n\nUpdated protection models with higher performance and support for Llama 4\n\n[_Learn more_](https://www.llama.com/docs/model-cards-and-prompt-formats/llama-guard-4/)\n\nGet the models\n--------------\n\nYou can obtain the models directly from Meta or from one of our partners, [Hugging Face](https://huggingface.co/meta-llama), [Kaggle](https://www.kaggle.com/organizations/metaresearch/models) or from our [1B/3B](https://www.llama.com/docs/getting-the-models/1b3b-partners/) or [405B](https://www.llama.com/docs/getting-the-models/405b-partners/) ecosystem partners. \n\n[Download the models](https://www.llama.com/llama-downloads/?utm_source=llama-overview&utm_medium=llama-referral&utm_campaign=llama-utm&utm_offering=llama-download&utm_product=llama)\n\n* * *\n\n### Llama 4 Scout\n\nNatively multimodal model that offers single H100 GPU efficiency and a 10M context window\n\n#### Model Card\n\nModel attributes in easy to consume, standard format.\n\n[See Card on GitHub](https://github.com/meta-llama/llama-models/blob/main/models/llama4/MODEL_CARD.md)\n\n#### Prompt Format\n\nHow to construct effective prompts.\n\n[Get Prompt Guidance](https://www.llama.com/docs/model-cards-and-prompt-formats/llama4/)\n\n#### Get the Model\n\n[![Image 6: Meta logo](https://lookaside.fbsbx.com/elementpath/media/?media_id=713120110906146&version=1745894340&transcode_extension=webp)Meta![Image 7: Arrow icon](https://lookaside.fbsbx.com/elementpath/media/?media_id=1516407255613247&version=1756816550&transcode_extension=webp)](https://www.llama.com/llama-downloads/)\n\n[![Image 8: Hugging Face logo](https://lookaside.fbsbx.com/elementpath/media/?media_id=415443844816742&version=1745894340&transcode_extension=webp)Hugging Face![Image 9: Arrow icon](https://lookaside.fbsbx.com/elementpath/media/?media_id=1516407255613247&version=1756816550&transcode_extension=webp)](https://huggingface.co/meta-llama)\n\n### Llama 4 Maverick\n\nNatively multimodal model for image and text understanding and fast responses at a low cost\n\n#### Model Card\n\nModel attributes in easy to consume, standard format\n\n[See Card on GitHub](https://github.com/meta-llama/llama-models/blob/main/models/llama4/MODEL_CARD.md)\n\n#### Prompt Format\n\nHow to construct effective prompts.\n\n[Get Prompt Guidance](https://www.llama.com/docs/model-cards-and-prompt-formats/llama4/)\n\n#### Get the Model\n\n[![Image 10: Meta logo](https://lookaside.fbsbx.com/elementpath/media/?media_id=713120110906146&version=1745894340&transcode_extension=webp)Meta![Image 11: Arrow icon](https://lookaside.fbsbx.com/elementpath/media/?media_id=1516407255613247&version=1756816550&transcode_extension=webp)](https://www.llama.com/llama-downloads/)\n\n[![Image 12: Hugging Face logo](https://lookaside.fbsbx.com/elementpath/media/?media_id=415443844816742&version=1745894340&transcode_extension=webp)Hugging Face![Image 13: Arrow icon](https://lookaside.fbsbx.com/elementpath/media/?media_id=1516407255613247&version=1756816550&transcode_extension=webp)](https://huggingface.co/meta-llama)\n\n### Llama Guard 4 (New)\n\nUpdated protection models with higher performance and support for Llama 4\n\n#### Model Card\n\nModel attributes in easy to consume, standard format.\n\n[See Card on GitHub](https://github.com/meta-llama/PurpleLlama/blob/main/Llama-Guard4/12B/MODEL_CARD.md)\n\n#### Prompt Format\n\nHow to construct effective prompts.\n\n[Get Prompt Guidance](https://www.llama.com/docs/model-cards-and-prompt-formats/llama-guard-4/)\n\n#### Get the Model\n\n[![Image 14: Meta logo](https://lookaside.fbsbx.com/elementpath/media/?media_id=713120110906146&version=1745894340&transcode_extension=webp)Meta![Image 15: Arrow icon](https://lookaside.fbsbx.com/elementpath/media/?media_id=1516407255613247&version=1756816550&transcode_extension=webp)](https://www.llama.com/llama-downloads/)\n\n[![Image 16: Hugging Face logo](https://lookaside.fbsbx.com/elementpath/media/?media_id=415443844816742&version=1745894340&transcode_extension=webp)Hugging Face![Image 17: Arrow icon](https://lookaside.fbsbx.com/elementpath/media/?media_id=1516407255613247&version=1756816550&transcode_extension=webp)](https://huggingface.co/meta-llama)\n\n[All models](https://www.llama.com/docs/model-cards-and-prompt-formats/)\n\nFind us on GitHub\n-----------------\n\n![Image 18: A black letter O with a white background](https://lookaside.fbsbx.com/elementpath/media/?media_id=1141246920260352&version=1745894340&transcode_extension=webp)\n\nLlama Cookbook\n--------------\n\nNotebooks and demos for learning Llama. Scripts for fine-tuning Llama3 with single/multi-node GPUs.\n\n[Learn more](https://github.com/meta-llama/llama-cookbook)\n\n![Image 19: A black letter O with a white background](https://lookaside.fbsbx.com/elementpath/media/?media_id=1207075900499699&version=1745894340&transcode_extension=webp)\n\nLlama Stack\n-----------\n\nDefines and standardizes the building blocks needed to bring generative AI applications to market.\n\n[Learn more](https://github.com/meta-llama/llama-stack)\n\nExplore the new capabilities of Llama 3.2\n-----------------------------------------\n\nThe Llama 3.2 lightweight models enable Llama to run on phones, tablets, and edge devices. View the video to see Llama running on phone. To see how this demo was implemented, check out [**the example code**](https://github.com/pytorch/executorch/blob/main/examples/demo-apps/android/LlamaDemo/docs/delegates/xnnpack_README.md) from ExecuTorch.\n\n[Learn more](https://www.llama.com/docs/model-cards-and-prompt-formats/llama3_2/#-llama-3.2-lightweight-models-(1b/3b)-)\n\n* * *\n\nOther topics in this Guide\n--------------------------\n\nTo discover more about what's possible with the Llama family of models, explore the topics below.\n\n![Image 20: placeholder-image](https://lookaside.fbsbx.com/elementpath/media/?media_id=439065215623582&version=1745894340&transcode_extension=webp)\n### Llama Everywhere\n\nNotebooks and information on how to run Llama on your local hardware or in the cloud.[Learn more](https://www.llama.com/docs/llama-everywhere/)\n\n![Image 21: placeholder-image](https://lookaside.fbsbx.com/elementpath/media/?media_id=1432889504083181&version=1745894340&transcode_extension=webp)\n### How-To Guides\n\nAn overview of the processes for developing any LLM: fine-tuning, prompt engineering, and model validation.[Learn more](https://www.llama.com/docs/how-to-guides/)\n\n![Image 22: placeholder-image](https://lookaside.fbsbx.com/elementpath/media/?media_id=1000771695131808&version=1745894340&transcode_extension=webp)\n### Integration Guides\n\nDevelop solutions based on Code Llama, LangChain, and LlamaIndex.[Learn more](https://www.llama.com/docs/integration-guides/)\n\n![Image 23: placeholder-image](https://lookaside.fbsbx.com/elementpath/media/?media_id=3595223014074409&version=1745894340&transcode_extension=webp)\n### Community Support\n\nCompilation of resources available from the community.[Learn more](https://www.llama.com/docs/community-support-and-resources/)\n\n* * *\n\n![Image 24: Meta](https://static.xx.fbcdn.net/rsrc.php/y9/r/tL_v571NdZ0.svg)\n\n[![Image 25: Facebook](https://scontent-sof1-1.xx.fbcdn.net/v/t39.2365-6/301846186_1133977354136753_4449523448606696437_n.svg?_nc_cat=104&ccb=1-7&_nc_sid=aa6a2f&_nc_ohc=1_ipXivXGxEQ7kNvwGu-ROd&_nc_oc=AdlZlYbzgFOKqzNNblkatg8ttIliHDQT3JiTzGPr3LMhKiedEmZiTmP_4T2E-cGoraloSTbKBcwEpWshPs9yZXJA&_nc_zt=14&_nc_ht=scontent-sof1-1.xx&_nc_gid=1hXJKg8T-FNppu977trcYQ&oh=00_AfYVV-opcLd37G41pCXwlOB408cOnZlUNG3lGPl5nJdqHg&oe=68CB0BC3)](https://www.facebook.com/AIatMeta/)[![Image 26: X](https://scontent-sof1-1.xx.fbcdn.net/v/t39.2365-6/467665288_1952116298626027_4990190601706024947_n.svg?_nc_cat=106&ccb=1-7&_nc_sid=aa6a2f&_nc_ohc=9qxGaFnoM5AQ7kNvwEAzN1e&_nc_oc=AdlEbYjWYIAvfXn6v8fANmlJi4HCm0U5PdCCL0-qRGBBtRf8_2fxsp9LSP4eWCbOrmD1sCLFJztkteUAK9mnSWCr&_nc_zt=14&_nc_ht=scontent-sof1-1.xx&_nc_gid=1hXJKg8T-FNppu977trcYQ&oh=00_AfYxGuEUvmGVwBY_UkH9zyoPQPAoHKv98ohuTWiB-FZz5w&oe=68CAFA2A)](https://twitter.com/aiatmeta/)[![Image 27: YouTube](https://scontent-sof1-1.xx.fbcdn.net/v/t39.2365-6/301448763_775186710293873_8271592194986836260_n.svg?_nc_cat=102&ccb=1-7&_nc_sid=aa6a2f&_nc_ohc=kMxx90KXJSEQ7kNvwEgg1X1&_nc_oc=AdnVXvARLLy6E4h9b0Aqpbjyqqcy6Oc950GzcQBpmvUtN7B6BVwZlOGvOQNYB-paxiio7pKedh1pE3QyYtmLV0CG&_nc_zt=14&_nc_ht=scontent-sof1-1.xx&_nc_gid=1hXJKg8T-FNppu977trcYQ&oh=00_Afa5KTgSKucUlKSI5skijSHcScAJQ66MQCzEoDr1DXG05g&oe=68CAFCA7)](https://www.youtube.com/@aiatmeta)[![Image 28: LinkedIn](https://scontent-sof1-2.xx.fbcdn.net/v/t39.2365-6/467689750_1684384502343829_7561568713040200172_n.svg?_nc_cat=103&ccb=1-7&_nc_sid=aa6a2f&_nc_ohc=jxripiNl15AQ7kNvwGGxEXI&_nc_oc=Adkcn-ZLDtXFziUhVQxxO01acRplHhgtMpq6fN_UnGsvOetN4JSNNj0IcUo_YZQDcCcyyKCv3M49A1OydwNGxCek&_nc_zt=14&_nc_ht=scontent-sof1-2.xx&_nc_gid=1hXJKg8T-FNppu977trcYQ&oh=00_AfZp2jdGfSelxDaRbSxM0wUcXE0XefJZhG1nbXnR3grVVQ&oe=68CAEB7E)](https://www.linkedin.com/showcase/aiatmeta)\n\nDocumentation\n\n[Overview](https://www.llama.com/docs/overview/)[Models](https://www.llama.com/docs/model-cards-and-prompt-formats/)[Getting the Models](https://www.llama.com/docs/getting_the_models/)[Running Llama](https://www.llama.com/docs/llama-everywhere/)[How-To Guides](https://www.llama.com/docs/how-to-guides/)[Integration Guides](https://www.llama.com/docs/integration-guides/)[Community Support](https://www.llama.com/docs/community-support-and-resources/)\n\n* * *\n\nCommunity\n\n[Community Stories](https://www.llama.com/community-stories/)[Open Innovation AI Research Community](https://www.llama.com/open-innovation-ai-research-community/)[Llama Impact Grants](https://www.llama.com/llama-ai-innovation/)\n\n* * *\n\nResources\n\n[Cookbook](https://www.llama.com/resources/cookbook/)[Case studies](https://www.llama.com/resources/case-studies/)[Videos](https://www.llama.com/resources/videos/)[AI at Meta Blog](https://ai.meta.com/blog/)[Meta Newsroom](https://about.fb.com/news/)[FAQ](https://www.llama.com/faq/)[Privacy Policy](https://www.facebook.com/privacy/policy/)[Terms](https://www.facebook.com/policies_center/)[Cookies](https://www.facebook.com/privacy/policies/cookies/?entry_point=cookie_policy_redirect&entry=0)\n\n* * *\n\nLlama Protections\n\n[Overview](https://www.llama.com/llama-protections/)[Llama Defenders Program](https://www.llama.com/llama-protections/ai-defenders/)[Developer Use Guide](https://www.llama.com/developer-use-guide/)\n\n* * *\n\nDocumentation\n\n[Overview](https://www.llama.com/docs/overview/)\n\n[Models](https://www.llama.com/docs/model-cards-and-prompt-formats/)\n\n[Getting the Models](https://www.llama.com/docs/getting_the_models/)\n\n[Running Llama](https://www.llama.com/docs/llama-everywhere/)\n\n[How-To Guides](https://www.llama.com/docs/how-to-guides/)\n\n[Integration Guides](https://www.llama.com/docs/integration-guides/)\n\n[Community Support](https://www.llama.com/docs/community-support-and-resources/)\n\nCommunity\n\n[Community Stories](https://www.llama.com/community-stories/)\n\n[Open Innovation AI Research Community](https://www.llama.com/open-innovation-ai-research-community/)\n\n[Llama Impact Grants](https://www.llama.com/llama-ai-innovation/)\n\nResources\n\n[Cookbook](https://www.llama.com/resources/cookbook/)\n\n[Case studies](https://www.llama.com/resources/case-studies/)\n\n[Videos](https://www.llama.com/resources/videos/)\n\n[AI at Meta Blog](https://ai.meta.com/blog/)\n\n[Meta Newsroom](https://about.fb.com/news/)\n\n[FAQ](https://www.llama.com/faq/)\n\n[Privacy Policy](https://www.facebook.com/privacy/policy/)\n\n[Terms](https://www.facebook.com/policies_center/)\n\n[Cookies](https://www.facebook.com/privacy/policies/cookies/?entry_point=cookie_policy_redirect&entry=0)\n\nLlama Protections\n\n[Overview](https://www.llama.com/llama-protections/)\n\n[Llama Defenders Program](https://www.llama.com/llama-protections/ai-defenders/)\n\n[Developer Use Guide](https://www.llama.com/developer-use-guide/)\n\nDocumentation\n\n[Overview](https://www.llama.com/docs/overview/)\n\n[Models](https://www.llama.com/docs/model-cards-and-prompt-formats/)\n\n[Getting the Models](https://www.llama.com/docs/getting_the_models/)\n\n[Running Llama](https://www.llama.com/docs/llama-everywhere/)\n\n[How-To Guides](https://www.llama.com/docs/how-to-guides/)\n\n[Integration Guides](https://www.llama.com/docs/integration-guides/)\n\n[Community Support](https://www.llama.com/docs/community-support-and-resources/)\n\nCommunity\n\n[Community Stories](https://www.llama.com/community-stories/)\n\n[Open Innovation AI Research Community](https://www.llama.com/open-innovation-ai-research-community/)\n\n[Llama Impact Grants](https://www.llama.com/llama-ai-innovation/)\n\nResources\n\n[Cookbook](https://www.llama.com/resources/cookbook/)\n\n[Case studies](https://www.llama.com/resources/case-studies/)\n\n[Videos](https://www.llama.com/resources/videos/)\n\n[AI at Meta Blog](https://ai.meta.com/blog/)\n\n[Meta Newsroom](https://about.fb.com/news/)\n\n[FAQ](https://www.llama.com/faq/)\n\n[Privacy Policy](https://www.facebook.com/privacy/policy/)\n\n[Terms](https://www.facebook.com/policies_center/)\n\n[Cookies](https://www.facebook.com/privacy/policies/cookies/?entry_point=cookie_policy_redirect&entry=0)\n\nLlama Protections\n\n[Overview](https://www.llama.com/llama-protections/)\n\n[Llama Defenders Program](https://www.llama.com/llama-protections/ai-defenders/)\n\n[Developer Use Guide](https://www.llama.com/developer-use-guide/)\n\nDocumentation\n\n[Overview](https://www.llama.com/docs/overview/)\n\n[Models](https://www.llama.com/docs/model-cards-and-prompt-formats/)\n\n[Getting the Models](https://www.llama.com/docs/getting_the_models/)\n\n[Running Llama](https://www.llama.com/docs/llama-everywhere/)\n\n[How-To Guides](https://www.llama.com/docs/how-to-guides/)\n\n[Integration Guides](https://www.llama.com/docs/integration-guides/)\n\n[Community Support](https://www.llama.com/docs/community-support-and-resources/)\n\nCommunity\n\n[Community Stories](https://www.llama.com/community-stories/)\n\n[Open Innovation AI Research Community](https://www.llama.com/open-innovation-ai-research-community/)\n\n[Llama Impact Grants](https://www.llama.com/llama-ai-innovation/)\n\nResources\n\n[Cookbook](https://www.llama.com/resources/cookbook/)\n\n[Case studies](https://www.llama.com/resources/case-studies/)\n\n[Videos](https://www.llama.com/resources/videos/)\n\n[AI at Meta Blog](https://ai.meta.com/blog/)\n\n[Meta Newsroom](https://about.fb.com/news/)\n\n[FAQ](https://www.llama.com/faq/)\n\n[Privacy Policy](https://www.facebook.com/privacy/policy/)\n\n[Terms](https://www.facebook.com/policies_center/)\n\n[Cookies](https://www.facebook.com/privacy/policies/cookies/?entry_point=cookie_policy_redirect&entry=0)\n\nLlama Protections\n\n[Overview](https://www.llama.com/llama-protections/)\n\n[Llama Defenders Program](https://www.llama.com/llama-protections/ai-defenders/)\n\n[Developer Use Guide](https://www.llama.com/developer-use-guide/)\n",
      "fetch_method": "jina-reader"
    },
    {
      "arxiv_id": "https://r.jina.ai/https://llama.com/docs/overview",
      "full_text": "Title: Docs & Resources | Llama AI\n\nURL Source: https://llama.com/docs/overview\n\nMarkdown Content:\nDocs & Resources | Llama AI\n\n===============\n\n[Skip to main content](https://llama.com/docs/overview#mdc-main-content)\n\n[![Image 5: Meta](https://static.xx.fbcdn.net/rsrc.php/y9/r/tL_v571NdZ0.svg)](https://llama.com/)\n\nModels & Products\n\nDocs\n\nCommunity\n\nResources\n\n[Llama API](https://llama.developer.meta.com/join_waitlist)\n\n[Download models](https://llama.com/llama-downloads/)\n\n### Table Of Contents\n\nOverview\n\n[Overview](https://llama.com/docs/overview/)\n\n[Models](https://llama.com/docs/model-cards-and-prompt-formats/)[Llama 4](https://llama.com/docs/model-cards-and-prompt-formats/llama4/)[Llama Guard 4 (New)](https://llama.com/docs/model-cards-and-prompt-formats/llama-guard-4/)[Llama 3.3](https://llama.com/docs/model-cards-and-prompt-formats/llama3_3/)[Llama 3.2](https://llama.com/docs/model-cards-and-prompt-formats/llama3_2/)[Llama 3.1](https://llama.com/docs/model-cards-and-prompt-formats/llama3_1/)[Llama Guard 3](https://llama.com/docs/model-cards-and-prompt-formats/llama-guard-3/)[Llama Prompt Guard 2 (New)](https://llama.com/docs/model-cards-and-prompt-formats/prompt-guard/)[Other models](https://llama.com/docs/model-cards-and-prompt-formats/other-models/)\n\n[Getting the Models](https://llama.com/docs/getting_the_models/)[Meta](https://llama.com/docs/getting_the_models/meta/)[Hugging Face](https://llama.com/docs/getting-the-models/hugging-face/)[Kaggle](https://llama.com/docs/getting-the-models/kaggle/)[1B/3B Partners](https://llama.com/docs/getting-the-models/1b3b-partners/)[405B Partners](https://llama.com/docs/getting-the-models/405b-partners/)\n\n[Running Llama](https://llama.com/docs/llama-everywhere/)[Linux](https://llama.com/docs/llama-everywhere/running-meta-llama-on-linux/)[Windows](https://llama.com/docs/llama-everywhere/running-meta-llama-on-windows/)[Mac](https://llama.com/docs/llama-everywhere/running-meta-llama-on-mac/)[Cloud](https://llama.com/docs/llama-everywhere/running-meta-llama-in-the-cloud/)[Migration (New)](https://llama.com/docs/llama-everywhere/migration/)[Deployment (New)](https://llama.com/docs/llama-everywhere/deployment-patterns/)\n\n[How-To Guides](https://llama.com/docs/how-to-guides/)[Fine-tuning](https://llama.com/docs/how-to-guides/fine-tuning/)[Quantization (Updated)](https://llama.com/docs/how-to-guides/quantization/)[Prompting](https://llama.com/docs/how-to-guides/prompting/)[Validation](https://llama.com/docs/how-to-guides/validation/)[Vision Capabilities](https://llama.com/docs/how-to-guides/vision-capabilities/)[Responsible Use](https://llama.com/docs/how-to-guides/responsible-use-guide-resources/)\n\n[Integration Guides](https://llama.com/docs/integration-guides/)[LangChain](https://llama.com/docs/integration-guides/langchain/)[Llamalndex](https://llama.com/docs/integration-guides/llamaindex/)\n\n[Community Support](https://llama.com/docs/community-support-and-resources/)[Resources](https://llama.com/docs/community-support-and-resources/)\n\n* * *\n\n[Overview](https://llama.com/docs/overview/)\n\n[Models](https://llama.com/docs/model-cards-and-prompt-formats/)[Llama 4](https://llama.com/docs/model-cards-and-prompt-formats/llama4/)[Llama Guard 4 (New)](https://llama.com/docs/model-cards-and-prompt-formats/llama-guard-4/)[Llama 3.3](https://llama.com/docs/model-cards-and-prompt-formats/llama3_3/)[Llama 3.2](https://llama.com/docs/model-cards-and-prompt-formats/llama3_2/)[Llama 3.1](https://llama.com/docs/model-cards-and-prompt-formats/llama3_1/)[Llama Guard 3](https://llama.com/docs/model-cards-and-prompt-formats/llama-guard-3/)[Llama Prompt Guard 2 (New)](https://llama.com/docs/model-cards-and-prompt-formats/prompt-guard/)[Other models](https://llama.com/docs/model-cards-and-prompt-formats/other-models/)\n\n[Getting the Models](https://llama.com/docs/getting_the_models/)[Meta](https://llama.com/docs/getting_the_models/meta/)[Hugging Face](https://llama.com/docs/getting-the-models/hugging-face/)[Kaggle](https://llama.com/docs/getting-the-models/kaggle/)[1B/3B Partners](https://llama.com/docs/getting-the-models/1b3b-partners/)[405B Partners](https://llama.com/docs/getting-the-models/405b-partners/)\n\n[Running Llama](https://llama.com/docs/llama-everywhere/)[Linux](https://llama.com/docs/llama-everywhere/running-meta-llama-on-linux/)[Windows](https://llama.com/docs/llama-everywhere/running-meta-llama-on-windows/)[Mac](https://llama.com/docs/llama-everywhere/running-meta-llama-on-mac/)[Cloud](https://llama.com/docs/llama-everywhere/running-meta-llama-in-the-cloud/)[Migration (New)](https://llama.com/docs/llama-everywhere/migration/)[Deployment (New)](https://llama.com/docs/llama-everywhere/deployment-patterns/)\n\n[How-To Guides](https://llama.com/docs/how-to-guides/)[Fine-tuning](https://llama.com/docs/how-to-guides/fine-tuning/)[Quantization (Updated)](https://llama.com/docs/how-to-guides/quantization/)[Prompting](https://llama.com/docs/how-to-guides/prompting/)[Validation](https://llama.com/docs/how-to-guides/validation/)[Vision Capabilities](https://llama.com/docs/how-to-guides/vision-capabilities/)[Responsible Use](https://llama.com/docs/how-to-guides/responsible-use-guide-resources/)\n\n[Integration Guides](https://llama.com/docs/integration-guides/)[LangChain](https://llama.com/docs/integration-guides/langchain/)[Llamalndex](https://llama.com/docs/integration-guides/llamaindex/)\n\n[Community Support](https://llama.com/docs/community-support-and-resources/)[Resources](https://llama.com/docs/community-support-and-resources/)\n\nDocumentation\n\nGet started with Llama\n======================\n\nThis guide provides information and resources to help you set up Llama including how to access the model, hosting, how-to and integration guides. Additionally, you will find supplemental materials to further assist you while building with Llama.\n\nWhat's new:\n-----------\n\n**Llama 4 Scout**\n\nNatively multimodal model that offers single H100 GPU efficiency and a 10M context window \n\n[_Learn more_](https://llama.com/docs/model-cards-and-prompt-formats/llama4_omni)\n\n**Llama 4 Maverick**\n\nNatively multimodal model for image and text understanding and fast responses at a low cost\n\n[_Learn more_](https://llama.com/docs/model-cards-and-prompt-formats/llama4_omni)\n\n**Llama Guard 4\n\nLlama Prompt Guard 2**\n\nUpdated protection models with higher performance and support for Llama 4\n\n[_Learn more_](https://www.llama.com/docs/model-cards-and-prompt-formats/llama-guard-4/)\n\nGet the models\n--------------\n\nYou can obtain the models directly from Meta or from one of our partners, [Hugging Face](https://huggingface.co/meta-llama), [Kaggle](https://www.kaggle.com/organizations/metaresearch/models) or from our [1B/3B](https://llama.com/docs/getting-the-models/1b3b-partners/) or [405B](https://llama.com/docs/getting-the-models/405b-partners/) ecosystem partners. \n\n[Download the models](https://llama.com/llama-downloads/?utm_source=llama-overview&utm_medium=llama-referral&utm_campaign=llama-utm&utm_offering=llama-download&utm_product=llama)\n\n* * *\n\n### Llama 4 Scout\n\nNatively multimodal model that offers single H100 GPU efficiency and a 10M context window\n\n#### Model Card\n\nModel attributes in easy to consume, standard format.\n\n[See Card on GitHub](https://github.com/meta-llama/llama-models/blob/main/models/llama4/MODEL_CARD.md)\n\n#### Prompt Format\n\nHow to construct effective prompts.\n\n[Get Prompt Guidance](https://llama.com/docs/model-cards-and-prompt-formats/llama4/)\n\n#### Get the Model\n\n[![Image 6: Meta logo](https://lookaside.fbsbx.com/elementpath/media/?media_id=713120110906146&version=1745894340&transcode_extension=webp)Meta![Image 7: Arrow icon](https://lookaside.fbsbx.com/elementpath/media/?media_id=1516407255613247&version=1756816550&transcode_extension=webp)](https://llama.com/llama-downloads/)\n\n[![Image 8: Hugging Face logo](https://lookaside.fbsbx.com/elementpath/media/?media_id=415443844816742&version=1745894340&transcode_extension=webp)Hugging Face![Image 9: Arrow icon](https://lookaside.fbsbx.com/elementpath/media/?media_id=1516407255613247&version=1756816550&transcode_extension=webp)](https://huggingface.co/meta-llama)\n\n### Llama 4 Maverick\n\nNatively multimodal model for image and text understanding and fast responses at a low cost\n\n#### Model Card\n\nModel attributes in easy to consume, standard format\n\n[See Card on GitHub](https://github.com/meta-llama/llama-models/blob/main/models/llama4/MODEL_CARD.md)\n\n#### Prompt Format\n\nHow to construct effective prompts.\n\n[Get Prompt Guidance](https://llama.com/docs/model-cards-and-prompt-formats/llama4/)\n\n#### Get the Model\n\n[![Image 10: Meta logo](https://lookaside.fbsbx.com/elementpath/media/?media_id=713120110906146&version=1745894340&transcode_extension=webp)Meta![Image 11: Arrow icon](https://lookaside.fbsbx.com/elementpath/media/?media_id=1516407255613247&version=1756816550&transcode_extension=webp)](https://llama.com/llama-downloads/)\n\n[![Image 12: Hugging Face logo](https://lookaside.fbsbx.com/elementpath/media/?media_id=415443844816742&version=1745894340&transcode_extension=webp)Hugging Face![Image 13: Arrow icon](https://lookaside.fbsbx.com/elementpath/media/?media_id=1516407255613247&version=1756816550&transcode_extension=webp)](https://huggingface.co/meta-llama)\n\n### Llama Guard 4 (New)\n\nUpdated protection models with higher performance and support for Llama 4\n\n#### Model Card\n\nModel attributes in easy to consume, standard format.\n\n[See Card on GitHub](https://github.com/meta-llama/PurpleLlama/blob/main/Llama-Guard4/12B/MODEL_CARD.md)\n\n#### Prompt Format\n\nHow to construct effective prompts.\n\n[Get Prompt Guidance](https://llama.com/docs/model-cards-and-prompt-formats/llama-guard-4/)\n\n#### Get the Model\n\n[![Image 14: Meta logo](https://lookaside.fbsbx.com/elementpath/media/?media_id=713120110906146&version=1745894340&transcode_extension=webp)Meta![Image 15: Arrow icon](https://lookaside.fbsbx.com/elementpath/media/?media_id=1516407255613247&version=1756816550&transcode_extension=webp)](https://llama.com/llama-downloads/)\n\n[![Image 16: Hugging Face logo](https://lookaside.fbsbx.com/elementpath/media/?media_id=415443844816742&version=1745894340&transcode_extension=webp)Hugging Face![Image 17: Arrow icon](https://lookaside.fbsbx.com/elementpath/media/?media_id=1516407255613247&version=1756816550&transcode_extension=webp)](https://huggingface.co/meta-llama)\n\n[All models](https://llama.com/docs/model-cards-and-prompt-formats/)\n\nFind us on GitHub\n-----------------\n\n![Image 18: A black letter O with a white background](https://lookaside.fbsbx.com/elementpath/media/?media_id=1141246920260352&version=1745894340&transcode_extension=webp)\n\nLlama Cookbook\n--------------\n\nNotebooks and demos for learning Llama. Scripts for fine-tuning Llama3 with single/multi-node GPUs.\n\n[Learn more](https://github.com/meta-llama/llama-cookbook)\n\n![Image 19: A black letter O with a white background](https://lookaside.fbsbx.com/elementpath/media/?media_id=1207075900499699&version=1745894340&transcode_extension=webp)\n\nLlama Stack\n-----------\n\nDefines and standardizes the building blocks needed to bring generative AI applications to market.\n\n[Learn more](https://github.com/meta-llama/llama-stack)\n\nExplore the new capabilities of Llama 3.2\n-----------------------------------------\n\nThe Llama 3.2 lightweight models enable Llama to run on phones, tablets, and edge devices. View the video to see Llama running on phone. To see how this demo was implemented, check out [**the example code**](https://github.com/pytorch/executorch/blob/main/examples/demo-apps/android/LlamaDemo/docs/delegates/xnnpack_README.md) from ExecuTorch.\n\n[Learn more](https://llama.com/docs/model-cards-and-prompt-formats/llama3_2/#-llama-3.2-lightweight-models-(1b/3b)-)\n\n* * *\n\nOther topics in this Guide\n--------------------------\n\nTo discover more about what's possible with the Llama family of models, explore the topics below.\n\n![Image 20: placeholder-image](https://lookaside.fbsbx.com/elementpath/media/?media_id=439065215623582&version=1745894340&transcode_extension=webp)\n### Llama Everywhere\n\nNotebooks and information on how to run Llama on your local hardware or in the cloud.[Learn more](https://llama.com/docs/llama-everywhere/)\n\n![Image 21: placeholder-image](https://lookaside.fbsbx.com/elementpath/media/?media_id=1432889504083181&version=1745894340&transcode_extension=webp)\n### How-To Guides\n\nAn overview of the processes for developing any LLM: fine-tuning, prompt engineering, and model validation.[Learn more](https://llama.com/docs/how-to-guides/)\n\n![Image 22: placeholder-image](https://lookaside.fbsbx.com/elementpath/media/?media_id=1000771695131808&version=1745894340&transcode_extension=webp)\n### Integration Guides\n\nDevelop solutions based on Code Llama, LangChain, and LlamaIndex.[Learn more](https://llama.com/docs/integration-guides/)\n\n![Image 23: placeholder-image](https://lookaside.fbsbx.com/elementpath/media/?media_id=3595223014074409&version=1745894340&transcode_extension=webp)\n### Community Support\n\nCompilation of resources available from the community.[Learn more](https://llama.com/docs/community-support-and-resources/)\n\n* * *\n\n![Image 24: Meta](https://static.xx.fbcdn.net/rsrc.php/y9/r/tL_v571NdZ0.svg)\n\n[![Image 25: Facebook](https://scontent-sof1-1.xx.fbcdn.net/v/t39.2365-6/301846186_1133977354136753_4449523448606696437_n.svg?_nc_cat=104&ccb=1-7&_nc_sid=aa6a2f&_nc_ohc=1_ipXivXGxEQ7kNvwFgNAxc&_nc_oc=Adnpxg-aiLEJoZx2F6cDXV469P1K-Yg_F7MWZoEhWW0wc_5dXdISK2sotXtYUZF3D66Zzx7JPQSvdcOB5M7VPdv_&_nc_zt=14&_nc_ht=scontent-sof1-1.xx&_nc_gid=V60DVvBiFJmSF-CFTRHfog&oh=00_AfYDiIrGk-7VTgJQ_hc70Uzif69ugAGswkmwl2KSNfoQkg&oe=68CB0BC3)](https://www.facebook.com/AIatMeta/)[![Image 26: X](https://scontent-sof1-1.xx.fbcdn.net/v/t39.2365-6/467665288_1952116298626027_4990190601706024947_n.svg?_nc_cat=106&ccb=1-7&_nc_sid=aa6a2f&_nc_ohc=9qxGaFnoM5AQ7kNvwGttego&_nc_oc=AdmyMcMsGr0R5xyEyFl2NdX7tqJ7Z5DVd7ovwZfzDO829Pursjd0-3kWaS7U4rbe47sEOSBA9uq9WHBQjcLv8i7b&_nc_zt=14&_nc_ht=scontent-sof1-1.xx&_nc_gid=V60DVvBiFJmSF-CFTRHfog&oh=00_AfamPV4ZQ-Zr3L778wvEAtT8B9DfMxjI5a656g5FMx1c8A&oe=68CAFA2A)](https://twitter.com/aiatmeta/)[![Image 27: YouTube](https://scontent-sof1-1.xx.fbcdn.net/v/t39.2365-6/301448763_775186710293873_8271592194986836260_n.svg?_nc_cat=102&ccb=1-7&_nc_sid=aa6a2f&_nc_ohc=kMxx90KXJSEQ7kNvwHt8zZC&_nc_oc=AdlhWLBzgdSwXrCF_gNPLgJUhgs48fI2APuamOCBuWZ4ereMHsFv-xgn9-Jr8Q6VcJ4msunZsHgEjbVSXushmz-4&_nc_zt=14&_nc_ht=scontent-sof1-1.xx&_nc_gid=V60DVvBiFJmSF-CFTRHfog&oh=00_AfYKh_9hpEnZCPBblNmD8rc8vv1da_K-U7vJJiRk8OEYow&oe=68CAFCA7)](https://www.youtube.com/@aiatmeta)[![Image 28: LinkedIn](https://scontent-sof1-2.xx.fbcdn.net/v/t39.2365-6/467689750_1684384502343829_7561568713040200172_n.svg?_nc_cat=103&ccb=1-7&_nc_sid=aa6a2f&_nc_ohc=jxripiNl15AQ7kNvwF1XRwW&_nc_oc=Adm0otLZ08efdHpq5WrrNqqxDn4o9bJqxsRhzLult2jSXyfUqoWyNeh6pFgPc80CVXcQtC9aGMp5DcoiiGEKe8s7&_nc_zt=14&_nc_ht=scontent-sof1-2.xx&_nc_gid=V60DVvBiFJmSF-CFTRHfog&oh=00_AfZbuKQCPryLZ-wcbYF6tjsXvJftCAQLaDYSCpeNstVLQQ&oe=68CAEB7E)](https://www.linkedin.com/showcase/aiatmeta)\n\nDocumentation\n\n[Overview](https://llama.com/docs/overview/)[Models](https://llama.com/docs/model-cards-and-prompt-formats/)[Getting the Models](https://llama.com/docs/getting_the_models/)[Running Llama](https://llama.com/docs/llama-everywhere/)[How-To Guides](https://llama.com/docs/how-to-guides/)[Integration Guides](https://llama.com/docs/integration-guides/)[Community Support](https://llama.com/docs/community-support-and-resources/)\n\n* * *\n\nCommunity\n\n[Community Stories](https://llama.com/community-stories/)[Open Innovation AI Research Community](https://llama.com/open-innovation-ai-research-community/)[Llama Impact Grants](https://llama.com/llama-impact-grants/)\n\n* * *\n\nResources\n\n[Cookbook](https://llama.com/cookbook/)[Case studies](https://llama.com/resources/case-studies/)[Videos](https://llama.com/resources/videos/)[AI at Meta Blog](https://ai.meta.com/blog/)[Meta Newsroom](https://about.fb.com/news/)[FAQ](https://llama.com/faq/)[Privacy Policy](https://www.facebook.com/privacy/policy/)[Terms](https://www.facebook.com/policies_center/)[Cookies](https://www.facebook.com/privacy/policies/cookies/?entry_point=cookie_policy_redirect&entry=0)\n\n* * *\n\nLlama Protections\n\n[Overview](https://llama.com/llama-protections/)[Llama Defenders Program](https://llama.com/llama-protections/ai-defenders/)[Developer Use Guide](https://llama.com/developer-use-guide/)\n\n* * *\n\nDocumentation\n\n[Overview](https://llama.com/docs/overview/)\n\n[Models](https://llama.com/docs/model-cards-and-prompt-formats/)\n\n[Getting the Models](https://llama.com/docs/getting_the_models/)\n\n[Running Llama](https://llama.com/docs/llama-everywhere/)\n\n[How-To Guides](https://llama.com/docs/how-to-guides/)\n\n[Integration Guides](https://llama.com/docs/integration-guides/)\n\n[Community Support](https://llama.com/docs/community-support-and-resources/)\n\nCommunity\n\n[Community Stories](https://llama.com/community-stories/)\n\n[Open Innovation AI Research Community](https://llama.com/open-innovation-ai-research-community/)\n\n[Llama Impact Grants](https://llama.com/llama-impact-grants/)\n\nResources\n\n[Cookbook](https://llama.com/cookbook/)\n\n[Case studies](https://llama.com/resources/case-studies/)\n\n[Videos](https://llama.com/resources/videos/)\n\n[AI at Meta Blog](https://ai.meta.com/blog/)\n\n[Meta Newsroom](https://about.fb.com/news/)\n\n[FAQ](https://llama.com/faq/)\n\n[Privacy Policy](https://www.facebook.com/privacy/policy/)\n\n[Terms](https://www.facebook.com/policies_center/)\n\n[Cookies](https://www.facebook.com/privacy/policies/cookies/?entry_point=cookie_policy_redirect&entry=0)\n\nLlama Protections\n\n[Overview](https://llama.com/llama-protections/)\n\n[Llama Defenders Program](https://llama.com/llama-protections/ai-defenders/)\n\n[Developer Use Guide](https://llama.com/developer-use-guide/)\n\nDocumentation\n\n[Overview](https://llama.com/docs/overview/)\n\n[Models](https://llama.com/docs/model-cards-and-prompt-formats/)\n\n[Getting the Models](https://llama.com/docs/getting_the_models/)\n\n[Running Llama](https://llama.com/docs/llama-everywhere/)\n\n[How-To Guides](https://llama.com/docs/how-to-guides/)\n\n[Integration Guides](https://llama.com/docs/integration-guides/)\n\n[Community Support](https://llama.com/docs/community-support-and-resources/)\n\nCommunity\n\n[Community Stories](https://llama.com/community-stories/)\n\n[Open Innovation AI Research Community](https://llama.com/open-innovation-ai-research-community/)\n\n[Llama Impact Grants](https://llama.com/llama-impact-grants/)\n\nResources\n\n[Cookbook](https://llama.com/cookbook/)\n\n[Case studies](https://llama.com/resources/case-studies/)\n\n[Videos](https://llama.com/resources/videos/)\n\n[AI at Meta Blog](https://ai.meta.com/blog/)\n\n[Meta Newsroom](https://about.fb.com/news/)\n\n[FAQ](https://llama.com/faq/)\n\n[Privacy Policy](https://www.facebook.com/privacy/policy/)\n\n[Terms](https://www.facebook.com/policies_center/)\n\n[Cookies](https://www.facebook.com/privacy/policies/cookies/?entry_point=cookie_policy_redirect&entry=0)\n\nLlama Protections\n\n[Overview](https://llama.com/llama-protections/)\n\n[Llama Defenders Program](https://llama.com/llama-protections/ai-defenders/)\n\n[Developer Use Guide](https://llama.com/developer-use-guide/)\n\nDocumentation\n\n[Overview](https://llama.com/docs/overview/)\n\n[Models](https://llama.com/docs/model-cards-and-prompt-formats/)\n\n[Getting the Models](https://llama.com/docs/getting_the_models/)\n\n[Running Llama](https://llama.com/docs/llama-everywhere/)\n\n[How-To Guides](https://llama.com/docs/how-to-guides/)\n\n[Integration Guides](https://llama.com/docs/integration-guides/)\n\n[Community Support](https://llama.com/docs/community-support-and-resources/)\n\nCommunity\n\n[Community Stories](https://llama.com/community-stories/)\n\n[Open Innovation AI Research Community](https://llama.com/open-innovation-ai-research-community/)\n\n[Llama Impact Grants](https://llama.com/llama-impact-grants/)\n\nResources\n\n[Cookbook](https://llama.com/cookbook/)\n\n[Case studies](https://llama.com/resources/case-studies/)\n\n[Videos](https://llama.com/resources/videos/)\n\n[AI at Meta Blog](https://ai.meta.com/blog/)\n\n[Meta Newsroom](https://about.fb.com/news/)\n\n[FAQ](https://llama.com/faq/)\n\n[Privacy Policy](https://www.facebook.com/privacy/policy/)\n\n[Terms](https://www.facebook.com/policies_center/)\n\n[Cookies](https://www.facebook.com/privacy/policies/cookies/?entry_point=cookie_policy_redirect&entry=0)\n\nLlama Protections\n\n[Overview](https://llama.com/llama-protections/)\n\n[Llama Defenders Program](https://llama.com/llama-protections/ai-defenders/)\n\n[Developer Use Guide](https://llama.com/developer-use-guide/)\n",
      "fetch_method": "jina-reader"
    },
    {
      "arxiv_id": "https://r.jina.ai/https://llama.meta.com/docs/model-cards-and-prompt-formats/llama3_1/",
      "full_text": "Title: Llama 3.1 | Model Cards and Prompt formats\n\nURL Source: https://llama.meta.com/docs/model-cards-and-prompt-formats/llama3_1/\n\nMarkdown Content:\nIntroduction\n------------\n\nThis page describes the prompt format for Llama 3.1 with an emphasis on new features in that release.\n\nWith the subsequent release of Llama 3.2, we have introduced new [lightweight models in 1B and 3B](https://www.llama.com/docs/model-cards-and-prompt-formats/llama3_2#-llama-3.2-lightweight-models-(1b/3b)-) and also [multimodal models in 11B and 90B](https://www.llama.com/docs/model-cards-and-prompt-formats/llama3_2#-llama-3.2-vision-models-(11b/90b)-). The first few sections of this page--**Prompt Template**, **Base Model Prompt**, and **Instruct Model Prompt**--are applicable across all the models released in both Llama 3.1 and Llama 3.2.\n\nPlease leverage this guidance in order to take full advantage of the new Llama models. Although prompts designed for Llama 3 should work unchanged in Llama 3.1 and Llama 3.2, we recommend that you update your prompts to the new format to obtain the best results.\n\n**Note:** We have introduced Llama 3.3 70B, an instruction-turned model with the latest advancements in post-training techniques; see the [model card](https://github.com/meta-llama/llama-models/blob/main/models/llama3_3/MODEL_CARD.md) for detailed performance information. This new model supersedes the instruction-tuned Llama 3.1 70B model. The new model name is `Llama-3.3-70B-Instruct`; developers should [install](https://www.llama.com/llama-downloads) and use the new model wherever they would otherwise have used instruction-tuned Llama 3.1 70B.\n\n[Download](https://www.llama.com/llama-downloads) the new Llama 3.3 model.\n\nModel Card\n----------\n\nFor comprehensive technical information about the Llama 3.1 collection of large-language models, please see the official [model card](https://github.com/meta-llama/llama-models/blob/main/models/llama3_1/MODEL_CARD.md), located on GitHub.\n\n[Download](https://www.llama.com/llama-downloads) Llama 3.1 models.\n\n### Special Tokens\n\nTokens\n\nDescription\n\n`<|begin_of_text|>`\n\nSpecifies the start of the prompt.\n\n`<|end_of_text|>`\n\nModel will cease to generate more tokens. This token is generated only by the base models.\n\n`<|finetune_right_pad_id|>`\n\nThis token is used for padding text sequences to the same length in a batch.\n\n`<|start_header_id|>`\n\n`<|end_header_id|>`\n\nThese tokens enclose the role for a particular message. The possible roles are: `[system, user, assistant, and ipython]`\n\n`<|eom_id|>`\n\nEnd of message. A message represents a possible stopping point for execution where the model can inform the executor that a tool call needs to be made. This is used for multi-step interactions between the model and any available tools. This token is emitted by the model when the `Environment: ipython` instruction is used in the system prompt, or if the model calls for a built-in tool.\n\n`<|eot_id|>`\n\nEnd of turn. Represents when the model has determined that it has finished interacting with the user message that initiated its response. This is used in two scenarios:\n\n*   at the end of a direct interaction between the model and the user \n*   at the end of multiple interactions between the model and any available tools\n\nThis token signals to the executor that the model has finished generating a response.\n\n`<|python_tag|>`\n\nSpecial tag used in the model’s response to signify a tool call.\n\n### Supported Roles\n\nThere are 4 different roles that are supported by Llama text models:\n\n1.   `system`: Sets the context in which to interact with the AI model. It typically includes rules, guidelines, or necessary information that help the model respond effectively.\n2.   `user`: Represents the human interacting with the model. It includes the inputs, commands, and questions to the model.\n3.   `ipython`: A new role introduced in Llama 3.1. Semantically, this role means \"tool\". This role is used to mark messages with the output of a tool call when sent back to the model from the executor.\n4.   `assistant`: Represents the response generated by the AI model based on the context provided in the `system`, `ipython` and `user` prompts.\n\n`[system, assistant, user, ipython]`\n\n### Pretrained Model Prompt\n\nThis is the simplest way to prompt llama-based models, starting with text and allowing the model to generate new content based on the user-provided input.\n\n`<|begin_of_text|>{{ user_message}}`\n\n### Instruct Model Prompt\n\nThe format for a regular multi-turn conversation between a user and the model has not changed between Llama 3 and Llama 3.1. Here is a simple example of how it's formatted.\n\n```\n<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nCutting Knowledge Date: December 2023\nToday Date: 23 July 2024\n\nYou are a helpful assistant<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nWhat is the capital of France?<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n```\n\nFor more examples of the prompt template, please refer to [`text_prompt_format.md`](https://github.com/meta-llama/llama-models/blob/main/models/llama3_2/text_prompt_format.md) in the `meta-llama` GitHub repository.\n\n**Note:** We have introduced Llama 3.3 70B, an instruction-turned model with the latest advancements in post-training techniques; see the [model card](https://github.com/meta-llama/llama-models/blob/main/models/llama3_3/MODEL_CARD.md) for detailed performance information. This new model supersedes the instruction-tuned Llama 3.1 70B model. The new model name is `Llama-3.3-70B-Instruct`; developers should [install](https://www.llama.com/llama-downloads) and use the new model wherever they would otherwise have used instruction-tuned Llama 3.1 70B.\n\n[Download](https://www.llama.com/llama-downloads) the new Llama 3.3 model.\n\nCode Interpreter\n----------------\n\nThe code interpreter feature allows the model to generate executable Python code in response to the user query. The code interpreter is triggered when `Environment: ipython` is included in the `system` prompt.\n\n**Notes**\n\n*   The model’s response is wrapped in a `<|python_tag|>` and terminated with an `<|eom_id|>` tag.\n*   The `<|eom_id|>` indicates a continued multi-step reasoning. That is, the model is expecting a continuation message with the output of the tool call. \n\nSample Input:\n\n```\n<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nEnvironment: ipython<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nWrite code to check if number is prime, use that to see if the number 7 is prime<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n```\n\nResponse:\n\n```\n<|python_tag|>def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\nprint(is_prime(7))  # Output: True<|eom_id|>\n```\n\nNote that _the model itself does not execute the code output_; you need to use our [llama-stack-apps](https://github.com/meta-llama/llama-stack-apps), or other similar framework to leverage code interpreters. When using `llama-stack-apps`, the results of the code are passed back to the model for further processing.\n\nTool Calling (8B/70B/405B)\n--------------------------\n\nTool-calling with the larger models can be done in three ways:\n\n*   Built-in Tools (Brave, Wolfram)\n*   JSON-based Tool Calling\n*   User-defined Custom Tool Calling\n\n**Note:** We recommend using Llama 70B-instruct or Llama 405B-instruct for applications that combine conversation and tool calling. Llama 8B-Instruct can not reliably maintain a conversation alongside tool calling definitions. It can be used for zero-shot tool calling, but tool instructions should be removed for regular conversations between the model and the user.\n\nDefining multiple tools in the system and/or user prompt can cause the model to generate multiple tool calls as a result of the user query. Developers must iterate on the prompts required to get the desired result and parse the result accordingly.\n\nTo better illustrate the flows below, this diagram shows the flow of information described:\n\n![Image 1: Flow diagram](https://lookaside.fbsbx.com/elementpath/media/?media_id=1171460727517928&version=1727736603&transcode_extension=webp)\n\n### User and assistant conversation\n\nThe format for a regular multi-turn conversation between a user and the model has not changed between Llama 3 and Llama 3.1. Here is a simple example of how it's formatted.\n\n```\n<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nCutting Knowledge Date: December 2023\nToday Date: 23 July 2024\n\nYou are a helpful assistant<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nWhat is the capital of France?<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n```\n\n### Built in Python based tool calling\n\nThe models are trained to use two built-in tools:\n\n1.   **Brave Search:** Tool call to perform web searches. \n2.   **Wolfram Alpha:** Tool call to perform complex mathematical calculations.\n\nThese can be turned on using the system prompt:\n\n```\n<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nEnvironment: ipython\nTools: brave_search, wolfram_alpha\nCutting Knowledge Date: December 2023\nToday Date: 23 July 2024\n\nYou are a helpful assistant<|eot_id|>\n<|start_header_id|>user<|end_header_id|>\n\nWhat is the current weather in Menlo Park, California?<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n```\n\nA few things to note:\n\n*   Just including Environment: ipython turns on code interpreter; therefore, you don’t need to specify code interpretation on the Tools: line. The model can generate python code which is interpreted by the executor, with the result provided back to the model.\n*   The message body of the assistant response starts with a special tag <|python_tag|>\n*   As alluded to above, in such an environment, the model can generate <|eom_id|> instead of just the standard <|eot_id|> . The latter indicates the turn is finished, while the former indicates continued multi-step reasoning. That is, the model is expecting a continuation message with the output of the tool call. \n\nThe built-in tool is called using _python syntax_, and not JSON format as for zero-shot tools. The python call that the model generates for each of the tools is of the form:\n\n```\n# for Search\n<|python_tag|>\nbrave_search.call(query=\"...\")\n<|eom_id|>\n\n# for Wolfram\n<|python_tag|>\nwolfram_alpha.call(query=\"...\")\n<|eom_id|>\n```\n\nTo create custom tool calls using the zero-shot learning capability of the model, you can provide instructions for the tool definition in the system prompt along with the format you want the model to produce for the call. A working example is provided in the [llama-agentic-system](https://github.com/meta-llama/llama-agentic-system) GitHub repository. You can check it out here.\n\nThe example below shows an end-to-end interaction of prompts between the user ⇔ model ⇔ tool. This sample system uses the `wolfram_alpha` in-built tool. (Please note: The model does not execute the call to the tool; you need to use our [llama-agentic-system](https://github.com/meta-llama/llama-agentic-system), or other similar framework, to leverage the tool-calling capabilities.)\n\n**Step - 1 User Prompt & System prompts**\n\n```\n<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nEnvironment: ipython\nTools: brave_search, wolfram_alpha\nCutting Knowledge Date: December 2023\nToday Date: 23 July 2024\n\nYou are a helpful assistant.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nCan you help me solve this equation: x^3 - 4x^2 + 6x - 24 = 0<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n```\n\n**Step - 2 Model determining which tool to call**\n\n`<|python_tag|>wolfram_alpha.call(query=\"solve x^3 - 4x^2 + 6x - 24 = 0\")<|eom_id|>`\n\n**Step - 3 Response generated by tool, that is, Wolfram Alpha.**\n\n```\n{\n  \"queryresult\": {\n    \"success\": true,\n    \"inputstring\": \"solve x^3 - 4x^2 + 6x - 24 = 0\",\n    \"pods\": [\n      {\n        \"title\": \"Input interpretation\",\n        \"subpods\": [\n          {\n            \"title\": \"\",\n            \"plaintext\": \"solve x^3 - 4 x^2 + 6 x - 24 = 0\"\n          }\n        ]\n      },\n      {\n        \"title\": \"Results\",\n        \"primary\": true,\n        \"subpods\": [\n          {\n            \"title\": \"\",\n            \"plaintext\": \"x = 4\"\n          },\n          {\n            \"title\": \"\",\n            \"plaintext\": \"x = ± (i sqrt(6))\"\n          }\n        ]\n      },\n      ...\n    ]\n  }\n}\n```\n\n**Step - 4 Reprompt Model with tool response**\n\n```\n<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nEnvironment: ipython\nTools: brave_search, wolfram_alpha\nCutting Knowledge Date: December 2023\nToday Date: 23 July 2024\n\nYou are a helpful assistant.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nCan you help me solve this equation: x^3 - 4x^2 + 6x - 24 = 0<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\n<|python_tag|>wolfram_alpha.call(query=\"solve x^3 - 4x^2 + 6x - 24 = 0\")<|eom_id|><|start_header_id|>ipython<|end_header_id|>\n\n{\"queryresult\": {\"success\": true, \"inputstring\": \"solve x^3 - 4x^2 + 6x - 24 = 0\", \"pods\": [{\"title\": \"Input interpretation\", \"subpods\": [{\"title\": \"\", \"plaintext\": \"solve x^3 - 4 x^2 + 6 x - 24 = 0\"}]}, {\"title\": \"Results\", \"primary\": true, \"subpods\": [{\"title\": \"\", \"plaintext\": \"x = 4\"}, {\"title\": \"\", \"plaintext\": \"x = \\u00b1 (i sqrt(6))\"}]}, ... ]}}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n```\n\n**Step - 5 Response from Agent to User**\n\n`The solutions to the equation x^3 - 4x^2 + 6x - 24 = 0 are x = 4 and x = ±(i√6).<|eot_id|>`\n\n### JSON based tool calling\n\nMeta Llama models can now output custom tool calls from a single message to allow easier tool calling. The following prompts provide an example of how custom tools can be called from the output of the model. It's important to note that the model itself does not execute the calls; it provides structured output to facilitate calling by an executor. An example executor can be found in the [llama-agentic-system](https://github.com/meta-llama/llama-agentic-system). The tool format is similar to the [OpenAI definition](https://platform.openai.com/docs/assistants/tools/function-calling/quickstart) and can be adjusted to better suit your needs, as noted in the following section.\n\n**Notes**\n\n*   With custom tool calling, for the model to output the `eom_id`, the following instruction needs to be added to the system prompt: `Environment: ipython`. Else, it should output `eot_id`.\n*   The system prompt needs to be adjusted to inform the model how to deal with tool call outputs \n*   The tool definition is provided in the user prompt, as that is how the model was trained for the built in JSON tool calling. However, it's possible to provide the tool definition in the system prompt as well—and get similar results. Developers must test which way works best for their use case.\n\n**Step - 1 User prompt with custom tool details**\n\n```\n<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nCutting Knowledge Date: December 2023\nToday Date: 23 July 2024\n\nWhen you receive a tool call response, use the output to format an answer to the orginal user question.\n\nYou are a helpful assistant with tool calling capabilities.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nGiven the following functions, please respond with a JSON for a function call with its proper arguments that best answers the given prompt.\n\nRespond in the format {\"name\": function name, \"parameters\": dictionary of argument name and its value}. Do not use variables.\n\n{\n    \"type\": \"function\",\n    \"function\": {\n    \"name\": \"get_current_conditions\",\n    \"description\": \"Get the current weather conditions for a specific location\",\n    \"parameters\": {\n        \"type\": \"object\",\n        \"properties\": {\n        \"location\": {\n            \"type\": \"string\",\n            \"description\": \"The city and state, e.g., San Francisco, CA\"\n        },\n        \"unit\": {\n            \"type\": \"string\",\n            \"enum\": [\"Celsius\", \"Fahrenheit\"],\n            \"description\": \"The temperature unit to use. Infer this from the user's location.\"\n        }\n        },\n        \"required\": [\"location\", \"unit\"]\n    }\n    }\n}\n\nQuestion: what is the weather like in San Fransisco?<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n```\n\n**Step - 2 Model determining which tool to call**\n\n**Note**:\n\n*   As we are not using the `Environment: ipython` instruction in the system prompt, the model ends generation with the `eot_id` token, not the `eom_id` token\n\n`{\"name\": \"get_current_conditions\", \"parameters\": {\"location\": \"San Francisco, CA\", \"unit\": \"Fahrenheit\"}}<eot_id>`\n\n**Step - 3 Result from calling the tool is passed back to the model**\n\nWhen the result of the tool call is sent back to the model, we use the new role, `ipython`, in the header.\n\n```\n<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a helpful assistant with tool calling capabilities. When you receive a tool call response, use the output to format an answer to the orginal use question.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nGiven the following functions, please respond with a JSON for a function call with its proper arguments that best answers the given prompt.\n\nRespond in the format {\"name\": function name, \"parameters\": dictionary of argument name and its value}. Do not use variables.\n\n{\n    \"type\": \"function\",\n    \"function\": {\n    \"name\": \"get_current_conditions\",\n    \"description\": \"Get the current weather conditions for a specific location\",\n    \"parameters\": {\n        \"type\": \"object\",\n        \"properties\": {\n        \"location\": {\n            \"type\": \"string\",\n            \"description\": \"The city and state, e.g., San Francisco, CA\"\n        },\n        \"unit\": {\n            \"type\": \"string\",\n            \"enum\": [\"Celsius\", \"Fahrenheit\"],\n            \"description\": \"The temperature unit to use. Infer this from the user's location.\"\n        }\n        },\n        \"required\": [\"location\", \"unit\"]\n    }\n    }\n}\n\nQuestion: what is the weather like in San Fransisco?<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\n{\"name\": \"get_current_conditions\", \"parameters\": {\"location\": \"San Francisco, CA\", \"unit\": \"Fahrenheit\"}}<|eot_id|><|start_header_id|>ipython<|end_header_id|>\n\n{\"output\": \"Clouds giving way to sun Hi: 76° Tonight: Mainly clear early, then areas of low clouds forming Lo: 56°\"}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n```\n\n**Step - 4 The model generates the final response the user**\n\n`The weather in Menlo Park is currently cloudy with a high of 76° and a low of 56°, with clear skies expected tonight.<eot_id>`\n\n### User-defined Custom tool calling\n\nThe following prompts provide an example of how to define your own format in the system prompt and make use of it while interacting with the model. This format will use a new and custom <function> tag to enclose a JSON object with the function parameters.\n\n**Notes**\n\n*   The model uses the `eom_id` token because of the `Environment: ipython` instruction.\n*   The system prompt defines the custom format as well as the tools the model has available. \n\n**Step - 1 System prompt with custom tool details**\n\n```\n<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nEnvironment: ipython\nTools: brave_search, wolfram_alpha\nCutting Knowledge Date: December 2023\nToday Date: 23 July 2024\n\n# Tool Instructions\n- Always execute python code in messages that you share.\n- When looking for real time information use relevant functions if available else fallback to brave_search\n\nYou have access to the following functions:\n\nUse the function 'spotify_trending_songs' to: Get top trending songs on Spotify\n{\n  \"name\": \"spotify_trending_songs\",\n  \"description\": \"Get top trending songs on Spotify\",\n  \"parameters\": {\n    \"n\": {\n      \"param_type\": \"int\",\n      \"description\": \"Number of trending songs to get\",\n      \"required\": true\n    }\n  }\n}\n\nIf a you choose to call a function ONLY reply in the following format:\n<{start_tag}={function_name}>{parameters}{end_tag}\nwhere\n\nstart_tag => `<function`\nparameters => a JSON dict with the function argument name as key and function argument value as value.\nend_tag => `</function>`\n\nHere is an example,\n<function=example_function_name>{\"example_name\": \"example_value\"}</function>\n\nReminder:\n- Function calls MUST follow the specified format\n- Required parameters MUST be specified\n- Only call one function at a time\n- Put the entire function call reply on one line\n- Always add your sources when using search results to answer the user query\n\nYou are a helpful assistant.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nCan you check the top 5 trending songs on spotify?<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n```\n\n**Step - 2 Model determining which tool to call**\n\nNow the model responds in accordance with the format defined in the system prompt, with the function name in the start tag, and the parameters, as a JSON object, in between the start and end tags.\n\n**Note**:\n\n*   As we are using the `Environment: ipython` instruction in the system prompt, the model ends generation with the `eom_id` token.\n\n`<function=spotify_trending_songs>{\"n\": \"5\"}</function><eom_id>`\n\n**Step - 3 Result from calling the tool is passed back to the model**\n\nWhen the result of the tool call is sent back to the model, we use the new role, `ipython`, in the header.\n\n```\n<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nEnvironment: ipython\nTools: brave_search, wolfram_alpha\nCutting Knowledge Date: December 2023\nToday Date: 23 July 2024\n\n# Tool Instructions\n- Always execute python code in messages that you share.\n- When looking for real time information use relevant functions if available else fallback to brave_search\n\nYou have access to the following functions:\n\nUse the function 'spotify_trending_songs' to: Get top trending songs on Spotify\n{\"name\": \"spotify_trending_songs\", \"description\": \"Get top trending songs on Spotify\", \"parameters\": {\"n\": {\"param_type\": \"int\", \"description\": \"Number of trending songs to get\", \"required\": true}}}\n\nIf a you choose to call a function ONLY reply in the following format:\n<{start_tag}={function_name}>{parameters}{end_tag}\nwhere\n\nstart_tag => `<function`\nparameters => a JSON dict with the function argument name as key and function argument value as value.\nend_tag => `</function>`\n\nHere is an example,\n<function=example_function_name>{\"example_name\": \"example_value\"}</function>\n\nReminder:\n- Function calls MUST follow the specified format\n- Required parameters MUST be specified\n- Only call one function at a time\n- Put the entire function call reply on one line\n- Always add your sources when using search results to answer the user query\n\nYou are a helpful assistant.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nCan you check the top 5 trending songs on spotify?<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\n<function=spotify_trending_songs>{\"n\": \"5\"}</function><|eom_id|><|start_header_id|>ipython<|end_header_id|>\n\n[\"1. BIRDS OF A FEATHER by Billie Eilish\", \"2. Espresso by Sabrina Carpenter\", \"3. Please Please Please by Sabrina Carpenter\", \"4. Not Like Us by Kendrick Lamar\", \"5. Gata Only by FloyyMenor, Cris Mj\"]<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n```\n\n**Step - 4 The model generates the final response the user**\n\n```\nThe top 5 trending songs on Spotify are:\n\n1. BIRDS OF A FEATHER by Billie Eilish\n2. Espresso by Sabrina Carpenter\n3. Please Please Please by Sabrina Carpenter\n4. Not Like Us by Kendrick Lamar\n5. Gata Only by FloyyMenor, Cris Mj<|eot_id|>\n```\n",
      "fetch_method": "jina-reader"
    },
    {
      "arxiv_id": "https://huggingface.co/docs/transformers/main/chat_templating#advanced-tool-use--function-calling",
      "full_text": " Chat templates Hugging Face Models Datasets Spaces Community Docs Enterprise Pricing Log In Sign Up Transformers documentation Chat templates Transformers 🏡 View all docs AWS Trainium &amp; Inferentia Accelerate Argilla AutoTrain Bitsandbytes Chat UI Dataset viewer Datasets Deploying on AWS Diffusers Distilabel Evaluate Gradio Hub Hub Python Library Huggingface.js Inference Endpoints (dedicated) Inference Providers LeRobot Leaderboards Lighteval Microsoft Azure Optimum PEFT Safetensors Sentence Transformers TRL Tasks Text Embeddings Inference Text Generation Inference Tokenizers Trackio Transformers Transformers.js smolagents timm Search documentation main v4.56.1 v4.55.4 v4.53.3 v4.52.3 v4.51.3 v4.50.0 v4.49.0 v4.48.2 v4.47.1 v4.46.3 v4.45.2 v4.44.2 v4.43.4 v4.42.4 v4.41.2 v4.40.2 v4.39.3 v4.38.2 v4.37.2 v4.36.1 v4.35.2 v4.34.1 v4.33.3 v4.32.1 v4.31.0 v4.30.0 v4.29.1 v4.28.1 v4.27.2 v4.26.1 v4.25.1 v4.24.0 v4.23.1 v4.22.2 v4.21.3 v4.20.1 v4.19.4 v4.18.0 v4.17.0 v4.16.2 v4.15.0 v4.14.1 v4.13.0 v4.12.5 v4.11.3 v4.10.1 v4.9.2 v4.8.2 v4.7.0 v4.6.0 v4.5.1 v4.4.2 v4.3.3 v4.2.2 v4.1.1 v4.0.1 v3.5.1 v3.4.0 v3.3.1 v3.2.0 v3.1.0 v3.0.2 v2.11.0 v2.10.0 v2.9.1 v2.8.0 v2.7.0 v2.6.0 v2.5.1 v2.4.1 v2.3.0 v2.2.2 v2.1.1 v2.0.0 v1.2.0 v1.1.0 v1.0.0 doc-builder-html AR DE EN ES FR HI IT JA KO PT TE TR ZH Get started Transformers Installation Quickstart Base classes Inference Pipeline API LLMs Chat with models Chat basics Chat templates Multimodal chat templates Tool use Writing a chat template Serving Optimization Agents Tools Inference server backends Training Quantization Export to production Resources Contribute API You are viewing main version, which requires installation from source . If you&#39;d like regular pip install, checkout the latest stable version ( v4.56.1 ). Join the Hugging Face community and get access to the augmented documentation experience Collaborate on models, datasets and Spaces Faster examples with accelerated inference Switch between documentation themes Sign Up to get started Chat templates The chat basics guide covers how to store chat histories and generate text from chat models using TextGenerationPipeline . This guide is intended for more advanced users, and covers the underlying classes and methods, as well as the key concepts for understanding what’s actually going on when you chat with a model. The critical insight needed to understand chat models is this: All causal LMs, whether chat-trained or not, continue a sequence of tokens. When causal LMs are trained, the training usually begins with “pre-training” on a huge corpus of text, which creates a “base” model. These base models are then often “fine-tuned” for chat, which means training them on data that is formatted as a sequence of messages. The chat is still just a sequence of tokens, though! The list of role and content dictionaries that you pass to a chat model get converted to a token sequence, often with control tokens like &lt;|user|&gt; or &lt;|assistant|&gt; or &lt;|end_of_message|&gt; , which allow the model to see the chat structure. There are many possible chat formats, and different models may use different formats or control tokens, even if they were fine-tuned from the same base model! Don’t panic, though - you don’t need to memorize every possible chat format in order to use chat models. Chat models come with chat templates , which indicate how they expect chats to be formatted. You can access these with the apply_chat_template method. Let’s see two examples. Both of these models are fine-tuned from the same Mistral-7B base model: Mistral Zephyr Copied from transformers import AutoTokenizer tokenizer = AutoTokenizer.from_pretrained( &quot;mistralai/Mistral-7B-Instruct-v0.1&quot; ) chat = [ { &quot;role&quot; : &quot;user&quot; , &quot;content&quot; : &quot;Hello, how are you?&quot; }, { &quot;role&quot; : &quot;assistant&quot; , &quot;content&quot; : &quot;I&#x27;m doing great. How can I help you today?&quot; }, { &quot;role&quot; : &quot;user&quot; , &quot;content&quot; : &quot;I&#x27;d like to show off how chat templating works!&quot; }, ] tokenizer.apply_chat_template(chat, tokenize= False ) Copied &lt; s &gt; [INST] Hello, how are you? [/INST]I&#x27;m doing great. How can I help you today? &lt;/ s &gt; [INST] I&#x27;d like to show off how chat templating works! [/INST] Mistral-7B-Instruct uses [INST] and [/INST] tokens to indicate the start and end of user messages, while Zephyr-7B uses &lt;|user|&gt; and &lt;|assistant|&gt; tokens to indicate speaker roles. This is why chat templates are important - with the wrong control tokens, these models would have drastically worse performance. Using apply_chat_template The input to apply_chat_template should be structured as a list of dictionaries with role and content keys. The role key specifies the speaker, and the content key contains the message. The common roles are: user for messages from the user assistant for messages from the model system for directives on how the model should act (usually placed at the beginning of the chat) apply_chat_template takes this list and returns a formatted sequence. Set tokenize=True if you want to tokenize the sequence. Copied import torch from transformers import AutoModelForCausalLM, AutoTokenizer tokenizer = AutoTokenizer.from_pretrained( &quot;HuggingFaceH4/zephyr-7b-beta&quot; ) model = AutoModelForCausalLM.from_pretrained( &quot;HuggingFaceH4/zephyr-7b-beta&quot; , device_map= &quot;auto&quot; , dtype=torch.bfloat16) messages = [ { &quot;role&quot; : &quot;system&quot; , &quot;content&quot; : &quot;You are a friendly chatbot who always responds in the style of a pirate&quot; ,}, { &quot;role&quot; : &quot;user&quot; , &quot;content&quot; : &quot;How many helicopters can a human eat in one sitting?&quot; }, ] tokenized_chat = tokenizer.apply_chat_template(messages, tokenize= True , add_generation_prompt= True , return_tensors= &quot;pt&quot; ) print (tokenizer.decode(tokenized_chat[ 0 ])) Copied &lt;|system|&gt; You are a friendly chatbot who always responds in the style of a pirate &lt;/ s &gt; &lt;|user|&gt; How many helicopters can a human eat in one sitting? &lt;/ s &gt; &lt;|assistant|&gt; Pass the tokenized chat to generate() to generate a response. Copied outputs = model.generate(tokenized_chat, max_new_tokens= 128 ) print (tokenizer.decode(outputs[ 0 ])) Copied &lt;|system|&gt; You are a friendly chatbot who always responds in the style of a pirate &lt;/ s &gt; &lt;|user|&gt; How many helicopters can a human eat in one sitting? &lt;/ s &gt; &lt;|assistant|&gt; Matey, I&#x27;m afraid I must inform ye that humans cannot eat helicopters. Helicopters are not food, they are flying machines. Food is meant to be eaten, like a hearty plate o&#x27; grog, a savory bowl o&#x27; stew, or a delicious loaf o&#x27; bread. But helicopters, they be for transportin&#x27; and movin&#x27; around, not for eatin&#x27;. So, I&#x27;d say none, me hearties. None at all. Some tokenizers add special &lt;bos&gt; and &lt;eos&gt; tokens. Chat templates should already include all the necessary special tokens, and adding additional special tokens is often incorrect or duplicated, hurting model performance. When you format text with apply_chat_template(tokenize=False) , make sure you set add_special_tokens=False if you tokenize later to avoid duplicating these tokens. This isn’t an issue if you use apply_chat_template(tokenize=True) , which means it’s usually the safer option! add_generation_prompt You may have noticed the add_generation_prompt argument in the above examples. This argument adds tokens to the end of the chat that indicate the start of an assistant response. Remember: Beneath all the chat abstractions, chat models are still just language models that continue a sequence of tokens! If you include tokens that tell it that it’s now in an assistant response, it will correctly write a response, but if you don’t include these tokens, the model may get confused and do something strange, like continuing the user’s message instead of replying to it! Let’s see an example to understand what add_generation_prompt is actually doing. First, let’s format a chat without add_generation_prompt : Copied tokenized_chat = tokenizer.apply_chat_template(messages, tokenize= False , add_generation_prompt= False ) tokenized_chat Copied &lt;|im _start|&gt;user Hi there!&lt;|im_ end|&gt; &lt;|im _start|&gt;assistant Nice to meet you!&lt;|im_ end|&gt; &lt;|im _start|&gt;user Can I ask a question?&lt;|im_ end|&gt; Now, let’s format the same chat with add_generation_prompt=True : Copied tokenized_chat = tokenizer.apply_chat_template(messages, tokenize= False , add_generation_prompt= True ) tokenized_chat Copied &lt;|im _start|&gt;user Hi there!&lt;|im_ end|&gt; &lt;|im _start|&gt;assistant Nice to meet you!&lt;|im_ end|&gt; &lt;|im _start|&gt;user Can I ask a question?&lt;|im_ end|&gt; &lt;|im _start|&gt;assistant When add_generation_prompt=True , &lt;|im_start|&gt;assistant is added at the end to indicate the start of an assistant message. This lets the model know an assistant response is next. Not all models require generation prompts, and some models, like Llama , don’t have any special tokens before the assistant response. In these cases, add_generation_prompt has no effect. continue_final_message The continue_final_message parameter controls whether the final message in the chat should be continued or not instead of starting a new one. It removes end of sequence tokens so that the model continues generation from the final message. This is useful for “prefilling” a model response. In the example below, the model generates text that continues the JSON string rather than starting a new message. It can be very useful for improving the accuracy of instruction following when you know how to start its replies. Copied chat = [ { &quot;role&quot; : &quot;user&quot; , &quot;content&quot; : &quot;Can you format the answer in JSON?&quot; }, { &quot;role&quot; : &quot;assistant&quot; , &quot;content&quot; : &#x27;{&quot;name&quot;: &quot;&#x27; }, ] formatted_chat = tokenizer.apply_chat_template(chat, tokenize= True , return_dict= True , continue_final_message= True ) model.generate(**formatted_chat) You shouldn’t use add_generation_prompt and continue_final_message together. The former adds tokens that start a new message, while the latter removes end of sequence tokens. Using them together returns an error. TextGenerationPipeline sets add_generation_prompt to True by default to start a new message. However, if the final message in the chat has the assistant role, it assumes the message is a prefill and switches to continue_final_message=True . This is because most models don’t support multiple consecutive assistant messages. To override this behavior, explicitly pass the continue_final_message argument to the pipeline. Model training Training a model with a chat template is a good way to ensure the template matches the tokens the model was trained on. Apply the chat template as a preprocessing step to your dataset. Set add_generation_prompt=False because the additional tokens to prompt an assistant response aren’t helpful during training. An example of preprocessing a dataset with a chat template is shown below. Copied from transformers import AutoTokenizer from datasets import Dataset tokenizer = AutoTokenizer.from_pretrained( &quot;HuggingFaceH4/zephyr-7b-beta&quot; ) chat1 = [ { &quot;role&quot; : &quot;user&quot; , &quot;content&quot; : &quot;Which is bigger, the moon or the sun?&quot; }, { &quot;role&quot; : &quot;assistant&quot; , &quot;content&quot; : &quot;The sun.&quot; } ] chat2 = [ { &quot;role&quot; : &quot;user&quot; , &quot;content&quot; : &quot;Which is bigger, a virus or a bacterium?&quot; }, { &quot;role&quot; : &quot;assistant&quot; , &quot;content&quot; : &quot;A bacterium.&quot; } ] dataset = Dataset.from_dict({ &quot;chat&quot; : [chat1, chat2]}) dataset = dataset. map ( lambda x: { &quot;formatted_chat&quot; : tokenizer.apply_chat_template(x[ &quot;chat&quot; ], tokenize= False , add_generation_prompt= False )}) print (dataset[ &#x27;formatted_chat&#x27; ][ 0 ]) Copied &lt;|user|&gt; Which is bigger, the moon or the sun? &lt;/ s &gt; &lt;|assistant|&gt; The sun. &lt;/ s &gt; After this step, you can continue following the training recipe for causal language models using the formatted_chat column. &lt; &gt; Update on GitHub ← Chat basics Multimodal chat templates → Chat templates Using apply_chat_template add_generation_prompt continue_final_message Model training ",
      "fetch_method": "direct-html"
    },
    {
      "arxiv_id": "https://arxiv.org/pdf/2204.05149",
      "full_text": "The Carbon Footprint of Machine Learning Training Will Plateau, Then Shrink\nDavid Patterson1,2, Joseph Gonzalez2, Urs Hölzle1, Quoc Le1, Chen Liang1, Lluis-Miquel Munguia1,\nDaniel Rothchild2, David So1, Maud Texier1, and Jeff Dean1\nAbstract: Machine Learning (ML) workloads have rapidly grown in importance, but raised concerns\nabout their carbon footprint. Four best practices can reduce ML training energy by up to 100x and CO2\nemissions up to 1000x. By following best practices, overall ML energy use (across research,\ndevelopment, and production) held steady at <15% of Google’s total energy use for the past three years.\nIf the whole ML field were to adopt best practices, total carbon emissions from training would reduce.\nHence, we recommend that ML papers include emissions explicitly to foster competition on more than\njust model quality. Estimates of emissions in papers that omitted them have been off 100x–100,000x, so\npublishing emissions has the added benefit of ensuring accurate accounting. Given the importance of\nclimate change, we must get the numbers right to make certain that we work on its biggest challenges.\nKeywords/Index terms: I.2.6.g Machine learning < I.2.6 Learning < I.2 Artificial Intelligence\n< I Computing Methodologies, I.2.7 Natural Language Processing < I.2 Artificial Intelligence\n< I Computing Methodologies, B.9 Power Management < B Hardware, C.1.3.i Neural nets\n< C.1.3 Other Architecture Styles < C.1 Processor Architectures < C Computer Systems Organization,\nC.4 Performance of Systems < C Computer Systems Organization\n1. Introduction\nOver the past few years, a growing number of papers have highlighted the carbon emissions of machine\nlearning (ML) workloads. While this work has been instrumental in rightfully elevating the discussion\naround carbon emissions in ML, some studies significantly overestimated actual emissions, which in turn\nled to worrisome extrapolations [1,2]:\nThe answers are grim: Training such a model would cost US$100 billion and would produce as\nmuch carbon emissions as New York City does in a month.\nRecent work highlights the complexities and nuances associated with carbon accounting for ML and\nmore broadly computing workloads [3, 4, 5]. In this paper, we\n●\nDescribe four practices that reduce the energy usage and carbon emissions of ML workloads by\norders of magnitude relative to traditional choices;\n●\nShow that these practices help keep ML under 15% of Google’s total energy use for the past\nthree years; and\n●\nExplain why published faulty estimates and extrapolations are 100x–100,000x higher than the\nreal carbon footprints.\nResponsible AI is a broad topic; we focus on a single issue that has received much attention from the\nML community and public: carbon emissions from ML training. Emissions can be classified as\n●\nOperational, the energy cost of operating the ML hardware including datacenter overheads, or\n●\nLifecycle, which additionally includes the embedded carbon emitted during the manufacturing of\nall components involved, from chips to datacenter buildings.\nLike prior work we focus on operational emissions; estimating lifecycle emissions is a larger, future study.\nWe identified best practices that can reduce energy by up to 100x and carbon emissions by up to\n1000x compared to following orthodox choices (“4Ms”):\n2 University of California, Berkeley\n1 Google\n1\n\n1.\nModel. Selecting efficient ML model architectures while advancing ML quality, such as sparse\nmodels versus dense modes, can reduce computation by factors of ~5–10.\n2.\nMachine. Using processors optimized for ML training such as TPUs or recent GPUs (e.g., V100\nor A100), versus general-purpose processors, can improve performance/Watt by factors of 2–5.\n3.\nMechanization. Computing in the Cloud rather than on premise improves datacenter energy\nefficiency3, reducing energy costs by a factor of 1.4–2.\n4.\nMap. Moreover, Cloud computing lets ML practitioners pick the location with the cleanest energy4,\nfurther reducing the gross carbon footprint by factors of 5–105.\nFigure 1. Reduction in gross CO2 emissions since 2017 from applying best practices (Section 3).\nThey show large end-to-end improvements, broken down into the 4Ms. Gross CO2 emissions here\nexcludes Google's carbon neutral and 100% renewable energy credits, and reflect Google's 24/7\nCFE methodology [5].\nFigure 1 illustrates how four good choices together reduce energy consumption by 83x and CO2\nemissions by 747x over four years while maintaining the same quality. The original modeled estimate\n5 Using a carbon-neutral cloud like Facebook or Google further reduces the footprint to zero because they match\n100% of operational energy use with renewable energy. We exclude those offsets.\n4 Most data transmission power is for the network equipment of the Internet even when idle [3]. In comparison,\nshipping photons over fiber optics is relatively trivial.\n3 The Cloud uses custom warehouses designed for energy efficiency, whereas on-premise datacenters are\ninefficiently located in smaller, older spaces intended for other purposes. HPC datacenters are efficient, but can’t\nenable shifting to green locations.\n2\n\nrepresents training the Transformer model in 2017 on an ML-oblivious GPU6 in an average datacenter\nusing an average energy mix (like [2]). The yellow line shows optimizations possible in 2019, the green\nline optimizations possible today. In both cases, optimized ML hardware reduces energy consumption\nsignificantly, with newest-generation hardware (TPUv4) providing an additional 2.4x over the 2019\nhardware (TPUv2). Using efficient cloud datacenters and a low-carbon datacenter region per Google’s\n24/7 carbon-free energy (CFE) methodology further reduces the carbon footprint by another order of\nmagnitude (note the log-scale Y axis), resulting in a 747-fold reduction in carbon footprint compared to\nthe original estimate. In this paper, gross CO2 emissions are the carbon emissions resulting from a\nworkload in a particular location before any compensating actions.\nSupported by the results in Figure 1 and in Section 3, we predict that if ML communities embrace\nthese best practices, the carbon footprint of ML training will shrink over this decade.\nBelow we summarize this paper’s contributions:\n●\nTwo studies show the impact of best practices: a 750x emissions reduction without loss of\naccuracy from Transformer (Figure 1) and a 14x emissions reduction from GPT-3 by the larger\nGLaM model that improves accuracy.\n●\nLocation choice, even within one country, can significantly impact the carbon footprint.\n●\nWe provide the first report by a hyperscaler company of the percentage of its overall energy use\ndevoted to ML training and inference.\n●\nWe show that the carbon footprint of searching for better ML models can reduce the impact of\ndownstream ML tasks by much more than the cost of the search.\n●\nWe describe how following best practices significantly reduced the energy consumption and\ncarbon footprint of training compared to the faulty estimates commonly cited [2,6,7].\n2. Overview of Energy and CO2e for ML Training\nWe estimate energy and carbon footprints using these terms:\n●\nCO2 equivalent emissions (CO2e) accounts for carbon dioxide (CO2) and all the other greenhouse\ngasses as well: methane, nitrous oxide, and so on.\n●\nMetric tons are the common CO2e unit of measure, abbreviated as tCO2e, representing 1000\nkilograms (2205 pounds).\n●\nMegawatt hours (MWh) measure energy; one MWh equals 1,000,000 Watts of electricity used\ncontinuously for 1 hour. One Terawatt hour (TWh) equals 1,000,000 MWh.\n●\nPower Usage Effectiveness (PUE) is the industry standard metric of datacenter efficiency, defined\nas the ratio between total energy usage (including all overheads, like cooling) divided by the\nenergy directly consumed by the datacenter’s computing equipment. The average industry\ndatacenter PUE in 2020 was 1.58 (58% overhead) while cloud providers have PUEs of ~1.10 [5].\n●\nCarbon intensity (tCO2e per MWh) is a measure of the cleanliness of a datacenter’s energy. The\naverage datacenter carbon emissions in 2020 was 0.429 tCO2e per MWh but the gross CO2e per\nMWh can be 5x lower in some Google datacenters.\n6 The 2016 NVIDIA P100 was optimized for graphics, not ML.\n3\n\nThe energy consumption of the servers performing a training task is proportional to the number of\nprocessors used and the duration of the training run:\n𝑀𝑊ℎ= 𝐻𝑜𝑢𝑟𝑠 𝑡𝑜 𝑡𝑟𝑎𝑖𝑛 × 𝑁𝑢𝑚𝑏𝑒𝑟 𝑜𝑓 𝑃𝑟𝑜𝑐𝑒𝑠𝑠𝑜𝑟𝑠× 𝐴𝑣𝑒𝑟𝑎𝑔𝑒 𝑃𝑜𝑤𝑒𝑟 𝑝𝑒𝑟 𝑃𝑟𝑜𝑐𝑒𝑠𝑠𝑜𝑟\nWe include all server components in “Processor” (including local memory, network links, and so on).\nAdditionally, the datacenter consumes energy to power and cool the hardware (e.g., voltage\ntransformation losses, cooling equipment), captured by PUE. Thus, the final formula for energy\nconsumption:\n𝑀𝑊ℎ= (𝐻𝑜𝑢𝑟𝑠 𝑡𝑜 𝑡𝑟𝑎𝑖𝑛 × 𝑁𝑢𝑚𝑏𝑒𝑟 𝑜𝑓 𝑃𝑟𝑜𝑐𝑒𝑠𝑠𝑜𝑟𝑠× 𝐴𝑣𝑒𝑟𝑎𝑔𝑒 𝑃𝑜𝑤𝑒𝑟 𝑝𝑒𝑟 𝑃𝑟𝑜𝑐𝑒𝑠𝑠𝑜𝑟) × 𝑃𝑈𝐸\nWe can then turn energy into carbon by multiplying it with the carbon intensity of the energy supply:\n𝑡𝐶𝑂2𝑒= 𝑀𝑊ℎ× 𝑡 𝐶𝑂2𝑒 𝑝𝑒𝑟 𝑀𝑊ℎ\nThe real-world values for many factors are readily available. ML practitioners usually publish the number\nand type of processors and hours to train, and the power consumption of most hardware components is\nwell known or can be measured accurately. Many Cloud companies publish the PUE of their datacenters.\nIn comparison, carbon intensity is harder to obtain. For this paper we use the carbon intensity of\nGoogle datacenters, derived from Figure 2. We hope other providers will publish so that carbon intensity\ncan be compared across datacenters.\nFigure 2. Percent Carbon Free Energy by Google Cloud Location in 2020. The map shows the\n%CFE and how the percentage changes by time of day. Chile has a high %CFE from 6AM to 8PM,\nbut not at night. The US examples on this map range from 19% CFE in Nevada to 93% in Iowa,\nwhich has strong prevailing winds both night and day. (sustainability.google/progress/energy/)\n4\n\n3. Case Study 1: Transformer vs. Evolved Transformer vs. Primer\nMany of the headline grabbing advances in AI stem from deep neural networks (DNNs); indeed, three\nDNN leaders shared the 2018 ACM A.M. Turing Award.\nDNN computations have two phases: training, which constructs accurate models through an\nintensive computational process involving iterative updating of parameters, and inference, which uses\nthe trained models to generate outputs from model inputs. ML practitioners use different models for\ndifferent tasks: object recognition, language translation, and so on. Training “learns” parameters that\nraise the likelihood of correctly mapping from input to result. Unlike in traditional computing, the actual\nDNN code is relatively small. The “smarts” come from training DNNs from millions of labeled examples\nversus writing millions of lines of code.\nThe Transformer model debuted in 2017 and is used primarily for natural language processing (NLP).\nIts distinguishing feature is focusing attention on portions of its input. Two years later, So et al used\nneural architecture search (NAS) to discover the Evolved Transformer model that matched Transformer’s\nquality scores but was ~1.3x faster [8]. In 2021, a different NAS found the Primer model that again\nmatched the quality scores but was 4.2x faster than the original Transformer [9].\nFigure 1 above plots the end-to-end reduction in CO2e by applying the best practices from Section 1.\nThe reference point is the Transformer model trained on a P100 GPU in an average on-premise\ndatacenter with the average PUE of 1.60 in 2017 and using the average tCO2e per MWh of 0.488. Here\nare the practices (4Ms):\n1.\nModel. In 2019 the best model was Evolved Transformer, in 2021 Primer.\n2.\nMachine. Compared to the unoptimized P100s from 2017, the ML-optimized TPUv2 in 2019 and\nTPUv4 in 2021 reduce energy consumption by 5.7x and 13.7x, respectively. This reduction is a\nfunction of both improved logic (more specialized hardware), newer chip fabrication technology,\nand more efficient mapping of the training task to hardware (better utilization of the functional\nunits) [10].\n3.\nMechanization. The third point shows a reduction of 1.4x from the better PUE of Google’s Cloud\ndatacenter versus the average datacenter.\n4.\nMap. A big surprise was how much location of the datacenter affected carbon intensity (Figure 2).\nIn 2019, the datacenter in the US region with the highest CFE score was Oklahoma with a score\nof 96%, and in 2020 it was Iowa at 93%.\nTo summarize, following best practices yields a 65x reduction in CO2e two years after Transformer\nwas introduced. Two additional years later—with ML model, hardware, and energy mix\nimprovements—another 11x was possible, for an overall reduction of 747x. These drastic overall\nimprovements, as well as their trajectory over time, suggest that extrapolating current parameters to\npredict future CO2e is fraught with peril.\n4. Case Study 2: GPT-3 vs GLaM\nNext is a large NLP model that received considerable attention in the ML community and in the press in\n2020: GPT-3 is an autoregressive language model with 175B parameters, 10x more than any non-sparse\nlanguage model at the time, and 100-1000x more than most other ML models [11]. To put GPT-3 into\nperspective, its predecessor GPT-2 had 1.5B parameters, and the Transformer models above used\n≤0.2B. Developed by OpenAI, GPT-3 was trained on 10,000 V100 GPUs7 in a Microsoft cloud\ndatacenter.\n7 The 2017 NVIDIA V100 is optimized for ML.\n5\n\nA winner of the best paper award at NeurIPS, the recent GPT-3 paper already has >2500 citations\nand made mainstream media headlines. One benefit of large models like GPT-3 is that they don’t need to\nbe retrained for every new task—called few-shot generalization—unlike smaller models.\nGLaM is a new language model using 7x more parameters than GPT-3. It is a mixture of experts\nmodel that only activates experts selectively based on the input so that no more than 95B parameters\n(8%) are active per input token. The dense GPT-3 activates all 175B parameters on every token. More\nparameters and sparsity allow GLaM to exceed GPT-3 on quality and efficiency [12].\nFigure 3 compares them. GPT-3 took 405 V100 years to train in 2020. OpenAI trained in the\nMicrosoft cloud to leverage a low PUE but with an energy mix that matched the US datacenter average\n[5]. In comparison, GLaM trained on TPUv4s in 2.8x fewer accelerator years, using 2.8x less energy than\nGPT-3. Additionally, GLaM ran in the Oklahoma datacenter where the tCO2e per MWh was ~5x lower\n(0.088 vs 0.429). Evolved Transformer and Primer improve energy use and CO2e while maintaining\nquality scores, but GLaM improves all three metrics.\nML researchers are continuously improving the efficiency of large language models through\ninnovations in algorithms and model architectures. Only 18 months after GPT-3, GLaM can reduce the\ngross carbon footprint by ~14x despite raising accuracy. These drastic improvements again show that\nextrapolating current ML trends to predict future ML energy use and CO2e can greatly overestimate\nconsumption, as there are continuous, significant improvements in algorithms and hardware.\nFigure 3. Parameters, accelerator years of computation, energy consumption, and gross CO2e for\nGPT-3 and GLaM. If instead of outperforming GPT-3 on quality scores, GLaM was only trained to\nmatch, it would halve the time, energy, and CO2e. Google's renewable energy purchases further\nreduce the impact to zero.\n5. Overall ML Energy Consumption\nThe previous sections investigate the energy consumption of a single training task. Here we discuss the\noverall footprint of all ML workloads at a major user of ML, Google.\nMany hyperscalers regularly publish their energy consumption metrics. According to their\nsustainability reports, the annual energy consumption in 2020 was 15.4 TWh for Google and 10.8 TWh\nfor Microsoft. These reports put the training energy of large models into perspective. Training GPT-3 was\n~0.012% of Microsoft’s energy consumption in 2020 and GlaM was ~0.004% of Google’s. For further\ncomparison, the portion of the 22,000 people from 68 countries who in 2019 flew to attend the two major\nML conferences (NeurIPS and CVPR) collectively had a CO2e impact arguably had ~10x–100x higher\nthan the impact of training of all the ML models in this paper [5].\n6\n\nWhile Google’s overall energy consumption increases as usage grows, our data shows that despite\nthe growth of ML applications, the ML portion of Google’s overall energy consumption is not increasing.\nTo estimate that fraction, we measured the energy consumption (including datacenter overheads) of the\nfollowing components:\n●\nAll TPUs and GPUs in Google datacenters, including associated dedicated servers and\nnetworking equipment. Virtually all ML training executes on TPUs and GPUs and most inference\nas well. We can differentiate training versus inference runs on TPUs and GPUs.\n●\nAny CPU consumption attributable to ML inference (no significant training was done solely on\nCPUs).\nTo estimate the CPU portion of inference, we inspected Google-Wide Profiling results to measure CPU\nconsumption of the libraries used for ML inference. We then converted CPU utilization into energy\nconsumption using sensors that measure server power. Our numbers likely overestimate because some\nlibraries are used in non-ML cases as well. Also, we may double count some host CPUs already\naccounted for in the TPU/GPU measurements, and some GPU use is for graphics.\nWe retroactively performed these calculations based on data for one week of April in 2019, 2020, and\n2021. Each time the ML portion was 10% to 15% of Google's total energy consumption for that week\ndespite ML representing 70%-80% of the FLOPS at Google8. While ML usage certainly increased during\nthese three years, algorithmic and hardware improvements kept that growth to a rate comparable with\noverall energy growth at Google. Across all three years, about ⅗ of ML energy use is for inference and ⅖\nfor training. These measurements include all ML energy usage: research, development, testing, and\nproduction.\nConsequently, we take the stable fraction for ML as a strong indication that despite ML’s increasing\npopularity, if we follow best practices its energy consumption is not skyrocketing, contrary to commonly\nexpressed fears. This stability may reflect economic factors in addition to technical factors: after all,\neverything has a budget, and budget limits encourage efficient use of ML resources.\nWorldwide datacenter energy consumption is not growing quickly either. [4] observes that global\ndatacenter energy consumption increased by only 6% from 2010 to 2018, despite datacenter computing\ncapacity increasing by 550% over the same time period, and contrary to 2010 predictions of a 70%\nincrease by 2018. One key factor was the shift from conventional datacenters to cloud datacenters. Not\nonly are cloud datacenters often more efficient, cloud servers typically have significantly higher utilization\nthan on-premise servers. That allows the same workloads to be served with less hardware and thus less\nenergy, just as books purchased for libraries are more frequently read than books purchased for home\nuse. As of 2021 only 15%-20% of all workloads have moved to the Cloud [13], so there is still plenty of\nheadroom for Cloud growth to replace inefficient on-premise datacenters.\nFinally, most cloud companies compensate at least partially for their carbon emissions. In particular,\nGoogle (since 2017) and Facebook (since 2020) purchase enough renewable energy annually to match\n100% of their usage, so each MWh of new consumption is offset by one MWh of new renewable energy,\nalbeit not necessarily in the same location. Microsoft’s similar goal is for 2025. Thus, the net carbon\nimpact of ML computations for some companies could be considered zero. Such multi-billion dollar direct\nenergy purchases by hyperscalers have spurred the growth of renewable energy substantially: in some\ncountries, they are more significant investors in renewable energy than government subsidies [14].\n6. Additional Factors\nFor completeness, we will briefly address two other concerns about ML energy usage: the impact of\nNeural Architecture Search (NAS), which may run thousands of training runs as part of a single\n8 See Section 7 for an explanation why using many more FLOPS does not imply using much more energy.\n7\n\nsearch—potentially exploding overall energy consumption—and ML’s impact on client-side energy\nusage.\nA commonly expressed concern is that automated methods might increase training energy\nconsumption. As the name implies, NAS uses computers to find models with higher quality or efficiency\nthan human experts can find. NAS is generally not performed once per model training, but once per\nproblem domain+architectural search space combination. Evolved Transformer and Primer are examples\nof the benefits of NAS [8, 9]. NAS has also been applied to find models that have better quality and run\nfaster by adapting them to a given processor [15].\nThe NAS producing Evolved Transformer used 7.5 MWh. The use of Evolved Transformer while\ntraining the large Meena model saved 15x the energy cost of this NAS [5]. Finding the even faster Primer\nused only 6.2 MWh. Overall, NAS is a net environmental gain if the discovered model is trained more\nthan a few times. Often, the more efficient models found by NAS are open-sourced and reused hundreds\nor even thousands of times [5]. Consequently, as a whole, it is likely that NAS reduces total ML energy\nusage by producing more efficient models whose downstream use more than compensates for the initial\nsearch effort.\nTo estimate ML energy use on client devices, [16] studied mobile phones. Most modern phones have\nML accelerators; for example, the Google Pixel 6 phone has an Edge TPU, which runs most of the ML\nworkload. During a typical day, the Edge TPU consumes less than 1% of the phone’s energy. Client use\nof ML libraries and ML applications (bar code reading, OCR, face recognition, etc) played a similar minor\nrole. CPU and GPU account for ~8% of total energy usage on phones, of which a small fraction is for ML.\nTo be on the safe side, we use a generous upper bound for ML energy usage on today’s mobile phones\nof 5%.\nThe estimated global energy use of the 3.8B mobile phones in 2021 is ~7.9 TWh, assuming nightly\ncharging and accounting for charger inefficiency [16]. The upper bound for ML on mobile phones is then\n0.4 TWh. Google’s ML server energy use in 2020 was ~6 times higher than this conservative estimate of\nML on all mobile phones. This calculation does not include the other energy consumption of ML at other\ncloud companies, so server-side ML energy usage clearly dominates client-side usage.\n7. Related Work\n[17] is a similar study that also provides a framework to understand the potential climate impacts of ML\nresearch. It also offers a leaderboard to foster competitions on reducing CO2e of ML and a tool to collect\nenergy use and CO2e from the preliminary training runs. [5] is a 22-page technical report by the authors\nof this paper that goes into greater detail on the many of the issues here.\n[18] warns of the danger of “Red AI”, which focuses on model quality gains regardless of the training\ncost or CO2e. They encourage embracing “Green AI” where the focus is on computing efficiency as well\nas model quality. Arguing that it can be difficult to measure energy and CO2e, they recommend\nminimizing the number of floating point operations (FLOPs) to train a model. Alas, FLOPs is not a good\nmetric, for time and energy can be uncorrelated with FLOPs. For example, AutoML found faster models\nthat used 2.4x as many FLOPs [15]. An underlying reason is that main memory accesses are much\nslower and use much more energy than FLOPs today. A DRAM access is ~6000x energy of a 16b FLOP\n(1300 vs 0.21 picoJoules) [10]. Another reason is that scaling up FLOPS/sec is much easier for ML\naccelerators than scaling up memory bandwidth9. To improve efficiency further, ML practitioners should\nfocus more on reducing memory accesses than on FLOPs. More successful attempts to simplify\ncalculation of energy are online calculators, such as the ML Emissions Calculator [5,19].\n9 These ratios and the ease for hardware to scale up FLOPS/second also helps explain how ML energy use can be\nunder 15% despite ML being responsible for 70%–80% of the FLOPS over the past three years.\n8\n\nThe opening quote in Section 1 is based on a 2019 study from the University of Massachusetts\n(UMass) that estimated the environmental impact of training [2]. More than 1000 papers cite this paper\nas the source for the impact on carbon emissions of ML models, e.g., [1,6,7,17,18,19,20]. The study\ncalculated the energy consumed and carbon footprint of the NAS by [8] that led to Evolved Transformer.\nThe UMass estimate was 284 tCO2e for NAS; the actual number was only 3.2 tCO2e, a factor of 88\nsmaller. The reasons for the overshoot:\n1.\nSince the authors of the original NAS paper didn’t include energy and emissions for Google\nsystems, the UMass estimate was based on older GPUs not optimized for ML10 instead of TPUv2\nand on the average datacenter PUE and average carbon intensity instead of the real numbers for\na Google datacenter. This difference explains 5x.\n2.\nThere was also confusion about the computational cost of NAS. Described subtly in [8], the\nEvolved Transformer NAS used a small proxy task to search for the best models to save time,\nmoney, and energy, and then scaled up the found models to full size. However, [2] assumed the\nsearch was done with full size tasks. The resulting computation estimate for NAS was another\n18.7x too high\nThe actual overshoot was 18.7x for computation and 5x for Google versus the average datacenter, so\nthe real emissions for the one-time search were 88x less (3.2 versus 284 tCO2e).\nThe faulty estimates in [2] are understandable given the lack of access to internal information. It is\nlikewise understandable that those estimates were propagated in other papers, like [1,6,7,17,18,19,20].\nUnfortunately, some papers that cite this work confused the one-time cost of the NAS of [8] with the\nrelatively tiny “every-time” cost that is incurred from training. This cost difference is more than 1000x11.\nThis confusion led them to believe Evolved Transformer used more than 2 million GPU hours to train,\ncost millions of dollars, and its emissions were five times the lifetime of a car (284,019 kg) [6,7]. In reality,\ntraining the medium Evolved Transformer, which achieves the same accuracy level as the\nTransformer-big model,   takes 120 TPUv2 hours, costs $40, and emits only 2.4 kg (0.00004 car\nlifetimes), 120,000x less. This gap is nearly as large as if one overestimated the CO2e to manufacture a\ncar by 100x and then used that number as the CO2e for driving a car.12\nAccuracy is difficult if estimated retrospectively, as evidenced by the difference between these\npublished estimates and actual measurements. This example underlines the importance of our\nrecommendation that authors calculate and publish energy consumption and carbon footprint.\n8.\nConclusion\nMachine Learning (ML) workloads have rapidly grown in importance, raising legitimate concerns about\ntheir energy usage. Fortunately, the real-world energy usage trend of ML is fairly boring. While overall\nenergy use at Google grows annually with greater usage, the percentage for ML has held steady for the\npast three years, representing <15% of total energy usage. Inference represents about ⅗ of total ML\nenergy usage at Google, owing to the many billion-user services that use ML. GLaM, the largest natural\nlanguage model trained in 2021, improved model quality yet produced 14x less CO2e than training the\nprevious state-of-the art model from 2020 (GPT-3) and used only 0.004% of Google’s annual energy.\nFurthermore, we illustrated that in large scale production ML deployments, minimizing emissions from\ntraining is not the ultimate goal. Instead, the combined emissions of training and serving need to be\nminimized. Approaches like neural architecture search increase emissions but lead to more efficient\nserving and a strong overall reduction of the carbon footprint of ML. Another perspective is that some\n12 The average US car trip produces 4 kg, but manufacturing a car generates 9200 kg of CO2e (2300x more).\n11 The NASs for Evolved Transformer and Primer produce 1347x and 1618x more CO2e, respectively, than their\ntraining.\n10 They used the P100. The most recent GPU available was the V100, which is much faster in part because it was\noptimized for ML, unlike the P100.\n9\n\nconsider the carbon footprint to be erased entirely if the cloud provider matches 100% of their energy\nconsumption with renewable energy, as Google and Facebook have done and as Microsoft will soon do.\nWhile ML workloads have grown rapidly over the past decade, and while the number of computations\nper training run has similarly increased by orders of magnitude, our data shows that technology\nimprovements have largely compensated for this increased load. We believe this consistent overall low\npercentage is a testimony to the benefits of following best practices:\n●\nDatacenter providers should publish the PUE, %CFE, and CO2e/MWh per location so that\ncustomers who care can understand and reduce their energy consumption and carbon footprint.\n●\nML practitioners should train using the most effective processors in the greenest datacenter that\nthey have access to, which today is often in the Cloud.\n●\nML researchers should continue to develop more efficient ML models [8,9], such as by leveraging\nsparsity [12] or by integrating retrieval into a smaller model. They should also publish their energy\nconsumption and carbon footprint, both in order to foster competition on more than just model\nquality and to ensure accurate accounting of their work, which is difficult to do accurately\npost-hoc.\nThese numbers may vary across companies, but the practices we’ve identified are applicable to virtually\nall ML training workloads and open to all to use. As a result, we predict that if all ML communities\nembrace these best practices, we can create a virtuous circle that will bend the curve so that in this\ndecade we’ll see the total carbon footprint of ML training at first plateau and then shrink.\nFinally, we show that published studies overestimated the cost and carbon footprint of ML training\nbecause they didn’t have access to the right information or because they extrapolated point-in-time data\nwithout accounting for algorithmic or hardware improvements.\nClimate change is important, so we must get the numbers right to ensure that we work on the biggest\nchallenges. Many efforts are underway to reduce the operational energy and CO2e of ML training, as\nillustrated by the 4Ms: model, machine, mechanization, and map. Thus, within information technology, we\nbelieve the biggest climate change challenge is not the operational cost of ML but more likely the\nlifecycle cost of manufacturing computing equipment of all types and sizes13.\nAcknowledgement. We had a great deal of help from others along the way for an earlier study [5]\nthat eventually led to this version of the paper. Emma Strubell made several suggestions for the prior\npaper, including the recommendation to examine the recent giant NLP models. Christopher Berner, Ilya\nSutskever, OpenAI, and Microsoft shared information about GPT-3. Dmitry Lepikhin and Zongwei Zhou\ndid a great deal of work to measure the performance and power of GPUs and TPUs in Google data\ncenters. Hallie Cramer, Anna Escuer, Elke Michlmayr, Kelli Wright, and Nick Zakrasek helped with the\ndata and policies for energy and CO2e emissions at Google. Talia Ringer provided helpful suggestions on\nhow to better present related work.\n9. References\n[1]\nThompson, N.C., et al., 2021. Deep Learning's Diminishing Returns: The Cost of Improvement is Becoming\nUnsustainable. IEEE Spectrum.\n[2]\nStrubell, E., et al., 2019. Energy and policy considerations for deep learning in NLP. Annual Meeting of the\nAssociation for Computational Linguistics.\n[3]\nKoomey, J., and Masanet, E., 2021. Does not compute: Avoiding pitfalls assessing the Internet's energy and\ncarbon impacts. Joule, 5(7), pp.1625-1628.\n[4]\nMasanet, E., et al., 2020. Recalibrating global datacenter energy-use estimates. Science, 367(6481).\n13 IT manufacturing for 2021 included 1700M cell phones, 340M PCs, and 12M data center servers.\n10\n\n[5]\nPatterson, D., et al., 2021. Carbon Emissions and Large Neural Network Training. arxiv:2104.10350.\n[6]\nThompson, N.C., et al., 2020. The computational limits of deep learning. arxiv:2007.05558.\n[7]\nFreitag, C., et al., 2021. The real climate and transformative impact of ICT: A critique of estimates, trends,\nand regulations. Patterns, 2(9).\n[8]\nSo, D.R., et al., 2019. The Evolved Transformer. International Conference on Machine Learning.\n[9]\nSo, D.R., et al., 2021. Primer: Searching for efficient transformers for language modeling. Conference on\nNeural Information Processing Systems.\n[10]\nJouppi, N., et al., 2021,Ten Lessons From Three Generations Shaped Google’s TPUv4i, International\nSymposium on Computer Architecture.\n[11]\nBrown, T.B., et al., 2020. Language models are few-shot learners. Conference on Neural Information\nProcessing Systems.\n[12]\nDu, N., et al., 2021. GLaM: Efficient Scaling of Language Models with Mixture-of-Experts.\narxiv:2112.06905.\n[13]\nEvans, B. 2021, Amazon Shocker: CEO Jassy Says Cloud Less than 5% of All IT Spending,\nhttps://cloudwars.co/amazon/amazon-shocker-ceo-jassy-cloud-less-than-5-percent-it-spending/\n[14]\nSchechner, S., 6/23/2021, Amazon and Other Tech Giants Race to Buy Up Renewable Energy, Wall Street\nJournal.\n[15]\nLi, S., et al., 2021 Searching for Fast Model Families on Datacenter Accelerators, Conference on Computer\nVision and Pattern Recognition.\n[16]\nPatterson, D., et al., 2022, Estimating ML Energy and Carbon Footprint in Smartphones, in preparation.\n[17]\nHenderson, P., et al., 2020. Towards the systematic reporting of the energy and carbon footprints of\nmachine learning. Journal of Machine Learning Research.\n[18]\nSchwartz, R., et al., 2020. Green AI. Communications of the ACM, 63(12).\n[19]\nLacoste, A., et al., 2019. Quantifying the carbon emissions of machine learning. arxiv:1910.09700.\n[20]\nBender, E.M., et al., 2021, On the Dangers of Stochastic Parrots: Can Language Models Be Too Big?. ACM\nConference on Fairness, Accountability, and Transparency.\nShort Author Bios\nDavid Patterson is a Distinguished Engineer in the Google Brain project in Mountain View, California,\n94043 USA, the vice-chair of the RISC-V Foundation's board of directors, Director of the RISC-V\nInternational Open Source Laboratory, and a professor emeritus at the University of California, Berkeley.\nHis research interests include domain-specific computer architectures and open instruction set\narchitectures. He has a PhD in computer science from the University of California, Los Angeles. Contact\nhim at pattrsn@berkeley.edu.\nJoseph Gonzalez is a professor of Computer Science at the University of California, Berkeley, California\n94720. His primary research interests are in the design of systems for machine learning as well as\nefficient neural architectures. He has worked on projects ranging from large-scale language modeling\nand efficient computer vision to the design of systems for graphical model inference, real-time prediction\nserving, and autonomous driving. He has a PhD in Machine Learning from Carnegie Mellon University.\nContact him at jegonzal@berkeley.edu.\nUrs Hölzle is the senior vice president of operations at Google and a Google Fellow. His interests include\nlarge scale clusters, cluster networking, Internet performance, and datacenter design. Hölzle received a\nPhD in computer science from Stanford University. Contact him at urs@gmail.com.\n11\n\nQuoc Le is a principal scientist at Google Brain. His research interests include AI, AutoML, natural\nlanguage understanding and computer vision. He has a PhD in Computer Science from Stanford\nUniversity and Bachelor at The Australian National University. Contact him at qvl@google.com\nChen Liang is a researcher in Google Brain. His works focus on the integration of machine learning and\nsymbolic representations. His research interests include automated machine learning (AutoML), neural\nsymbolic methods, natural language understanding and program synthesis. He has a PhD in Computer\nScience from Northwestern University and a B.S. in Physics from Peking University. Contact him at\ncrazydonkey200@gmail.com.\nLluis-Miquel Munguia is a Senior Software Engineer at Google, where he works on co-design for\ndeep-learning accelerators. His main research interests include the performance analysis of\nspecial-purpose computer architectures, power efficiency, and high performance computing. He has a\nPhD in computational science and engineering from the Georgia Institute of Technology. Contact him at\nllmunguia@google.com.\nDaniel Rothchild is a PhD student at the University of California, Berkeley advised by Joseph Gonzalez.\nResearch interests include distributed and federated learning, and machine learning for drug discovery\nand materials design. Contact him at drothchild@berkeley.edu.\nDavid R. So is a Senior Research Engineer in the Google Brain project. His research focuses on\nlanguage modeling, AutoML, and improving deep learning efficiency. Contact him at\ndavidso@google.com.\nMaud Texier is Head of Energy Development at Google. She leads a team responsible for developing and\nscaling 24/7 carbon-free energy for Google's data centers. Her research interests are in carbon\nabatements technologies, carbon-free energy technologies, grid systems modernization and\ndecarbonization. Maud holds an MS of engineering in Energy and Power systems from Ecole Centrale\nParis. Contact her at maudt@google.com.\nJeff Dean is Google Senior Fellow and the Senior Vice President of Research at Google, where he\nco-founded the Google Brain project, and has worked on a variety of machine learning and software\nsystems that underlie Google's products, many of which are open-sourced. His research interests include\nlarge-scale distributed systems, machine learning, applications of machine learning, information retrieval,\nmicroprocessor architecture, and compiler optimizations. He has a PhD in computer science from the\nUniversity of Washington. Contact him at jeff@google.com.\n12\n",
      "fetch_method": "direct-pdf"
    },
    {
      "arxiv_id": "https://r.jina.ai/https://llama.meta.com/docs/get-started/",
      "full_text": "Title: Docs & Resources | Llama AI\n\nURL Source: https://llama.meta.com/docs/get-started/\n\nMarkdown Content:\nDocs & Resources | Llama AI\n\n===============\n\n[Skip to main content](https://llama.meta.com/docs/get-started/#mdc-main-content)\n\n[![Image 5: Meta](https://static.xx.fbcdn.net/rsrc.php/y9/r/tL_v571NdZ0.svg)](https://llama.meta.com/)\n\nModels & Products\n\nDocs\n\nCommunity\n\nResources\n\n[Llama API](https://llama.developer.meta.com/join_waitlist)\n\n[Download models](https://llama.meta.com/llama-downloads/)\n\n### Table Of Contents\n\nOverview\n\n[Overview](https://llama.meta.com/docs/overview/)\n\n[Models](https://llama.meta.com/docs/model-cards-and-prompt-formats/)[Llama 4](https://llama.meta.com/docs/model-cards-and-prompt-formats/llama4/)[Llama Guard 4 (New)](https://llama.meta.com/docs/model-cards-and-prompt-formats/llama-guard-4/)[Llama 3.3](https://llama.meta.com/docs/model-cards-and-prompt-formats/llama3_3/)[Llama 3.2](https://llama.meta.com/docs/model-cards-and-prompt-formats/llama3_2/)[Llama 3.1](https://llama.meta.com/docs/model-cards-and-prompt-formats/llama3_1/)[Llama Guard 3](https://llama.meta.com/docs/model-cards-and-prompt-formats/llama-guard-3/)[Llama Prompt Guard 2 (New)](https://llama.meta.com/docs/model-cards-and-prompt-formats/prompt-guard/)[Other models](https://llama.meta.com/docs/model-cards-and-prompt-formats/other-models/)\n\n[Getting the Models](https://llama.meta.com/docs/getting_the_models/)[Meta](https://llama.meta.com/docs/getting_the_models/meta/)[Hugging Face](https://llama.meta.com/docs/getting-the-models/hugging-face/)[Kaggle](https://llama.meta.com/docs/getting-the-models/kaggle/)[1B/3B Partners](https://llama.meta.com/docs/getting-the-models/1b3b-partners/)[405B Partners](https://llama.meta.com/docs/getting-the-models/405b-partners/)\n\n[Running Llama](https://llama.meta.com/docs/llama-everywhere/)[Linux](https://llama.meta.com/docs/llama-everywhere/running-meta-llama-on-linux/)[Windows](https://llama.meta.com/docs/llama-everywhere/running-meta-llama-on-windows/)[Mac](https://llama.meta.com/docs/llama-everywhere/running-meta-llama-on-mac/)[Cloud](https://llama.meta.com/docs/llama-everywhere/running-meta-llama-in-the-cloud/)[Migration (New)](https://llama.meta.com/docs/llama-everywhere/migration/)[Deployment (New)](https://llama.meta.com/docs/llama-everywhere/deployment-patterns/)\n\n[How-To Guides](https://llama.meta.com/docs/how-to-guides/)[Fine-tuning](https://llama.meta.com/docs/how-to-guides/fine-tuning/)[Quantization (Updated)](https://llama.meta.com/docs/how-to-guides/quantization/)[Prompting](https://llama.meta.com/docs/how-to-guides/prompting/)[Validation](https://llama.meta.com/docs/how-to-guides/validation/)[Vision Capabilities](https://llama.meta.com/docs/how-to-guides/vision-capabilities/)[Responsible Use](https://llama.meta.com/docs/how-to-guides/responsible-use-guide-resources/)\n\n[Integration Guides](https://llama.meta.com/docs/integration-guides/)[LangChain](https://llama.meta.com/docs/integration-guides/langchain/)[Llamalndex](https://llama.meta.com/docs/integration-guides/llamaindex/)\n\n[Community Support](https://llama.meta.com/docs/community-support-and-resources/)[Resources](https://llama.meta.com/docs/community-support-and-resources/)\n\n* * *\n\n[Overview](https://llama.meta.com/docs/overview/)\n\n[Models](https://llama.meta.com/docs/model-cards-and-prompt-formats/)[Llama 4](https://llama.meta.com/docs/model-cards-and-prompt-formats/llama4/)[Llama Guard 4 (New)](https://llama.meta.com/docs/model-cards-and-prompt-formats/llama-guard-4/)[Llama 3.3](https://llama.meta.com/docs/model-cards-and-prompt-formats/llama3_3/)[Llama 3.2](https://llama.meta.com/docs/model-cards-and-prompt-formats/llama3_2/)[Llama 3.1](https://llama.meta.com/docs/model-cards-and-prompt-formats/llama3_1/)[Llama Guard 3](https://llama.meta.com/docs/model-cards-and-prompt-formats/llama-guard-3/)[Llama Prompt Guard 2 (New)](https://llama.meta.com/docs/model-cards-and-prompt-formats/prompt-guard/)[Other models](https://llama.meta.com/docs/model-cards-and-prompt-formats/other-models/)\n\n[Getting the Models](https://llama.meta.com/docs/getting_the_models/)[Meta](https://llama.meta.com/docs/getting_the_models/meta/)[Hugging Face](https://llama.meta.com/docs/getting-the-models/hugging-face/)[Kaggle](https://llama.meta.com/docs/getting-the-models/kaggle/)[1B/3B Partners](https://llama.meta.com/docs/getting-the-models/1b3b-partners/)[405B Partners](https://llama.meta.com/docs/getting-the-models/405b-partners/)\n\n[Running Llama](https://llama.meta.com/docs/llama-everywhere/)[Linux](https://llama.meta.com/docs/llama-everywhere/running-meta-llama-on-linux/)[Windows](https://llama.meta.com/docs/llama-everywhere/running-meta-llama-on-windows/)[Mac](https://llama.meta.com/docs/llama-everywhere/running-meta-llama-on-mac/)[Cloud](https://llama.meta.com/docs/llama-everywhere/running-meta-llama-in-the-cloud/)[Migration (New)](https://llama.meta.com/docs/llama-everywhere/migration/)[Deployment (New)](https://llama.meta.com/docs/llama-everywhere/deployment-patterns/)\n\n[How-To Guides](https://llama.meta.com/docs/how-to-guides/)[Fine-tuning](https://llama.meta.com/docs/how-to-guides/fine-tuning/)[Quantization (Updated)](https://llama.meta.com/docs/how-to-guides/quantization/)[Prompting](https://llama.meta.com/docs/how-to-guides/prompting/)[Validation](https://llama.meta.com/docs/how-to-guides/validation/)[Vision Capabilities](https://llama.meta.com/docs/how-to-guides/vision-capabilities/)[Responsible Use](https://llama.meta.com/docs/how-to-guides/responsible-use-guide-resources/)\n\n[Integration Guides](https://llama.meta.com/docs/integration-guides/)[LangChain](https://llama.meta.com/docs/integration-guides/langchain/)[Llamalndex](https://llama.meta.com/docs/integration-guides/llamaindex/)\n\n[Community Support](https://llama.meta.com/docs/community-support-and-resources/)[Resources](https://llama.meta.com/docs/community-support-and-resources/)\n\nDocumentation\n\nGet started with Llama\n======================\n\nThis guide provides information and resources to help you set up Llama including how to access the model, hosting, how-to and integration guides. Additionally, you will find supplemental materials to further assist you while building with Llama.\n\nWhat's new:\n-----------\n\n**Llama 4 Scout**\n\nNatively multimodal model that offers single H100 GPU efficiency and a 10M context window \n\n[_Learn more_](https://llama.meta.com/docs/model-cards-and-prompt-formats/llama4_omni)\n\n**Llama 4 Maverick**\n\nNatively multimodal model for image and text understanding and fast responses at a low cost\n\n[_Learn more_](https://llama.meta.com/docs/model-cards-and-prompt-formats/llama4_omni)\n\n**Llama Guard 4\n\nLlama Prompt Guard 2**\n\nUpdated protection models with higher performance and support for Llama 4\n\n[_Learn more_](https://www.llama.com/docs/model-cards-and-prompt-formats/llama-guard-4/)\n\nGet the models\n--------------\n\nYou can obtain the models directly from Meta or from one of our partners, [Hugging Face](https://huggingface.co/meta-llama), [Kaggle](https://www.kaggle.com/organizations/metaresearch/models) or from our [1B/3B](https://llama.meta.com/docs/getting-the-models/1b3b-partners/) or [405B](https://llama.meta.com/docs/getting-the-models/405b-partners/) ecosystem partners. \n\n[Download the models](https://llama.meta.com/llama-downloads/?utm_source=llama-overview&utm_medium=llama-referral&utm_campaign=llama-utm&utm_offering=llama-download&utm_product=llama)\n\n* * *\n\n### Llama 4 Scout\n\nNatively multimodal model that offers single H100 GPU efficiency and a 10M context window\n\n#### Model Card\n\nModel attributes in easy to consume, standard format.\n\n[See Card on GitHub](https://github.com/meta-llama/llama-models/blob/main/models/llama4/MODEL_CARD.md)\n\n#### Prompt Format\n\nHow to construct effective prompts.\n\n[Get Prompt Guidance](https://llama.meta.com/docs/model-cards-and-prompt-formats/llama4_omni/)\n\n#### Get the Model\n\n[![Image 6: Meta logo](https://lookaside.fbsbx.com/elementpath/media/?media_id=713120110906146&version=1745894340&transcode_extension=webp)Meta![Image 7: Arrow icon](https://lookaside.fbsbx.com/elementpath/media/?media_id=1516407255613247&version=1756816550&transcode_extension=webp)](https://llama.meta.com/llama-downloads/)\n\n[![Image 8: Hugging Face logo](https://lookaside.fbsbx.com/elementpath/media/?media_id=415443844816742&version=1745894340&transcode_extension=webp)Hugging Face![Image 9: Arrow icon](https://lookaside.fbsbx.com/elementpath/media/?media_id=1516407255613247&version=1756816550&transcode_extension=webp)](https://huggingface.co/meta-llama)\n\n### Llama 4 Maverick\n\nNatively multimodal model for image and text understanding and fast responses at a low cost\n\n#### Model Card\n\nModel attributes in easy to consume, standard format\n\n[See Card on GitHub](https://github.com/meta-llama/llama-models/blob/main/models/llama4/MODEL_CARD.md)\n\n#### Prompt Format\n\nHow to construct effective prompts.\n\n[Get Prompt Guidance](https://llama.meta.com/docs/model-cards-and-prompt-formats/llama4_omni/)\n\n#### Get the Model\n\n[![Image 10: Meta logo](https://lookaside.fbsbx.com/elementpath/media/?media_id=713120110906146&version=1745894340&transcode_extension=webp)Meta![Image 11: Arrow icon](https://lookaside.fbsbx.com/elementpath/media/?media_id=1516407255613247&version=1756816550&transcode_extension=webp)](https://llama.meta.com/llama-downloads/)\n\n[![Image 12: Hugging Face logo](https://lookaside.fbsbx.com/elementpath/media/?media_id=415443844816742&version=1745894340&transcode_extension=webp)Hugging Face![Image 13: Arrow icon](https://lookaside.fbsbx.com/elementpath/media/?media_id=1516407255613247&version=1756816550&transcode_extension=webp)](https://huggingface.co/meta-llama)\n\n### Llama Guard 4 (New)\n\nUpdated protection models with higher performance and support for Llama 4\n\n#### Model Card\n\nModel attributes in easy to consume, standard format.\n\n[See Card on GitHub](https://github.com/meta-llama/PurpleLlama/blob/main/Llama-Guard4/12B/MODEL_CARD.md)\n\n#### Prompt Format\n\nHow to construct effective prompts.\n\n[Get Prompt Guidance](https://llama.meta.com/docs/model-cards-and-prompt-formats/llama-guard-4/)\n\n#### Get the Model\n\n[![Image 14: Meta logo](https://lookaside.fbsbx.com/elementpath/media/?media_id=713120110906146&version=1745894340&transcode_extension=webp)Meta![Image 15: Arrow icon](https://lookaside.fbsbx.com/elementpath/media/?media_id=1516407255613247&version=1756816550&transcode_extension=webp)](https://llama.meta.com/llama-downloads/)\n\n[![Image 16: Hugging Face logo](https://lookaside.fbsbx.com/elementpath/media/?media_id=415443844816742&version=1745894340&transcode_extension=webp)Hugging Face![Image 17: Arrow icon](https://lookaside.fbsbx.com/elementpath/media/?media_id=1516407255613247&version=1756816550&transcode_extension=webp)](https://huggingface.co/meta-llama)\n\n[All models](https://llama.meta.com/docs/model-cards-and-prompt-formats/)\n\nFind us on GitHub\n-----------------\n\n![Image 18: A black letter O with a white background](https://lookaside.fbsbx.com/elementpath/media/?media_id=1141246920260352&version=1745894340&transcode_extension=webp)\n\nLlama Cookbook\n--------------\n\nNotebooks and demos for learning Llama. Scripts for fine-tuning Llama3 with single/multi-node GPUs.\n\n[Learn more](https://github.com/meta-llama/llama-cookbook)\n\n![Image 19: A black letter O with a white background](https://lookaside.fbsbx.com/elementpath/media/?media_id=1207075900499699&version=1745894340&transcode_extension=webp)\n\nLlama Stack\n-----------\n\nDefines and standardizes the building blocks needed to bring generative AI applications to market.\n\n[Learn more](https://github.com/meta-llama/llama-stack)\n\nExplore the new capabilities of Llama 3.2\n-----------------------------------------\n\nThe Llama 3.2 lightweight models enable Llama to run on phones, tablets, and edge devices. View the video to see Llama running on phone. To see how this demo was implemented, check out [**the example code**](https://github.com/pytorch/executorch/blob/main/examples/demo-apps/android/LlamaDemo/docs/delegates/xnnpack_README.md) from ExecuTorch.\n\n[Learn more](https://www.llama.com/docs/model-cards-and-prompt-formats/llama3_2#-llama-3.2-lightweight-models-(1b/3b)-)\n\n* * *\n\nOther topics in this Guide\n--------------------------\n\nTo discover more about what's possible with the Llama family of models, explore the topics below.\n\n![Image 20: placeholder-image](https://lookaside.fbsbx.com/elementpath/media/?media_id=439065215623582&version=1745894340&transcode_extension=webp)\n### Llama Everywhere\n\nNotebooks and information on how to run Llama on your local hardware or in the cloud.[Learn more](https://llama.meta.com/docs/llama-everywhere/)\n\n![Image 21: placeholder-image](https://lookaside.fbsbx.com/elementpath/media/?media_id=1432889504083181&version=1745894340&transcode_extension=webp)\n### How-To Guides\n\nAn overview of the processes for developing any LLM: fine-tuning, prompt engineering, and model validation.[Learn more](https://llama.meta.com/docs/how-to-guides/)\n\n![Image 22: placeholder-image](https://lookaside.fbsbx.com/elementpath/media/?media_id=1000771695131808&version=1745894340&transcode_extension=webp)\n### Integration Guides\n\nDevelop solutions based on Code Llama, LangChain, and LlamaIndex.[Learn more](https://llama.meta.com/docs/integration-guides/)\n\n![Image 23: placeholder-image](https://lookaside.fbsbx.com/elementpath/media/?media_id=3595223014074409&version=1745894340&transcode_extension=webp)\n### Community Support\n\nCompilation of resources available from the community.[Learn more](https://llama.meta.com/docs/community-support-and-resources/)\n\n* * *\n\n![Image 24: Meta](https://static.xx.fbcdn.net/rsrc.php/y9/r/tL_v571NdZ0.svg)\n\n[![Image 25: Facebook](https://scontent-sof1-1.xx.fbcdn.net/v/t39.2365-6/301846186_1133977354136753_4449523448606696437_n.svg?_nc_cat=104&ccb=1-7&_nc_sid=aa6a2f&_nc_ohc=1_ipXivXGxEQ7kNvwF1ALjt&_nc_oc=AdkEJlIDe1dKOtWKCzNrQwN0eyW9HlBlksu-u5duHWk9Bdrbnp0nc92MuPctBNeoqh09rf28tnsUjK4cG1akJqWT&_nc_zt=14&_nc_ht=scontent-sof1-1.xx&_nc_gid=woHMXMj7I05nmDxFgeWbgg&oh=00_AfYxnWksfvM37E9cnVH5CV2t54EmRbDfH3N4zCCeLw_Scg&oe=68CB0BC3)](https://www.facebook.com/AIatMeta/)[![Image 26: X](https://scontent-sof1-1.xx.fbcdn.net/v/t39.2365-6/467665288_1952116298626027_4990190601706024947_n.svg?_nc_cat=106&ccb=1-7&_nc_sid=aa6a2f&_nc_ohc=9qxGaFnoM5AQ7kNvwEK7XhX&_nc_oc=AdmLRn1yM5_4gGeO0FKg4vFjrIzSxgli93tTB7qzGDWLpZ3RlFgPKmFlGTtzMfP3pHYLaCefa5s-S7V5Ma-AyN4d&_nc_zt=14&_nc_ht=scontent-sof1-1.xx&_nc_gid=woHMXMj7I05nmDxFgeWbgg&oh=00_AfaXGrGAKzhJuzPaBnmnPhU0jr7Yp5bXPDKGaZXmutgCtA&oe=68CAFA2A)](https://twitter.com/aiatmeta/)[![Image 27: YouTube](https://scontent-sof1-1.xx.fbcdn.net/v/t39.2365-6/301448763_775186710293873_8271592194986836260_n.svg?_nc_cat=102&ccb=1-7&_nc_sid=aa6a2f&_nc_ohc=kMxx90KXJSEQ7kNvwHFk4Y4&_nc_oc=Adm8MZfhex1BKlPGN8v3b-pboJrzYc2-J9jsVRI8staHiiFDjAidq6CQYS63t38jd5_jynMXmoixJgCK84VbGrb5&_nc_zt=14&_nc_ht=scontent-sof1-1.xx&_nc_gid=woHMXMj7I05nmDxFgeWbgg&oh=00_Afbh9__htz_n4PmTzrzahj2ePVLEIcYoxZehQmcuHNgfMw&oe=68CAFCA7)](https://www.youtube.com/@aiatmeta)[![Image 28: LinkedIn](https://scontent-sof1-2.xx.fbcdn.net/v/t39.2365-6/467689750_1684384502343829_7561568713040200172_n.svg?_nc_cat=103&ccb=1-7&_nc_sid=aa6a2f&_nc_ohc=jxripiNl15AQ7kNvwHaP8rX&_nc_oc=AdnHT01KXk691MLKSwr0_PJmNxc0xny3ywCEBhn0PQGWnbx_VX2aBhJAURpDO0DqzTb7P-eCuSGpZopKdXIKzVhC&_nc_zt=14&_nc_ht=scontent-sof1-2.xx&_nc_gid=woHMXMj7I05nmDxFgeWbgg&oh=00_AfYHLqIXrAWDcazRc7JkdyKK7Xj6EeGExH8IQUDwySm9Cg&oe=68CAEB7E)](https://www.linkedin.com/showcase/aiatmeta)\n\nDocumentation\n\n[Overview](https://llama.meta.com/docs/overview/)[Models](https://llama.meta.com/docs/model-cards-and-prompt-formats/)[Getting the Models](https://llama.meta.com/docs/getting_the_models/)[Running Llama](https://llama.meta.com/docs/llama-everywhere/)[How-To Guides](https://llama.meta.com/docs/how-to-guides/)[Integration Guides](https://llama.meta.com/docs/integration-guides/)[Community Support](https://llama.meta.com/docs/community-support-and-resources/)\n\n* * *\n\nCommunity\n\n[Community Stories](https://llama.meta.com/community-stories/)[Open Innovation AI Research Community](https://llama.meta.com/open-innovation-ai-research-community/)[Llama Impact Grants](https://llama.meta.com/llama-ai-innovation/)\n\n* * *\n\nResources\n\n[Cookbook](https://llama.meta.com/resources/cookbook/)[Case studies](https://llama.meta.com/resources/case-studies/)[Videos](https://llama.meta.com/resources/videos/)[AI at Meta Blog](https://ai.meta.com/blog/)[Meta Newsroom](https://about.fb.com/news/)[FAQ](https://llama.meta.com/faq/)[Privacy Policy](https://www.facebook.com/privacy/policy/)[Terms](https://www.facebook.com/policies_center/)[Cookies](https://www.facebook.com/privacy/policies/cookies/?entry_point=cookie_policy_redirect&entry=0)\n\n* * *\n\nLlama Protections\n\n[Overview](https://llama.meta.com/llama-protections/)[Llama Defenders Program](https://llama.meta.com/llama-protections/ai-defenders/)[Developer Use Guide](https://llama.meta.com/developer-use-guide/)\n\n* * *\n\nDocumentation\n\n[Overview](https://llama.meta.com/docs/overview/)\n\n[Models](https://llama.meta.com/docs/model-cards-and-prompt-formats/)\n\n[Getting the Models](https://llama.meta.com/docs/getting_the_models/)\n\n[Running Llama](https://llama.meta.com/docs/llama-everywhere/)\n\n[How-To Guides](https://llama.meta.com/docs/how-to-guides/)\n\n[Integration Guides](https://llama.meta.com/docs/integration-guides/)\n\n[Community Support](https://llama.meta.com/docs/community-support-and-resources/)\n\nCommunity\n\n[Community Stories](https://llama.meta.com/community-stories/)\n\n[Open Innovation AI Research Community](https://llama.meta.com/open-innovation-ai-research-community/)\n\n[Llama Impact Grants](https://llama.meta.com/llama-ai-innovation/)\n\nResources\n\n[Cookbook](https://llama.meta.com/resources/cookbook/)\n\n[Case studies](https://llama.meta.com/resources/case-studies/)\n\n[Videos](https://llama.meta.com/resources/videos/)\n\n[AI at Meta Blog](https://ai.meta.com/blog/)\n\n[Meta Newsroom](https://about.fb.com/news/)\n\n[FAQ](https://llama.meta.com/faq/)\n\n[Privacy Policy](https://www.facebook.com/privacy/policy/)\n\n[Terms](https://www.facebook.com/policies_center/)\n\n[Cookies](https://www.facebook.com/privacy/policies/cookies/?entry_point=cookie_policy_redirect&entry=0)\n\nLlama Protections\n\n[Overview](https://llama.meta.com/llama-protections/)\n\n[Llama Defenders Program](https://llama.meta.com/llama-protections/ai-defenders/)\n\n[Developer Use Guide](https://llama.meta.com/developer-use-guide/)\n\nDocumentation\n\n[Overview](https://llama.meta.com/docs/overview/)\n\n[Models](https://llama.meta.com/docs/model-cards-and-prompt-formats/)\n\n[Getting the Models](https://llama.meta.com/docs/getting_the_models/)\n\n[Running Llama](https://llama.meta.com/docs/llama-everywhere/)\n\n[How-To Guides](https://llama.meta.com/docs/how-to-guides/)\n\n[Integration Guides](https://llama.meta.com/docs/integration-guides/)\n\n[Community Support](https://llama.meta.com/docs/community-support-and-resources/)\n\nCommunity\n\n[Community Stories](https://llama.meta.com/community-stories/)\n\n[Open Innovation AI Research Community](https://llama.meta.com/open-innovation-ai-research-community/)\n\n[Llama Impact Grants](https://llama.meta.com/llama-ai-innovation/)\n\nResources\n\n[Cookbook](https://llama.meta.com/resources/cookbook/)\n\n[Case studies](https://llama.meta.com/resources/case-studies/)\n\n[Videos](https://llama.meta.com/resources/videos/)\n\n[AI at Meta Blog](https://ai.meta.com/blog/)\n\n[Meta Newsroom](https://about.fb.com/news/)\n\n[FAQ](https://llama.meta.com/faq/)\n\n[Privacy Policy](https://www.facebook.com/privacy/policy/)\n\n[Terms](https://www.facebook.com/policies_center/)\n\n[Cookies](https://www.facebook.com/privacy/policies/cookies/?entry_point=cookie_policy_redirect&entry=0)\n\nLlama Protections\n\n[Overview](https://llama.meta.com/llama-protections/)\n\n[Llama Defenders Program](https://llama.meta.com/llama-protections/ai-defenders/)\n\n[Developer Use Guide](https://llama.meta.com/developer-use-guide/)\n\nDocumentation\n\n[Overview](https://llama.meta.com/docs/overview/)\n\n[Models](https://llama.meta.com/docs/model-cards-and-prompt-formats/)\n\n[Getting the Models](https://llama.meta.com/docs/getting_the_models/)\n\n[Running Llama](https://llama.meta.com/docs/llama-everywhere/)\n\n[How-To Guides](https://llama.meta.com/docs/how-to-guides/)\n\n[Integration Guides](https://llama.meta.com/docs/integration-guides/)\n\n[Community Support](https://llama.meta.com/docs/community-support-and-resources/)\n\nCommunity\n\n[Community Stories](https://llama.meta.com/community-stories/)\n\n[Open Innovation AI Research Community](https://llama.meta.com/open-innovation-ai-research-community/)\n\n[Llama Impact Grants](https://llama.meta.com/llama-ai-innovation/)\n\nResources\n\n[Cookbook](https://llama.meta.com/resources/cookbook/)\n\n[Case studies](https://llama.meta.com/resources/case-studies/)\n\n[Videos](https://llama.meta.com/resources/videos/)\n\n[AI at Meta Blog](https://ai.meta.com/blog/)\n\n[Meta Newsroom](https://about.fb.com/news/)\n\n[FAQ](https://llama.meta.com/faq/)\n\n[Privacy Policy](https://www.facebook.com/privacy/policy/)\n\n[Terms](https://www.facebook.com/policies_center/)\n\n[Cookies](https://www.facebook.com/privacy/policies/cookies/?entry_point=cookie_policy_redirect&entry=0)\n\nLlama Protections\n\n[Overview](https://llama.meta.com/llama-protections/)\n\n[Llama Defenders Program](https://llama.meta.com/llama-protections/ai-defenders/)\n\n[Developer Use Guide](https://llama.meta.com/developer-use-guide/)\n",
      "fetch_method": "jina-reader"
    },
    {
      "arxiv_id": "https://r.jina.ai/https://ai.meta.com/blog/",
      "full_text": "Title: AI at Meta Blog\n\nURL Source: https://ai.meta.com/blog/\n\nMarkdown Content:\nAI at Meta Blog\n\n===============\n\n[](https://ai.meta.com/blog/# \"Go up one level\")[![Image 10: Meta](https://scontent-sof1-1.xx.fbcdn.net/v/t39.8562-6/252294889_575082167077436_6034106545912333281_n.svg/meta-logo-primary_standardsize.svg?_nc_cat=108&ccb=1-7&_nc_sid=e280be&_nc_ohc=3pKBrH2lZYkQ7kNvwElWNUN&_nc_oc=Adnun0-RKuQh9kOgGsBzmNZcesiOWPIlzQW2v1OXEBAzTeAiB1RqTk0eDPMwKshEA17Q91YoJI_x1Sdge_YUr291&_nc_zt=14&_nc_ht=scontent-sof1-1.xx&_nc_gid=Z99Bt6X0bExGEh4ifn4Gmg&oh=00_AfakDOiE3iGBtjYGnnpz9Cs6Yc7vs95ur1C_TvtBmbXhrQ&oe=68CB1EB9)](https://ai.meta.com/)\n*   [Meta AI](https://ai.meta.com/blog/#) \n*   [AI Research](https://ai.meta.com/blog/#) \n*   [The Latest](https://ai.meta.com/blog/) \n*   [About](https://ai.meta.com/blog/#) \n*   [Get Llama](https://www.llama.com/?utm_source=ai_meta_site&utm_medium=web&utm_content=AI_nav&utm_campaign=09052025_moment) \n\n*   [Try Meta AI](https://www.meta.ai/?utm_source=ai_meta_site&utm_medium=web&utm_content=AI_nav&utm_campaign=09052025_moment)\n*   [](https://ai.meta.com/blog/# \"Toggle site search\") \n\n[](https://ai.meta.com/blog/# \"Close submenu\")[](https://ai.meta.com/blog/# \"Main menu\")\n\n[BACK](https://ai.meta.com/blog/# \"Go up one level\")\n\n*   [Explore Meta AI](https://ai.meta.com/meta-ai/)\n*   [Get Meta AI](https://ai.meta.com/get-meta-ai/)\n*   [Meta AI Studio](https://ai.meta.com/ai-studio/)\n\n*   [Overview](https://ai.meta.com/research/)\n*   [Projects](https://ai.meta.com/research/#projects)\n*   [Research Areas](https://ai.meta.com/research/#research-areas)\n*   [People](https://ai.meta.com/results/?content_types[0]=person)\n\n*   [Overview](https://ai.meta.com/meta-ai/)\n*   [Open Source](https://ai.meta.com/opensourceai/)\n*   [Careers](https://www.metacareers.com/)\n\nClear\n\n*   Clear   \n*   [Meta AI >](https://ai.meta.com/blog/#) \n*   [AI Research >](https://ai.meta.com/blog/#) \n*   [The Latest](https://ai.meta.com/blog/)\n*   [About >](https://ai.meta.com/blog/#) \n*   [Get Llama](https://www.llama.com/?utm_source=ai_meta_site&utm_medium=web&utm_content=AI_nav&utm_campaign=09052025_moment)\n\n[Try Meta AI](https://www.meta.ai/?utm_source=ai_meta_site&utm_medium=web&utm_content=AI_nav&utm_campaign=09052025_moment)\n\nThe latest AI news from Meta\n\n[FEATURED ![Image 11](https://scontent-sof1-1.xx.fbcdn.net/v/t39.2365-6/531962783_1221397443074543_4195342750351180590_n.gif?_nc_cat=108&ccb=1-7&_nc_sid=e280be&_nc_ohc=qRGiITM5CCMQ7kNvwF0ogg1&_nc_oc=Adks-d2PHWVR3P68cWv9VNcCtKt-u4q2hDPfvff-GVf-QduAdQIfGwzhGCnsglI1enyESuCIWel8FXzhHImaBPd7&_nc_zt=14&_nc_ht=scontent-sof1-1.xx&_nc_gid=Z99Bt6X0bExGEh4ifn4Gmg&oh=00_AfY6R1sNwfyqygagl4K7MAmOenrDjdzY5Rz8vi-kGODQzg&oe=68DF65A9)](https://ai.meta.com/blog/dinov3-self-supervised-vision-model/)\n\nOpen Source\n\n[DINOv3: Self-supervised learning for vision at unprecedented scale](https://ai.meta.com/blog/dinov3-self-supervised-vision-model/)\n\nDINOv3 scales self-supervised learning for images to create universal vision backbones that achieve absolute state-of-the-art performance across diverse domains, including web and satellite imagery.\n\nAugust 14, 2025\n\nLatest News\n\n[![Image 12](https://scontent-sof1-1.xx.fbcdn.net/v/t39.2365-6/532059419_1159626692796432_4760051607316339037_n.png?_nc_cat=101&ccb=1-7&_nc_sid=e280be&_nc_ohc=mYq2YH0wvNIQ7kNvwGvWDuD&_nc_oc=AdlHixUkhkLALnFmji74E2P9Zz_UCCSVMjQy4ASwdEUwm5b6g25YEAFcztHGMh5jOxkSRxm4Yikj3hy2gtXmuz2X&_nc_zt=14&_nc_ht=scontent-sof1-1.xx&_nc_gid=Z99Bt6X0bExGEh4ifn4Gmg&oh=00_AfYWKGOfmHidt3aNy4tlmlSwHJb41b0n-FTV1ki_D1vVIw&oe=68DF7093)](https://ai.meta.com/blog/llama-oracle-help-students-in-brazil/)\n\nOpen Source\n\n[How Llama and Oracle are helping Instituto PROA kickstart careers for students in Brazil](https://ai.meta.com/blog/llama-oracle-help-students-in-brazil/)\n\nAug 27, 2025\n\n[![Image 13](https://scontent-sof1-1.xx.fbcdn.net/v/t39.2365-6/527921411_2457172288013343_1323178884043439975_n.png?_nc_cat=102&ccb=1-7&_nc_sid=e280be&_nc_ohc=38puafVPde8Q7kNvwFQwQl6&_nc_oc=AdmPSS2A8ZlnXEjPw4l1asfHFOWrWNENHjWSLpQsqNkgBYOYmefNS4XEqXymUzr_ViiTf0i5XG2CTf66OQPnAe84&_nc_zt=14&_nc_ht=scontent-sof1-1.xx&_nc_gid=Z99Bt6X0bExGEh4ifn4Gmg&oh=00_AfYwwws59sO4fuBUCXJFAtVUFSUdtMNyP5MNddlb-71uRw&oe=68DF7E85)](https://ai.meta.com/blog/nasa-jpl-dino-robot-explorers/)\n\nOpen Source\n\n[Small robots, mighty vision: NASA Jet Propulsion Laboratory's DINOv2-enabled robot rovers and the future of planetary exploration](https://ai.meta.com/blog/nasa-jpl-dino-robot-explorers/)\n\nAug 14, 2025\n\n[![Image 14](https://scontent-sof1-1.xx.fbcdn.net/v/t39.2365-6/532553566_774197078627099_5292500968323138459_n.png?_nc_cat=102&ccb=1-7&_nc_sid=e280be&_nc_ohc=dcc6UtrnoDkQ7kNvwHaxubd&_nc_oc=AdnNS2_mP1LOSaq0IHEUF1FizhjiGiuRDdr0R97QoAjhAuBr_zmq5p72JGrxknnOLpHvXu4UV-IxXBWGY48xc_YF&_nc_zt=14&_nc_ht=scontent-sof1-1.xx&_nc_gid=Z99Bt6X0bExGEh4ifn4Gmg&oh=00_AfbESK-7s24iORXXXOOeb-2SR0_B_d3NUkR0jaEVQbUXAQ&oe=68DF81B5)](https://ai.meta.com/blog/world-resources-institute-dinov3/)\n\nOpen Source\n\n[How DINOv3 is helping World Resources Institute restore forests and farms globally](https://ai.meta.com/blog/world-resources-institute-dinov3/)\n\nAug 14, 2025\n\n[![Image 15](https://scontent-sof1-2.xx.fbcdn.net/v/t39.2365-6/528410853_4083892945184275_6100634806326674200_n.jpg?_nc_cat=110&ccb=1-7&_nc_sid=e280be&_nc_ohc=s6bB5MrmA7gQ7kNvwEc1w4f&_nc_oc=Adlq0mjLZhq1_-b1AyslIqk7Jt31ADym5PRCSTrad9QfTEJjf6lERX1Lo1B9P3XTb1n_4fRFGZpSAykJ8QAPjWB9&_nc_zt=14&_nc_ht=scontent-sof1-2.xx&_nc_gid=Z99Bt6X0bExGEh4ifn4Gmg&oh=00_AfZn3mpsBt9AOwZJgK_-jNf4G4zaQLDV3tCsIv6Aqmj3rg&oe=68DF72F7)](https://ai.meta.com/blog/llama-helps-biofy-fight-antibiotic-resistance/)\n\nOpen Source\n\n[How Llama helps Biofy Technologies in the fight against antibiotic resistance](https://ai.meta.com/blog/llama-helps-biofy-fight-antibiotic-resistance/)\n\nAug 7, 2025\n\n* * *\n\nMore from AI at Meta\n\nFilter:\n\nAll\n\nFeatured\n\n ML applications\n\n Open source\n\n Research\n\n Computer vision\n\n Hardware\n\n Natural language processing\n\n Speech & Audio\n\n* * *\n\n[![Image 16](https://scontent-sof1-1.xx.fbcdn.net/v/t39.2365-6/525911517_763583199523319_1148911740457961155_n.png?_nc_cat=108&ccb=1-7&_nc_sid=e280be&_nc_ohc=Sz9nhUmh_E4Q7kNvwH_dhbK&_nc_oc=Adl8xUDE-xQ2tdJhdojweJndrJv6H25R4KV3nXyH8qHEjIQYDdNoLE3_wwI4FBrSJvvNM-MX8CiYyuFtTbtCser6&_nc_zt=14&_nc_ht=scontent-sof1-1.xx&_nc_gid=0iUylkE0C25xzrTT0hPG2A&oh=00_AfbSH7NdY1VqQhgRp8IUf5cND8PmzF6zybdF-Ww4kosu_g&oe=68DF7ED8)](https://ai.meta.com/blog/upwork-helps-freelancers-with-llama/)\n\nOpen Source\n\n[How Upwork helps freelancers win more work with Llama](https://ai.meta.com/blog/upwork-helps-freelancers-with-llama/)\n\nUpwork, one of the world’s largest work marketplaces, is using Llama to power Uma, its mindful AI, to help freelancers land jobs faster and more confidently.\n\nJuly 31, 2025\n\n[![Image 17](https://scontent-sof1-1.xx.fbcdn.net/v/t39.2365-6/519420961_903925431933844_6571497333803218581_n.png?_nc_cat=100&ccb=1-7&_nc_sid=e280be&_nc_ohc=XBgADLXnu3QQ7kNvwHmaDre&_nc_oc=AdlKvwhrYi0iOGMem1I_4761-0lZUMV-CWbk4-us8Onn2gyZnMr-u0cYqJqxEKiM0iT-R-oq5CeAf97zW2tCsgKB&_nc_zt=14&_nc_ht=scontent-sof1-1.xx&_nc_gid=0iUylkE0C25xzrTT0hPG2A&oh=00_AfZTypLsdVn7OA5quGqyK5yoiLq1kC8Z72Sao34i3LuZEw&oe=68DF6485)](https://ai.meta.com/blog/aws-program-startups-build-with-llama/)\n\nOpen Source\n\n[Joining forces with AWS on a new program to help startups build with Llama](https://ai.meta.com/blog/aws-program-startups-build-with-llama/)\n\nWe're joining forces with Amazon Web Services to announce a new program that will provide resources and support to 30 promising startups in the U.S. that are building with Llama.\n\nJuly 21, 2025\n\n[![Image 18](https://scontent-sof1-1.xx.fbcdn.net/v/t39.2365-6/513299632_1777929793108543_6083053408152212084_n.gif?_nc_cat=105&ccb=1-7&_nc_sid=e280be&_nc_ohc=diX6T3JpjRcQ7kNvwGENjo4&_nc_oc=AdnTL3SuNGU9iGsEEJE9oEGhP1EMkKAv_Rmg-oERS-o7vd-j3vUYqywkaZSWBaprWA5mHZWuJi_bQIw7qglRJZiK&_nc_zt=14&_nc_ht=scontent-sof1-1.xx&_nc_gid=0iUylkE0C25xzrTT0hPG2A&oh=00_AfYexYkZz4yL6BY7cAtcCWpX2FpqZih3AYVxSg1LjxeTGw&oe=68DF7980)](https://ai.meta.com/blog/seamless-interaction-natural-conversational-dynamics/)\n\nOpen Source\n\n[Modeling natural conversational dynamics with Seamless Interaction](https://ai.meta.com/blog/seamless-interaction-natural-conversational-dynamics/)\nJune 27, 2025\n\n[![Image 19](https://scontent-sof1-2.xx.fbcdn.net/v/t39.2365-6/506435837_623618166663466_4115418445989642949_n.jpg?_nc_cat=103&ccb=1-7&_nc_sid=e280be&_nc_ohc=1hWBoEs8O5sQ7kNvwEGLFvB&_nc_oc=AdlP4sL8AzdD6zwNe1He6Bz1NqEq4OCtwijJEaqV6IlSVKIiGLY5ML3orXS_lfPaoHmA3xzcwSz8cV6Q5C7nkMuL&_nc_zt=14&_nc_ht=scontent-sof1-2.xx&_nc_gid=0iUylkE0C25xzrTT0hPG2A&oh=00_Afbmt9AwCNEjV2E1NY-oidDXwXWMJeqmLi9xsEGGmiiFlQ&oe=68DF6904)](https://ai.meta.com/blog/llama-helps-efficiency-anz-bank/)\n\nOpen Source\n\n[How Llama helps drive engineering efficiency at a major Australian bank](https://ai.meta.com/blog/llama-helps-efficiency-anz-bank/)\n\nANZ, one of Australia's Big Four banks, is driving engineering efficiency with Llama.\n\nJune 18, 2025\n\n* * *\n\nLoad more\n\nGet the latest from AI at Meta in your inbox\n\n[Sign up](https://ai.meta.com/subscribe/)\n\n[Our approach](https://ai.meta.com/about)\n\n[About AI at Meta](https://ai.meta.com/about)\n\n[People](https://ai.meta.com/results/?content_types%5B0%5D=person&sort_by=random)\n\n[Careers](https://www.metacareers.com/jobs/?is_leadership=0&sub_teams[0]=Artificial%20Intelligence&is_in_page=0)\n\n[Research](https://ai.meta.com/research)\n\n[Infrastructure](https://ai.meta.com/infrastructure)\n\n[Resources](https://ai.meta.com/resources)\n\n[Demos](https://aidemos.meta.com/)\n\n[Meta AI](https://ai.meta.com/meta-ai/)\n\n[Explore Meta AI](https://ai.meta.com/meta-ai/)\n\n[Get Meta AI](https://ai.meta.com/get-meta-ai/)\n\n[AI Studio](https://ai.meta.com/ai-studio/)\n\n[Latest news](https://ai.meta.com/blog)\n\n[Blog](https://ai.meta.com/blog)\n\n[Newsletter](https://ai.meta.com/subscribe)\n\nFoundational models\n\n[Llama](https://www.llama.com/)\n\n![Image 20](https://scontent-sof1-2.xx.fbcdn.net/v/t39.2365-6/87524316_2677189655726266_6338721200264445952_n.svg?_nc_cat=103&ccb=1-7&_nc_sid=e280be&_nc_ohc=nTPig30RHbMQ7kNvwGrMXkC&_nc_oc=AdmPAApgXC2YA2nkkduW-cTOWD4jnaETWbO97947APvdT6dAeJb4K8F6wRDP4foJzRW5r_14FFBJvzooZpVt21e-&_nc_zt=14&_nc_ht=scontent-sof1-2.xx&_nc_gid=Z99Bt6X0bExGEh4ifn4Gmg&oh=00_Afbd6Z8rT8ewAaQR82vMH7x_SKrAiaBQpSE0XIQK2R4GMQ&oe=68DF8878)\n\n![Image 21](https://scontent-sof1-2.xx.fbcdn.net/v/t39.2365-6/85559716_2814260008668824_1992323131183726592_n.svg?_nc_cat=103&ccb=1-7&_nc_sid=e280be&_nc_ohc=FqMkpP-eCj0Q7kNvwEQeJVX&_nc_oc=AdmxWy-LMKfP5dhKuf0KlGUUaH3qKEvArSCGUW5FhjErRZEUN8-TGG1fKs8oDwlP85wAcxmus9S6s5CAnI1NGF-E&_nc_zt=14&_nc_ht=scontent-sof1-2.xx&_nc_gid=Z99Bt6X0bExGEh4ifn4Gmg&oh=00_AfZS5o6ZckUMo_LMKIjMS9NyiYyCWw5_7x2OF-DCsRojPw&oe=68DF8D4F)\n\n[![Image 22](https://scontent-sof1-1.xx.fbcdn.net/v/t39.8562-6/335682312_964107378293184_3093631164486164913_n.svg?_nc_cat=100&ccb=1-7&_nc_sid=e280be&_nc_ohc=Zb7S6L1w11IQ7kNvwGGHryZ&_nc_oc=AdmIARqfvJg-U4Ul-i12YnW7rMU-hKuMNzPUe-1Y17cm_r1cH2PdNwJudkiRen6y37dWoYV1058x2qcFqy9V6XdU&_nc_zt=14&_nc_ht=scontent-sof1-1.xx&_nc_gid=Z99Bt6X0bExGEh4ifn4Gmg&oh=00_AfaqWdTU4CKMtslSjHZr6KZZngrrCGls94V49MpykkbNVA&oe=68CB0EE7) ![Image 23](https://scontent-sof1-1.xx.fbcdn.net/v/t39.8562-6/335682312_964107378293184_3093631164486164913_n.svg?_nc_cat=100&ccb=1-7&_nc_sid=e280be&_nc_ohc=Zb7S6L1w11IQ7kNvwGGHryZ&_nc_oc=AdmIARqfvJg-U4Ul-i12YnW7rMU-hKuMNzPUe-1Y17cm_r1cH2PdNwJudkiRen6y37dWoYV1058x2qcFqy9V6XdU&_nc_zt=14&_nc_ht=scontent-sof1-1.xx&_nc_gid=Z99Bt6X0bExGEh4ifn4Gmg&oh=00_AfaqWdTU4CKMtslSjHZr6KZZngrrCGls94V49MpykkbNVA&oe=68CB0EE7)](https://www.facebook.com/aiatmeta/)\n\n[![Image 24](https://scontent-sof1-2.xx.fbcdn.net/v/t39.8562-6/336009607_1870102080040414_6753977241281150924_n.svg?_nc_cat=103&ccb=1-7&_nc_sid=e280be&_nc_ohc=tDkPeDpRWR8Q7kNvwG8gf6h&_nc_oc=AdldAwr9Pmovh0eYMWwEkfS2qqasmIKS8UfmL9nMI195im0AoX56ybeuxICbxLKhMuQSn4v7topkqE9kV0igPZ8F&_nc_zt=14&_nc_ht=scontent-sof1-2.xx&_nc_gid=Z99Bt6X0bExGEh4ifn4Gmg&oh=00_AfaPMrFCJk4QLKi2y1Ic6YyIbPqo-HbPq3rm9_Hk8pHpwA&oe=68CB0722) ![Image 25](https://scontent-sof1-2.xx.fbcdn.net/v/t39.8562-6/336009607_1870102080040414_6753977241281150924_n.svg?_nc_cat=103&ccb=1-7&_nc_sid=e280be&_nc_ohc=tDkPeDpRWR8Q7kNvwG8gf6h&_nc_oc=AdldAwr9Pmovh0eYMWwEkfS2qqasmIKS8UfmL9nMI195im0AoX56ybeuxICbxLKhMuQSn4v7topkqE9kV0igPZ8F&_nc_zt=14&_nc_ht=scontent-sof1-2.xx&_nc_gid=Z99Bt6X0bExGEh4ifn4Gmg&oh=00_AfaPMrFCJk4QLKi2y1Ic6YyIbPqo-HbPq3rm9_Hk8pHpwA&oe=68CB0722)](https://twitter.com/aiatmeta/)\n\n[![Image 26](https://scontent-sof1-2.xx.fbcdn.net/v/t39.8562-6/336289415_1541032296405649_2165099305308791297_n.svg?_nc_cat=109&ccb=1-7&_nc_sid=e280be&_nc_ohc=k31iOH_3FnsQ7kNvwE_SyMm&_nc_oc=AdmXOZ1kngaEb97tZcA9SA3O36ljwaRzI-1JeJj0cL3zQ5jUISq1-NcczcnnlzVrcfgJfGjqUXhiKYynQBHy_Rp9&_nc_zt=14&_nc_ht=scontent-sof1-2.xx&_nc_gid=Z99Bt6X0bExGEh4ifn4Gmg&oh=00_AfaJFntEKiace7SBxJ0vay7GeNvcR16dv14aAPLEoa9S_A&oe=68CAFABB) ![Image 27](https://scontent-sof1-2.xx.fbcdn.net/v/t39.8562-6/336289415_1541032296405649_2165099305308791297_n.svg?_nc_cat=109&ccb=1-7&_nc_sid=e280be&_nc_ohc=k31iOH_3FnsQ7kNvwE_SyMm&_nc_oc=AdmXOZ1kngaEb97tZcA9SA3O36ljwaRzI-1JeJj0cL3zQ5jUISq1-NcczcnnlzVrcfgJfGjqUXhiKYynQBHy_Rp9&_nc_zt=14&_nc_ht=scontent-sof1-2.xx&_nc_gid=Z99Bt6X0bExGEh4ifn4Gmg&oh=00_AfaJFntEKiace7SBxJ0vay7GeNvcR16dv14aAPLEoa9S_A&oe=68CAFABB)](https://www.linkedin.com/showcase/aiatmeta)\n\n[![Image 28](https://scontent-sof1-1.xx.fbcdn.net/v/t39.8562-6/335648731_142576991793348_7786819189843639239_n.svg?_nc_cat=108&ccb=1-7&_nc_sid=e280be&_nc_ohc=4RUW6YGIwZwQ7kNvwH28_CP&_nc_oc=AdkK7N5BBJafUMKlxC3cZGu7Zqz0Ga3RrM5YSgpEy0ALxh-4iRwvSFE3AE9u-9FG6U3ZpVeV6NKXVSpNJ6pINz8h&_nc_zt=14&_nc_ht=scontent-sof1-1.xx&_nc_gid=Z99Bt6X0bExGEh4ifn4Gmg&oh=00_AfYfL-DOQWQDJdzBayrUB75Zp7C9Bw6BmP8_3gLtACcs_g&oe=68CB142E) ![Image 29](https://scontent-sof1-1.xx.fbcdn.net/v/t39.8562-6/335648731_142576991793348_7786819189843639239_n.svg?_nc_cat=108&ccb=1-7&_nc_sid=e280be&_nc_ohc=4RUW6YGIwZwQ7kNvwH28_CP&_nc_oc=AdkK7N5BBJafUMKlxC3cZGu7Zqz0Ga3RrM5YSgpEy0ALxh-4iRwvSFE3AE9u-9FG6U3ZpVeV6NKXVSpNJ6pINz8h&_nc_zt=14&_nc_ht=scontent-sof1-1.xx&_nc_gid=Z99Bt6X0bExGEh4ifn4Gmg&oh=00_AfYfL-DOQWQDJdzBayrUB75Zp7C9Bw6BmP8_3gLtACcs_g&oe=68CB142E)](https://www.youtube.com/@aiatmeta)\n\nOur approach\n\n[Our approach](https://ai.meta.com/about)[About AI at Meta](https://ai.meta.com/about)[People](https://ai.meta.com/results/?content_types%5B0%5D=person&sort_by=random)[Careers](https://www.metacareers.com/jobs/?is_leadership=0&sub_teams[0]=Artificial%20Intelligence&is_in_page=0)\n\nResearch\n\n[Research](https://ai.meta.com/research)[Infrastructure](https://ai.meta.com/infrastructure)[Resources](https://ai.meta.com/resources)[Demos](https://aidemos.meta.com/)\n\nMeta AI\n\n[Meta AI](https://ai.meta.com/meta-ai/)[Explore Meta AI](https://ai.meta.com/meta-ai/)[Get Meta AI](https://ai.meta.com/get-meta-ai/)[AI Studio](https://ai.meta.com/ai-studio/)\n\nLatest news\n\n[Latest news](https://ai.meta.com/blog)[Blog](https://ai.meta.com/blog)[Newsletter](https://ai.meta.com/subscribe)\n\nFoundational models\n\n[Llama](https://www.llama.com/)\n\n[![Image 30](https://scontent-sof1-1.xx.fbcdn.net/v/t39.8562-6/335682312_964107378293184_3093631164486164913_n.svg?_nc_cat=100&ccb=1-7&_nc_sid=e280be&_nc_ohc=Zb7S6L1w11IQ7kNvwGGHryZ&_nc_oc=AdmIARqfvJg-U4Ul-i12YnW7rMU-hKuMNzPUe-1Y17cm_r1cH2PdNwJudkiRen6y37dWoYV1058x2qcFqy9V6XdU&_nc_zt=14&_nc_ht=scontent-sof1-1.xx&_nc_gid=Z99Bt6X0bExGEh4ifn4Gmg&oh=00_AfaqWdTU4CKMtslSjHZr6KZZngrrCGls94V49MpykkbNVA&oe=68CB0EE7) ![Image 31](https://scontent-sof1-1.xx.fbcdn.net/v/t39.8562-6/335682312_964107378293184_3093631164486164913_n.svg?_nc_cat=100&ccb=1-7&_nc_sid=e280be&_nc_ohc=Zb7S6L1w11IQ7kNvwGGHryZ&_nc_oc=AdmIARqfvJg-U4Ul-i12YnW7rMU-hKuMNzPUe-1Y17cm_r1cH2PdNwJudkiRen6y37dWoYV1058x2qcFqy9V6XdU&_nc_zt=14&_nc_ht=scontent-sof1-1.xx&_nc_gid=Z99Bt6X0bExGEh4ifn4Gmg&oh=00_AfaqWdTU4CKMtslSjHZr6KZZngrrCGls94V49MpykkbNVA&oe=68CB0EE7)](https://www.facebook.com/aiatmeta/)\n\n[![Image 32](https://scontent-sof1-2.xx.fbcdn.net/v/t39.8562-6/336009607_1870102080040414_6753977241281150924_n.svg?_nc_cat=103&ccb=1-7&_nc_sid=e280be&_nc_ohc=tDkPeDpRWR8Q7kNvwG8gf6h&_nc_oc=AdldAwr9Pmovh0eYMWwEkfS2qqasmIKS8UfmL9nMI195im0AoX56ybeuxICbxLKhMuQSn4v7topkqE9kV0igPZ8F&_nc_zt=14&_nc_ht=scontent-sof1-2.xx&_nc_gid=Z99Bt6X0bExGEh4ifn4Gmg&oh=00_AfaPMrFCJk4QLKi2y1Ic6YyIbPqo-HbPq3rm9_Hk8pHpwA&oe=68CB0722) ![Image 33](https://scontent-sof1-2.xx.fbcdn.net/v/t39.8562-6/336009607_1870102080040414_6753977241281150924_n.svg?_nc_cat=103&ccb=1-7&_nc_sid=e280be&_nc_ohc=tDkPeDpRWR8Q7kNvwG8gf6h&_nc_oc=AdldAwr9Pmovh0eYMWwEkfS2qqasmIKS8UfmL9nMI195im0AoX56ybeuxICbxLKhMuQSn4v7topkqE9kV0igPZ8F&_nc_zt=14&_nc_ht=scontent-sof1-2.xx&_nc_gid=Z99Bt6X0bExGEh4ifn4Gmg&oh=00_AfaPMrFCJk4QLKi2y1Ic6YyIbPqo-HbPq3rm9_Hk8pHpwA&oe=68CB0722)](https://twitter.com/aiatmeta/)\n\n[![Image 34](https://scontent-sof1-2.xx.fbcdn.net/v/t39.8562-6/336289415_1541032296405649_2165099305308791297_n.svg?_nc_cat=109&ccb=1-7&_nc_sid=e280be&_nc_ohc=k31iOH_3FnsQ7kNvwE_SyMm&_nc_oc=AdmXOZ1kngaEb97tZcA9SA3O36ljwaRzI-1JeJj0cL3zQ5jUISq1-NcczcnnlzVrcfgJfGjqUXhiKYynQBHy_Rp9&_nc_zt=14&_nc_ht=scontent-sof1-2.xx&_nc_gid=Z99Bt6X0bExGEh4ifn4Gmg&oh=00_AfaJFntEKiace7SBxJ0vay7GeNvcR16dv14aAPLEoa9S_A&oe=68CAFABB) ![Image 35](https://scontent-sof1-2.xx.fbcdn.net/v/t39.8562-6/336289415_1541032296405649_2165099305308791297_n.svg?_nc_cat=109&ccb=1-7&_nc_sid=e280be&_nc_ohc=k31iOH_3FnsQ7kNvwE_SyMm&_nc_oc=AdmXOZ1kngaEb97tZcA9SA3O36ljwaRzI-1JeJj0cL3zQ5jUISq1-NcczcnnlzVrcfgJfGjqUXhiKYynQBHy_Rp9&_nc_zt=14&_nc_ht=scontent-sof1-2.xx&_nc_gid=Z99Bt6X0bExGEh4ifn4Gmg&oh=00_AfaJFntEKiace7SBxJ0vay7GeNvcR16dv14aAPLEoa9S_A&oe=68CAFABB)](https://www.linkedin.com/showcase/aiatmeta)\n\n[![Image 36](https://scontent-sof1-1.xx.fbcdn.net/v/t39.8562-6/335648731_142576991793348_7786819189843639239_n.svg?_nc_cat=108&ccb=1-7&_nc_sid=e280be&_nc_ohc=4RUW6YGIwZwQ7kNvwH28_CP&_nc_oc=AdkK7N5BBJafUMKlxC3cZGu7Zqz0Ga3RrM5YSgpEy0ALxh-4iRwvSFE3AE9u-9FG6U3ZpVeV6NKXVSpNJ6pINz8h&_nc_zt=14&_nc_ht=scontent-sof1-1.xx&_nc_gid=Z99Bt6X0bExGEh4ifn4Gmg&oh=00_AfYfL-DOQWQDJdzBayrUB75Zp7C9Bw6BmP8_3gLtACcs_g&oe=68CB142E) ![Image 37](https://scontent-sof1-1.xx.fbcdn.net/v/t39.8562-6/335648731_142576991793348_7786819189843639239_n.svg?_nc_cat=108&ccb=1-7&_nc_sid=e280be&_nc_ohc=4RUW6YGIwZwQ7kNvwH28_CP&_nc_oc=AdkK7N5BBJafUMKlxC3cZGu7Zqz0Ga3RrM5YSgpEy0ALxh-4iRwvSFE3AE9u-9FG6U3ZpVeV6NKXVSpNJ6pINz8h&_nc_zt=14&_nc_ht=scontent-sof1-1.xx&_nc_gid=Z99Bt6X0bExGEh4ifn4Gmg&oh=00_AfYfL-DOQWQDJdzBayrUB75Zp7C9Bw6BmP8_3gLtACcs_g&oe=68CB142E)](https://www.youtube.com/@aiatmeta)\n\n[Privacy Policy](https://www.facebook.com/about/privacy/)\n\n[Terms](https://www.facebook.com/policies/)\n\n[Cookies](https://www.facebook.com/policies/cookies/)\n\nMeta © 2025\n\n[![Image 38](https://scontent-sof1-1.xx.fbcdn.net/v/t39.8562-6/335682312_964107378293184_3093631164486164913_n.svg?_nc_cat=100&ccb=1-7&_nc_sid=e280be&_nc_ohc=Zb7S6L1w11IQ7kNvwGGHryZ&_nc_oc=AdmIARqfvJg-U4Ul-i12YnW7rMU-hKuMNzPUe-1Y17cm_r1cH2PdNwJudkiRen6y37dWoYV1058x2qcFqy9V6XdU&_nc_zt=14&_nc_ht=scontent-sof1-1.xx&_nc_gid=Z99Bt6X0bExGEh4ifn4Gmg&oh=00_AfaqWdTU4CKMtslSjHZr6KZZngrrCGls94V49MpykkbNVA&oe=68CB0EE7) ![Image 39](https://scontent-sof1-1.xx.fbcdn.net/v/t39.8562-6/335682312_964107378293184_3093631164486164913_n.svg?_nc_cat=100&ccb=1-7&_nc_sid=e280be&_nc_ohc=Zb7S6L1w11IQ7kNvwGGHryZ&_nc_oc=AdmIARqfvJg-U4Ul-i12YnW7rMU-hKuMNzPUe-1Y17cm_r1cH2PdNwJudkiRen6y37dWoYV1058x2qcFqy9V6XdU&_nc_zt=14&_nc_ht=scontent-sof1-1.xx&_nc_gid=Z99Bt6X0bExGEh4ifn4Gmg&oh=00_AfaqWdTU4CKMtslSjHZr6KZZngrrCGls94V49MpykkbNVA&oe=68CB0EE7)](https://www.facebook.com/aiatmeta/)\n\n[![Image 40](https://scontent-sof1-2.xx.fbcdn.net/v/t39.8562-6/336009607_1870102080040414_6753977241281150924_n.svg?_nc_cat=103&ccb=1-7&_nc_sid=e280be&_nc_ohc=tDkPeDpRWR8Q7kNvwG8gf6h&_nc_oc=AdldAwr9Pmovh0eYMWwEkfS2qqasmIKS8UfmL9nMI195im0AoX56ybeuxICbxLKhMuQSn4v7topkqE9kV0igPZ8F&_nc_zt=14&_nc_ht=scontent-sof1-2.xx&_nc_gid=Z99Bt6X0bExGEh4ifn4Gmg&oh=00_AfaPMrFCJk4QLKi2y1Ic6YyIbPqo-HbPq3rm9_Hk8pHpwA&oe=68CB0722) ![Image 41](https://scontent-sof1-2.xx.fbcdn.net/v/t39.8562-6/336009607_1870102080040414_6753977241281150924_n.svg?_nc_cat=103&ccb=1-7&_nc_sid=e280be&_nc_ohc=tDkPeDpRWR8Q7kNvwG8gf6h&_nc_oc=AdldAwr9Pmovh0eYMWwEkfS2qqasmIKS8UfmL9nMI195im0AoX56ybeuxICbxLKhMuQSn4v7topkqE9kV0igPZ8F&_nc_zt=14&_nc_ht=scontent-sof1-2.xx&_nc_gid=Z99Bt6X0bExGEh4ifn4Gmg&oh=00_AfaPMrFCJk4QLKi2y1Ic6YyIbPqo-HbPq3rm9_Hk8pHpwA&oe=68CB0722)](https://twitter.com/aiatmeta/)\n\n[![Image 42](https://scontent-sof1-2.xx.fbcdn.net/v/t39.8562-6/336289415_1541032296405649_2165099305308791297_n.svg?_nc_cat=109&ccb=1-7&_nc_sid=e280be&_nc_ohc=k31iOH_3FnsQ7kNvwE_SyMm&_nc_oc=AdmXOZ1kngaEb97tZcA9SA3O36ljwaRzI-1JeJj0cL3zQ5jUISq1-NcczcnnlzVrcfgJfGjqUXhiKYynQBHy_Rp9&_nc_zt=14&_nc_ht=scontent-sof1-2.xx&_nc_gid=Z99Bt6X0bExGEh4ifn4Gmg&oh=00_AfaJFntEKiace7SBxJ0vay7GeNvcR16dv14aAPLEoa9S_A&oe=68CAFABB) ![Image 43](https://scontent-sof1-2.xx.fbcdn.net/v/t39.8562-6/336289415_1541032296405649_2165099305308791297_n.svg?_nc_cat=109&ccb=1-7&_nc_sid=e280be&_nc_ohc=k31iOH_3FnsQ7kNvwE_SyMm&_nc_oc=AdmXOZ1kngaEb97tZcA9SA3O36ljwaRzI-1JeJj0cL3zQ5jUISq1-NcczcnnlzVrcfgJfGjqUXhiKYynQBHy_Rp9&_nc_zt=14&_nc_ht=scontent-sof1-2.xx&_nc_gid=Z99Bt6X0bExGEh4ifn4Gmg&oh=00_AfaJFntEKiace7SBxJ0vay7GeNvcR16dv14aAPLEoa9S_A&oe=68CAFABB)](https://www.linkedin.com/showcase/aiatmeta)\n\n[![Image 44](https://scontent-sof1-1.xx.fbcdn.net/v/t39.8562-6/335648731_142576991793348_7786819189843639239_n.svg?_nc_cat=108&ccb=1-7&_nc_sid=e280be&_nc_ohc=4RUW6YGIwZwQ7kNvwH28_CP&_nc_oc=AdkK7N5BBJafUMKlxC3cZGu7Zqz0Ga3RrM5YSgpEy0ALxh-4iRwvSFE3AE9u-9FG6U3ZpVeV6NKXVSpNJ6pINz8h&_nc_zt=14&_nc_ht=scontent-sof1-1.xx&_nc_gid=Z99Bt6X0bExGEh4ifn4Gmg&oh=00_AfYfL-DOQWQDJdzBayrUB75Zp7C9Bw6BmP8_3gLtACcs_g&oe=68CB142E) ![Image 45](https://scontent-sof1-1.xx.fbcdn.net/v/t39.8562-6/335648731_142576991793348_7786819189843639239_n.svg?_nc_cat=108&ccb=1-7&_nc_sid=e280be&_nc_ohc=4RUW6YGIwZwQ7kNvwH28_CP&_nc_oc=AdkK7N5BBJafUMKlxC3cZGu7Zqz0Ga3RrM5YSgpEy0ALxh-4iRwvSFE3AE9u-9FG6U3ZpVeV6NKXVSpNJ6pINz8h&_nc_zt=14&_nc_ht=scontent-sof1-1.xx&_nc_gid=Z99Bt6X0bExGEh4ifn4Gmg&oh=00_AfYfL-DOQWQDJdzBayrUB75Zp7C9Bw6BmP8_3gLtACcs_g&oe=68CB142E)](https://www.youtube.com/@aiatmeta)\n",
      "fetch_method": "jina-reader"
    },
    {
      "arxiv_id": "https://huggingface.co/docs/transformers/en/main_classes/pipelines",
      "full_text": " Pipelines Hugging Face Models Datasets Spaces Community Docs Enterprise Pricing Log In Sign Up Transformers documentation Pipelines Transformers 🏡 View all docs AWS Trainium &amp; Inferentia Accelerate Argilla AutoTrain Bitsandbytes Chat UI Dataset viewer Datasets Deploying on AWS Diffusers Distilabel Evaluate Gradio Hub Hub Python Library Huggingface.js Inference Endpoints (dedicated) Inference Providers LeRobot Leaderboards Lighteval Microsoft Azure Optimum PEFT Safetensors Sentence Transformers TRL Tasks Text Embeddings Inference Text Generation Inference Tokenizers Trackio Transformers Transformers.js smolagents timm Search documentation main v4.56.1 v4.55.4 v4.53.3 v4.52.3 v4.51.3 v4.50.0 v4.49.0 v4.48.2 v4.47.1 v4.46.3 v4.45.2 v4.44.2 v4.43.4 v4.42.4 v4.41.2 v4.40.2 v4.39.3 v4.38.2 v4.37.2 v4.36.1 v4.35.2 v4.34.1 v4.33.3 v4.32.1 v4.31.0 v4.30.0 v4.29.1 v4.28.1 v4.27.2 v4.26.1 v4.25.1 v4.24.0 v4.23.1 v4.22.2 v4.21.3 v4.20.1 v4.19.4 v4.18.0 v4.17.0 v4.16.2 v4.15.0 v4.14.1 v4.13.0 v4.12.5 v4.11.3 v4.10.1 v4.9.2 v4.8.2 v4.7.0 v4.6.0 v4.5.1 v4.4.2 v4.3.3 v4.2.2 v4.1.1 v4.0.1 v3.5.1 v3.4.0 v3.3.1 v3.2.0 v3.1.0 v3.0.2 v2.11.0 v2.10.0 v2.9.1 v2.8.0 v2.7.0 v2.6.0 v2.5.1 v2.4.1 v2.3.0 v2.2.2 v2.1.1 v2.0.0 v1.2.0 v1.1.0 v1.0.0 doc-builder-html AR DE EN ES FR HI IT JA KO PT TE TR ZH Get started Transformers Installation Quickstart Base classes Inference Training Quantization Export to production Resources Contribute API Main Classes Auto Classes Backbones Callbacks Configuration Data Collator Keras callbacks Logging Models Text Generation ONNX Optimization Model outputs PEFT Pipelines Processors Quantization Tokenizer Trainer DeepSpeed ExecuTorch Feature Extractor Image Processor Video Processor Models Internal helpers Reference Join the Hugging Face community and get access to the augmented documentation experience Collaborate on models, datasets and Spaces Faster examples with accelerated inference Switch between documentation themes Sign Up to get started Pipelines The pipelines are a great and easy way to use models for inference. These pipelines are objects that abstract most of the complex code from the library, offering a simple API dedicated to several tasks, including Named Entity Recognition, Masked Language Modeling, Sentiment Analysis, Feature Extraction and Question Answering. See the task summary for examples of use. There are two categories of pipeline abstractions to be aware about: The pipeline() which is the most powerful object encapsulating all other pipelines. Task-specific pipelines are available for audio , computer vision , natural language processing , and multimodal tasks. The pipeline abstraction The pipeline abstraction is a wrapper around all the other available pipelines. It is instantiated as any other pipeline but can provide additional quality of life. Simple call on one item: Copied &gt;&gt;&gt; pipe = pipeline( &quot;text-classification&quot; ) &gt;&gt;&gt; pipe( &quot;This restaurant is awesome&quot; ) [{ &#x27;label&#x27; : &#x27;POSITIVE&#x27; , &#x27;score&#x27; : 0.9998743534088135 }] If you want to use a specific model from the hub you can ignore the task if the model on the hub already defines it: Copied &gt;&gt;&gt; pipe = pipeline(model= &quot;FacebookAI/roberta-large-mnli&quot; ) &gt;&gt;&gt; pipe( &quot;This restaurant is awesome&quot; ) [{ &#x27;label&#x27; : &#x27;NEUTRAL&#x27; , &#x27;score&#x27; : 0.7313136458396912 }] To call a pipeline on many items, you can call it with a list . Copied &gt;&gt;&gt; pipe = pipeline( &quot;text-classification&quot; ) &gt;&gt;&gt; pipe([ &quot;This restaurant is awesome&quot; , &quot;This restaurant is awful&quot; ]) [{ &#x27;label&#x27; : &#x27;POSITIVE&#x27; , &#x27;score&#x27; : 0.9998743534088135 }, { &#x27;label&#x27; : &#x27;NEGATIVE&#x27; , &#x27;score&#x27; : 0.9996669292449951 }] To iterate over full datasets it is recommended to use a dataset directly. This means you don’t need to allocate the whole dataset at once, nor do you need to do batching yourself. This should work just as fast as custom loops on GPU. If it doesn’t don’t hesitate to create an issue. Copied import datasets from transformers import pipeline from transformers.pipelines.pt_utils import KeyDataset from tqdm.auto import tqdm pipe = pipeline( &quot;automatic-speech-recognition&quot; , model= &quot;facebook/wav2vec2-base-960h&quot; , device= 0 ) dataset = datasets.load_dataset( &quot;superb&quot; , name= &quot;asr&quot; , split= &quot;test&quot; ) # KeyDataset (only *pt*) will simply return the item in the dict returned by the dataset item # as we&#x27;re not interested in the *target* part of the dataset. For sentence pair use KeyPairDataset for out in tqdm(pipe(KeyDataset(dataset, &quot;file&quot; ))): print (out) # {&quot;text&quot;: &quot;NUMBER TEN FRESH NELLY IS WAITING ON YOU GOOD NIGHT HUSBAND&quot;} # {&quot;text&quot;: ....} # .... For ease of use, a generator is also possible: Copied from transformers import pipeline pipe = pipeline( &quot;text-classification&quot; ) def data (): while True : # This could come from a dataset, a database, a queue or HTTP request # in a server # Caveat: because this is iterative, you cannot use `num_workers &gt; 1` variable # to use multiple threads to preprocess data. You can still have 1 thread that # does the preprocessing while the main runs the big inference yield &quot;This is a test&quot; for out in pipe(data()): print (out) # {&quot;text&quot;: &quot;NUMBER TEN FRESH NELLY IS WAITING ON YOU GOOD NIGHT HUSBAND&quot;} # {&quot;text&quot;: ....} # .... transformers.pipeline &lt; source &gt; ( task : typing.Optional[str] = None model : typing.Union[str, ForwardRef('PreTrainedModel'), ForwardRef('TFPreTrainedModel'), NoneType] = None config : typing.Union[str, transformers.configuration_utils.PretrainedConfig, NoneType] = None tokenizer : typing.Union[str, transformers.tokenization_utils.PreTrainedTokenizer, ForwardRef('PreTrainedTokenizerFast'), NoneType] = None feature_extractor : typing.Union[str, ForwardRef('SequenceFeatureExtractor'), NoneType] = None image_processor : typing.Union[str, transformers.image_processing_utils.BaseImageProcessor, NoneType] = None processor : typing.Union[str, transformers.processing_utils.ProcessorMixin, NoneType] = None framework : typing.Optional[str] = None revision : typing.Optional[str] = None use_fast : bool = True token : typing.Union[str, bool, NoneType] = None device : typing.Union[int, str, ForwardRef('torch.device'), NoneType] = None device_map : typing.Union[str, dict[str, typing.Union[int, str]], NoneType] = None dtype : typing.Union[str, ForwardRef('torch.dtype'), NoneType] = 'auto' trust_remote_code : typing.Optional[bool] = None model_kwargs : typing.Optional[dict[str, typing.Any]] = None pipeline_class : typing.Optional[typing.Any] = None **kwargs : typing.Any ) → Pipeline Parameters task ( str ) &#x2014; The task defining which pipeline will be returned. Currently accepted tasks are: &quot;audio-classification&quot; : will return a AudioClassificationPipeline . &quot;automatic-speech-recognition&quot; : will return a AutomaticSpeechRecognitionPipeline . &quot;depth-estimation&quot; : will return a DepthEstimationPipeline . &quot;document-question-answering&quot; : will return a DocumentQuestionAnsweringPipeline . &quot;feature-extraction&quot; : will return a FeatureExtractionPipeline . &quot;fill-mask&quot; : will return a FillMaskPipeline :. &quot;image-classification&quot; : will return a ImageClassificationPipeline . &quot;image-feature-extraction&quot; : will return an ImageFeatureExtractionPipeline . &quot;image-segmentation&quot; : will return a ImageSegmentationPipeline . &quot;image-text-to-text&quot; : will return a ImageTextToTextPipeline . &quot;image-to-image&quot; : will return a ImageToImagePipeline . &quot;image-to-text&quot; : will return a ImageToTextPipeline . &quot;keypoint-matching&quot; : will return a KeypointMatchingPipeline . &quot;mask-generation&quot; : will return a MaskGenerationPipeline . &quot;object-detection&quot; : will return a ObjectDetectionPipeline . &quot;question-answering&quot; : will return a QuestionAnsweringPipeline . &quot;summarization&quot; : will return a SummarizationPipeline . &quot;table-question-answering&quot; : will return a TableQuestionAnsweringPipeline . &quot;text2text-generation&quot; : will return a Text2TextGenerationPipeline . &quot;text-classification&quot; (alias &quot;sentiment-analysis&quot; available): will return a TextClassificationPipeline . &quot;text-generation&quot; : will return a TextGenerationPipeline :. &quot;text-to-audio&quot; (alias &quot;text-to-speech&quot; available): will return a TextToAudioPipeline :. &quot;token-classification&quot; (alias &quot;ner&quot; available): will return a TokenClassificationPipeline . &quot;translation&quot; : will return a TranslationPipeline . &quot;translation_xx_to_yy&quot; : will return a TranslationPipeline . &quot;video-classification&quot; : will return a VideoClassificationPipeline . &quot;visual-question-answering&quot; : will return a VisualQuestionAnsweringPipeline . &quot;zero-shot-classification&quot; : will return a ZeroShotClassificationPipeline . &quot;zero-shot-image-classification&quot; : will return a ZeroShotImageClassificationPipeline . &quot;zero-shot-audio-classification&quot; : will return a ZeroShotAudioClassificationPipeline . &quot;zero-shot-object-detection&quot; : will return a ZeroShotObjectDetectionPipeline . model ( str or PreTrainedModel or TFPreTrainedModel , optional ) &#x2014; The model that will be used by the pipeline to make predictions. This can be a model identifier or an actual instance of a pretrained model inheriting from PreTrainedModel (for PyTorch) or TFPreTrainedModel (for TensorFlow). If not provided, the default for the task will be loaded. config ( str or PretrainedConfig , optional ) &#x2014; The configuration that will be used by the pipeline to instantiate the model. This can be a model identifier or an actual pretrained model configuration inheriting from PretrainedConfig . If not provided, the default configuration file for the requested model will be used. That means that if model is given, its default configuration will be used. However, if model is not supplied, this task &#x2019;s default model&#x2019;s config is used instead. tokenizer ( str or PreTrainedTokenizer , optional ) &#x2014; The tokenizer that will be used by the pipeline to encode data for the model. This can be a model identifier or an actual pretrained tokenizer inheriting from PreTrainedTokenizer . If not provided, the default tokenizer for the given model will be loaded (if it is a string). If model is not specified or not a string, then the default tokenizer for config is loaded (if it is a string). However, if config is also not given or not a string, then the default tokenizer for the given task will be loaded. feature_extractor ( str or PreTrainedFeatureExtractor , optional ) &#x2014; The feature extractor that will be used by the pipeline to encode data for the model. This can be a model identifier or an actual pretrained feature extractor inheriting from PreTrainedFeatureExtractor . Feature extractors are used for non-NLP models, such as Speech or Vision models as well as multi-modal models. Multi-modal models will also require a tokenizer to be passed. If not provided, the default feature extractor for the given model will be loaded (if it is a string). If model is not specified or not a string, then the default feature extractor for config is loaded (if it is a string). However, if config is also not given or not a string, then the default feature extractor for the given task will be loaded. image_processor ( str or BaseImageProcessor , optional ) &#x2014; The image processor that will be used by the pipeline to preprocess images for the model. This can be a model identifier or an actual image processor inheriting from BaseImageProcessor . Image processors are used for Vision models and multi-modal models that require image inputs. Multi-modal models will also require a tokenizer to be passed. If not provided, the default image processor for the given model will be loaded (if it is a string). If model is not specified or not a string, then the default image processor for config is loaded (if it is a string). processor ( str or ProcessorMixin , optional ) &#x2014; The processor that will be used by the pipeline to preprocess data for the model. This can be a model identifier or an actual processor inheriting from ProcessorMixin . Processors are used for multi-modal models that require multi-modal inputs, for example, a model that requires both text and image inputs. If not provided, the default processor for the given model will be loaded (if it is a string). If model is not specified or not a string, then the default processor for config is loaded (if it is a string). framework ( str , optional ) &#x2014; The framework to use, either &quot;pt&quot; for PyTorch or &quot;tf&quot; for TensorFlow. The specified framework must be installed. If no framework is specified, will default to the one currently installed. If no framework is specified and both frameworks are installed, will default to the framework of the model , or to PyTorch if no model is provided. revision ( str , optional , defaults to &quot;main&quot; ) &#x2014; When passing a task name or a string model identifier: The specific model version to use. It can be a branch name, a tag name, or a commit id, since we use a git-based system for storing models and other artifacts on huggingface.co, so revision can be any identifier allowed by git. use_fast ( bool , optional , defaults to True ) &#x2014; Whether or not to use a Fast tokenizer if possible (a PreTrainedTokenizerFast ). use_auth_token ( str or bool , optional ) &#x2014; The token to use as HTTP bearer authorization for remote files. If True , will use the token generated when running hf auth login (stored in ~/.huggingface ). device ( int or str or torch.device ) &#x2014; Defines the device ( e.g. , &quot;cpu&quot; , &quot;cuda:1&quot; , &quot;mps&quot; , or a GPU ordinal rank like 1 ) on which this pipeline will be allocated. device_map ( str or dict[str, Union[int, str, torch.device] , optional ) &#x2014; Sent directly as model_kwargs (just a simpler shortcut). When accelerate library is present, set device_map=&quot;auto&quot; to compute the most optimized device_map automatically (see here for more information). Do not use device_map AND device at the same time as they will conflict dtype ( str or torch.dtype , optional ) &#x2014; Sent directly as model_kwargs (just a simpler shortcut) to use the available precision for this model ( torch.float16 , torch.bfloat16 , &#x2026; or &quot;auto&quot; ). trust_remote_code ( bool , optional , defaults to False ) &#x2014; Whether or not to allow for custom code defined on the Hub in their own modeling, configuration, tokenization or even pipeline files. This option should only be set to True for repositories you trust and in which you have read the code, as it will execute code present on the Hub on your local machine. model_kwargs ( dict[str, Any] , optional ) &#x2014; Additional dictionary of keyword arguments passed along to the model&#x2019;s from_pretrained(..., **model_kwargs) function. kwargs ( dict[str, Any] , optional ) &#x2014; Additional keyword arguments passed along to the specific pipeline init (see the documentation for the corresponding pipeline class for possible values). Returns Pipeline A suitable pipeline for the task. Utility factory method to build a Pipeline . A pipeline consists of: One or more components for pre-processing model inputs, such as a tokenizer , image_processor , feature_extractor , or processor . A model that generates predictions from the inputs. Optional post-processing steps to refine the model’s output, which can also be handled by processors. While there are such optional arguments as `tokenizer`, `feature_extractor`, `image_processor`, and `processor`, they shouldn&#39;t be specified all at once. If these components are not provided, `pipeline` will try to load required ones automatically. In case you want to provide these components explicitly, please refer to a specific pipeline in order to get more details regarding what components are required. Examples: Copied &gt;&gt;&gt; from transformers import pipeline, AutoModelForTokenClassification, AutoTokenizer &gt;&gt;&gt; # Sentiment analysis pipeline &gt;&gt;&gt; analyzer = pipeline( &quot;sentiment-analysis&quot; ) &gt;&gt;&gt; # Question answering pipeline, specifying the checkpoint identifier &gt;&gt;&gt; oracle = pipeline( ... &quot;question-answering&quot; , model= &quot;distilbert/distilbert-base-cased-distilled-squad&quot; , tokenizer= &quot;google-bert/bert-base-cased&quot; ... ) &gt;&gt;&gt; # Named entity recognition pipeline, passing in a specific model and tokenizer &gt;&gt;&gt; model = AutoModelForTokenClassification.from_pretrained( &quot;dbmdz/bert-large-cased-finetuned-conll03-english&quot; ) &gt;&gt;&gt; tokenizer = AutoTokenizer.from_pretrained( &quot;google-bert/bert-base-cased&quot; ) &gt;&gt;&gt; recognizer = pipeline( &quot;ner&quot; , model=model, tokenizer=tokenizer) Pipeline batching All pipelines can use batching. This will work whenever the pipeline uses its streaming ability (so when passing lists or Dataset or generator ). Copied from transformers import pipeline from transformers.pipelines.pt_utils import KeyDataset import datasets dataset = datasets.load_dataset( &quot;imdb&quot; , name= &quot;plain_text&quot; , split= &quot;unsupervised&quot; ) pipe = pipeline( &quot;text-classification&quot; , device= 0 ) for out in pipe(KeyDataset(dataset, &quot;text&quot; ), batch_size= 8 , truncation= &quot;only_first&quot; ): print (out) # [{&#x27;label&#x27;: &#x27;POSITIVE&#x27;, &#x27;score&#x27;: 0.9998743534088135}] # Exactly the same output as before, but the content are passed # as batches to the model However, this is not automatically a win for performance. It can be either a 10x speedup or 5x slowdown depending on hardware, data and the actual model being used. Example where it’s mostly a speedup: Copied from transformers import pipeline from torch.utils.data import Dataset from tqdm.auto import tqdm pipe = pipeline( &quot;text-classification&quot; , device= 0 ) class MyDataset ( Dataset ): def __len__ ( self ): return 5000 def __getitem__ ( self, i ): return &quot;This is a test&quot; dataset = MyDataset() for batch_size in [ 1 , 8 , 64 , 256 ]: print ( &quot;-&quot; * 30 ) print ( f&quot;Streaming batch_size= {batch_size} &quot; ) for out in tqdm(pipe(dataset, batch_size=batch_size), total= len (dataset)): pass Copied # On GTX 970 ------------------------------ Streaming no batching 100%|██████████████████████████████████████████████████████████████████████| 5000/5000 [00:26&lt;00:00, 187.52it/s] ------------------------------ Streaming batch_size=8 100%|█████████████████████████████████████████████████████████████████████| 5000/5000 [00:04&lt;00:00, 1205.95it/s] ------------------------------ Streaming batch _size=64 100%|█████████████████████████████████████████████████████████████████████| 5000/5000 [00:02&lt;00:00, 2478.24it/s] ------------------------------ Streaming batch_ size=256 100%|█████████████████████████████████████████████████████████████████████| 5000/5000 [00:01&lt;00:00, 2554.43it/s] (diminishing returns, saturated the GPU) Example where it’s most a slowdown: Copied class MyDataset ( Dataset ): def __len__ ( self ): return 5000 def __getitem__ ( self, i ): if i % 64 == 0 : n = 100 else : n = 1 return &quot;This is a test&quot; * n This is a occasional very long sentence compared to the other. In that case, the whole batch will need to be 400 tokens long, so the whole batch will be [64, 400] instead of [64, 4], leading to the high slowdown. Even worse, on bigger batches, the program simply crashes. Copied ------------------------------ Streaming no batching 100 %|█████████████████████████████████████████████████████████████████████| 1000 / 1000 [ 00 : 05 &lt; 00 : 00 , 183.69 it /s] ------------------------------ Streaming batch_size= 8 100 %|█████████████████████████████████████████████████████████████████████| 1000 / 1000 [ 00 : 03 &lt; 00 : 00 , 265.74 it /s] ------------------------------ Streaming batch_size= 64 100 %|██████████████████████████████████████████████████████████████████████| 1000 / 1000 [ 00 : 26 &lt; 00 : 00 , 37.80 it /s] ------------------------------ Streaming batch_size= 256 0 %| | 0 / 1000 [ 00 : 00 &lt;? , ? it /s] Traceback (most recent call last ): File &quot;/home/nicolas/src/transformers/test.py&quot; , line 42 , in &lt;module&gt; for out in tqdm(pipe(dataset, batch_size= 256 ), total= len (dataset)): .... q = q / math. sqrt (dim_per_head) # (bs, n_heads, q_length, dim_per_head) RuntimeError: CUDA out of memory. Tried to allocate 376.00 MiB (GPU 0 ; 3.95 GiB total capacity; 1.72 GiB already allocated; 354.88 MiB free; 2.46 GiB reserved in total by PyTorch) There are no good (general) solutions for this problem, and your mileage may vary depending on your use cases. Rule of thumb: For users, a rule of thumb is: Measure performance on your load, with your hardware. Measure, measure, and keep measuring. Real numbers are the only way to go. If you are latency constrained (live product doing inference), don’t batch. If you are using CPU, don’t batch. If you are using throughput (you want to run your model on a bunch of static data), on GPU, then: If you have no clue about the size of the sequence_length (“natural” data), by default don’t batch, measure and try tentatively to add it, add OOM checks to recover when it will fail (and it will at some point if you don’t control the sequence_length.) If your sequence_length is super regular, then batching is more likely to be VERY interesting, measure and push it until you get OOMs. The larger the GPU the more likely batching is going to be more interesting As soon as you enable batching, make sure you can handle OOMs nicely. Pipeline chunk batching zero-shot-classification and question-answering are slightly specific in the sense, that a single input might yield multiple forward pass of a model. Under normal circumstances, this would yield issues with batch_size argument. In order to circumvent this issue, both of these pipelines are a bit specific, they are ChunkPipeline instead of regular Pipeline . In short: Copied preprocessed = pipe.preprocess(inputs) model_outputs = pipe.forward(preprocessed) outputs = pipe.postprocess(model_outputs) Now becomes: Copied all_model_outputs = [] for preprocessed in pipe.preprocess(inputs): model_outputs = pipe.forward(preprocessed) all_model_outputs.append(model_outputs) outputs = pipe.postprocess(all_model_outputs) This should be very transparent to your code because the pipelines are used in the same way. This is a simplified view, since the pipeline can handle automatically the batch to ! Meaning you don’t have to care about how many forward passes you inputs are actually going to trigger, you can optimize the batch_size independently of the inputs. The caveats from the previous section still apply. Pipeline FP16 inference Models can be run in FP16 which can be significantly faster on GPU while saving memory. Most models will not suffer noticeable performance loss from this. The larger the model, the less likely that it will. To enable FP16 inference, you can simply pass dtype=torch.float16 or dtype=&#39;float16&#39; to the pipeline constructor. Note that this only works for models with a PyTorch backend. Your inputs will be converted to FP16 internally. Pipeline custom code If you want to override a specific pipeline. Don’t hesitate to create an issue for your task at hand, the goal of the pipeline is to be easy to use and support most cases, so transformers could maybe support your use case. If you want to try simply you can: Subclass your pipeline of choice Copied class MyPipeline ( TextClassificationPipeline ): def postprocess (): # Your code goes here scores = scores * 100 # And here my_pipeline = MyPipeline(model=model, tokenizer=tokenizer, ...) # or if you use *pipeline* function, then: my_pipeline = pipeline(model= &quot;xxxx&quot; , pipeline_class=MyPipeline) That should enable you to do all the custom code you want. Implementing a pipeline Implementing a new pipeline Audio Pipelines available for audio tasks include the following. AudioClassificationPipeline class transformers. AudioClassificationPipeline &lt; source &gt; ( *args **kwargs ) Parameters model ( PreTrainedModel or TFPreTrainedModel ) &#x2014; The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from PreTrainedModel for PyTorch and TFPreTrainedModel for TensorFlow. feature_extractor ( SequenceFeatureExtractor ) &#x2014; The feature extractor that will be used by the pipeline to encode data for the model. This object inherits from SequenceFeatureExtractor . modelcard ( str or ModelCard , optional ) &#x2014; Model card attributed to the model for this pipeline. framework ( str , optional ) &#x2014; The framework to use, either &quot;pt&quot; for PyTorch or &quot;tf&quot; for TensorFlow. The specified framework must be installed. If no framework is specified, will default to the one currently installed. If no framework is specified and both frameworks are installed, will default to the framework of the model , or to PyTorch if no model is provided. task ( str , defaults to &quot;&quot; ) &#x2014; A task-identifier for the pipeline. num_workers ( int , optional , defaults to 8) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the number of workers to be used. batch_size ( int , optional , defaults to 1) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the size of the batch to use, for inference this is not always beneficial, please read Batching with pipelines . args_parser ( ArgumentHandler , optional ) &#x2014; Reference to the object in charge of parsing supplied pipeline parameters. device ( int , optional , defaults to -1) &#x2014; Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on the associated CUDA device id. You can pass native torch.device or a str too dtype ( str or torch.dtype , optional ) &#x2014; Sent directly as model_kwargs (just a simpler shortcut) to use the available precision for this model ( torch.float16 , torch.bfloat16 , &#x2026; or &quot;auto&quot; ) binary_output ( bool , optional , defaults to False ) &#x2014; Flag indicating if the output the pipeline should happen in a serialized format (i.e., pickle) or as the raw output data e.g. text. Audio classification pipeline using any AutoModelForAudioClassification . This pipeline predicts the class of a raw waveform or an audio file. In case of an audio file, ffmpeg should be installed to support multiple audio formats. Example: Copied &gt;&gt;&gt; from transformers import pipeline &gt;&gt;&gt; classifier = pipeline(model= &quot;superb/wav2vec2-base-superb-ks&quot; ) &gt;&gt;&gt; classifier( &quot;https://huggingface.co/datasets/Narsil/asr_dummy/resolve/main/1.flac&quot; ) [{ &#x27;score&#x27; : 0.997 , &#x27;label&#x27; : &#x27;_unknown_&#x27; }, { &#x27;score&#x27; : 0.002 , &#x27;label&#x27; : &#x27;left&#x27; }, { &#x27;score&#x27; : 0.0 , &#x27;label&#x27; : &#x27;yes&#x27; }, { &#x27;score&#x27; : 0.0 , &#x27;label&#x27; : &#x27;down&#x27; }, { &#x27;score&#x27; : 0.0 , &#x27;label&#x27; : &#x27;stop&#x27; }] Learn more about the basics of using a pipeline in the pipeline tutorial This pipeline can currently be loaded from pipeline() using the following task identifier: &quot;audio-classification&quot; . See the list of available models on huggingface.co/models . __call__ &lt; source &gt; ( inputs : typing.Union[numpy.ndarray, bytes, str, dict] **kwargs : typing.Any ) → A list of dict with the following keys Parameters inputs ( np.ndarray or bytes or str or dict ) &#x2014; The inputs is either : str that is the filename of the audio file, the file will be read at the correct sampling rate to get the waveform using ffmpeg . This requires ffmpeg to be installed on the system. bytes it is supposed to be the content of an audio file and is interpreted by ffmpeg in the same way. ( np.ndarray of shape (n, ) of type np.float32 or np.float64 ) Raw audio at the correct sampling rate (no further check will be done) dict form can be used to pass raw audio sampled at arbitrary sampling_rate and let this pipeline do the resampling. The dict must be either be in the format {&quot;sampling_rate&quot;: int, &quot;raw&quot;: np.array} , or {&quot;sampling_rate&quot;: int, &quot;array&quot;: np.array} , where the key &quot;raw&quot; or &quot;array&quot; is used to denote the raw audio waveform. top_k ( int , optional , defaults to None) &#x2014; The number of top labels that will be returned by the pipeline. If the provided number is None or higher than the number of labels available in the model configuration, it will default to the number of labels. function_to_apply( str , optional , defaults to &#x201C;softmax&#x201D;) &#x2014; The function to apply to the model output. By default, the pipeline will apply the softmax function to the output of the model. Valid options: [&#x201C;softmax&#x201D;, &#x201C;sigmoid&#x201D;, &#x201C;none&#x201D;]. Note that passing Python&#x2019;s built-in None will default to &#x201C;softmax&#x201D;, so you need to pass the string &#x201C;none&#x201D; to disable any post-processing. Returns A list of dict with the following keys label ( str ) — The label predicted. score ( float ) — The corresponding probability. Classify the sequence(s) given as inputs. See the AutomaticSpeechRecognitionPipeline documentation for more information. AutomaticSpeechRecognitionPipeline class transformers. AutomaticSpeechRecognitionPipeline &lt; source &gt; ( model : PreTrainedModel feature_extractor : typing.Union[ForwardRef('SequenceFeatureExtractor'), str] = None tokenizer : typing.Optional[transformers.tokenization_utils.PreTrainedTokenizer] = None decoder : typing.Union[ForwardRef('BeamSearchDecoderCTC'), str, NoneType] = None device : typing.Union[int, ForwardRef('torch.device')] = None **kwargs ) Parameters model ( PreTrainedModel or TFPreTrainedModel ) &#x2014; The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from PreTrainedModel for PyTorch and TFPreTrainedModel for TensorFlow. feature_extractor ( SequenceFeatureExtractor ) &#x2014; The feature extractor that will be used by the pipeline to encode waveform for the model. tokenizer ( PreTrainedTokenizer ) &#x2014; The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from PreTrainedTokenizer . decoder ( pyctcdecode.BeamSearchDecoderCTC , optional ) &#x2014; PyCTCDecode&#x2019;s BeamSearchDecoderCTC can be passed for language model boosted decoding. See Wav2Vec2ProcessorWithLM for more information. chunk_length_s ( float , optional , defaults to 0) &#x2014; The input length for in each chunk. If chunk_length_s = 0 then chunking is disabled (default). For more information on how to effectively use chunk_length_s , please have a look at the ASR chunking blog post . stride_length_s ( float , optional , defaults to chunk_length_s / 6 ) &#x2014; The length of stride on the left and right of each chunk. Used only with chunk_length_s &gt; 0 . This enables the model to see more context and infer letters better than without this context but the pipeline discards the stride bits at the end to make the final reconstitution as perfect as possible. For more information on how to effectively use stride_length_s , please have a look at the ASR chunking blog post . framework ( str , optional ) &#x2014; The framework to use, either &quot;pt&quot; for PyTorch or &quot;tf&quot; for TensorFlow. The specified framework must be installed. If no framework is specified, will default to the one currently installed. If no framework is specified and both frameworks are installed, will default to the framework of the model , or to PyTorch if no model is provided. device (Union[ int , torch.device ], optional ) &#x2014; Device ordinal for CPU/GPU supports. Setting this to None will leverage CPU, a positive will run the model on the associated CUDA device id. Pipeline that aims at extracting spoken text contained within some audio. The input can be either a raw waveform or a audio file. In case of the audio file, ffmpeg should be installed for to support multiple audio formats Unless the model you’re using explicitly sets these generation parameters in its configuration files ( generation_config.json ), the following default values will be used: max_new_tokens: 256 num_beams: 5 Example: Copied &gt;&gt;&gt; from transformers import pipeline &gt;&gt;&gt; transcriber = pipeline(model= &quot;openai/whisper-base&quot; ) &gt;&gt;&gt; transcriber( &quot;https://huggingface.co/datasets/Narsil/asr_dummy/resolve/main/1.flac&quot; ) { &#x27;text&#x27; : &#x27; He hoped there would be stew for dinner, turnips and carrots and bruised potatoes and fat mutton pieces to be ladled out in thick, peppered flour-fatten sauce.&#x27; } Learn more about the basics of using a pipeline in the pipeline tutorial __call__ &lt; source &gt; ( inputs : typing.Union[numpy.ndarray, bytes, str, dict] **kwargs : typing.Any ) → Dict Parameters inputs ( np.ndarray or bytes or str or dict ) &#x2014; The inputs is either : str that is either the filename of a local audio file, or a public URL address to download the audio file. The file will be read at the correct sampling rate to get the waveform using ffmpeg . This requires ffmpeg to be installed on the system. bytes it is supposed to be the content of an audio file and is interpreted by ffmpeg in the same way. ( np.ndarray of shape (n, ) of type np.float32 or np.float64 ) Raw audio at the correct sampling rate (no further check will be done) dict form can be used to pass raw audio sampled at arbitrary sampling_rate and let this pipeline do the resampling. The dict must be in the format {&quot;sampling_rate&quot;: int, &quot;raw&quot;: np.array} with optionally a &quot;stride&quot;: (left: int, right: int) than can ask the pipeline to treat the first left samples and last right samples to be ignored in decoding (but used at inference to provide more context to the model). Only use stride with CTC models. return_timestamps ( optional , str or bool ) &#x2014; Only available for pure CTC models (Wav2Vec2, HuBERT, etc) and the Whisper model. Not available for other sequence-to-sequence models. For CTC models, timestamps can take one of two formats: &quot;char&quot; : the pipeline will return timestamps along the text for every character in the text. For instance, if you get [{&quot;text&quot;: &quot;h&quot;, &quot;timestamp&quot;: (0.5, 0.6)}, {&quot;text&quot;: &quot;i&quot;, &quot;timestamp&quot;: (0.7, 0.9)}] , then it means the model predicts that the letter &#x201C;h&#x201D; was spoken after 0.5 and before 0.6 seconds. &quot;word&quot; : the pipeline will return timestamps along the text for every word in the text. For instance, if you get [{&quot;text&quot;: &quot;hi &quot;, &quot;timestamp&quot;: (0.5, 0.9)}, {&quot;text&quot;: &quot;there&quot;, &quot;timestamp&quot;: (1.0, 1.5)}] , then it means the model predicts that the word &#x201C;hi&#x201D; was spoken after 0.5 and before 0.9 seconds. For the Whisper model, timestamps can take one of two formats: &quot;word&quot; : same as above for word-level CTC timestamps. Word-level timestamps are predicted through the dynamic-time warping (DTW) algorithm, an approximation to word-level timestamps by inspecting the cross-attention weights. True : the pipeline will return timestamps along the text for segments of words in the text. For instance, if you get [{&quot;text&quot;: &quot; Hi there!&quot;, &quot;timestamp&quot;: (0.5, 1.5)}] , then it means the model predicts that the segment &#x201C;Hi there!&#x201D; was spoken after 0.5 and before 1.5 seconds. Note that a segment of text refers to a sequence of one or more words, rather than individual words as with word-level timestamps. generate_kwargs ( dict , optional ) &#x2014; The dictionary of ad-hoc parametrization of generate_config to be used for the generation call. For a complete overview of generate, check the following guide . Returns Dict A dictionary with the following keys: text ( str ): The recognized text. chunks ( optional(, list[Dict] ) When using return_timestamps , the chunks will become a list containing all the various text chunks identified by the model, e.g.* [&#123;\"text\": \"hi \", \"timestamp\": (0.5, 0.9)&#125;, &#123;\"text\": \"there\", \"timestamp\": (1.0, 1.5)&#125;] . The original full text can roughly be recovered by doing \"\".join(chunk[\"text\"] for chunk in output[\"chunks\"]) . Transcribe the audio sequence(s) given as inputs to text. See the AutomaticSpeechRecognitionPipeline documentation for more information. TextToAudioPipeline class transformers. TextToAudioPipeline &lt; source &gt; ( *args vocoder = None sampling_rate = None no_processor = True **kwargs ) Text-to-audio generation pipeline using any AutoModelForTextToWaveform or AutoModelForTextToSpectrogram . This pipeline generates an audio file from an input text and optional other conditional inputs. Unless the model you’re using explicitly sets these generation parameters in its configuration files ( generation_config.json ), the following default values will be used: max_new_tokens: 256 Example: Copied &gt;&gt;&gt; from transformers import pipeline &gt;&gt;&gt; pipe = pipeline(model= &quot;suno/bark-small&quot; ) &gt;&gt;&gt; output = pipe( &quot;Hey it&#x27;s HuggingFace on the phone!&quot; ) &gt;&gt;&gt; audio = output[ &quot;audio&quot; ] &gt;&gt;&gt; sampling_rate = output[ &quot;sampling_rate&quot; ] Learn more about the basics of using a pipeline in the pipeline tutorial You can specify parameters passed to the model by using TextToAudioPipeline.__call__.forward_params or TextToAudioPipeline.__call__.generate_kwargs . Example: Copied &gt;&gt;&gt; from transformers import pipeline &gt;&gt;&gt; music_generator = pipeline(task= &quot;text-to-audio&quot; , model= &quot;facebook/musicgen-small&quot; , framework= &quot;pt&quot; ) &gt;&gt;&gt; # diversify the music generation by adding randomness with a high temperature and set a maximum music length &gt;&gt;&gt; generate_kwargs = { ... &quot;do_sample&quot; : True , ... &quot;temperature&quot; : 0.7 , ... &quot;max_new_tokens&quot; : 35 , ... } &gt;&gt;&gt; outputs = music_generator( &quot;Techno music with high melodic riffs&quot; , generate_kwargs=generate_kwargs) This pipeline can currently be loaded from pipeline() using the following task identifiers: &quot;text-to-speech&quot; or &quot;text-to-audio&quot; . See the list of available models on huggingface.co/models . __call__ &lt; source &gt; ( text_inputs : typing.Union[str, list[str]] **forward_params ) → A dict or a list of dict Parameters text_inputs ( str or list[str] ) &#x2014; The text(s) to generate. forward_params ( dict , optional ) &#x2014; Parameters passed to the model generation/forward method. forward_params are always passed to the underlying model. generate_kwargs ( dict , optional ) &#x2014; The dictionary of ad-hoc parametrization of generate_config to be used for the generation call. For a complete overview of generate, check the following guide . generate_kwargs are only passed to the underlying model if the latter is a generative model. Returns A dict or a list of dict The dictionaries have two keys: audio ( np.ndarray of shape (nb_channels, audio_length) ) — The generated audio waveform. sampling_rate ( int ) — The sampling rate of the generated audio waveform. Generates speech/audio from the inputs. See the TextToAudioPipeline documentation for more information. ZeroShotAudioClassificationPipeline class transformers. ZeroShotAudioClassificationPipeline &lt; source &gt; ( **kwargs ) Parameters model ( PreTrainedModel or TFPreTrainedModel ) &#x2014; The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from PreTrainedModel for PyTorch and TFPreTrainedModel for TensorFlow. tokenizer ( PreTrainedTokenizer ) &#x2014; The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from PreTrainedTokenizer . feature_extractor ( SequenceFeatureExtractor ) &#x2014; The feature extractor that will be used by the pipeline to encode data for the model. This object inherits from SequenceFeatureExtractor . modelcard ( str or ModelCard , optional ) &#x2014; Model card attributed to the model for this pipeline. framework ( str , optional ) &#x2014; The framework to use, either &quot;pt&quot; for PyTorch or &quot;tf&quot; for TensorFlow. The specified framework must be installed. If no framework is specified, will default to the one currently installed. If no framework is specified and both frameworks are installed, will default to the framework of the model , or to PyTorch if no model is provided. task ( str , defaults to &quot;&quot; ) &#x2014; A task-identifier for the pipeline. num_workers ( int , optional , defaults to 8) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the number of workers to be used. batch_size ( int , optional , defaults to 1) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the size of the batch to use, for inference this is not always beneficial, please read Batching with pipelines . args_parser ( ArgumentHandler , optional ) &#x2014; Reference to the object in charge of parsing supplied pipeline parameters. device ( int , optional , defaults to -1) &#x2014; Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on the associated CUDA device id. You can pass native torch.device or a str too dtype ( str or torch.dtype , optional ) &#x2014; Sent directly as model_kwargs (just a simpler shortcut) to use the available precision for this model ( torch.float16 , torch.bfloat16 , &#x2026; or &quot;auto&quot; ) binary_output ( bool , optional , defaults to False ) &#x2014; Flag indicating if the output the pipeline should happen in a serialized format (i.e., pickle) or as the raw output data e.g. text. Zero shot audio classification pipeline using ClapModel . This pipeline predicts the class of an audio when you provide an audio and a set of candidate_labels . The default hypothesis_template is : &quot;This is a sound of {}.&quot; . Make sure you update it for your usage. Example: Copied &gt;&gt;&gt; from transformers import pipeline &gt;&gt;&gt; from datasets import load_dataset &gt;&gt;&gt; dataset = load_dataset( &quot;ashraq/esc50&quot; ) &gt;&gt;&gt; audio = next ( iter (dataset[ &quot;train&quot; ][ &quot;audio&quot; ]))[ &quot;array&quot; ] &gt;&gt;&gt; classifier = pipeline(task= &quot;zero-shot-audio-classification&quot; , model= &quot;laion/clap-htsat-unfused&quot; ) &gt;&gt;&gt; classifier(audio, candidate_labels=[ &quot;Sound of a dog&quot; , &quot;Sound of vacuum cleaner&quot; ]) [{ &#x27;score&#x27; : 0.9996 , &#x27;label&#x27; : &#x27;Sound of a dog&#x27; }, { &#x27;score&#x27; : 0.0004 , &#x27;label&#x27; : &#x27;Sound of vaccum cleaner&#x27; }] Learn more about the basics of using a pipeline in the pipeline tutorial This audio classification pipeline can currently be loaded from pipeline() using the following task identifier: &quot;zero-shot-audio-classification&quot; . See the list of available models on huggingface.co/models . __call__ &lt; source &gt; ( audios : typing.Union[numpy.ndarray, bytes, str, dict] **kwargs : typing.Any ) Parameters audios ( str , list[str] , np.array or list[np.array] ) &#x2014; The pipeline handles three types of inputs: A string containing a http link pointing to an audio A string containing a local path to an audio An audio loaded in numpy candidate_labels ( list[str] ) &#x2014; The candidate labels for this audio. They will be formatted using hypothesis_template . hypothesis_template ( str , optional , defaults to &quot;This is a sound of {}&quot; ) &#x2014; The format used in conjunction with candidate_labels to attempt the audio classification by replacing the placeholder with the candidate_labels. Pass &#x201D;{}&#x201D; if candidate_labels are already formatted. Assign labels to the audio(s) passed as inputs. Computer vision Pipelines available for computer vision tasks include the following. DepthEstimationPipeline class transformers. DepthEstimationPipeline &lt; source &gt; ( *args **kwargs ) Parameters model ( PreTrainedModel or TFPreTrainedModel ) &#x2014; The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from PreTrainedModel for PyTorch and TFPreTrainedModel for TensorFlow. image_processor ( BaseImageProcessor ) &#x2014; The image processor that will be used by the pipeline to encode data for the model. This object inherits from BaseImageProcessor . modelcard ( str or ModelCard , optional ) &#x2014; Model card attributed to the model for this pipeline. framework ( str , optional ) &#x2014; The framework to use, either &quot;pt&quot; for PyTorch or &quot;tf&quot; for TensorFlow. The specified framework must be installed. If no framework is specified, will default to the one currently installed. If no framework is specified and both frameworks are installed, will default to the framework of the model , or to PyTorch if no model is provided. task ( str , defaults to &quot;&quot; ) &#x2014; A task-identifier for the pipeline. num_workers ( int , optional , defaults to 8) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the number of workers to be used. batch_size ( int , optional , defaults to 1) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the size of the batch to use, for inference this is not always beneficial, please read Batching with pipelines . args_parser ( ArgumentHandler , optional ) &#x2014; Reference to the object in charge of parsing supplied pipeline parameters. device ( int , optional , defaults to -1) &#x2014; Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on the associated CUDA device id. You can pass native torch.device or a str too dtype ( str or torch.dtype , optional ) &#x2014; Sent directly as model_kwargs (just a simpler shortcut) to use the available precision for this model ( torch.float16 , torch.bfloat16 , &#x2026; or &quot;auto&quot; ) binary_output ( bool , optional , defaults to False ) &#x2014; Flag indicating if the output the pipeline should happen in a serialized format (i.e., pickle) or as the raw output data e.g. text. Depth estimation pipeline using any AutoModelForDepthEstimation . This pipeline predicts the depth of an image. Example: Copied &gt;&gt;&gt; from transformers import pipeline &gt;&gt;&gt; depth_estimator = pipeline(task= &quot;depth-estimation&quot; , model= &quot;LiheYoung/depth-anything-base-hf&quot; ) &gt;&gt;&gt; output = depth_estimator( &quot;http://images.cocodataset.org/val2017/000000039769.jpg&quot; ) &gt;&gt;&gt; # This is a tensor with the values being the depth expressed in meters for each pixel &gt;&gt;&gt; output[ &quot;predicted_depth&quot; ].shape torch.Size([ 1 , 384 , 384 ]) Learn more about the basics of using a pipeline in the pipeline tutorial This depth estimation pipeline can currently be loaded from pipeline() using the following task identifier: &quot;depth-estimation&quot; . See the list of available models on huggingface.co/models . __call__ &lt; source &gt; ( inputs : typing.Union[str, list[str], ForwardRef('Image.Image'), list['Image.Image']] **kwargs : typing.Any ) Parameters inputs ( str , list[str] , PIL.Image or list[PIL.Image] ) &#x2014; The pipeline handles three types of images: A string containing a http link pointing to an image A string containing a local path to an image An image loaded in PIL directly The pipeline accepts either a single image or a batch of images, which must then be passed as a string. Images in a batch must all be in the same format: all as http links, all as local paths, or all as PIL images. parameters ( Dict , optional ) &#x2014; A dictionary of argument names to parameter values, to control pipeline behaviour. The only parameter available right now is timeout , which is the length of time, in seconds, that the pipeline should wait before giving up on trying to download an image. timeout ( float , optional , defaults to None) &#x2014; The maximum time in seconds to wait for fetching images from the web. If None, no timeout is set and the call may block forever. Predict the depth(s) of the image(s) passed as inputs. ImageClassificationPipeline class transformers. ImageClassificationPipeline &lt; source &gt; ( *args **kwargs ) Parameters model ( PreTrainedModel or TFPreTrainedModel ) &#x2014; The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from PreTrainedModel for PyTorch and TFPreTrainedModel for TensorFlow. image_processor ( BaseImageProcessor ) &#x2014; The image processor that will be used by the pipeline to encode data for the model. This object inherits from BaseImageProcessor . modelcard ( str or ModelCard , optional ) &#x2014; Model card attributed to the model for this pipeline. framework ( str , optional ) &#x2014; The framework to use, either &quot;pt&quot; for PyTorch or &quot;tf&quot; for TensorFlow. The specified framework must be installed. If no framework is specified, will default to the one currently installed. If no framework is specified and both frameworks are installed, will default to the framework of the model , or to PyTorch if no model is provided. task ( str , defaults to &quot;&quot; ) &#x2014; A task-identifier for the pipeline. num_workers ( int , optional , defaults to 8) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the number of workers to be used. batch_size ( int , optional , defaults to 1) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the size of the batch to use, for inference this is not always beneficial, please read Batching with pipelines . args_parser ( ArgumentHandler , optional ) &#x2014; Reference to the object in charge of parsing supplied pipeline parameters. device ( int , optional , defaults to -1) &#x2014; Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on the associated CUDA device id. You can pass native torch.device or a str too dtype ( str or torch.dtype , optional ) &#x2014; Sent directly as model_kwargs (just a simpler shortcut) to use the available precision for this model ( torch.float16 , torch.bfloat16 , &#x2026; or &quot;auto&quot; ) binary_output ( bool , optional , defaults to False ) &#x2014; Flag indicating if the output the pipeline should happen in a serialized format (i.e., pickle) or as the raw output data e.g. text. function_to_apply ( str , optional , defaults to &quot;default&quot; ) &#x2014; The function to apply to the model outputs in order to retrieve the scores. Accepts four different values: &quot;default&quot; : if the model has a single label, will apply the sigmoid function on the output. If the model has several labels, will apply the softmax function on the output. &quot;sigmoid&quot; : Applies the sigmoid function on the output. &quot;softmax&quot; : Applies the softmax function on the output. &quot;none&quot; : Does not apply any function on the output. Image classification pipeline using any AutoModelForImageClassification . This pipeline predicts the class of an image. Example: Copied &gt;&gt;&gt; from transformers import pipeline &gt;&gt;&gt; classifier = pipeline(model= &quot;microsoft/beit-base-patch16-224-pt22k-ft22k&quot; ) &gt;&gt;&gt; classifier( &quot;https://huggingface.co/datasets/Narsil/image_dummy/raw/main/parrots.png&quot; ) [{ &#x27;score&#x27; : 0.442 , &#x27;label&#x27; : &#x27;macaw&#x27; }, { &#x27;score&#x27; : 0.088 , &#x27;label&#x27; : &#x27;popinjay&#x27; }, { &#x27;score&#x27; : 0.075 , &#x27;label&#x27; : &#x27;parrot&#x27; }, { &#x27;score&#x27; : 0.073 , &#x27;label&#x27; : &#x27;parodist, lampooner&#x27; }, { &#x27;score&#x27; : 0.046 , &#x27;label&#x27; : &#x27;poll, poll_parrot&#x27; }] Learn more about the basics of using a pipeline in the pipeline tutorial This image classification pipeline can currently be loaded from pipeline() using the following task identifier: &quot;image-classification&quot; . See the list of available models on huggingface.co/models . __call__ &lt; source &gt; ( inputs : typing.Union[str, list[str], ForwardRef('Image.Image'), list['Image.Image']] **kwargs : typing.Any ) Parameters inputs ( str , list[str] , PIL.Image or list[PIL.Image] ) &#x2014; The pipeline handles three types of images: A string containing a http link pointing to an image A string containing a local path to an image An image loaded in PIL directly The pipeline accepts either a single image or a batch of images, which must then be passed as a string. Images in a batch must all be in the same format: all as http links, all as local paths, or all as PIL images. function_to_apply ( str , optional , defaults to &quot;default&quot; ) &#x2014; The function to apply to the model outputs in order to retrieve the scores. Accepts four different values: If this argument is not specified, then it will apply the following functions according to the number of labels: If the model has a single label, will apply the sigmoid function on the output. If the model has several labels, will apply the softmax function on the output. Possible values are: &quot;sigmoid&quot; : Applies the sigmoid function on the output. &quot;softmax&quot; : Applies the softmax function on the output. &quot;none&quot; : Does not apply any function on the output. top_k ( int , optional , defaults to 5) &#x2014; The number of top labels that will be returned by the pipeline. If the provided number is higher than the number of labels available in the model configuration, it will default to the number of labels. timeout ( float , optional , defaults to None) &#x2014; The maximum time in seconds to wait for fetching images from the web. If None, no timeout is set and the call may block forever. Assign labels to the image(s) passed as inputs. ImageSegmentationPipeline class transformers. ImageSegmentationPipeline &lt; source &gt; ( *args **kwargs ) Parameters model ( PreTrainedModel or TFPreTrainedModel ) &#x2014; The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from PreTrainedModel for PyTorch and TFPreTrainedModel for TensorFlow. image_processor ( BaseImageProcessor ) &#x2014; The image processor that will be used by the pipeline to encode data for the model. This object inherits from BaseImageProcessor . modelcard ( str or ModelCard , optional ) &#x2014; Model card attributed to the model for this pipeline. framework ( str , optional ) &#x2014; The framework to use, either &quot;pt&quot; for PyTorch or &quot;tf&quot; for TensorFlow. The specified framework must be installed. If no framework is specified, will default to the one currently installed. If no framework is specified and both frameworks are installed, will default to the framework of the model , or to PyTorch if no model is provided. task ( str , defaults to &quot;&quot; ) &#x2014; A task-identifier for the pipeline. num_workers ( int , optional , defaults to 8) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the number of workers to be used. batch_size ( int , optional , defaults to 1) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the size of the batch to use, for inference this is not always beneficial, please read Batching with pipelines . args_parser ( ArgumentHandler , optional ) &#x2014; Reference to the object in charge of parsing supplied pipeline parameters. device ( int , optional , defaults to -1) &#x2014; Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on the associated CUDA device id. You can pass native torch.device or a str too dtype ( str or torch.dtype , optional ) &#x2014; Sent directly as model_kwargs (just a simpler shortcut) to use the available precision for this model ( torch.float16 , torch.bfloat16 , &#x2026; or &quot;auto&quot; ) binary_output ( bool , optional , defaults to False ) &#x2014; Flag indicating if the output the pipeline should happen in a serialized format (i.e., pickle) or as the raw output data e.g. text. Image segmentation pipeline using any AutoModelForXXXSegmentation . This pipeline predicts masks of objects and their classes. Example: Copied &gt;&gt;&gt; from transformers import pipeline &gt;&gt;&gt; segmenter = pipeline(model= &quot;facebook/detr-resnet-50-panoptic&quot; ) &gt;&gt;&gt; segments = segmenter( &quot;https://huggingface.co/datasets/Narsil/image_dummy/raw/main/parrots.png&quot; ) &gt;&gt;&gt; len (segments) 2 &gt;&gt;&gt; segments[ 0 ][ &quot;label&quot; ] &#x27;bird&#x27; &gt;&gt;&gt; segments[ 1 ][ &quot;label&quot; ] &#x27;bird&#x27; &gt;&gt;&gt; type (segments[ 0 ][ &quot;mask&quot; ]) # This is a black and white mask showing where is the bird on the original image. &lt; class &#x27;PIL.Image.Image&#x27; &gt; &gt;&gt;&gt; segments[ 0 ][ &quot;mask&quot; ].size ( 768 , 512 ) This image segmentation pipeline can currently be loaded from pipeline() using the following task identifier: &quot;image-segmentation&quot; . See the list of available models on huggingface.co/models . __call__ &lt; source &gt; ( inputs : typing.Union[str, ForwardRef('Image.Image'), list[str], list['Image.Image']] **kwargs : typing.Any ) Parameters inputs ( str , list[str] , PIL.Image or list[PIL.Image] ) &#x2014; The pipeline handles three types of images: A string containing an HTTP(S) link pointing to an image A string containing a local path to an image An image loaded in PIL directly The pipeline accepts either a single image or a batch of images. Images in a batch must all be in the same format: all as HTTP(S) links, all as local paths, or all as PIL images. subtask ( str , optional ) &#x2014; Segmentation task to be performed, choose [ semantic , instance and panoptic ] depending on model capabilities. If not set, the pipeline will attempt tp resolve in the following order: panoptic , instance , semantic . threshold ( float , optional , defaults to 0.9) &#x2014; Probability threshold to filter out predicted masks. mask_threshold ( float , optional , defaults to 0.5) &#x2014; Threshold to use when turning the predicted masks into binary values. overlap_mask_area_threshold ( float , optional , defaults to 0.5) &#x2014; Mask overlap threshold to eliminate small, disconnected segments. timeout ( float , optional , defaults to None) &#x2014; The maximum time in seconds to wait for fetching images from the web. If None, no timeout is set and the call may block forever. Perform segmentation (detect masks &amp; classes) in the image(s) passed as inputs. ImageToImagePipeline class transformers. ImageToImagePipeline &lt; source &gt; ( *args **kwargs ) Parameters model ( PreTrainedModel or TFPreTrainedModel ) &#x2014; The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from PreTrainedModel for PyTorch and TFPreTrainedModel for TensorFlow. image_processor ( BaseImageProcessor ) &#x2014; The image processor that will be used by the pipeline to encode data for the model. This object inherits from BaseImageProcessor . modelcard ( str or ModelCard , optional ) &#x2014; Model card attributed to the model for this pipeline. framework ( str , optional ) &#x2014; The framework to use, either &quot;pt&quot; for PyTorch or &quot;tf&quot; for TensorFlow. The specified framework must be installed. If no framework is specified, will default to the one currently installed. If no framework is specified and both frameworks are installed, will default to the framework of the model , or to PyTorch if no model is provided. task ( str , defaults to &quot;&quot; ) &#x2014; A task-identifier for the pipeline. num_workers ( int , optional , defaults to 8) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the number of workers to be used. batch_size ( int , optional , defaults to 1) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the size of the batch to use, for inference this is not always beneficial, please read Batching with pipelines . args_parser ( ArgumentHandler , optional ) &#x2014; Reference to the object in charge of parsing supplied pipeline parameters. device ( int , optional , defaults to -1) &#x2014; Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on the associated CUDA device id. You can pass native torch.device or a str too dtype ( str or torch.dtype , optional ) &#x2014; Sent directly as model_kwargs (just a simpler shortcut) to use the available precision for this model ( torch.float16 , torch.bfloat16 , &#x2026; or &quot;auto&quot; ) binary_output ( bool , optional , defaults to False ) &#x2014; Flag indicating if the output the pipeline should happen in a serialized format (i.e., pickle) or as the raw output data e.g. text. Image to Image pipeline using any AutoModelForImageToImage . This pipeline generates an image based on a previous image input. Example: Copied &gt;&gt;&gt; from PIL import Image &gt;&gt;&gt; import requests &gt;&gt;&gt; from transformers import pipeline &gt;&gt;&gt; upscaler = pipeline( &quot;image-to-image&quot; , model= &quot;caidas/swin2SR-classical-sr-x2-64&quot; ) &gt;&gt;&gt; img = Image. open (requests.get( &quot;http://images.cocodataset.org/val2017/000000039769.jpg&quot; , stream= True ).raw) &gt;&gt;&gt; img = img.resize(( 64 , 64 )) &gt;&gt;&gt; upscaled_img = upscaler(img) &gt;&gt;&gt; img.size ( 64 , 64 ) &gt;&gt;&gt; upscaled_img.size ( 144 , 144 ) This image to image pipeline can currently be loaded from pipeline() using the following task identifier: &quot;image-to-image&quot; . See the list of available models on huggingface.co/models . __call__ &lt; source &gt; ( images : typing.Union[str, list[str], ForwardRef('Image.Image'), list['Image.Image']] **kwargs : typing.Any ) Parameters images ( str , list[str] , PIL.Image or list[PIL.Image] ) &#x2014; The pipeline handles three types of images: A string containing a http link pointing to an image A string containing a local path to an image An image loaded in PIL directly The pipeline accepts either a single image or a batch of images, which must then be passed as a string. Images in a batch must all be in the same format: all as http links, all as local paths, or all as PIL images. timeout ( float , optional , defaults to None) &#x2014; The maximum time in seconds to wait for fetching images from the web. If None, no timeout is used and the call may block forever. Transform the image(s) passed as inputs. KeypointMatchingPipeline class transformers. KeypointMatchingPipeline &lt; source &gt; ( *args **kwargs ) Keypoint matching pipeline using any AutoModelForKeypointMatching . This pipeline matches keypoints between two images. __call__ &lt; source &gt; ( inputs : typing.Union[list[typing.Sequence[typing.Union[ForwardRef('Image.Image'), str]]], typing.Sequence[typing.Union[ForwardRef('Image.Image'), str]]] threshold : float = 0.0 **kwargs : typing.Any ) → Union[list[Match], list[list[Match]]] Parameters inputs ( str , list[str] , PIL.Image or list[PIL.Image] ) &#x2014; The pipeline handles three types of images: A string containing a http link pointing to an image A string containing a local path to an image An image loaded in PIL directly The pipeline accepts either a single pair of images or a batch of image pairs, which must then be passed as a string. Images in a batch must all be in the same format: all as http links, all as local paths, or all as PIL images. threshold ( float , optional , defaults to 0.0) &#x2014; The threshold to use for keypoint matching. Keypoints matched with a lower matching score will be filtered out. A value of 0 means that all matched keypoints will be returned. kwargs &#x2014; timeout ( float , *optional*, defaults to None) The maximum time in seconds to wait for fetching images from the web. If None, no timeout is set and the call may block forever. Returns Union[list[Match], list[list[Match]]] A list of matches or a list if a single image pair is provided, or of lists of matches if a batch of image pairs is provided. Each match is a dictionary containing the following keys: keypoint_image_0 ( Keypoint ): The keypoint in the first image (x, y coordinates). keypoint_image_1 ( Keypoint ): The keypoint in the second image (x, y coordinates). score ( float ): The matching score between the two keypoints. Find matches between keypoints in two images. ObjectDetectionPipeline class transformers. ObjectDetectionPipeline &lt; source &gt; ( *args **kwargs ) Parameters model ( PreTrainedModel or TFPreTrainedModel ) &#x2014; The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from PreTrainedModel for PyTorch and TFPreTrainedModel for TensorFlow. image_processor ( BaseImageProcessor ) &#x2014; The image processor that will be used by the pipeline to encode data for the model. This object inherits from BaseImageProcessor . modelcard ( str or ModelCard , optional ) &#x2014; Model card attributed to the model for this pipeline. framework ( str , optional ) &#x2014; The framework to use, either &quot;pt&quot; for PyTorch or &quot;tf&quot; for TensorFlow. The specified framework must be installed. If no framework is specified, will default to the one currently installed. If no framework is specified and both frameworks are installed, will default to the framework of the model , or to PyTorch if no model is provided. task ( str , defaults to &quot;&quot; ) &#x2014; A task-identifier for the pipeline. num_workers ( int , optional , defaults to 8) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the number of workers to be used. batch_size ( int , optional , defaults to 1) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the size of the batch to use, for inference this is not always beneficial, please read Batching with pipelines . args_parser ( ArgumentHandler , optional ) &#x2014; Reference to the object in charge of parsing supplied pipeline parameters. device ( int , optional , defaults to -1) &#x2014; Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on the associated CUDA device id. You can pass native torch.device or a str too dtype ( str or torch.dtype , optional ) &#x2014; Sent directly as model_kwargs (just a simpler shortcut) to use the available precision for this model ( torch.float16 , torch.bfloat16 , &#x2026; or &quot;auto&quot; ) binary_output ( bool , optional , defaults to False ) &#x2014; Flag indicating if the output the pipeline should happen in a serialized format (i.e., pickle) or as the raw output data e.g. text. Object detection pipeline using any AutoModelForObjectDetection . This pipeline predicts bounding boxes of objects and their classes. Example: Copied &gt;&gt;&gt; from transformers import pipeline &gt;&gt;&gt; detector = pipeline(model= &quot;facebook/detr-resnet-50&quot; ) &gt;&gt;&gt; detector( &quot;https://huggingface.co/datasets/Narsil/image_dummy/raw/main/parrots.png&quot; ) [{ &#x27;score&#x27; : 0.997 , &#x27;label&#x27; : &#x27;bird&#x27; , &#x27;box&#x27; : { &#x27;xmin&#x27; : 69 , &#x27;ymin&#x27; : 171 , &#x27;xmax&#x27; : 396 , &#x27;ymax&#x27; : 507 }}, { &#x27;score&#x27; : 0.999 , &#x27;label&#x27; : &#x27;bird&#x27; , &#x27;box&#x27; : { &#x27;xmin&#x27; : 398 , &#x27;ymin&#x27; : 105 , &#x27;xmax&#x27; : 767 , &#x27;ymax&#x27; : 507 }}] &gt;&gt;&gt; # x, y are expressed relative to the top left hand corner. Learn more about the basics of using a pipeline in the pipeline tutorial This object detection pipeline can currently be loaded from pipeline() using the following task identifier: &quot;object-detection&quot; . See the list of available models on huggingface.co/models . __call__ &lt; source &gt; ( *args **kwargs ) Parameters inputs ( str , list[str] , PIL.Image or list[PIL.Image] ) &#x2014; The pipeline handles three types of images: A string containing an HTTP(S) link pointing to an image A string containing a local path to an image An image loaded in PIL directly The pipeline accepts either a single image or a batch of images. Images in a batch must all be in the same format: all as HTTP(S) links, all as local paths, or all as PIL images. threshold ( float , optional , defaults to 0.5) &#x2014; The probability necessary to make a prediction. timeout ( float , optional , defaults to None) &#x2014; The maximum time in seconds to wait for fetching images from the web. If None, no timeout is set and the call may block forever. Detect objects (bounding boxes &amp; classes) in the image(s) passed as inputs. VideoClassificationPipeline class transformers. VideoClassificationPipeline &lt; source &gt; ( *args **kwargs ) Parameters model ( PreTrainedModel or TFPreTrainedModel ) &#x2014; The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from PreTrainedModel for PyTorch and TFPreTrainedModel for TensorFlow. image_processor ( BaseImageProcessor ) &#x2014; The image processor that will be used by the pipeline to encode data for the model. This object inherits from BaseImageProcessor . modelcard ( str or ModelCard , optional ) &#x2014; Model card attributed to the model for this pipeline. framework ( str , optional ) &#x2014; The framework to use, either &quot;pt&quot; for PyTorch or &quot;tf&quot; for TensorFlow. The specified framework must be installed. If no framework is specified, will default to the one currently installed. If no framework is specified and both frameworks are installed, will default to the framework of the model , or to PyTorch if no model is provided. task ( str , defaults to &quot;&quot; ) &#x2014; A task-identifier for the pipeline. num_workers ( int , optional , defaults to 8) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the number of workers to be used. batch_size ( int , optional , defaults to 1) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the size of the batch to use, for inference this is not always beneficial, please read Batching with pipelines . args_parser ( ArgumentHandler , optional ) &#x2014; Reference to the object in charge of parsing supplied pipeline parameters. device ( int , optional , defaults to -1) &#x2014; Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on the associated CUDA device id. You can pass native torch.device or a str too dtype ( str or torch.dtype , optional ) &#x2014; Sent directly as model_kwargs (just a simpler shortcut) to use the available precision for this model ( torch.float16 , torch.bfloat16 , &#x2026; or &quot;auto&quot; ) binary_output ( bool , optional , defaults to False ) &#x2014; Flag indicating if the output the pipeline should happen in a serialized format (i.e., pickle) or as the raw output data e.g. text. Video classification pipeline using any AutoModelForVideoClassification . This pipeline predicts the class of a video. This video classification pipeline can currently be loaded from pipeline() using the following task identifier: &quot;video-classification&quot; . See the list of available models on huggingface.co/models . __call__ &lt; source &gt; ( inputs : typing.Union[str, list[str], NoneType] = None **kwargs ) Parameters inputs ( str , list[str] ) &#x2014; The pipeline handles three types of videos: A string containing a http link pointing to a video A string containing a local path to a video The pipeline accepts either a single video or a batch of videos, which must then be passed as a string. Videos in a batch must all be in the same format: all as http links or all as local paths. top_k ( int , optional , defaults to 5) &#x2014; The number of top labels that will be returned by the pipeline. If the provided number is higher than the number of labels available in the model configuration, it will default to the number of labels. num_frames ( int , optional , defaults to self.model.config.num_frames ) &#x2014; The number of frames sampled from the video to run the classification on. If not provided, will default to the number of frames specified in the model configuration. frame_sampling_rate ( int , optional , defaults to 1) &#x2014; The sampling rate used to select frames from the video. If not provided, will default to 1, i.e. every frame will be used. function_to_apply( str , optional , defaults to &#x201C;softmax&#x201D;) &#x2014; The function to apply to the model output. By default, the pipeline will apply the softmax function to the output of the model. Valid options: [&#x201C;softmax&#x201D;, &#x201C;sigmoid&#x201D;, &#x201C;none&#x201D;]. Note that passing Python&#x2019;s built-in None will default to &#x201C;softmax&#x201D;, so you need to pass the string &#x201C;none&#x201D; to disable any post-processing. Assign labels to the video(s) passed as inputs. ZeroShotImageClassificationPipeline class transformers. ZeroShotImageClassificationPipeline &lt; source &gt; ( **kwargs ) Parameters model ( PreTrainedModel or TFPreTrainedModel ) &#x2014; The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from PreTrainedModel for PyTorch and TFPreTrainedModel for TensorFlow. image_processor ( BaseImageProcessor ) &#x2014; The image processor that will be used by the pipeline to encode data for the model. This object inherits from BaseImageProcessor . modelcard ( str or ModelCard , optional ) &#x2014; Model card attributed to the model for this pipeline. framework ( str , optional ) &#x2014; The framework to use, either &quot;pt&quot; for PyTorch or &quot;tf&quot; for TensorFlow. The specified framework must be installed. If no framework is specified, will default to the one currently installed. If no framework is specified and both frameworks are installed, will default to the framework of the model , or to PyTorch if no model is provided. task ( str , defaults to &quot;&quot; ) &#x2014; A task-identifier for the pipeline. num_workers ( int , optional , defaults to 8) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the number of workers to be used. batch_size ( int , optional , defaults to 1) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the size of the batch to use, for inference this is not always beneficial, please read Batching with pipelines . args_parser ( ArgumentHandler , optional ) &#x2014; Reference to the object in charge of parsing supplied pipeline parameters. device ( int , optional , defaults to -1) &#x2014; Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on the associated CUDA device id. You can pass native torch.device or a str too dtype ( str or torch.dtype , optional ) &#x2014; Sent directly as model_kwargs (just a simpler shortcut) to use the available precision for this model ( torch.float16 , torch.bfloat16 , &#x2026; or &quot;auto&quot; ) binary_output ( bool , optional , defaults to False ) &#x2014; Flag indicating if the output the pipeline should happen in a serialized format (i.e., pickle) or as the raw output data e.g. text. Zero shot image classification pipeline using CLIPModel . This pipeline predicts the class of an image when you provide an image and a set of candidate_labels . Example: Copied &gt;&gt;&gt; from transformers import pipeline &gt;&gt;&gt; classifier = pipeline(model= &quot;google/siglip-so400m-patch14-384&quot; ) &gt;&gt;&gt; classifier( ... &quot;https://huggingface.co/datasets/Narsil/image_dummy/raw/main/parrots.png&quot; , ... candidate_labels=[ &quot;animals&quot; , &quot;humans&quot; , &quot;landscape&quot; ], ... ) [{ &#x27;score&#x27; : 0.965 , &#x27;label&#x27; : &#x27;animals&#x27; }, { &#x27;score&#x27; : 0.03 , &#x27;label&#x27; : &#x27;humans&#x27; }, { &#x27;score&#x27; : 0.005 , &#x27;label&#x27; : &#x27;landscape&#x27; }] &gt;&gt;&gt; classifier( ... &quot;https://huggingface.co/datasets/Narsil/image_dummy/raw/main/parrots.png&quot; , ... candidate_labels=[ &quot;black and white&quot; , &quot;photorealist&quot; , &quot;painting&quot; ], ... ) [{ &#x27;score&#x27; : 0.996 , &#x27;label&#x27; : &#x27;black and white&#x27; }, { &#x27;score&#x27; : 0.003 , &#x27;label&#x27; : &#x27;photorealist&#x27; }, { &#x27;score&#x27; : 0.0 , &#x27;label&#x27; : &#x27;painting&#x27; }] Learn more about the basics of using a pipeline in the pipeline tutorial This image classification pipeline can currently be loaded from pipeline() using the following task identifier: &quot;zero-shot-image-classification&quot; . See the list of available models on huggingface.co/models . __call__ &lt; source &gt; ( image : typing.Union[str, list[str], ForwardRef('Image.Image'), list['Image.Image']] candidate_labels : list **kwargs : typing.Any ) Parameters image ( str , list[str] , PIL.Image or list[PIL.Image] ) &#x2014; The pipeline handles three types of images: A string containing a http link pointing to an image A string containing a local path to an image An image loaded in PIL directly candidate_labels ( list[str] ) &#x2014; The candidate labels for this image. They will be formatted using hypothesis_template . hypothesis_template ( str , optional , defaults to &quot;This is a photo of {}&quot; ) &#x2014; The format used in conjunction with candidate_labels to attempt the image classification by replacing the placeholder with the candidate_labels. Pass &#x201D;{}&#x201D; if candidate_labels are already formatted. timeout ( float , optional , defaults to None) &#x2014; The maximum time in seconds to wait for fetching images from the web. If None, no timeout is set and the call may block forever. Assign labels to the image(s) passed as inputs. ZeroShotObjectDetectionPipeline class transformers. ZeroShotObjectDetectionPipeline &lt; source &gt; ( **kwargs ) Parameters model ( PreTrainedModel or TFPreTrainedModel ) &#x2014; The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from PreTrainedModel for PyTorch and TFPreTrainedModel for TensorFlow. image_processor ( BaseImageProcessor ) &#x2014; The image processor that will be used by the pipeline to encode data for the model. This object inherits from BaseImageProcessor . modelcard ( str or ModelCard , optional ) &#x2014; Model card attributed to the model for this pipeline. framework ( str , optional ) &#x2014; The framework to use, either &quot;pt&quot; for PyTorch or &quot;tf&quot; for TensorFlow. The specified framework must be installed. If no framework is specified, will default to the one currently installed. If no framework is specified and both frameworks are installed, will default to the framework of the model , or to PyTorch if no model is provided. task ( str , defaults to &quot;&quot; ) &#x2014; A task-identifier for the pipeline. num_workers ( int , optional , defaults to 8) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the number of workers to be used. batch_size ( int , optional , defaults to 1) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the size of the batch to use, for inference this is not always beneficial, please read Batching with pipelines . args_parser ( ArgumentHandler , optional ) &#x2014; Reference to the object in charge of parsing supplied pipeline parameters. device ( int , optional , defaults to -1) &#x2014; Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on the associated CUDA device id. You can pass native torch.device or a str too dtype ( str or torch.dtype , optional ) &#x2014; Sent directly as model_kwargs (just a simpler shortcut) to use the available precision for this model ( torch.float16 , torch.bfloat16 , &#x2026; or &quot;auto&quot; ) binary_output ( bool , optional , defaults to False ) &#x2014; Flag indicating if the output the pipeline should happen in a serialized format (i.e., pickle) or as the raw output data e.g. text. Zero shot object detection pipeline using OwlViTForObjectDetection . This pipeline predicts bounding boxes of objects when you provide an image and a set of candidate_labels . Example: Copied &gt;&gt;&gt; from transformers import pipeline &gt;&gt;&gt; detector = pipeline(model= &quot;google/owlvit-base-patch32&quot; , task= &quot;zero-shot-object-detection&quot; ) &gt;&gt;&gt; detector( ... &quot;http://images.cocodataset.org/val2017/000000039769.jpg&quot; , ... candidate_labels=[ &quot;cat&quot; , &quot;couch&quot; ], ... ) [{ &#x27;score&#x27; : 0.287 , &#x27;label&#x27; : &#x27;cat&#x27; , &#x27;box&#x27; : { &#x27;xmin&#x27; : 324 , &#x27;ymin&#x27; : 20 , &#x27;xmax&#x27; : 640 , &#x27;ymax&#x27; : 373 }}, { &#x27;score&#x27; : 0.254 , &#x27;label&#x27; : &#x27;cat&#x27; , &#x27;box&#x27; : { &#x27;xmin&#x27; : 1 , &#x27;ymin&#x27; : 55 , &#x27;xmax&#x27; : 315 , &#x27;ymax&#x27; : 472 }}, { &#x27;score&#x27; : 0.121 , &#x27;label&#x27; : &#x27;couch&#x27; , &#x27;box&#x27; : { &#x27;xmin&#x27; : 4 , &#x27;ymin&#x27; : 0 , &#x27;xmax&#x27; : 642 , &#x27;ymax&#x27; : 476 }}] &gt;&gt;&gt; detector( ... &quot;https://huggingface.co/datasets/Narsil/image_dummy/raw/main/parrots.png&quot; , ... candidate_labels=[ &quot;head&quot; , &quot;bird&quot; ], ... ) [{ &#x27;score&#x27; : 0.119 , &#x27;label&#x27; : &#x27;bird&#x27; , &#x27;box&#x27; : { &#x27;xmin&#x27; : 71 , &#x27;ymin&#x27; : 170 , &#x27;xmax&#x27; : 410 , &#x27;ymax&#x27; : 508 }}] Learn more about the basics of using a pipeline in the pipeline tutorial This object detection pipeline can currently be loaded from pipeline() using the following task identifier: &quot;zero-shot-object-detection&quot; . See the list of available models on huggingface.co/models . __call__ &lt; source &gt; ( image : typing.Union[str, ForwardRef('Image.Image'), list[dict[str, typing.Any]]] candidate_labels : typing.Union[str, list[str], NoneType] = None **kwargs : typing.Any ) Parameters image ( str , PIL.Image or list[dict[str, Any]] ) &#x2014; The pipeline handles three types of images: A string containing an http url pointing to an image A string containing a local path to an image An image loaded in PIL directly You can use this parameter to send directly a list of images, or a dataset or a generator like so: Detect objects (bounding boxes &amp; classes) in the image(s) passed as inputs. Natural Language Processing Pipelines available for natural language processing tasks include the following. FillMaskPipeline class transformers. FillMaskPipeline &lt; source &gt; ( model : typing.Union[ForwardRef('PreTrainedModel'), ForwardRef('TFPreTrainedModel')] tokenizer : typing.Optional[transformers.tokenization_utils.PreTrainedTokenizer] = None feature_extractor : typing.Optional[ForwardRef('SequenceFeatureExtractor')] = None image_processor : typing.Optional[transformers.image_processing_utils.BaseImageProcessor] = None processor : typing.Optional[transformers.processing_utils.ProcessorMixin] = None modelcard : typing.Optional[transformers.modelcard.ModelCard] = None framework : typing.Optional[str] = None task : str = '' device : typing.Union[int, ForwardRef('torch.device')] = None binary_output : bool = False **kwargs ) Parameters model ( PreTrainedModel or TFPreTrainedModel ) &#x2014; The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from PreTrainedModel for PyTorch and TFPreTrainedModel for TensorFlow. tokenizer ( PreTrainedTokenizer ) &#x2014; The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from PreTrainedTokenizer . modelcard ( str or ModelCard , optional ) &#x2014; Model card attributed to the model for this pipeline. framework ( str , optional ) &#x2014; The framework to use, either &quot;pt&quot; for PyTorch or &quot;tf&quot; for TensorFlow. The specified framework must be installed. If no framework is specified, will default to the one currently installed. If no framework is specified and both frameworks are installed, will default to the framework of the model , or to PyTorch if no model is provided. task ( str , defaults to &quot;&quot; ) &#x2014; A task-identifier for the pipeline. num_workers ( int , optional , defaults to 8) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the number of workers to be used. batch_size ( int , optional , defaults to 1) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the size of the batch to use, for inference this is not always beneficial, please read Batching with pipelines . args_parser ( ArgumentHandler , optional ) &#x2014; Reference to the object in charge of parsing supplied pipeline parameters. device ( int , optional , defaults to -1) &#x2014; Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on the associated CUDA device id. You can pass native torch.device or a str too dtype ( str or torch.dtype , optional ) &#x2014; Sent directly as model_kwargs (just a simpler shortcut) to use the available precision for this model ( torch.float16 , torch.bfloat16 , &#x2026; or &quot;auto&quot; ) binary_output ( bool , optional , defaults to False ) &#x2014; Flag indicating if the output the pipeline should happen in a serialized format (i.e., pickle) or as the raw output data e.g. text. top_k ( int , optional , defaults to 5) &#x2014; The number of predictions to return. targets ( str or list[str] , optional ) &#x2014; When passed, the model will limit the scores to the passed targets instead of looking up in the whole vocab. If the provided targets are not in the model vocab, they will be tokenized and the first resulting token will be used (with a warning, and that might be slower). tokenizer_kwargs ( dict , optional ) &#x2014; Additional dictionary of keyword arguments passed along to the tokenizer. __call__ &lt; source &gt; ( inputs : typing.Union[str, list[str]] **kwargs : typing.Any ) → A list or a list of list of dict Parameters inputs ( str or list[str] ) &#x2014; One or several texts (or one list of prompts) with masked tokens. targets ( str or list[str] , optional ) &#x2014; When passed, the model will limit the scores to the passed targets instead of looking up in the whole vocab. If the provided targets are not in the model vocab, they will be tokenized and the first resulting token will be used (with a warning, and that might be slower). top_k ( int , optional ) &#x2014; When passed, overrides the number of predictions to return. Returns A list or a list of list of dict Each result comes as list of dictionaries with the following keys: sequence ( str ) — The corresponding input with the mask token prediction. score ( float ) — The corresponding probability. token ( int ) — The predicted token id (to replace the masked one). token_str ( str ) — The predicted token (to replace the masked one). Fill the masked token in the text(s) given as inputs. QuestionAnsweringPipeline class transformers. QuestionAnsweringPipeline &lt; source &gt; ( model : typing.Union[ForwardRef('PreTrainedModel'), ForwardRef('TFPreTrainedModel')] tokenizer : PreTrainedTokenizer modelcard : typing.Optional[transformers.modelcard.ModelCard] = None framework : typing.Optional[str] = None task : str = '' **kwargs ) Parameters model ( PreTrainedModel or TFPreTrainedModel ) &#x2014; The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from PreTrainedModel for PyTorch and TFPreTrainedModel for TensorFlow. tokenizer ( PreTrainedTokenizer ) &#x2014; The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from PreTrainedTokenizer . modelcard ( str or ModelCard , optional ) &#x2014; Model card attributed to the model for this pipeline. framework ( str , optional ) &#x2014; The framework to use, either &quot;pt&quot; for PyTorch or &quot;tf&quot; for TensorFlow. The specified framework must be installed. If no framework is specified, will default to the one currently installed. If no framework is specified and both frameworks are installed, will default to the framework of the model , or to PyTorch if no model is provided. task ( str , defaults to &quot;&quot; ) &#x2014; A task-identifier for the pipeline. num_workers ( int , optional , defaults to 8) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the number of workers to be used. batch_size ( int , optional , defaults to 1) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the size of the batch to use, for inference this is not always beneficial, please read Batching with pipelines . args_parser ( ArgumentHandler , optional ) &#x2014; Reference to the object in charge of parsing supplied pipeline parameters. device ( int , optional , defaults to -1) &#x2014; Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on the associated CUDA device id. You can pass native torch.device or a str too dtype ( str or torch.dtype , optional ) &#x2014; Sent directly as model_kwargs (just a simpler shortcut) to use the available precision for this model ( torch.float16 , torch.bfloat16 , &#x2026; or &quot;auto&quot; ) binary_output ( bool , optional , defaults to False ) &#x2014; Flag indicating if the output the pipeline should happen in a serialized format (i.e., pickle) or as the raw output data e.g. text. Question Answering pipeline using any ModelForQuestionAnswering . See the question answering examples for more information. Example: Copied &gt;&gt;&gt; from transformers import pipeline &gt;&gt;&gt; oracle = pipeline(model= &quot;deepset/roberta-base-squad2&quot; ) &gt;&gt;&gt; oracle(question= &quot;Where do I live?&quot; , context= &quot;My name is Wolfgang and I live in Berlin&quot; ) { &#x27;score&#x27; : 0.9191 , &#x27;start&#x27; : 34 , &#x27;end&#x27; : 40 , &#x27;answer&#x27; : &#x27;Berlin&#x27; } Learn more about the basics of using a pipeline in the pipeline tutorial This question answering pipeline can currently be loaded from pipeline() using the following task identifier: &quot;question-answering&quot; . The models that this pipeline can use are models that have been fine-tuned on a question answering task. See the up-to-date list of available models on huggingface.co/models . __call__ &lt; source &gt; ( *args **kwargs ) → A dict or a list of dict Parameters question ( str or list[str] ) &#x2014; One or several question(s) (must be used in conjunction with the context argument). context ( str or list[str] ) &#x2014; One or several context(s) associated with the question(s) (must be used in conjunction with the question argument). top_k ( int , optional , defaults to 1) &#x2014; The number of answers to return (will be chosen by order of likelihood). Note that we return less than top_k answers if there are not enough options available within the context. doc_stride ( int , optional , defaults to 128) &#x2014; If the context is too long to fit with the question for the model, it will be split in several chunks with some overlap. This argument controls the size of that overlap. max_answer_len ( int , optional , defaults to 15) &#x2014; The maximum length of predicted answers (e.g., only answers with a shorter length are considered). max_seq_len ( int , optional , defaults to 384) &#x2014; The maximum length of the total sentence (context + question) in tokens of each chunk passed to the model. The context will be split in several chunks (using doc_stride as overlap) if needed. max_question_len ( int , optional , defaults to 64) &#x2014; The maximum length of the question after tokenization. It will be truncated if needed. handle_impossible_answer ( bool , optional , defaults to False ) &#x2014; Whether or not we accept impossible as an answer. align_to_words ( bool , optional , defaults to True ) &#x2014; Attempts to align the answer to real words. Improves quality on space separated languages. Might hurt on non-space-separated languages (like Japanese or Chinese) Returns A dict or a list of dict Each result comes as a dictionary with the following keys: score ( float ) — The probability associated to the answer. start ( int ) — The character start index of the answer (in the tokenized version of the input). end ( int ) — The character end index of the answer (in the tokenized version of the input). answer ( str ) — The answer to the question. Answer the question(s) given as inputs by using the context(s). create_sample &lt; source &gt; ( question : typing.Union[str, list[str]] context : typing.Union[str, list[str]] ) → One or a list of SquadExample Parameters question ( str or list[str] ) &#x2014; The question(s) asked. context ( str or list[str] ) &#x2014; The context(s) in which we will look for the answer. Returns One or a list of SquadExample The corresponding SquadExample grouping question and context. QuestionAnsweringPipeline leverages the SquadExample internally. This helper method encapsulate all the logic for converting question(s) and context(s) to SquadExample . We currently support extractive question answering. span_to_answer &lt; source &gt; ( text : str start : int end : int ) → Dictionary like `{‘answer’ Parameters text ( str ) &#x2014; The actual context to extract the answer from. start ( int ) &#x2014; The answer starting token index. end ( int ) &#x2014; The answer end token index. Returns Dictionary like `{‘answer’ str, ‘start’: int, ‘end’: int}` When decoding from token probabilities, this method maps token indexes to actual word in the initial context. SummarizationPipeline class transformers. SummarizationPipeline &lt; source &gt; ( *args **kwargs ) Parameters model ( PreTrainedModel or TFPreTrainedModel ) &#x2014; The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from PreTrainedModel for PyTorch and TFPreTrainedModel for TensorFlow. tokenizer ( PreTrainedTokenizer ) &#x2014; The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from PreTrainedTokenizer . modelcard ( str or ModelCard , optional ) &#x2014; Model card attributed to the model for this pipeline. framework ( str , optional ) &#x2014; The framework to use, either &quot;pt&quot; for PyTorch or &quot;tf&quot; for TensorFlow. The specified framework must be installed. If no framework is specified, will default to the one currently installed. If no framework is specified and both frameworks are installed, will default to the framework of the model , or to PyTorch if no model is provided. task ( str , defaults to &quot;&quot; ) &#x2014; A task-identifier for the pipeline. num_workers ( int , optional , defaults to 8) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the number of workers to be used. batch_size ( int , optional , defaults to 1) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the size of the batch to use, for inference this is not always beneficial, please read Batching with pipelines . args_parser ( ArgumentHandler , optional ) &#x2014; Reference to the object in charge of parsing supplied pipeline parameters. device ( int , optional , defaults to -1) &#x2014; Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on the associated CUDA device id. You can pass native torch.device or a str too dtype ( str or torch.dtype , optional ) &#x2014; Sent directly as model_kwargs (just a simpler shortcut) to use the available precision for this model ( torch.float16 , torch.bfloat16 , &#x2026; or &quot;auto&quot; ) binary_output ( bool , optional , defaults to False ) &#x2014; Flag indicating if the output the pipeline should happen in a serialized format (i.e., pickle) or as the raw output data e.g. text. Summarize news articles and other documents. This summarizing pipeline can currently be loaded from pipeline() using the following task identifier: &quot;summarization&quot; . The models that this pipeline can use are models that have been fine-tuned on a summarization task, which is currently, ’ bart-large-cnn ’, ’ google-t5/t5-small ’, ’ google-t5/t5-base ’, ’ google-t5/t5-large ’, ’ google-t5/t5-3b ’, ’ google-t5/t5-11b ’. See the up-to-date list of available models on huggingface.co/models . For a list of available parameters, see the following documentation Unless the model you’re using explicitly sets these generation parameters in its configuration files ( generation_config.json ), the following default values will be used: max_new_tokens: 256 num_beams: 4 Usage: Copied # use bart in pytorch summarizer = pipeline( &quot;summarization&quot; ) summarizer( &quot;An apple a day, keeps the doctor away&quot; , min_length= 5 , max_length= 20 ) # use t5 in tf summarizer = pipeline( &quot;summarization&quot; , model= &quot;google-t5/t5-base&quot; , tokenizer= &quot;google-t5/t5-base&quot; , framework= &quot;tf&quot; ) summarizer( &quot;An apple a day, keeps the doctor away&quot; , min_length= 5 , max_length= 20 ) __call__ &lt; source &gt; ( *args **kwargs ) → A list or a list of list of dict Parameters documents ( str or list[str] ) &#x2014; One or several articles (or one list of articles) to summarize. return_text ( bool , optional , defaults to True ) &#x2014; Whether or not to include the decoded texts in the outputs return_tensors ( bool , optional , defaults to False ) &#x2014; Whether or not to include the tensors of predictions (as token indices) in the outputs. clean_up_tokenization_spaces ( bool , optional , defaults to False ) &#x2014; Whether or not to clean up the potential extra spaces in the text output. generate_kwargs &#x2014; Additional keyword arguments to pass along to the generate method of the model (see the generate method corresponding to your framework here ). Returns A list or a list of list of dict Each result comes as a dictionary with the following keys: summary_text ( str , present when return_text=True ) — The summary of the corresponding input. summary_token_ids ( torch.Tensor or tf.Tensor , present when return_tensors=True ) — The token ids of the summary. Summarize the text(s) given as inputs. TableQuestionAnsweringPipeline class transformers. TableQuestionAnsweringPipeline &lt; source &gt; ( args_parser = &lt;transformers.pipelines.table_question_answering.TableQuestionAnsweringArgumentHandler object at 0x7f69503ece50> *args **kwargs ) Parameters model ( PreTrainedModel or TFPreTrainedModel ) &#x2014; The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from PreTrainedModel for PyTorch and TFPreTrainedModel for TensorFlow. tokenizer ( PreTrainedTokenizer ) &#x2014; The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from PreTrainedTokenizer . modelcard ( str or ModelCard , optional ) &#x2014; Model card attributed to the model for this pipeline. framework ( str , optional ) &#x2014; The framework to use, either &quot;pt&quot; for PyTorch or &quot;tf&quot; for TensorFlow. The specified framework must be installed. If no framework is specified, will default to the one currently installed. If no framework is specified and both frameworks are installed, will default to the framework of the model , or to PyTorch if no model is provided. task ( str , defaults to &quot;&quot; ) &#x2014; A task-identifier for the pipeline. num_workers ( int , optional , defaults to 8) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the number of workers to be used. batch_size ( int , optional , defaults to 1) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the size of the batch to use, for inference this is not always beneficial, please read Batching with pipelines . args_parser ( ArgumentHandler , optional ) &#x2014; Reference to the object in charge of parsing supplied pipeline parameters. device ( int , optional , defaults to -1) &#x2014; Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on the associated CUDA device id. You can pass native torch.device or a str too dtype ( str or torch.dtype , optional ) &#x2014; Sent directly as model_kwargs (just a simpler shortcut) to use the available precision for this model ( torch.float16 , torch.bfloat16 , &#x2026; or &quot;auto&quot; ) binary_output ( bool , optional , defaults to False ) &#x2014; Flag indicating if the output the pipeline should happen in a serialized format (i.e., pickle) or as the raw output data e.g. text. Table Question Answering pipeline using a ModelForTableQuestionAnswering . This pipeline is only available in PyTorch. Unless the model you’re using explicitly sets these generation parameters in its configuration files ( generation_config.json ), the following default values will be used: max_new_tokens: 256 Example: Copied &gt;&gt;&gt; from transformers import pipeline &gt;&gt;&gt; oracle = pipeline(model= &quot;google/tapas-base-finetuned-wtq&quot; ) &gt;&gt;&gt; table = { ... &quot;Repository&quot; : [ &quot;Transformers&quot; , &quot;Datasets&quot; , &quot;Tokenizers&quot; ], ... &quot;Stars&quot; : [ &quot;36542&quot; , &quot;4512&quot; , &quot;3934&quot; ], ... &quot;Contributors&quot; : [ &quot;651&quot; , &quot;77&quot; , &quot;34&quot; ], ... &quot;Programming language&quot; : [ &quot;Python&quot; , &quot;Python&quot; , &quot;Rust, Python and NodeJS&quot; ], ... } &gt;&gt;&gt; oracle(query= &quot;How many stars does the transformers repository have?&quot; , table=table) { &#x27;answer&#x27; : &#x27;AVERAGE &gt; 36542&#x27; , &#x27;coordinates&#x27; : [( 0 , 1 )], &#x27;cells&#x27; : [ &#x27;36542&#x27; ], &#x27;aggregator&#x27; : &#x27;AVERAGE&#x27; } Learn more about the basics of using a pipeline in the pipeline tutorial This tabular question answering pipeline can currently be loaded from pipeline() using the following task identifier: &quot;table-question-answering&quot; . The models that this pipeline can use are models that have been fine-tuned on a tabular question answering task. See the up-to-date list of available models on huggingface.co/models . __call__ &lt; source &gt; ( *args **kwargs ) → A dictionary or a list of dictionaries containing results Parameters table ( pd.DataFrame or Dict ) &#x2014; Pandas DataFrame or dictionary that will be converted to a DataFrame containing all the table values. See above for an example of dictionary. query ( str or list[str] ) &#x2014; Query or list of queries that will be sent to the model alongside the table. sequential ( bool , optional , defaults to False ) &#x2014; Whether to do inference sequentially or as a batch. Batching is faster, but models like SQA require the inference to be done sequentially to extract relations within sequences, given their conversational nature. padding ( bool , str or PaddingStrategy , optional , defaults to False ) &#x2014; Activates and controls padding. Accepts the following values: True or &apos;longest&apos; : Pad to the longest sequence in the batch (or no padding if only a single sequence if provided). &apos;max_length&apos; : Pad to a maximum length specified with the argument max_length or to the maximum acceptable input length for the model if that argument is not provided. False or &apos;do_not_pad&apos; (default): No padding (i.e., can output a batch with sequences of different lengths). truncation ( bool , str or TapasTruncationStrategy , optional , defaults to False ) &#x2014; Activates and controls truncation. Accepts the following values: True or &apos;drop_rows_to_fit&apos; : Truncate to a maximum length specified with the argument max_length or to the maximum acceptable input length for the model if that argument is not provided. This will truncate row by row, removing rows from the table. False or &apos;do_not_truncate&apos; (default): No truncation (i.e., can output batch with sequence lengths greater than the model maximum admissible input size). Returns A dictionary or a list of dictionaries containing results Each result is a dictionary with the following keys: answer ( str ) — The answer of the query given the table. If there is an aggregator, the answer will be preceded by AGGREGATOR &gt; . coordinates ( list[tuple[int, int]] ) — Coordinates of the cells of the answers. cells ( list[str] ) — List of strings made up of the answer cell values. aggregator ( str ) — If the model has an aggregator, this returns the aggregator. Answers queries according to a table. The pipeline accepts several types of inputs which are detailed below: pipeline(table, query) pipeline(table, [query]) pipeline(table=table, query=query) pipeline(table=table, query=[query]) pipeline({&quot;table&quot;: table, &quot;query&quot;: query}) pipeline({&quot;table&quot;: table, &quot;query&quot;: [query]}) pipeline([{&quot;table&quot;: table, &quot;query&quot;: query}, {&quot;table&quot;: table, &quot;query&quot;: query}]) The table argument should be a dict or a DataFrame built from that dict, containing the whole table: Example: Copied data = { &quot;actors&quot; : [ &quot;brad pitt&quot; , &quot;leonardo di caprio&quot; , &quot;george clooney&quot; ], &quot;age&quot; : [ &quot;56&quot; , &quot;45&quot; , &quot;59&quot; ], &quot;number of movies&quot; : [ &quot;87&quot; , &quot;53&quot; , &quot;69&quot; ], &quot;date of birth&quot; : [ &quot;7 february 1967&quot; , &quot;10 june 1996&quot; , &quot;28 november 1967&quot; ], } This dictionary can be passed in as such, or can be converted to a pandas DataFrame: Example: Copied import pandas as pd table = pd.DataFrame.from_dict(data) TextClassificationPipeline class transformers. TextClassificationPipeline &lt; source &gt; ( **kwargs ) Parameters model ( PreTrainedModel or TFPreTrainedModel ) &#x2014; The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from PreTrainedModel for PyTorch and TFPreTrainedModel for TensorFlow. tokenizer ( PreTrainedTokenizer ) &#x2014; The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from PreTrainedTokenizer . modelcard ( str or ModelCard , optional ) &#x2014; Model card attributed to the model for this pipeline. framework ( str , optional ) &#x2014; The framework to use, either &quot;pt&quot; for PyTorch or &quot;tf&quot; for TensorFlow. The specified framework must be installed. If no framework is specified, will default to the one currently installed. If no framework is specified and both frameworks are installed, will default to the framework of the model , or to PyTorch if no model is provided. task ( str , defaults to &quot;&quot; ) &#x2014; A task-identifier for the pipeline. num_workers ( int , optional , defaults to 8) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the number of workers to be used. batch_size ( int , optional , defaults to 1) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the size of the batch to use, for inference this is not always beneficial, please read Batching with pipelines . args_parser ( ArgumentHandler , optional ) &#x2014; Reference to the object in charge of parsing supplied pipeline parameters. device ( int , optional , defaults to -1) &#x2014; Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on the associated CUDA device id. You can pass native torch.device or a str too dtype ( str or torch.dtype , optional ) &#x2014; Sent directly as model_kwargs (just a simpler shortcut) to use the available precision for this model ( torch.float16 , torch.bfloat16 , &#x2026; or &quot;auto&quot; ) binary_output ( bool , optional , defaults to False ) &#x2014; Flag indicating if the output the pipeline should happen in a serialized format (i.e., pickle) or as the raw output data e.g. text. return_all_scores ( bool , optional , defaults to False ) &#x2014; Whether to return all prediction scores or just the one of the predicted class. function_to_apply ( str , optional , defaults to &quot;default&quot; ) &#x2014; The function to apply to the model outputs in order to retrieve the scores. Accepts four different values: &quot;default&quot; : if the model has a single label, will apply the sigmoid function on the output. If the model has several labels, will apply the softmax function on the output. In case of regression tasks, will not apply any function on the output. &quot;sigmoid&quot; : Applies the sigmoid function on the output. &quot;softmax&quot; : Applies the softmax function on the output. &quot;none&quot; : Does not apply any function on the output. Text classification pipeline using any ModelForSequenceClassification . See the sequence classification examples for more information. Example: Copied &gt;&gt;&gt; from transformers import pipeline &gt;&gt;&gt; classifier = pipeline(model= &quot;distilbert/distilbert-base-uncased-finetuned-sst-2-english&quot; ) &gt;&gt;&gt; classifier( &quot;This movie is disgustingly good !&quot; ) [{ &#x27;label&#x27; : &#x27;POSITIVE&#x27; , &#x27;score&#x27; : 1.0 }] &gt;&gt;&gt; classifier( &quot;Director tried too much.&quot; ) [{ &#x27;label&#x27; : &#x27;NEGATIVE&#x27; , &#x27;score&#x27; : 0.996 }] Learn more about the basics of using a pipeline in the pipeline tutorial This text classification pipeline can currently be loaded from pipeline() using the following task identifier: &quot;sentiment-analysis&quot; (for classifying sequences according to positive or negative sentiments). If multiple classification labels are available ( model.config.num_labels &gt;= 2 ), the pipeline will run a softmax over the results. If there is a single label, the pipeline will run a sigmoid over the result. In case of regression tasks ( model.config.problem_type == &quot;regression&quot; ), will not apply any function on the output. The models that this pipeline can use are models that have been fine-tuned on a sequence classification task. See the up-to-date list of available models on huggingface.co/models . __call__ &lt; source &gt; ( inputs : typing.Union[str, list[str], dict[str, str], list[dict[str, str]]] **kwargs : typing.Any ) → A list of dict Parameters inputs ( str or list[str] or dict[str] , or list[dict[str]] ) &#x2014; One or several texts to classify. In order to use text pairs for your classification, you can send a dictionary containing {&quot;text&quot;, &quot;text_pair&quot;} keys, or a list of those. top_k ( int , optional , defaults to 1 ) &#x2014; How many results to return. function_to_apply ( str , optional , defaults to &quot;default&quot; ) &#x2014; The function to apply to the model outputs in order to retrieve the scores. Accepts four different values: If this argument is not specified, then it will apply the following functions according to the number of labels: If problem type is regression, will not apply any function on the output. If the model has a single label, will apply the sigmoid function on the output. If the model has several labels, will apply the softmax function on the output. Possible values are: &quot;sigmoid&quot; : Applies the sigmoid function on the output. &quot;softmax&quot; : Applies the softmax function on the output. &quot;none&quot; : Does not apply any function on the output. Returns A list of dict Each result comes as list of dictionaries with the following keys: label ( str ) — The label predicted. score ( float ) — The corresponding probability. If top_k is used, one such dictionary is returned per label. Classify the text(s) given as inputs. TextGenerationPipeline class transformers. TextGenerationPipeline &lt; source &gt; ( *args **kwargs ) Parameters model ( PreTrainedModel or TFPreTrainedModel ) &#x2014; The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from PreTrainedModel for PyTorch and TFPreTrainedModel for TensorFlow. tokenizer ( PreTrainedTokenizer ) &#x2014; The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from PreTrainedTokenizer . modelcard ( str or ModelCard , optional ) &#x2014; Model card attributed to the model for this pipeline. framework ( str , optional ) &#x2014; The framework to use, either &quot;pt&quot; for PyTorch or &quot;tf&quot; for TensorFlow. The specified framework must be installed. If no framework is specified, will default to the one currently installed. If no framework is specified and both frameworks are installed, will default to the framework of the model , or to PyTorch if no model is provided. task ( str , defaults to &quot;&quot; ) &#x2014; A task-identifier for the pipeline. num_workers ( int , optional , defaults to 8) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the number of workers to be used. batch_size ( int , optional , defaults to 1) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the size of the batch to use, for inference this is not always beneficial, please read Batching with pipelines . args_parser ( ArgumentHandler , optional ) &#x2014; Reference to the object in charge of parsing supplied pipeline parameters. device ( int , optional , defaults to -1) &#x2014; Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on the associated CUDA device id. You can pass native torch.device or a str too dtype ( str or torch.dtype , optional ) &#x2014; Sent directly as model_kwargs (just a simpler shortcut) to use the available precision for this model ( torch.float16 , torch.bfloat16 , &#x2026; or &quot;auto&quot; ) binary_output ( bool , optional , defaults to False ) &#x2014; Flag indicating if the output the pipeline should happen in a serialized format (i.e., pickle) or as the raw output data e.g. text. Language generation pipeline using any ModelWithLMHead or ModelForCausalLM . This pipeline predicts the words that will follow a specified text prompt. When the underlying model is a conversational model, it can also accept one or more chats, in which case the pipeline will operate in chat mode and will continue the chat(s) by adding its response(s). Each chat takes the form of a list of dicts, where each dict contains “role” and “content” keys. Unless the model you’re using explicitly sets these generation parameters in its configuration files ( generation_config.json ), the following default values will be used: max_new_tokens: 256 do_sample: True temperature: 0.7 Examples: Copied &gt;&gt;&gt; from transformers import pipeline &gt;&gt;&gt; generator = pipeline(model= &quot;openai-community/gpt2&quot; ) &gt;&gt;&gt; generator( &quot;I can&#x27;t believe you did such a &quot; , do_sample= False ) [{ &#x27;generated_text&#x27; : &quot;I can&#x27;t believe you did such a icky thing to me. I&#x27;m so sorry. I&#x27;m so sorry. I&#x27;m so sorry. I&#x27;m so sorry. I&#x27;m so sorry. I&#x27;m so sorry. I&#x27;m so sorry. I&quot; }] &gt;&gt;&gt; # These parameters will return suggestions, and only the newly created text making it easier for prompting suggestions. &gt;&gt;&gt; outputs = generator( &quot;My tart needs some&quot; , num_return_sequences= 4 , return_full_text= False ) Copied &gt;&gt;&gt; from transformers import pipeline &gt;&gt;&gt; generator = pipeline(model= &quot;HuggingFaceH4/zephyr-7b-beta&quot; ) &gt;&gt;&gt; # Zephyr-beta is a conversational model, so let&#x27;s pass it a chat instead of a single string &gt;&gt;&gt; generator([{ &quot;role&quot; : &quot;user&quot; , &quot;content&quot; : &quot;What is the capital of France? Answer in one word.&quot; }], do_sample= False , max_new_tokens= 2 ) [{ &#x27;generated_text&#x27; : [{ &#x27;role&#x27; : &#x27;user&#x27; , &#x27;content&#x27; : &#x27;What is the capital of France? Answer in one word.&#x27; }, { &#x27;role&#x27; : &#x27;assistant&#x27; , &#x27;content&#x27; : &#x27;Paris&#x27; }]}] Learn more about the basics of using a pipeline in the pipeline tutorial . You can pass text generation parameters to this pipeline to control stopping criteria, decoding strategy, and more. Learn more about text generation parameters in Text generation strategies and Text generation . This language generation pipeline can currently be loaded from pipeline() using the following task identifier: &quot;text-generation&quot; . The models that this pipeline can use are models that have been trained with an autoregressive language modeling objective. See the list of available text completion models and the list of conversational models on [huggingface.co/models]. __call__ &lt; source &gt; ( text_inputs **kwargs ) → A list or a list of lists of dict Parameters text_inputs ( str , list[str] , list[dict[str, str]], or list[list[dict[str, str]]] ) &#x2014; One or several prompts (or one list of prompts) to complete. If strings or a list of string are passed, this pipeline will continue each prompt. Alternatively, a &#x201C;chat&#x201D;, in the form of a list of dicts with &#x201C;role&#x201D; and &#x201C;content&#x201D; keys, can be passed, or a list of such chats. When chats are passed, the model&#x2019;s chat template will be used to format them before passing them to the model. return_tensors ( bool , optional , defaults to False ) &#x2014; Returns the tensors of predictions (as token indices) in the outputs. If set to True , the decoded text is not returned. return_text ( bool , optional ) &#x2014; Returns the decoded texts in the outputs. return_full_text ( bool , optional , defaults to True ) &#x2014; If set to False only added text is returned, otherwise the full text is returned. Cannot be specified at the same time as return_text . clean_up_tokenization_spaces ( bool , optional , defaults to True ) &#x2014; Whether or not to clean up the potential extra spaces in the text output. continue_final_message( bool , optional ) &#x2014; This indicates that you want the model to continue the last message in the input chat rather than starting a new one, allowing you to &#x201C;prefill&#x201D; its response. By default this is True when the final message in the input chat has the assistant role and False otherwise, but you can manually override that behaviour by setting this flag. prefix ( str , optional ) &#x2014; Prefix added to prompt. handle_long_generation ( str , optional ) &#x2014; By default, this pipelines does not handle long generation (ones that exceed in one form or the other the model maximum length). There is no perfect way to address this (more info : https://github.com/huggingface/transformers/issues/14033#issuecomment-948385227 ). This provides common strategies to work around that problem depending on your use case. None : default strategy where nothing in particular happens &quot;hole&quot; : Truncates left of input, and leaves a gap wide enough to let generation happen (might truncate a lot of the prompt and not suitable when generation exceed the model capacity) tokenizer_encode_kwargs ( dict , optional ) &#x2014; Additional keyword arguments to pass along to the encoding step of the tokenizer. If the text input is a chat, it is passed to apply_chat_template . Otherwise, it is passed to __call__ . generate_kwargs ( dict , optional ) &#x2014; Additional keyword arguments to pass along to the generate method of the model (see the generate method corresponding to your framework here ). Returns A list or a list of lists of dict Returns one of the following dictionaries (cannot return a combination of both generated_text and generated_token_ids ): generated_text ( str , present when return_text=True ) — The generated text. generated_token_ids ( torch.Tensor or tf.Tensor , present when return_tensors=True ) — The token ids of the generated text. Complete the prompt(s) given as inputs. Text2TextGenerationPipeline class transformers. Text2TextGenerationPipeline &lt; source &gt; ( *args **kwargs ) Parameters model ( PreTrainedModel or TFPreTrainedModel ) &#x2014; The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from PreTrainedModel for PyTorch and TFPreTrainedModel for TensorFlow. tokenizer ( PreTrainedTokenizer ) &#x2014; The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from PreTrainedTokenizer . modelcard ( str or ModelCard , optional ) &#x2014; Model card attributed to the model for this pipeline. framework ( str , optional ) &#x2014; The framework to use, either &quot;pt&quot; for PyTorch or &quot;tf&quot; for TensorFlow. The specified framework must be installed. If no framework is specified, will default to the one currently installed. If no framework is specified and both frameworks are installed, will default to the framework of the model , or to PyTorch if no model is provided. task ( str , defaults to &quot;&quot; ) &#x2014; A task-identifier for the pipeline. num_workers ( int , optional , defaults to 8) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the number of workers to be used. batch_size ( int , optional , defaults to 1) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the size of the batch to use, for inference this is not always beneficial, please read Batching with pipelines . args_parser ( ArgumentHandler , optional ) &#x2014; Reference to the object in charge of parsing supplied pipeline parameters. device ( int , optional , defaults to -1) &#x2014; Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on the associated CUDA device id. You can pass native torch.device or a str too dtype ( str or torch.dtype , optional ) &#x2014; Sent directly as model_kwargs (just a simpler shortcut) to use the available precision for this model ( torch.float16 , torch.bfloat16 , &#x2026; or &quot;auto&quot; ) binary_output ( bool , optional , defaults to False ) &#x2014; Flag indicating if the output the pipeline should happen in a serialized format (i.e., pickle) or as the raw output data e.g. text. Pipeline for text to text generation using seq2seq models. Unless the model you’re using explicitly sets these generation parameters in its configuration files ( generation_config.json ), the following default values will be used: max_new_tokens: 256 num_beams: 4 Example: Copied &gt;&gt;&gt; from transformers import pipeline &gt;&gt;&gt; generator = pipeline(model= &quot;mrm8488/t5-base-finetuned-question-generation-ap&quot; ) &gt;&gt;&gt; generator( ... &quot;answer: Manuel context: Manuel has created RuPERTa-base with the support of HF-Transformers and Google&quot; ... ) [{ &#x27;generated_text&#x27; : &#x27;question: Who created the RuPERTa-base?&#x27; }] Learn more about the basics of using a pipeline in the pipeline tutorial . You can pass text generation parameters to this pipeline to control stopping criteria, decoding strategy, and more. Learn more about text generation parameters in Text generation strategies and Text generation . This Text2TextGenerationPipeline pipeline can currently be loaded from pipeline() using the following task identifier: &quot;text2text-generation&quot; . The models that this pipeline can use are models that have been fine-tuned on a translation task. See the up-to-date list of available models on huggingface.co/models . For a list of available parameters, see the following documentation Usage: Copied text2text_generator = pipeline( &quot;text2text-generation&quot; ) text2text_generator( &quot;question: What is 42 ? context: 42 is the answer to life, the universe and everything&quot; ) __call__ &lt; source &gt; ( *args : typing.Union[str, list[str]] **kwargs : typing.Any ) → A list or a list of list of dict Parameters args ( str or list[str] ) &#x2014; Input text for the encoder. return_tensors ( bool , optional , defaults to False ) &#x2014; Whether or not to include the tensors of predictions (as token indices) in the outputs. return_text ( bool , optional , defaults to True ) &#x2014; Whether or not to include the decoded texts in the outputs. clean_up_tokenization_spaces ( bool , optional , defaults to False ) &#x2014; Whether or not to clean up the potential extra spaces in the text output. truncation ( TruncationStrategy , optional , defaults to TruncationStrategy.DO_NOT_TRUNCATE ) &#x2014; The truncation strategy for the tokenization within the pipeline. TruncationStrategy.DO_NOT_TRUNCATE (default) will never truncate, but it is sometimes desirable to truncate the input to fit the model&#x2019;s max_length instead of throwing an error down the line. generate_kwargs &#x2014; Additional keyword arguments to pass along to the generate method of the model (see the generate method corresponding to your framework here ). Returns A list or a list of list of dict Each result comes as a dictionary with the following keys: generated_text ( str , present when return_text=True ) — The generated text. generated_token_ids ( torch.Tensor or tf.Tensor , present when return_tensors=True ) — The token ids of the generated text. Generate the output text(s) using text(s) given as inputs. check_inputs &lt; source &gt; ( input_length : int min_length : int max_length : int ) Checks whether there might be something wrong with given input with regard to the model. TokenClassificationPipeline class transformers. TokenClassificationPipeline &lt; source &gt; ( args_parser = &lt;transformers.pipelines.token_classification.TokenClassificationArgumentHandler object at 0x7f69503ef760> *args **kwargs ) Parameters model ( PreTrainedModel or TFPreTrainedModel ) &#x2014; The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from PreTrainedModel for PyTorch and TFPreTrainedModel for TensorFlow. tokenizer ( PreTrainedTokenizer ) &#x2014; The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from PreTrainedTokenizer . modelcard ( str or ModelCard , optional ) &#x2014; Model card attributed to the model for this pipeline. framework ( str , optional ) &#x2014; The framework to use, either &quot;pt&quot; for PyTorch or &quot;tf&quot; for TensorFlow. The specified framework must be installed. If no framework is specified, will default to the one currently installed. If no framework is specified and both frameworks are installed, will default to the framework of the model , or to PyTorch if no model is provided. task ( str , defaults to &quot;&quot; ) &#x2014; A task-identifier for the pipeline. num_workers ( int , optional , defaults to 8) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the number of workers to be used. batch_size ( int , optional , defaults to 1) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the size of the batch to use, for inference this is not always beneficial, please read Batching with pipelines . args_parser ( ArgumentHandler , optional ) &#x2014; Reference to the object in charge of parsing supplied pipeline parameters. device ( int , optional , defaults to -1) &#x2014; Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on the associated CUDA device id. You can pass native torch.device or a str too dtype ( str or torch.dtype , optional ) &#x2014; Sent directly as model_kwargs (just a simpler shortcut) to use the available precision for this model ( torch.float16 , torch.bfloat16 , &#x2026; or &quot;auto&quot; ) binary_output ( bool , optional , defaults to False ) &#x2014; Flag indicating if the output the pipeline should happen in a serialized format (i.e., pickle) or as the raw output data e.g. text. ignore_labels ( list[str] , defaults to [&quot;O&quot;] ) &#x2014; A list of labels to ignore. grouped_entities ( bool , optional , defaults to False ) &#x2014; DEPRECATED, use aggregation_strategy instead. Whether or not to group the tokens corresponding to the same entity together in the predictions or not. stride ( int , optional ) &#x2014; If stride is provided, the pipeline is applied on all the text. The text is split into chunks of size model_max_length. Works only with fast tokenizers and aggregation_strategy different from NONE . The value of this argument defines the number of overlapping tokens between chunks. In other words, the model will shift forward by tokenizer.model_max_length - stride tokens each step. aggregation_strategy ( str , optional , defaults to &quot;none&quot; ) &#x2014; The strategy to fuse (or not) tokens based on the model prediction. &#x201C;none&#x201D; : Will simply not do any aggregation and simply return raw results from the model &#x201C;simple&#x201D; : Will attempt to group entities following the default schema. (A, B-TAG), (B, I-TAG), (C, I-TAG), (D, B-TAG2) (E, B-TAG2) will end up being [{&#x201C;word&#x201D;: ABC, &#x201C;entity&#x201D;: &#x201C;TAG&#x201D;}, {&#x201C;word&#x201D;: &#x201C;D&#x201D;, &#x201C;entity&#x201D;: &#x201C;TAG2&#x201D;}, {&#x201C;word&#x201D;: &#x201C;E&#x201D;, &#x201C;entity&#x201D;: &#x201C;TAG2&#x201D;}] Notice that two consecutive B tags will end up as different entities. On word based languages, we might end up splitting words undesirably : Imagine Microsoft being tagged as [{&#x201C;word&#x201D;: &#x201C;Micro&#x201D;, &#x201C;entity&#x201D;: &#x201C;ENTERPRISE&#x201D;}, {&#x201C;word&#x201D;: &#x201C;soft&#x201D;, &#x201C;entity&#x201D;: &#x201C;NAME&#x201D;}]. Look for FIRST, MAX, AVERAGE for ways to mitigate that and disambiguate words (on languages that support that meaning, which is basically tokens separated by a space). These mitigations will only work on real words, &#x201C;New york&#x201D; might still be tagged with two different entities. &#x201C;first&#x201D; : (works only on word based models) Will use the SIMPLE strategy except that words, cannot end up with different tags. Words will simply use the tag of the first token of the word when there is ambiguity. &#x201C;average&#x201D; : (works only on word based models) Will use the SIMPLE strategy except that words, cannot end up with different tags. scores will be averaged first across tokens, and then the maximum label is applied. &#x201C;max&#x201D; : (works only on word based models) Will use the SIMPLE strategy except that words, cannot end up with different tags. Word entity will simply be the token with the maximum score. Named Entity Recognition pipeline using any ModelForTokenClassification . See the named entity recognition examples for more information. Example: Copied &gt;&gt;&gt; from transformers import pipeline &gt;&gt;&gt; token_classifier = pipeline(model= &quot;Jean-Baptiste/camembert-ner&quot; , aggregation_strategy= &quot;simple&quot; ) &gt;&gt;&gt; sentence = &quot;Je m&#x27;appelle jean-baptiste et je vis à montréal&quot; &gt;&gt;&gt; tokens = token_classifier(sentence) &gt;&gt;&gt; tokens [{ &#x27;entity_group&#x27; : &#x27;PER&#x27; , &#x27;score&#x27; : 0.9931 , &#x27;word&#x27; : &#x27;jean-baptiste&#x27; , &#x27;start&#x27; : 12 , &#x27;end&#x27; : 26 }, { &#x27;entity_group&#x27; : &#x27;LOC&#x27; , &#x27;score&#x27; : 0.998 , &#x27;word&#x27; : &#x27;montréal&#x27; , &#x27;start&#x27; : 38 , &#x27;end&#x27; : 47 }] &gt;&gt;&gt; token = tokens[ 0 ] &gt;&gt;&gt; # Start and end provide an easy way to highlight words in the original text. &gt;&gt;&gt; sentence[token[ &quot;start&quot; ] : token[ &quot;end&quot; ]] &#x27; jean-baptiste&#x27; &gt;&gt;&gt; # Some models use the same idea to do part of speech. &gt;&gt;&gt; syntaxer = pipeline(model= &quot;vblagoje/bert-english-uncased-finetuned-pos&quot; , aggregation_strategy= &quot;simple&quot; ) &gt;&gt;&gt; syntaxer( &quot;My name is Sarah and I live in London&quot; ) [{ &#x27;entity_group&#x27; : &#x27;PRON&#x27; , &#x27;score&#x27; : 0.999 , &#x27;word&#x27; : &#x27;my&#x27; , &#x27;start&#x27; : 0 , &#x27;end&#x27; : 2 }, { &#x27;entity_group&#x27; : &#x27;NOUN&#x27; , &#x27;score&#x27; : 0.997 , &#x27;word&#x27; : &#x27;name&#x27; , &#x27;start&#x27; : 3 , &#x27;end&#x27; : 7 }, { &#x27;entity_group&#x27; : &#x27;AUX&#x27; , &#x27;score&#x27; : 0.994 , &#x27;word&#x27; : &#x27;is&#x27; , &#x27;start&#x27; : 8 , &#x27;end&#x27; : 10 }, { &#x27;entity_group&#x27; : &#x27;PROPN&#x27; , &#x27;score&#x27; : 0.999 , &#x27;word&#x27; : &#x27;sarah&#x27; , &#x27;start&#x27; : 11 , &#x27;end&#x27; : 16 }, { &#x27;entity_group&#x27; : &#x27;CCONJ&#x27; , &#x27;score&#x27; : 0.999 , &#x27;word&#x27; : &#x27;and&#x27; , &#x27;start&#x27; : 17 , &#x27;end&#x27; : 20 }, { &#x27;entity_group&#x27; : &#x27;PRON&#x27; , &#x27;score&#x27; : 0.999 , &#x27;word&#x27; : &#x27;i&#x27; , &#x27;start&#x27; : 21 , &#x27;end&#x27; : 22 }, { &#x27;entity_group&#x27; : &#x27;VERB&#x27; , &#x27;score&#x27; : 0.998 , &#x27;word&#x27; : &#x27;live&#x27; , &#x27;start&#x27; : 23 , &#x27;end&#x27; : 27 }, { &#x27;entity_group&#x27; : &#x27;ADP&#x27; , &#x27;score&#x27; : 0.999 , &#x27;word&#x27; : &#x27;in&#x27; , &#x27;start&#x27; : 28 , &#x27;end&#x27; : 30 }, { &#x27;entity_group&#x27; : &#x27;PROPN&#x27; , &#x27;score&#x27; : 0.999 , &#x27;word&#x27; : &#x27;london&#x27; , &#x27;start&#x27; : 31 , &#x27;end&#x27; : 37 }] Learn more about the basics of using a pipeline in the pipeline tutorial This token recognition pipeline can currently be loaded from pipeline() using the following task identifier: &quot;ner&quot; (for predicting the classes of tokens in a sequence: person, organisation, location or miscellaneous). The models that this pipeline can use are models that have been fine-tuned on a token classification task. See the up-to-date list of available models on huggingface.co/models . __call__ &lt; source &gt; ( inputs : typing.Union[str, list[str]] **kwargs : typing.Any ) → A list or a list of list of dict Parameters inputs ( str or List[str] ) &#x2014; One or several texts (or one list of texts) for token classification. Can be pre-tokenized when is_split_into_words=True . Returns A list or a list of list of dict Each result comes as a list of dictionaries (one for each token in the corresponding input, or each entity if this pipeline was instantiated with an aggregation_strategy) with the following keys: word ( str ) — The token/word classified. This is obtained by decoding the selected tokens. If you want to have the exact string in the original sentence, use start and end . score ( float ) — The corresponding probability for entity . entity ( str ) — The entity predicted for that token/word (it is named entity_group when aggregation_strategy is not \"none\" . index ( int , only present when aggregation_strategy=\"none\" ) — The index of the corresponding token in the sentence. start ( int , optional ) — The index of the start of the corresponding entity in the sentence. Only exists if the offsets are available within the tokenizer end ( int , optional ) — The index of the end of the corresponding entity in the sentence. Only exists if the offsets are available within the tokenizer Classify each token of the text(s) given as inputs. aggregate_words &lt; source &gt; ( entities : list aggregation_strategy : AggregationStrategy ) Override tokens from a given word that disagree to force agreement on word boundaries. Example: micro|soft| com|pany| B-ENT I-NAME I-ENT I-ENT will be rewritten with first strategy as microsoft| company| B-ENT I-ENT gather_pre_entities &lt; source &gt; ( sentence : str input_ids : ndarray scores : ndarray offset_mapping : typing.Optional[list[tuple[int, int]]] special_tokens_mask : ndarray aggregation_strategy : AggregationStrategy word_ids : typing.Optional[list[typing.Optional[int]]] = None word_to_chars_map : typing.Optional[list[tuple[int, int]]] = None ) Fuse various numpy arrays into dicts with all the information needed for aggregation group_entities &lt; source &gt; ( entities : list ) Parameters entities ( dict ) &#x2014; The entities predicted by the pipeline. Find and group together the adjacent tokens with the same entity predicted. group_sub_entities &lt; source &gt; ( entities : list ) Parameters entities ( dict ) &#x2014; The entities predicted by the pipeline. Group together the adjacent tokens with the same entity predicted. TranslationPipeline class transformers. TranslationPipeline &lt; source &gt; ( *args **kwargs ) Parameters model ( PreTrainedModel or TFPreTrainedModel ) &#x2014; The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from PreTrainedModel for PyTorch and TFPreTrainedModel for TensorFlow. tokenizer ( PreTrainedTokenizer ) &#x2014; The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from PreTrainedTokenizer . modelcard ( str or ModelCard , optional ) &#x2014; Model card attributed to the model for this pipeline. framework ( str , optional ) &#x2014; The framework to use, either &quot;pt&quot; for PyTorch or &quot;tf&quot; for TensorFlow. The specified framework must be installed. If no framework is specified, will default to the one currently installed. If no framework is specified and both frameworks are installed, will default to the framework of the model , or to PyTorch if no model is provided. task ( str , defaults to &quot;&quot; ) &#x2014; A task-identifier for the pipeline. num_workers ( int , optional , defaults to 8) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the number of workers to be used. batch_size ( int , optional , defaults to 1) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the size of the batch to use, for inference this is not always beneficial, please read Batching with pipelines . args_parser ( ArgumentHandler , optional ) &#x2014; Reference to the object in charge of parsing supplied pipeline parameters. device ( int , optional , defaults to -1) &#x2014; Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on the associated CUDA device id. You can pass native torch.device or a str too dtype ( str or torch.dtype , optional ) &#x2014; Sent directly as model_kwargs (just a simpler shortcut) to use the available precision for this model ( torch.float16 , torch.bfloat16 , &#x2026; or &quot;auto&quot; ) binary_output ( bool , optional , defaults to False ) &#x2014; Flag indicating if the output the pipeline should happen in a serialized format (i.e., pickle) or as the raw output data e.g. text. Translates from one language to another. This translation pipeline can currently be loaded from pipeline() using the following task identifier: &quot;translation_xx_to_yy&quot; . The models that this pipeline can use are models that have been fine-tuned on a translation task. See the up-to-date list of available models on huggingface.co/models . For a list of available parameters, see the following documentation Unless the model you’re using explicitly sets these generation parameters in its configuration files ( generation_config.json ), the following default values will be used: max_new_tokens: 256 num_beams: 4 Usage: Copied en_fr_translator = pipeline( &quot;translation_en_to_fr&quot; ) en_fr_translator( &quot;How old are you?&quot; ) __call__ &lt; source &gt; ( *args **kwargs ) → A list or a list of list of dict Parameters args ( str or list[str] ) &#x2014; Texts to be translated. return_tensors ( bool , optional , defaults to False ) &#x2014; Whether or not to include the tensors of predictions (as token indices) in the outputs. return_text ( bool , optional , defaults to True ) &#x2014; Whether or not to include the decoded texts in the outputs. clean_up_tokenization_spaces ( bool , optional , defaults to False ) &#x2014; Whether or not to clean up the potential extra spaces in the text output. src_lang ( str , optional ) &#x2014; The language of the input. Might be required for multilingual models. Will not have any effect for single pair translation models tgt_lang ( str , optional ) &#x2014; The language of the desired output. Might be required for multilingual models. Will not have any effect for single pair translation models generate_kwargs &#x2014; Additional keyword arguments to pass along to the generate method of the model (see the generate method corresponding to your framework here ). Returns A list or a list of list of dict Each result comes as a dictionary with the following keys: translation_text ( str , present when return_text=True ) — The translation. translation_token_ids ( torch.Tensor or tf.Tensor , present when return_tensors=True ) — The token ids of the translation. Translate the text(s) given as inputs. ZeroShotClassificationPipeline class transformers. ZeroShotClassificationPipeline &lt; source &gt; ( args_parser = &lt;transformers.pipelines.zero_shot_classification.ZeroShotClassificationArgumentHandler object at 0x7f69502ae4d0> *args **kwargs ) Parameters model ( PreTrainedModel or TFPreTrainedModel ) &#x2014; The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from PreTrainedModel for PyTorch and TFPreTrainedModel for TensorFlow. tokenizer ( PreTrainedTokenizer ) &#x2014; The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from PreTrainedTokenizer . modelcard ( str or ModelCard , optional ) &#x2014; Model card attributed to the model for this pipeline. framework ( str , optional ) &#x2014; The framework to use, either &quot;pt&quot; for PyTorch or &quot;tf&quot; for TensorFlow. The specified framework must be installed. If no framework is specified, will default to the one currently installed. If no framework is specified and both frameworks are installed, will default to the framework of the model , or to PyTorch if no model is provided. task ( str , defaults to &quot;&quot; ) &#x2014; A task-identifier for the pipeline. num_workers ( int , optional , defaults to 8) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the number of workers to be used. batch_size ( int , optional , defaults to 1) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the size of the batch to use, for inference this is not always beneficial, please read Batching with pipelines . args_parser ( ArgumentHandler , optional ) &#x2014; Reference to the object in charge of parsing supplied pipeline parameters. device ( int , optional , defaults to -1) &#x2014; Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on the associated CUDA device id. You can pass native torch.device or a str too dtype ( str or torch.dtype , optional ) &#x2014; Sent directly as model_kwargs (just a simpler shortcut) to use the available precision for this model ( torch.float16 , torch.bfloat16 , &#x2026; or &quot;auto&quot; ) binary_output ( bool , optional , defaults to False ) &#x2014; Flag indicating if the output the pipeline should happen in a serialized format (i.e., pickle) or as the raw output data e.g. text. NLI-based zero-shot classification pipeline using a ModelForSequenceClassification trained on NLI (natural language inference) tasks. Equivalent of text-classification pipelines, but these models don’t require a hardcoded number of potential classes, they can be chosen at runtime. It usually means it’s slower but it is much more flexible. Any combination of sequences and labels can be passed and each combination will be posed as a premise/hypothesis pair and passed to the pretrained model. Then, the logit for entailment is taken as the logit for the candidate label being valid. Any NLI model can be used, but the id of the entailment label must be included in the model config’s :attr: ~transformers.PretrainedConfig.label2id . Example: Copied &gt;&gt;&gt; from transformers import pipeline &gt;&gt;&gt; oracle = pipeline(model= &quot;facebook/bart-large-mnli&quot; ) &gt;&gt;&gt; oracle( ... &quot;I have a problem with my iphone that needs to be resolved asap!!&quot; , ... candidate_labels=[ &quot;urgent&quot; , &quot;not urgent&quot; , &quot;phone&quot; , &quot;tablet&quot; , &quot;computer&quot; ], ... ) { &#x27;sequence&#x27; : &#x27;I have a problem with my iphone that needs to be resolved asap!!&#x27; , &#x27;labels&#x27; : [ &#x27;urgent&#x27; , &#x27;phone&#x27; , &#x27;computer&#x27; , &#x27;not urgent&#x27; , &#x27;tablet&#x27; ], &#x27;scores&#x27; : [ 0.504 , 0.479 , 0.013 , 0.003 , 0.002 ]} &gt;&gt;&gt; oracle( ... &quot;I have a problem with my iphone that needs to be resolved asap!!&quot; , ... candidate_labels=[ &quot;english&quot; , &quot;german&quot; ], ... ) { &#x27;sequence&#x27; : &#x27;I have a problem with my iphone that needs to be resolved asap!!&#x27; , &#x27;labels&#x27; : [ &#x27;english&#x27; , &#x27;german&#x27; ], &#x27;scores&#x27; : [ 0.814 , 0.186 ]} Learn more about the basics of using a pipeline in the pipeline tutorial This NLI pipeline can currently be loaded from pipeline() using the following task identifier: &quot;zero-shot-classification&quot; . The models that this pipeline can use are models that have been fine-tuned on an NLI task. See the up-to-date list of available models on huggingface.co/models . __call__ &lt; source &gt; ( sequences : typing.Union[str, list[str]] *args **kwargs ) → A dict or a list of dict Parameters sequences ( str or list[str] ) &#x2014; The sequence(s) to classify, will be truncated if the model input is too large. candidate_labels ( str or list[str] ) &#x2014; The set of possible class labels to classify each sequence into. Can be a single label, a string of comma-separated labels, or a list of labels. hypothesis_template ( str , optional , defaults to &quot;This example is {}.&quot; ) &#x2014; The template used to turn each label into an NLI-style hypothesis. This template must include a {} or similar syntax for the candidate label to be inserted into the template. For example, the default template is &quot;This example is {}.&quot; With the candidate label &quot;sports&quot; , this would be fed into the model like &quot;&lt;cls&gt; sequence to classify &lt;sep&gt; This example is sports . &lt;sep&gt;&quot; . The default template works well in many cases, but it may be worthwhile to experiment with different templates depending on the task setting. multi_label ( bool , optional , defaults to False ) &#x2014; Whether or not multiple candidate labels can be true. If False , the scores are normalized such that the sum of the label likelihoods for each sequence is 1. If True , the labels are considered independent and probabilities are normalized for each candidate by doing a softmax of the entailment score vs. the contradiction score. Returns A dict or a list of dict Each result comes as a dictionary with the following keys: sequence ( str ) — The sequence for which this is the output. labels ( list[str] ) — The labels sorted by order of likelihood. scores ( list[float] ) — The probabilities for each of the labels. Classify the sequence(s) given as inputs. See the ZeroShotClassificationPipeline documentation for more information. Multimodal Pipelines available for multimodal tasks include the following. DocumentQuestionAnsweringPipeline class transformers. DocumentQuestionAnsweringPipeline &lt; source &gt; ( *args **kwargs ) Parameters model ( PreTrainedModel or TFPreTrainedModel ) &#x2014; The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from PreTrainedModel for PyTorch and TFPreTrainedModel for TensorFlow. tokenizer ( PreTrainedTokenizer ) &#x2014; The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from PreTrainedTokenizer . image_processor ( BaseImageProcessor ) &#x2014; The image processor that will be used by the pipeline to encode data for the model. This object inherits from BaseImageProcessor . modelcard ( str or ModelCard , optional ) &#x2014; Model card attributed to the model for this pipeline. framework ( str , optional ) &#x2014; The framework to use, either &quot;pt&quot; for PyTorch or &quot;tf&quot; for TensorFlow. The specified framework must be installed. If no framework is specified, will default to the one currently installed. If no framework is specified and both frameworks are installed, will default to the framework of the model , or to PyTorch if no model is provided. task ( str , defaults to &quot;&quot; ) &#x2014; A task-identifier for the pipeline. num_workers ( int , optional , defaults to 8) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the number of workers to be used. batch_size ( int , optional , defaults to 1) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the size of the batch to use, for inference this is not always beneficial, please read Batching with pipelines . args_parser ( ArgumentHandler , optional ) &#x2014; Reference to the object in charge of parsing supplied pipeline parameters. device ( int , optional , defaults to -1) &#x2014; Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on the associated CUDA device id. You can pass native torch.device or a str too dtype ( str or torch.dtype , optional ) &#x2014; Sent directly as model_kwargs (just a simpler shortcut) to use the available precision for this model ( torch.float16 , torch.bfloat16 , &#x2026; or &quot;auto&quot; ) binary_output ( bool , optional , defaults to False ) &#x2014; Flag indicating if the output the pipeline should happen in a serialized format (i.e., pickle) or as the raw output data e.g. text. Document Question Answering pipeline using any AutoModelForDocumentQuestionAnswering . The inputs/outputs are similar to the (extractive) question answering pipeline; however, the pipeline takes an image (and optional OCR’d words/boxes) as input instead of text context. Unless the model you’re using explicitly sets these generation parameters in its configuration files ( generation_config.json ), the following default values will be used: max_new_tokens: 256 Example: Copied &gt;&gt;&gt; from transformers import pipeline &gt;&gt;&gt; document_qa = pipeline(model= &quot;impira/layoutlm-document-qa&quot; ) &gt;&gt;&gt; document_qa( ... image= &quot;https://huggingface.co/spaces/impira/docquery/resolve/2359223c1837a7587402bda0f2643382a6eefeab/invoice.png&quot; , ... question= &quot;What is the invoice number?&quot; , ... ) [{ &#x27;score&#x27; : 0.425 , &#x27;answer&#x27; : &#x27;us-001&#x27; , &#x27;start&#x27; : 16 , &#x27;end&#x27; : 16 }] Learn more about the basics of using a pipeline in the pipeline tutorial This document question answering pipeline can currently be loaded from pipeline() using the following task identifier: &quot;document-question-answering&quot; . The models that this pipeline can use are models that have been fine-tuned on a document question answering task. See the up-to-date list of available models on huggingface.co/models . __call__ &lt; source &gt; ( image : typing.Union[ForwardRef('Image.Image'), str, list[dict[str, typing.Any]]] question : typing.Optional[str] = None word_boxes : typing.Optional[tuple[str, list[float]]] = None **kwargs : typing.Any ) → A dict or a list of dict Parameters image ( str or PIL.Image ) &#x2014; The pipeline handles three types of images: A string containing a http link pointing to an image A string containing a local path to an image An image loaded in PIL directly The pipeline accepts either a single image or a batch of images. If given a single image, it can be broadcasted to multiple questions. question ( str ) &#x2014; A question to ask of the document. word_boxes ( list[str, tuple[float, float, float, float]] , optional ) &#x2014; A list of words and bounding boxes (normalized 0-&gt;1000). If you provide this optional input, then the pipeline will use these words and boxes instead of running OCR on the image to derive them for models that need them (e.g. LayoutLM). This allows you to reuse OCR&#x2019;d results across many invocations of the pipeline without having to re-run it each time. top_k ( int , optional , defaults to 1) &#x2014; The number of answers to return (will be chosen by order of likelihood). Note that we return less than top_k answers if there are not enough options available within the context. doc_stride ( int , optional , defaults to 128) &#x2014; If the words in the document are too long to fit with the question for the model, it will be split in several chunks with some overlap. This argument controls the size of that overlap. max_answer_len ( int , optional , defaults to 15) &#x2014; The maximum length of predicted answers (e.g., only answers with a shorter length are considered). max_seq_len ( int , optional , defaults to 384) &#x2014; The maximum length of the total sentence (context + question) in tokens of each chunk passed to the model. The context will be split in several chunks (using doc_stride as overlap) if needed. max_question_len ( int , optional , defaults to 64) &#x2014; The maximum length of the question after tokenization. It will be truncated if needed. handle_impossible_answer ( bool , optional , defaults to False ) &#x2014; Whether or not we accept impossible as an answer. lang ( str , optional ) &#x2014; Language to use while running OCR. Defaults to english. tesseract_config ( str , optional ) &#x2014; Additional flags to pass to tesseract while running OCR. timeout ( float , optional , defaults to None) &#x2014; The maximum time in seconds to wait for fetching images from the web. If None, no timeout is set and the call may block forever. Returns A dict or a list of dict Each result comes as a dictionary with the following keys: score ( float ) — The probability associated to the answer. start ( int ) — The start word index of the answer (in the OCR’d version of the input or provided word_boxes ). end ( int ) — The end word index of the answer (in the OCR’d version of the input or provided word_boxes ). answer ( str ) — The answer to the question. words ( list[int] ) — The index of each word/box pair that is in the answer Answer the question(s) given as inputs by using the document(s). A document is defined as an image and an optional list of (word, box) tuples which represent the text in the document. If the word_boxes are not provided, it will use the Tesseract OCR engine (if available) to extract the words and boxes automatically for LayoutLM-like models which require them as input. For Donut, no OCR is run. You can invoke the pipeline several ways: pipeline(image=image, question=question) pipeline(image=image, question=question, word_boxes=word_boxes) pipeline([{&quot;image&quot;: image, &quot;question&quot;: question}]) pipeline([{&quot;image&quot;: image, &quot;question&quot;: question, &quot;word_boxes&quot;: word_boxes}]) FeatureExtractionPipeline class transformers. FeatureExtractionPipeline &lt; source &gt; ( model : typing.Union[ForwardRef('PreTrainedModel'), ForwardRef('TFPreTrainedModel')] tokenizer : typing.Optional[transformers.tokenization_utils.PreTrainedTokenizer] = None feature_extractor : typing.Optional[ForwardRef('SequenceFeatureExtractor')] = None image_processor : typing.Optional[transformers.image_processing_utils.BaseImageProcessor] = None processor : typing.Optional[transformers.processing_utils.ProcessorMixin] = None modelcard : typing.Optional[transformers.modelcard.ModelCard] = None framework : typing.Optional[str] = None task : str = '' device : typing.Union[int, ForwardRef('torch.device')] = None binary_output : bool = False **kwargs ) Parameters model ( PreTrainedModel or TFPreTrainedModel ) &#x2014; The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from PreTrainedModel for PyTorch and TFPreTrainedModel for TensorFlow. tokenizer ( PreTrainedTokenizer ) &#x2014; The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from PreTrainedTokenizer . modelcard ( str or ModelCard , optional ) &#x2014; Model card attributed to the model for this pipeline. framework ( str , optional ) &#x2014; The framework to use, either &quot;pt&quot; for PyTorch or &quot;tf&quot; for TensorFlow. The specified framework must be installed. If no framework is specified, will default to the one currently installed. If no framework is specified and both frameworks are installed, will default to the framework of the model , or to PyTorch if no model is provided. task ( str , defaults to &quot;&quot; ) &#x2014; A task-identifier for the pipeline. num_workers ( int , optional , defaults to 8) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the number of workers to be used. batch_size ( int , optional , defaults to 1) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the size of the batch to use, for inference this is not always beneficial, please read Batching with pipelines . args_parser ( ArgumentHandler , optional ) &#x2014; Reference to the object in charge of parsing supplied pipeline parameters. device ( int , optional , defaults to -1) &#x2014; Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on the associated CUDA device id. You can pass native torch.device or a str too dtype ( str or torch.dtype , optional ) &#x2014; Sent directly as model_kwargs (just a simpler shortcut) to use the available precision for this model ( torch.float16 , torch.bfloat16 , &#x2026; or &quot;auto&quot; ) tokenize_kwargs ( dict , optional ) &#x2014; Additional dictionary of keyword arguments passed along to the tokenizer. return_tensors ( bool , optional ) &#x2014; If True , returns a tensor according to the specified framework, otherwise returns a list. Feature extraction pipeline uses no model head. This pipeline extracts the hidden states from the base transformer, which can be used as features in downstream tasks. Example: Copied &gt;&gt;&gt; from transformers import pipeline &gt;&gt;&gt; extractor = pipeline(model= &quot;google-bert/bert-base-uncased&quot; , task= &quot;feature-extraction&quot; ) &gt;&gt;&gt; result = extractor( &quot;This is a simple test.&quot; , return_tensors= True ) &gt;&gt;&gt; result.shape # This is a tensor of shape [1, sequence_length, hidden_dimension] representing the input string. torch.Size([ 1 , 8 , 768 ]) Learn more about the basics of using a pipeline in the pipeline tutorial This feature extraction pipeline can currently be loaded from pipeline() using the task identifier: &quot;feature-extraction&quot; . All models may be used for this pipeline. See a list of all models, including community-contributed models on huggingface.co/models . __call__ &lt; source &gt; ( *args : typing.Union[str, list[str]] **kwargs : typing.Any ) → A nested list of float Parameters args ( str or list[str] ) &#x2014; One or several texts (or one list of texts) to get the features of. Returns A nested list of float The features computed by the model. Extract the features of the input(s) text. ImageFeatureExtractionPipeline class transformers. ImageFeatureExtractionPipeline &lt; source &gt; ( model : typing.Union[ForwardRef('PreTrainedModel'), ForwardRef('TFPreTrainedModel')] tokenizer : typing.Optional[transformers.tokenization_utils.PreTrainedTokenizer] = None feature_extractor : typing.Optional[ForwardRef('SequenceFeatureExtractor')] = None image_processor : typing.Optional[transformers.image_processing_utils.BaseImageProcessor] = None processor : typing.Optional[transformers.processing_utils.ProcessorMixin] = None modelcard : typing.Optional[transformers.modelcard.ModelCard] = None framework : typing.Optional[str] = None task : str = '' device : typing.Union[int, ForwardRef('torch.device')] = None binary_output : bool = False **kwargs ) Parameters model ( PreTrainedModel or TFPreTrainedModel ) &#x2014; The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from PreTrainedModel for PyTorch and TFPreTrainedModel for TensorFlow. image_processor ( BaseImageProcessor ) &#x2014; The image processor that will be used by the pipeline to encode data for the model. This object inherits from BaseImageProcessor . modelcard ( str or ModelCard , optional ) &#x2014; Model card attributed to the model for this pipeline. framework ( str , optional ) &#x2014; The framework to use, either &quot;pt&quot; for PyTorch or &quot;tf&quot; for TensorFlow. The specified framework must be installed. If no framework is specified, will default to the one currently installed. If no framework is specified and both frameworks are installed, will default to the framework of the model , or to PyTorch if no model is provided. task ( str , defaults to &quot;&quot; ) &#x2014; A task-identifier for the pipeline. num_workers ( int , optional , defaults to 8) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the number of workers to be used. batch_size ( int , optional , defaults to 1) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the size of the batch to use, for inference this is not always beneficial, please read Batching with pipelines . args_parser ( ArgumentHandler , optional ) &#x2014; Reference to the object in charge of parsing supplied pipeline parameters. device ( int , optional , defaults to -1) &#x2014; Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on the associated CUDA device id. You can pass native torch.device or a str too dtype ( str or torch.dtype , optional ) &#x2014; Sent directly as model_kwargs (just a simpler shortcut) to use the available precision for this model ( torch.float16 , torch.bfloat16 , &#x2026; or &quot;auto&quot; ) binary_output ( bool , optional , defaults to False ) &#x2014; Flag indicating if the output the pipeline should happen in a serialized format (i.e., pickle) or as the raw output data e.g. text. image_processor_kwargs ( dict , optional ) &#x2014; Additional dictionary of keyword arguments passed along to the image processor e.g. {&#x201C;size&#x201D;: {&#x201C;height&#x201D;: 100, &#x201C;width&#x201D;: 100}&#x200C;} pool ( bool , optional , defaults to False ) &#x2014; Whether or not to return the pooled output. If False , the model will return the raw hidden states. Image feature extraction pipeline uses no model head. This pipeline extracts the hidden states from the base transformer, which can be used as features in downstream tasks. Example: Copied &gt;&gt;&gt; from transformers import pipeline &gt;&gt;&gt; extractor = pipeline(model= &quot;google/vit-base-patch16-224&quot; , task= &quot;image-feature-extraction&quot; ) &gt;&gt;&gt; result = extractor( &quot;https://huggingface.co/datasets/Narsil/image_dummy/raw/main/parrots.png&quot; , return_tensors= True ) &gt;&gt;&gt; result.shape # This is a tensor of shape [1, sequence_lenth, hidden_dimension] representing the input image. torch.Size([ 1 , 197 , 768 ]) Learn more about the basics of using a pipeline in the pipeline tutorial This image feature extraction pipeline can currently be loaded from pipeline() using the task identifier: &quot;image-feature-extraction&quot; . All vision models may be used for this pipeline. See a list of all models, including community-contributed models on huggingface.co/models . __call__ &lt; source &gt; ( *args : typing.Union[str, ForwardRef('Image.Image'), list['Image.Image'], list[str]] **kwargs : typing.Any ) → A nested list of float Parameters images ( str , list[str] , PIL.Image or list[PIL.Image] ) &#x2014; The pipeline handles three types of images: A string containing a http link pointing to an image A string containing a local path to an image An image loaded in PIL directly The pipeline accepts either a single image or a batch of images, which must then be passed as a string. Images in a batch must all be in the same format: all as http links, all as local paths, or all as PIL images. timeout ( float , optional , defaults to None) &#x2014; The maximum time in seconds to wait for fetching images from the web. If None, no timeout is used and the call may block forever. Returns A nested list of float The features computed by the model. Extract the features of the input(s). ImageToTextPipeline class transformers. ImageToTextPipeline &lt; source &gt; ( *args **kwargs ) Parameters model ( PreTrainedModel or TFPreTrainedModel ) &#x2014; The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from PreTrainedModel for PyTorch and TFPreTrainedModel for TensorFlow. tokenizer ( PreTrainedTokenizer ) &#x2014; The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from PreTrainedTokenizer . image_processor ( BaseImageProcessor ) &#x2014; The image processor that will be used by the pipeline to encode data for the model. This object inherits from BaseImageProcessor . modelcard ( str or ModelCard , optional ) &#x2014; Model card attributed to the model for this pipeline. framework ( str , optional ) &#x2014; The framework to use, either &quot;pt&quot; for PyTorch or &quot;tf&quot; for TensorFlow. The specified framework must be installed. If no framework is specified, will default to the one currently installed. If no framework is specified and both frameworks are installed, will default to the framework of the model , or to PyTorch if no model is provided. task ( str , defaults to &quot;&quot; ) &#x2014; A task-identifier for the pipeline. num_workers ( int , optional , defaults to 8) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the number of workers to be used. batch_size ( int , optional , defaults to 1) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the size of the batch to use, for inference this is not always beneficial, please read Batching with pipelines . args_parser ( ArgumentHandler , optional ) &#x2014; Reference to the object in charge of parsing supplied pipeline parameters. device ( int , optional , defaults to -1) &#x2014; Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on the associated CUDA device id. You can pass native torch.device or a str too dtype ( str or torch.dtype , optional ) &#x2014; Sent directly as model_kwargs (just a simpler shortcut) to use the available precision for this model ( torch.float16 , torch.bfloat16 , &#x2026; or &quot;auto&quot; ) binary_output ( bool , optional , defaults to False ) &#x2014; Flag indicating if the output the pipeline should happen in a serialized format (i.e., pickle) or as the raw output data e.g. text. Image To Text pipeline using a AutoModelForVision2Seq . This pipeline predicts a caption for a given image. Unless the model you’re using explicitly sets these generation parameters in its configuration files ( generation_config.json ), the following default values will be used: max_new_tokens: 256 Example: Copied &gt;&gt;&gt; from transformers import pipeline &gt;&gt;&gt; captioner = pipeline(model= &quot;ydshieh/vit-gpt2-coco-en&quot; ) &gt;&gt;&gt; captioner( &quot;https://huggingface.co/datasets/Narsil/image_dummy/raw/main/parrots.png&quot; ) [{ &#x27;generated_text&#x27; : &#x27;two birds are standing next to each other &#x27; }] Learn more about the basics of using a pipeline in the pipeline tutorial This image to text pipeline can currently be loaded from pipeline() using the following task identifier: “image-to-text”. See the list of available models on huggingface.co/models . __call__ &lt; source &gt; ( inputs : typing.Union[str, list[str], ForwardRef('Image.Image'), list['Image.Image']] **kwargs ) → A list or a list of list of dict Parameters inputs ( str , list[str] , PIL.Image or list[PIL.Image] ) &#x2014; The pipeline handles three types of images: A string containing a HTTP(s) link pointing to an image A string containing a local path to an image An image loaded in PIL directly The pipeline accepts either a single image or a batch of images. max_new_tokens ( int , optional ) &#x2014; The amount of maximum tokens to generate. By default it will use generate default. generate_kwargs ( Dict , optional ) &#x2014; Pass it to send all of these arguments directly to generate allowing full control of this function. timeout ( float , optional , defaults to None) &#x2014; The maximum time in seconds to wait for fetching images from the web. If None, no timeout is set and the call may block forever. Returns A list or a list of list of dict Each result comes as a dictionary with the following key: generated_text ( str ) — The generated text. Assign labels to the image(s) passed as inputs. ImageTextToTextPipeline class transformers. ImageTextToTextPipeline &lt; source &gt; ( *args **kwargs ) Parameters model ( PreTrainedModel or TFPreTrainedModel ) &#x2014; The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from PreTrainedModel for PyTorch and TFPreTrainedModel for TensorFlow. processor ( ProcessorMixin ) &#x2014; The processor that will be used by the pipeline to encode data for the model. This object inherits from ProcessorMixin . Processor is a composite object that might contain tokenizer , feature_extractor , and image_processor . modelcard ( str or ModelCard , optional ) &#x2014; Model card attributed to the model for this pipeline. framework ( str , optional ) &#x2014; The framework to use, either &quot;pt&quot; for PyTorch or &quot;tf&quot; for TensorFlow. The specified framework must be installed. If no framework is specified, will default to the one currently installed. If no framework is specified and both frameworks are installed, will default to the framework of the model , or to PyTorch if no model is provided. task ( str , defaults to &quot;&quot; ) &#x2014; A task-identifier for the pipeline. num_workers ( int , optional , defaults to 8) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the number of workers to be used. batch_size ( int , optional , defaults to 1) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the size of the batch to use, for inference this is not always beneficial, please read Batching with pipelines . args_parser ( ArgumentHandler , optional ) &#x2014; Reference to the object in charge of parsing supplied pipeline parameters. device ( int , optional , defaults to -1) &#x2014; Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on the associated CUDA device id. You can pass native torch.device or a str too dtype ( str or torch.dtype , optional ) &#x2014; Sent directly as model_kwargs (just a simpler shortcut) to use the available precision for this model ( torch.float16 , torch.bfloat16 , &#x2026; or &quot;auto&quot; ) binary_output ( bool , optional , defaults to False ) &#x2014; Flag indicating if the output the pipeline should happen in a serialized format (i.e., pickle) or as the raw output data e.g. text. Image-text-to-text pipeline using an AutoModelForImageTextToText . This pipeline generates text given an image and text. When the underlying model is a conversational model, it can also accept one or more chats, in which case the pipeline will operate in chat mode and will continue the chat(s) by adding its response(s). Each chat takes the form of a list of dicts, where each dict contains “role” and “content” keys. Unless the model you’re using explicitly sets these generation parameters in its configuration files ( generation_config.json ), the following default values will be used: max_new_tokens: 256 Example: Copied &gt;&gt;&gt; from transformers import pipeline &gt;&gt;&gt; pipe = pipeline(task= &quot;image-text-to-text&quot; , model= &quot;Salesforce/blip-image-captioning-base&quot; ) &gt;&gt;&gt; pipe( &quot;https://huggingface.co/datasets/Narsil/image_dummy/raw/main/parrots.png&quot; , text= &quot;A photo of&quot; ) [{ &#x27;generated_text&#x27; : &#x27;a photo of two birds&#x27; }] Copied &gt;&gt;&gt; from transformers import pipeline &gt;&gt;&gt; pipe = pipeline( &quot;image-text-to-text&quot; , model= &quot;llava-hf/llava-interleave-qwen-0.5b-hf&quot; ) &gt;&gt;&gt; messages = [ &gt;&gt;&gt; { &gt;&gt;&gt; &quot;role&quot; : &quot;user&quot; , &gt;&gt;&gt; &quot;content&quot; : [ &gt;&gt;&gt; { &gt;&gt;&gt; &quot;type&quot; : &quot;image&quot; , &gt;&gt;&gt; &quot;url&quot; : &quot;https://qianwen-res.oss-cn-beijing.aliyuncs.com/Qwen-VL/assets/demo.jpeg&quot; , &gt;&gt;&gt; }, &gt;&gt;&gt; { &quot;type&quot; : &quot;text&quot; , &quot;text&quot; : &quot;Describe this image.&quot; }, &gt;&gt;&gt; ], &gt;&gt;&gt; }, &gt;&gt;&gt; { &gt;&gt;&gt; &quot;role&quot; : &quot;assistant&quot; , &gt;&gt;&gt; &quot;content&quot; : [ &gt;&gt;&gt; { &quot;type&quot; : &quot;text&quot; , &quot;text&quot; : &quot;There is a dog and&quot; }, &gt;&gt;&gt; ], &gt;&gt;&gt; }, &gt;&gt;&gt; ] &gt;&gt;&gt; pipe(text=messages, max_new_tokens= 20 , return_full_text= False ) [{ &#x27;input_text&#x27; : [{ &#x27;role&#x27; : &#x27;user&#x27; , &#x27;content&#x27; : [{ &#x27;type&#x27; : &#x27;image&#x27; , &#x27;url&#x27; : &#x27;https://qianwen-res.oss-cn-beijing.aliyuncs.com/Qwen-VL/assets/demo.jpeg&#x27; }, { &#x27;type&#x27; : &#x27;text&#x27; , &#x27;text&#x27; : &#x27;Describe this image.&#x27; }]}, { &#x27;role&#x27; : &#x27;assistant&#x27; , &#x27;content&#x27; : [{ &#x27;type&#x27; : &#x27;text&#x27; , &#x27;text&#x27; : &#x27;There is a dog and&#x27; }]}], &#x27;generated_text&#x27; : &#x27; a person in the image. The dog is sitting on the sand, and the person is sitting on&#x27; }] Learn more about the basics of using a pipeline in the pipeline tutorial This image-text to text pipeline can currently be loaded from pipeline() using the following task identifier: “image-text-to-text”. See the list of available models on huggingface.co/models . __call__ &lt; source &gt; ( images : typing.Union[str, list[str], list[list[str]], ForwardRef('Image.Image'), list['Image.Image'], list[list['Image.Image']], list[dict], NoneType] = None text : typing.Union[str, list[str], list[dict], NoneType] = None **kwargs ) → A list or a list of list of dict Parameters images ( str , list[str] , PIL.Image, list[PIL.Image] , list[dict[str, Union[str, PIL.Image]]]`) &#x2014; The pipeline handles three types of images: A string containing a HTTP(s) link pointing to an image A string containing a local path to an image An image loaded in PIL directly The pipeline accepts either a single image or a batch of images. Finally, this pipeline also supports the chat format (see text ) containing images and text in this argument. text (str, list[str], list[dict[str, Union[str, PIL.Image]]] ) &#x2014; The text to be used for generation. If a list of strings is passed, the length of the list should be the same as the number of images. Text can also follow the chat format: a list of dictionaries where each dictionary represents a message in a conversation. Each dictionary should have two keys: &#x2018;role&#x2019; and &#x2018;content&#x2019;. &#x2018;role&#x2019; should be one of &#x2018;user&#x2019;, &#x2018;system&#x2019; or &#x2018;assistant&#x2019;. &#x2018;content&#x2019; should be a list of dictionary containing the text of the message and the type of the message. The type of the message can be either &#x2018;text&#x2019; or &#x2018;image&#x2019;. If the type is &#x2018;image&#x2019;, no text is needed. return_tensors ( bool , optional , defaults to False ) &#x2014; Returns the tensors of predictions (as token indices) in the outputs. If set to True , the decoded text is not returned. return_text ( bool , optional ) &#x2014; Returns the decoded texts in the outputs. return_full_text ( bool , optional , defaults to True ) &#x2014; If set to False only added text is returned, otherwise the full text is returned. Cannot be specified at the same time as return_text . clean_up_tokenization_spaces ( bool , optional , defaults to True ) &#x2014; Whether or not to clean up the potential extra spaces in the text output. continue_final_message( bool , optional ) &#x2014; This indicates that you want the model to continue the last message in the input chat rather than starting a new one, allowing you to &#x201C;prefill&#x201D; its response. By default this is True when the final message in the input chat has the assistant role and False otherwise, but you can manually override that behaviour by setting this flag. Returns A list or a list of list of dict Each result comes as a dictionary with the following key (cannot return a combination of both generated_text and generated_token_ids ): generated_text ( str , present when return_text=True ) — The generated text. generated_token_ids ( torch.Tensor , present when return_tensors=True ) — The token ids of the generated text. input_text ( str ) — The input text. Generate a text given text and the image(s) passed as inputs. MaskGenerationPipeline class transformers. MaskGenerationPipeline &lt; source &gt; ( **kwargs ) Parameters model ( PreTrainedModel or TFPreTrainedModel ) &#x2014; The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from PreTrainedModel for PyTorch and TFPreTrainedModel for TensorFlow. image_processor ( BaseImageProcessor ) &#x2014; The image processor that will be used by the pipeline to encode data for the model. This object inherits from BaseImageProcessor . modelcard ( str or ModelCard , optional ) &#x2014; Model card attributed to the model for this pipeline. framework ( str , optional ) &#x2014; The framework to use, either &quot;pt&quot; for PyTorch or &quot;tf&quot; for TensorFlow. The specified framework must be installed. If no framework is specified, will default to the one currently installed. If no framework is specified and both frameworks are installed, will default to the framework of the model , or to PyTorch if no model is provided. task ( str , defaults to &quot;&quot; ) &#x2014; A task-identifier for the pipeline. num_workers ( int , optional , defaults to 8) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the number of workers to be used. batch_size ( int , optional , defaults to 1) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the size of the batch to use, for inference this is not always beneficial, please read Batching with pipelines . args_parser ( ArgumentHandler , optional ) &#x2014; Reference to the object in charge of parsing supplied pipeline parameters. device ( int , optional , defaults to -1) &#x2014; Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on the associated CUDA device id. You can pass native torch.device or a str too dtype ( str or torch.dtype , optional ) &#x2014; Sent directly as model_kwargs (just a simpler shortcut) to use the available precision for this model ( torch.float16 , torch.bfloat16 , &#x2026; or &quot;auto&quot; ) binary_output ( bool , optional , defaults to False ) &#x2014; Flag indicating if the output the pipeline should happen in a serialized format (i.e., pickle) or as the raw output data e.g. text. points_per_batch ( optional , int, default to 64) &#x2014; Sets the number of points run simultaneously by the model. Higher numbers may be faster but use more GPU memory. output_bboxes_mask ( bool , optional , default to False ) &#x2014; Whether or not to output the bounding box predictions. output_rle_masks ( bool , optional , default to False ) &#x2014; Whether or not to output the masks in RLE format Automatic mask generation for images using SamForMaskGeneration . This pipeline predicts binary masks for an image, given an image. It is a ChunkPipeline because you can separate the points in a mini-batch in order to avoid OOM issues. Use the points_per_batch argument to control the number of points that will be processed at the same time. Default is 64 . The pipeline works in 3 steps: preprocess : A grid of 1024 points evenly separated is generated along with bounding boxes and point labels. For more details on how the points and bounding boxes are created, check the _generate_crop_boxes function. The image is also preprocessed using the image_processor . This function yields a minibatch of points_per_batch . forward : feeds the outputs of preprocess to the model. The image embedding is computed only once. Calls both self.model.get_image_embeddings and makes sure that the gradients are not computed, and the tensors and models are on the same device. postprocess : The most important part of the automatic mask generation happens here. Three steps are induced: image_processor.postprocess_masks (run on each minibatch loop): takes in the raw output masks, resizes them according to the image size, and transforms there to binary masks. image_processor.filter_masks (on each minibatch loop): uses both pred_iou_thresh and stability_scores . Also applies a variety of filters based on non maximum suppression to remove bad masks. image_processor.postprocess_masks_for_amg applies the NSM on the mask to only keep relevant ones. Example: Copied &gt;&gt;&gt; from transformers import pipeline &gt;&gt;&gt; generator = pipeline(model= &quot;facebook/sam-vit-base&quot; , task= &quot;mask-generation&quot; ) &gt;&gt;&gt; outputs = generator( ... &quot;http://images.cocodataset.org/val2017/000000039769.jpg&quot; , ... ) &gt;&gt;&gt; outputs = generator( ... &quot;https://huggingface.co/datasets/Narsil/image_dummy/raw/main/parrots.png&quot; , points_per_batch= 128 ... ) Learn more about the basics of using a pipeline in the pipeline tutorial This segmentation pipeline can currently be loaded from pipeline() using the following task identifier: &quot;mask-generation&quot; . See the list of available models on huggingface.co/models . __call__ &lt; source &gt; ( image : typing.Union[str, ForwardRef('Image.Image'), list[str], list['Image.Image']] *args : typing.Any **kwargs : typing.Any ) → Dict Parameters image ( str , List[str] , PIL.Image or List[PIL.Image] ) &#x2014; Image or list of images. mask_threshold ( float , optional , defaults to 0.0) &#x2014; Threshold to use when turning the predicted masks into binary values. pred_iou_thresh ( float , optional , defaults to 0.88) &#x2014; A filtering threshold in [0,1] applied on the model&#x2019;s predicted mask quality. stability_score_thresh ( float , optional , defaults to 0.95) &#x2014; A filtering threshold in [0,1] , using the stability of the mask under changes to the cutoff used to binarize the model&#x2019;s mask predictions. stability_score_offset ( int , optional , defaults to 1) &#x2014; The amount to shift the cutoff when calculated the stability score. crops_nms_thresh ( float , optional , defaults to 0.7) &#x2014; The box IoU cutoff used by non-maximal suppression to filter duplicate masks. crops_n_layers ( int , optional , defaults to 0) &#x2014; If crops_n_layers&gt;0 , mask prediction will be run again on crops of the image. Sets the number of layers to run, where each layer has 2**i_layer number of image crops. crop_overlap_ratio ( float , optional , defaults to 512 / 1500 ) &#x2014; Sets the degree to which crops overlap. In the first crop layer, crops will overlap by this fraction of the image length. Later layers with more crops scale down this overlap. crop_n_points_downscale_factor ( int , optional , defaults to 1 ) &#x2014; The number of points-per-side sampled in layer n is scaled down by crop_n_points_downscale_factor**n. timeout ( float , optional , defaults to None) &#x2014; The maximum time in seconds to wait for fetching images from the web. If None, no timeout is set and the call may block forever. Returns Dict A dictionary with the following keys: mask ( PIL.Image ) — A binary mask of the detected object as a PIL Image of shape (width, height) of the original image. Returns a mask filled with zeros if no object is found. score ( optional float ) — Optionally, when the model is capable of estimating a confidence of the “object” described by the label and the mask. Generates binary segmentation masks VisualQuestionAnsweringPipeline class transformers. VisualQuestionAnsweringPipeline &lt; source &gt; ( *args **kwargs ) Parameters model ( PreTrainedModel or TFPreTrainedModel ) &#x2014; The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from PreTrainedModel for PyTorch and TFPreTrainedModel for TensorFlow. tokenizer ( PreTrainedTokenizer ) &#x2014; The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from PreTrainedTokenizer . image_processor ( BaseImageProcessor ) &#x2014; The image processor that will be used by the pipeline to encode data for the model. This object inherits from BaseImageProcessor . modelcard ( str or ModelCard , optional ) &#x2014; Model card attributed to the model for this pipeline. framework ( str , optional ) &#x2014; The framework to use, either &quot;pt&quot; for PyTorch or &quot;tf&quot; for TensorFlow. The specified framework must be installed. If no framework is specified, will default to the one currently installed. If no framework is specified and both frameworks are installed, will default to the framework of the model , or to PyTorch if no model is provided. task ( str , defaults to &quot;&quot; ) &#x2014; A task-identifier for the pipeline. num_workers ( int , optional , defaults to 8) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the number of workers to be used. batch_size ( int , optional , defaults to 1) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the size of the batch to use, for inference this is not always beneficial, please read Batching with pipelines . args_parser ( ArgumentHandler , optional ) &#x2014; Reference to the object in charge of parsing supplied pipeline parameters. device ( int , optional , defaults to -1) &#x2014; Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on the associated CUDA device id. You can pass native torch.device or a str too dtype ( str or torch.dtype , optional ) &#x2014; Sent directly as model_kwargs (just a simpler shortcut) to use the available precision for this model ( torch.float16 , torch.bfloat16 , &#x2026; or &quot;auto&quot; ) binary_output ( bool , optional , defaults to False ) &#x2014; Flag indicating if the output the pipeline should happen in a serialized format (i.e., pickle) or as the raw output data e.g. text. Visual Question Answering pipeline using a AutoModelForVisualQuestionAnswering . This pipeline is currently only available in PyTorch. Unless the model you’re using explicitly sets these generation parameters in its configuration files ( generation_config.json ), the following default values will be used: max_new_tokens: 256 Example: Copied &gt;&gt;&gt; from transformers import pipeline &gt;&gt;&gt; oracle = pipeline(model= &quot;dandelin/vilt-b32-finetuned-vqa&quot; ) &gt;&gt;&gt; image_url = &quot;https://huggingface.co/datasets/Narsil/image_dummy/raw/main/lena.png&quot; &gt;&gt;&gt; oracle(question= &quot;What is she wearing ?&quot; , image=image_url) [{ &#x27;score&#x27; : 0.948 , &#x27;answer&#x27; : &#x27;hat&#x27; }, { &#x27;score&#x27; : 0.009 , &#x27;answer&#x27; : &#x27;fedora&#x27; }, { &#x27;score&#x27; : 0.003 , &#x27;answer&#x27; : &#x27;clothes&#x27; }, { &#x27;score&#x27; : 0.003 , &#x27;answer&#x27; : &#x27;sun hat&#x27; }, { &#x27;score&#x27; : 0.002 , &#x27;answer&#x27; : &#x27;nothing&#x27; }] &gt;&gt;&gt; oracle(question= &quot;What is she wearing ?&quot; , image=image_url, top_k= 1 ) [{ &#x27;score&#x27; : 0.948 , &#x27;answer&#x27; : &#x27;hat&#x27; }] &gt;&gt;&gt; oracle(question= &quot;Is this a person ?&quot; , image=image_url, top_k= 1 ) [{ &#x27;score&#x27; : 0.993 , &#x27;answer&#x27; : &#x27;yes&#x27; }] &gt;&gt;&gt; oracle(question= &quot;Is this a man ?&quot; , image=image_url, top_k= 1 ) [{ &#x27;score&#x27; : 0.996 , &#x27;answer&#x27; : &#x27;no&#x27; }] Learn more about the basics of using a pipeline in the pipeline tutorial This visual question answering pipeline can currently be loaded from pipeline() using the following task identifiers: &quot;visual-question-answering&quot;, &quot;vqa&quot; . The models that this pipeline can use are models that have been fine-tuned on a visual question answering task. See the up-to-date list of available models on huggingface.co/models . __call__ &lt; source &gt; ( image : typing.Union[ForwardRef('Image.Image'), str, list['Image.Image'], list[str], ForwardRef('KeyDataset')] question : typing.Union[str, list[str], NoneType] = None **kwargs ) → A dictionary or a list of dictionaries containing the result. The dictionaries contain the following keys Parameters image ( str , list[str] , PIL.Image , list[PIL.Image] or KeyDataset ) &#x2014; The pipeline handles three types of images: A string containing a http link pointing to an image A string containing a local path to an image An image loaded in PIL directly The pipeline accepts either a single image or a batch of images. If given a single image, it can be broadcasted to multiple questions. For dataset: the passed in dataset must be of type transformers.pipelines.pt_utils.KeyDataset Example: Returns A dictionary or a list of dictionaries containing the result. The dictionaries contain the following keys label ( str ) — The label identified by the model. score ( int ) — The score attributed by the model for that label. Answers open-ended questions about images. The pipeline accepts several types of inputs which are detailed below: pipeline(image=image, question=question) pipeline({&quot;image&quot;: image, &quot;question&quot;: question}) pipeline([{&quot;image&quot;: image, &quot;question&quot;: question}]) pipeline([{&quot;image&quot;: image, &quot;question&quot;: question}, {&quot;image&quot;: image, &quot;question&quot;: question}]) Parent class: Pipeline class transformers. Pipeline &lt; source &gt; ( model : typing.Union[ForwardRef('PreTrainedModel'), ForwardRef('TFPreTrainedModel')] tokenizer : typing.Optional[transformers.tokenization_utils.PreTrainedTokenizer] = None feature_extractor : typing.Optional[ForwardRef('SequenceFeatureExtractor')] = None image_processor : typing.Optional[transformers.image_processing_utils.BaseImageProcessor] = None processor : typing.Optional[transformers.processing_utils.ProcessorMixin] = None modelcard : typing.Optional[transformers.modelcard.ModelCard] = None framework : typing.Optional[str] = None task : str = '' device : typing.Union[int, ForwardRef('torch.device')] = None binary_output : bool = False **kwargs ) Parameters model ( PreTrainedModel or TFPreTrainedModel ) &#x2014; The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from PreTrainedModel for PyTorch and TFPreTrainedModel for TensorFlow. tokenizer ( PreTrainedTokenizer ) &#x2014; The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from PreTrainedTokenizer . feature_extractor ( SequenceFeatureExtractor ) &#x2014; The feature extractor that will be used by the pipeline to encode data for the model. This object inherits from SequenceFeatureExtractor . image_processor ( BaseImageProcessor ) &#x2014; The image processor that will be used by the pipeline to encode data for the model. This object inherits from BaseImageProcessor . processor ( ProcessorMixin ) &#x2014; The processor that will be used by the pipeline to encode data for the model. This object inherits from ProcessorMixin . Processor is a composite object that might contain tokenizer , feature_extractor , and image_processor . modelcard ( str or ModelCard , optional ) &#x2014; Model card attributed to the model for this pipeline. framework ( str , optional ) &#x2014; The framework to use, either &quot;pt&quot; for PyTorch or &quot;tf&quot; for TensorFlow. The specified framework must be installed. If no framework is specified, will default to the one currently installed. If no framework is specified and both frameworks are installed, will default to the framework of the model , or to PyTorch if no model is provided. task ( str , defaults to &quot;&quot; ) &#x2014; A task-identifier for the pipeline. num_workers ( int , optional , defaults to 8) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the number of workers to be used. batch_size ( int , optional , defaults to 1) &#x2014; When the pipeline will use DataLoader (when passing a dataset, on GPU for a Pytorch model), the size of the batch to use, for inference this is not always beneficial, please read Batching with pipelines . args_parser ( ArgumentHandler , optional ) &#x2014; Reference to the object in charge of parsing supplied pipeline parameters. device ( int , optional , defaults to -1) &#x2014; Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on the associated CUDA device id. You can pass native torch.device or a str too dtype ( str or torch.dtype , optional ) &#x2014; Sent directly as model_kwargs (just a simpler shortcut) to use the available precision for this model ( torch.float16 , torch.bfloat16 , &#x2026; or &quot;auto&quot; ) binary_output ( bool , optional , defaults to False ) &#x2014; Flag indicating if the output the pipeline should happen in a serialized format (i.e., pickle) or as the raw output data e.g. text. The Pipeline class is the class from which all pipelines inherit. Refer to this class for methods shared across different pipelines. Base class implementing pipelined operations. Pipeline workflow is defined as a sequence of the following operations: Input -&gt; Tokenization -&gt; Model Inference -&gt; Post-Processing (task dependent) -&gt; Output Pipeline supports running on CPU or GPU through the device argument (see below). Some pipeline, like for instance FeatureExtractionPipeline ( &#39;feature-extraction&#39; ) output large tensor object as nested-lists. In order to avoid dumping such large structure as textual data we provide the binary_output constructor argument. If set to True , the output will be stored in the pickle format. check_model_type &lt; source &gt; ( supported_models : typing.Union[list[str], dict] ) Parameters supported_models ( list[str] or dict ) &#x2014; The list of models supported by the pipeline, or a dictionary with model class values. Check if the model class is in supported by the pipeline. device_placement &lt; source &gt; ( ) Context Manager allowing tensor allocation on the user-specified device in framework agnostic way. Examples: Copied # Explicitly ask for tensor allocation on CUDA device :0 pipe = pipeline(..., device= 0 ) with pipe.device_placement(): # Every framework specific tensor allocation will be done on the request device output = pipe(...) ensure_tensor_on_device &lt; source &gt; ( **inputs ) → dict[str, torch.Tensor] Parameters inputs (keyword arguments that should be torch.Tensor , the rest is ignored) &#x2014; The tensors to place on self.device . Recursive on lists only . &#x2014; Returns dict[str, torch.Tensor] The same as inputs but on the proper device. Ensure PyTorch tensors are on the specified device. postprocess &lt; source &gt; ( model_outputs : ModelOutput **postprocess_parameters : dict ) Postprocess will receive the raw outputs of the _forward method, generally tensors, and reformat them into something more friendly. Generally it will output a list or a dict or results (containing just strings and numbers). predict &lt; source &gt; ( X ) Scikit / Keras interface to transformers’ pipelines. This method will forward to call (). preprocess &lt; source &gt; ( input_ : typing.Any **preprocess_parameters : dict ) Preprocess will take the input_ of a specific pipeline and return a dictionary of everything necessary for _forward to run properly. It should contain at least one tensor, but might have arbitrary other items. push_to_hub &lt; source &gt; ( repo_id : str use_temp_dir : typing.Optional[bool] = None commit_message : typing.Optional[str] = None private : typing.Optional[bool] = None token : typing.Union[bool, str, NoneType] = None max_shard_size : typing.Union[str, int, NoneType] = '5GB' create_pr : bool = False safe_serialization : bool = True revision : typing.Optional[str] = None commit_description : typing.Optional[str] = None tags : typing.Optional[list[str]] = None **deprecated_kwargs ) Parameters repo_id ( str ) &#x2014; The name of the repository you want to push your pipe to. It should contain your organization name when pushing to a given organization. use_temp_dir ( bool , optional ) &#x2014; Whether or not to use a temporary directory to store the files saved before they are pushed to the Hub. Will default to True if there is no directory named like repo_id , False otherwise. commit_message ( str , optional ) &#x2014; Message to commit while pushing. Will default to &quot;Upload pipe&quot; . private ( bool , optional ) &#x2014; Whether to make the repo private. If None (default), the repo will be public unless the organization&#x2019;s default is private. This value is ignored if the repo already exists. token ( bool or str , optional ) &#x2014; The token to use as HTTP bearer authorization for remote files. If True , will use the token generated when running hf auth login (stored in ~/.huggingface ). Will default to True if repo_url is not specified. max_shard_size ( int or str , optional , defaults to &quot;5GB&quot; ) &#x2014; Only applicable for models. The maximum size for a checkpoint before being sharded. Checkpoints shard will then be each of size lower than this size. If expressed as a string, needs to be digits followed by a unit (like &quot;5MB&quot; ). We default it to &quot;5GB&quot; so that users can easily load models on free-tier Google Colab instances without any CPU OOM issues. create_pr ( bool , optional , defaults to False ) &#x2014; Whether or not to create a PR with the uploaded files or directly commit. safe_serialization ( bool , optional , defaults to True ) &#x2014; Whether or not to convert the model weights in safetensors format for safer serialization. revision ( str , optional ) &#x2014; Branch to push the uploaded files to. commit_description ( str , optional ) &#x2014; The description of the commit that will be created tags ( list[str] , optional ) &#x2014; List of tags to push on the Hub. Upload the pipeline file to the 🤗 Model Hub. Examples: Copied from transformers import pipeline pipe = pipeline( &quot;google-bert/bert-base-cased&quot; ) # Push the pipe to your namespace with the name &quot;my-finetuned-bert&quot;. pipe.push_to_hub( &quot;my-finetuned-bert&quot; ) # Push the pipe to an organization with the name &quot;my-finetuned-bert&quot;. pipe.push_to_hub( &quot;huggingface/my-finetuned-bert&quot; ) save_pretrained &lt; source &gt; ( save_directory : typing.Union[str, os.PathLike] safe_serialization : bool = True **kwargs ) Parameters save_directory ( str or os.PathLike ) &#x2014; A path to the directory where to saved. It will be created if it doesn&#x2019;t exist. safe_serialization ( str ) &#x2014; Whether to save the model using safetensors or the traditional way for PyTorch or Tensorflow. kwargs ( dict[str, Any] , optional ) &#x2014; Additional key word arguments passed along to the push_to_hub() method. Save the pipeline’s model and tokenizer. transform &lt; source &gt; ( X ) Scikit / Keras interface to transformers’ pipelines. This method will forward to call (). &lt; &gt; Update on GitHub ← PEFT Processors → Pipelines The pipeline abstraction Pipeline batching Pipeline chunk batching Pipeline F P16 inference Pipeline custom code Implementing a pipeline Audio Audio Classification Pipeline Automatic Speech Recognition Pipeline Text To Audio Pipeline Zero Shot Audio Classification Pipeline Computer vision Depth Estimation Pipeline Image Classification Pipeline Image Segmentation Pipeline Image To Image Pipeline Keypoint Matching Pipeline Object Detection Pipeline Video Classification Pipeline Zero Shot Image Classification Pipeline Zero Shot Object Detection Pipeline Natural Language Processing Fill Mask Pipeline Question Answering Pipeline Summarization Pipeline Table Question Answering Pipeline Text Classification Pipeline Text Generation Pipeline Text2 Text Generation Pipeline Token Classification Pipeline Translation Pipeline Zero Shot Classification Pipeline Multimodal Document Question Answering Pipeline Feature Extraction Pipeline Image Feature Extraction Pipeline Image To Text Pipeline Image Text To Text Pipeline Mask Generation Pipeline Visual Question Answering Pipeline Parent class: Pipeline ",
      "fetch_method": "direct-html"
    }
  ]
}