{
    "repo": "Tencent-Hunyuan/HunyuanImage-2.1",
    "branch": "main",
    "files": [
        ".gitattributes",
        ".gitignore",
        "LICENSE",
        "NOTICE",
        "README.md",
        "README_CN.md",
        "assets/WECHAT.md",
        "assets/comparison.png",
        "assets/framework_overall.png",
        "assets/framework_prompt_rewrite.png",
        "assets/gsb.png",
        "assets/logo.png",
        "assets/reprompt.jpg",
        "assets/show_cases.png",
        "assets/wechat.png",
        "ckpts/checkpoints-download.md",
        "hyimage/common/config/__init__.py",
        "hyimage/common/config/base_config.py",
        "hyimage/common/config/lazy.py",
        "hyimage/common/constants.py",
        "hyimage/common/format_prompt.py",
        "hyimage/diffusion/cfg_utils.py",
        "hyimage/diffusion/pipelines/__init__.py",
        "hyimage/diffusion/pipelines/hunyuanimage_pipeline.py",
        "hyimage/diffusion/pipelines/hunyuanimage_refiner_pipeline.py",
        "hyimage/models/hunyuan/__init__.py",
        "hyimage/models/hunyuan/configs/hunyuanimage_config.py",
        "hyimage/models/hunyuan/modules/__init__.py",
        "hyimage/models/hunyuan/modules/activation_layers.py",
        "hyimage/models/hunyuan/modules/embed_layers.py",
        "hyimage/models/hunyuan/modules/flash_attn_no_pad.py",
        "hyimage/models/hunyuan/modules/hunyuanimage_dit.py",
        "hyimage/models/hunyuan/modules/mlp_layers.py",
        "hyimage/models/hunyuan/modules/models.py",
        "hyimage/models/hunyuan/modules/modulate_layers.py",
        "hyimage/models/hunyuan/modules/norm_layers.py",
        "hyimage/models/hunyuan/modules/posemb_layers.py",
        "hyimage/models/hunyuan/modules/token_refiner.py",
        "hyimage/models/hunyuan/utils/__init__.py",
        "hyimage/models/hunyuan/utils/helpers.py",
        "hyimage/models/model_zoo.py",
        "hyimage/models/reprompt/__init__.py",
        "hyimage/models/reprompt/reprompt.py",
        "hyimage/models/text_encoder/__init__.py",
        "hyimage/models/text_encoder/byT5/__init__.py",
        "hyimage/models/utils/fp8_quantization.py",
        "hyimage/models/vae/__init__.py",
        "hyimage/models/vae/hunyuanimage_vae.py",
        "hyimage/models/vae/refiner_vae.py",
        "requirements.txt"
    ],
    "license_files": {
        "LICENSE": "TENCENT HUNYUAN COMMUNITY LICENSE AGREEMENT\r\nTencent HunyuanImage 2.1 Release Date: September 8, 2025\r\nTHIS LICENSE AGREEMENT DOES NOT APPLY IN THE EUROPEAN UNION, UNITED KINGDOM AND SOUTH KOREA AND IS EXPRESSLY LIMITED TO THE TERRITORY, AS DEFINED BELOW.\r\nBy clicking to agree or by using, reproducing, modifying, distributing, performing or displaying any portion or element of the Tencent Hunyuan Works, including via any Hosted Service, You will be deemed to have recognized and accepted the content of this Agreement, which is effective immediately.\r\n1.\tDEFINITIONS.\r\na.\t“Acceptable Use Policy” shall mean the policy made available by Tencent as set forth in the Exhibit A.\r\nb.\t“Agreement” shall mean the terms and conditions for use, reproduction, distribution, modification, performance and displaying of Tencent Hunyuan Works or any portion or element thereof set forth herein.\r\nc.\t“Documentation” shall mean the specifications, manuals and documentation for Tencent Hunyuan made publicly available by Tencent.\r\nd.\t“Hosted Service” shall mean a hosted service offered via an application programming interface (API), web access, or any other electronic or remote means.\r\ne.\t“Licensee,” “You” or “Your” shall mean a natural person or legal entity exercising the rights granted by this Agreement and/or using the Tencent Hunyuan Works for any purpose and in any field of use.\r\nf.\t“Materials” shall mean, collectively, Tencent’s proprietary Tencent Hunyuan and Documentation (and any portion thereof) as made available by Tencent under this Agreement.\r\ng.\t“Model Derivatives” shall mean all: (i) modifications to Tencent Hunyuan or any Model Derivative of Tencent Hunyuan; (ii) works based on Tencent Hunyuan or any Model Derivative of Tencent Hunyuan; or (iii) any other machine learning model which is created by transfer of patterns of the weights, parameters, operations, or Output of Tencent Hunyuan or any Model Derivative of Tencent Hunyuan, to that model in order to cause that model to perform similarly to Tencent Hunyuan or a Model Derivative of Tencent Hunyuan, including distillation methods, methods that use intermediate data representations, or methods based on the generation of synthetic data Outputs by Tencent Hunyuan or a Model Derivative of Tencent Hunyuan for training that model. For clarity, Outputs by themselves are not deemed Model Derivatives.\r\nh.\t“Output” shall mean the information and/or content output of Tencent Hunyuan or a Model Derivative that results from operating or otherwise using Tencent Hunyuan or a Model Derivative, including via a Hosted Service.\r\ni.\t“Tencent,” “We” or “Us” shall mean the applicable entity or entities in the Tencent corporate family that own(s) intellectual property or other rights embodied in or utilized by the Materials.\r\nj.\t“Tencent Hunyuan” shall mean the large language models, text/image/video/audio/3D generation models, and multimodal large language models and their software and algorithms, including trained model weights, parameters (including optimizer states), machine-learning model code, inference-enabling code, training-enabling code, fine-tuning enabling code and other elements of the foregoing made publicly available by Us, including, without limitation to, Tencent HunyuanImage 2.1 released at [https://github.com/Tencent-Hunyuan/HunyuanImage-2.1/blob/master/LICENSE；https://huggingface.co/tencent/HunyuanImage-2.1/blob/main/LICENSE].\r\nk.\t“Tencent Hunyuan Works” shall mean: (i) the Materials; (ii) Model Derivatives; and (iii) all derivative works thereof.\r\nl.\t“Territory” shall mean the worldwide territory, excluding the territory of the European Union, United Kingdom and South Korea. \r\nm.\t“Third Party” or “Third Parties” shall mean individuals or legal entities that are not under common control with Us or You.\r\nn.\t“including” shall mean including but not limited to.\r\n2.\tGRANT OF RIGHTS.\r\nWe grant You, for the Territory only, a non-exclusive, non-transferable and royalty-free limited license under Tencent’s intellectual property or other rights owned by Us embodied in or utilized by the Materials to use, reproduce, distribute, create derivative works of (including Model Derivatives), and make modifications to the Materials, only in accordance with the terms of this Agreement and the Acceptable Use Policy, and You must not violate (or encourage or permit anyone else to violate) any term of this Agreement or the Acceptable Use Policy.\r\n3.\tDISTRIBUTION.\r\nYou may, subject to Your compliance with this Agreement, distribute or make available to Third Parties the Tencent Hunyuan Works, exclusively in the Territory, provided that You meet all of the following conditions:\r\na.\tYou must provide all such Third Party recipients of the Tencent Hunyuan Works or products or services using them a copy of this Agreement;\r\nb.\tYou must cause any modified files to carry prominent notices stating that You changed the files;\r\nc.\tYou are encouraged to: (i) publish at least one technology introduction blogpost or one public statement expressing Your experience of using the Tencent Hunyuan Works; and (ii) mark the products or services developed by using the Tencent Hunyuan Works to indicate that the product/service is “Powered by Tencent Hunyuan”; and\r\nd.\tAll distributions to Third Parties (other than through a Hosted Service) must be accompanied by a “Notice” text file that contains the following notice: “Tencent Hunyuan is licensed under the Tencent Hunyuan Community License Agreement, Copyright © 2025 Tencent. All Rights Reserved. The trademark rights of “Tencent Hunyuan” are owned by Tencent or its affiliate.”\r\nYou may add Your own copyright statement to Your modifications and, except as set forth in this Section and in Section 5, may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Model Derivatives as a whole, provided Your use, reproduction, modification, distribution, performance and display of the work otherwise complies with the terms and conditions of this Agreement (including as regards the Territory). If You receive Tencent Hunyuan Works from a Licensee as part of an integrated end user product, then this Section 3 of this Agreement will not apply to You.\r\n4.\tADDITIONAL COMMERCIAL TERMS.\r\nIf, on the Tencent Hunyuan version release date, the monthly active users of all products or services made available by or for Licensee is greater than 100 million monthly active users in the preceding calendar month, You must request a license from Tencent, which Tencent may grant to You in its sole discretion, and You are not authorized to exercise any of the rights under this Agreement unless or until Tencent otherwise expressly grants You such rights.\r\n5.\tRULES OF USE.\r\na.\tYour use of the Tencent Hunyuan Works must comply with applicable laws and regulations (including trade compliance laws and regulations) and adhere to the Acceptable Use Policy for the Tencent Hunyuan Works, which is hereby incorporated by reference into this Agreement. You must include the use restrictions referenced in these Sections 5(a) and 5(b) as an enforceable provision in any agreement (e.g., license agreement, terms of use, etc.) governing the use and/or distribution of Tencent Hunyuan Works and You must provide notice to subsequent users to whom You distribute that Tencent Hunyuan Works are subject to the use restrictions in these Sections 5(a) and 5(b).\r\nb.\tYou must not use the Tencent Hunyuan Works or any Output or results of the Tencent Hunyuan Works to improve any other AI model (other than Tencent Hunyuan or Model Derivatives thereof).\r\nc.\tYou must not use, reproduce, modify, distribute, or display the Tencent Hunyuan Works, Output or results of the Tencent Hunyuan Works outside the Territory. Any such use outside the Territory is unlicensed and unauthorized under this Agreement.\r\n6.\tINTELLECTUAL PROPERTY.\r\na.\tSubject to Tencent’s ownership of Tencent Hunyuan Works made by or for Tencent and intellectual property rights therein, conditioned upon Your compliance with the terms and conditions of this Agreement, as between You and Tencent, You will be the owner of any derivative works and modifications of the Materials and any Model Derivatives that are made by or for You.\r\nb.\tNo trademark licenses are granted under this Agreement, and in connection with the Tencent Hunyuan Works, Licensee may not use any name or mark owned by or associated with Tencent or any of its affiliates, except as required for reasonable and customary use in describing and distributing the Tencent Hunyuan Works. Tencent hereby grants You a license to use “Tencent Hunyuan” (the “Mark”) in the Territory solely as required to comply with the provisions of Section 3(c), provided that You comply with any applicable laws related to trademark protection. All goodwill arising out of Your use of the Mark will inure to the benefit of Tencent.\r\nc.\tIf You commence a lawsuit or other proceedings (including a cross-claim or counterclaim in a lawsuit) against Us or any person or entity alleging that the Materials or any Output, or any portion of any of the foregoing, infringe any intellectual property or other right owned or licensable by You, then all licenses granted to You under this Agreement shall terminate as of the date such lawsuit or other proceeding is filed. You will defend, indemnify and hold harmless Us from and against any claim by any Third Party arising out of or related to Your or the Third Party’s use or distribution of the Tencent Hunyuan Works.\r\nd.\tTencent claims no rights in Outputs You generate. You and Your users are solely responsible for Outputs and their subsequent uses.\r\n7.\tDISCLAIMERS OF WARRANTY AND LIMITATIONS OF LIABILITY.\r\na.\tWe are not obligated to support, update, provide training for, or develop any further version of the Tencent Hunyuan Works or to grant any license thereto.\r\nb.\tUNLESS AND ONLY TO THE EXTENT REQUIRED BY APPLICABLE LAW, THE TENCENT HUNYUAN WORKS AND ANY OUTPUT AND RESULTS THEREFROM ARE PROVIDED “AS IS” WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES OF ANY KIND INCLUDING ANY WARRANTIES OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, COURSE OF DEALING, USAGE OF TRADE, OR FITNESS FOR A PARTICULAR PURPOSE. YOU ARE SOLELY RESPONSIBLE FOR DETERMINING THE APPROPRIATENESS OF USING, REPRODUCING, MODIFYING, PERFORMING, DISPLAYING OR DISTRIBUTING ANY OF THE TENCENT HUNYUAN WORKS OR OUTPUTS AND ASSUME ANY AND ALL RISKS ASSOCIATED WITH YOUR OR A THIRD PARTY’S USE OR DISTRIBUTION OF ANY OF THE TENCENT HUNYUAN WORKS OR OUTPUTS AND YOUR EXERCISE OF RIGHTS AND PERMISSIONS UNDER THIS AGREEMENT.\r\nc.\tTO THE FULLEST EXTENT PERMITTED BY APPLICABLE LAW, IN NO EVENT SHALL TENCENT OR ITS AFFILIATES BE LIABLE UNDER ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, TORT, NEGLIGENCE, PRODUCTS LIABILITY, OR OTHERWISE, FOR ANY DAMAGES, INCLUDING ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL, EXEMPLARY, CONSEQUENTIAL OR PUNITIVE DAMAGES, OR LOST PROFITS OF ANY KIND ARISING FROM THIS AGREEMENT OR RELATED TO ANY OF THE TENCENT HUNYUAN WORKS OR OUTPUTS, EVEN IF TENCENT OR ITS AFFILIATES HAVE BEEN ADVISED OF THE POSSIBILITY OF ANY OF THE FOREGOING.\r\n8.\tSURVIVAL AND TERMINATION.\r\na.\tThe term of this Agreement shall commence upon Your acceptance of this Agreement or access to the Materials and will continue in full force and effect until terminated in accordance with the terms and conditions herein.\r\nb.\tWe may terminate this Agreement if You breach any of the terms or conditions of this Agreement. Upon termination of this Agreement, You must promptly delete and cease use of the Tencent Hunyuan Works. Sections 6(a), 6(c), 7 and 9 shall survive the termination of this Agreement.\r\n9.\tGOVERNING LAW AND JURISDICTION.\r\na.\tThis Agreement and any dispute arising out of or relating to it will be governed by the laws of the Hong Kong Special Administrative Region of the People’s Republic of China, without regard to conflict of law principles, and the UN Convention on Contracts for the International Sale of Goods does not apply to this Agreement.\r\nb.\tExclusive jurisdiction and venue for any dispute arising out of or relating to this Agreement will be a court of competent jurisdiction in the Hong Kong Special Administrative Region of the People’s Republic of China, and Tencent and Licensee consent to the exclusive jurisdiction of such court with respect to any such dispute.\r\n \r\nEXHIBIT A\r\nACCEPTABLE USE POLICY\r\n\r\nTencent reserves the right to update this Acceptable Use Policy from time to time.\r\nLast modified: November 5, 2024\r\n\r\nTencent endeavors to promote safe and fair use of its tools and features, including Tencent Hunyuan. You agree not to use Tencent Hunyuan or Model Derivatives:\r\n1.\tOutside the Territory;\r\n2.\tIn any way that violates any applicable national, federal, state, local, international or any other law or regulation;\r\n3.\tTo harm Yourself or others;\r\n4.\tTo repurpose or distribute output from Tencent Hunyuan or any Model Derivatives to harm Yourself or others; \r\n5.\tTo override or circumvent the safety guardrails and safeguards We have put in place;\r\n6.\tFor the purpose of exploiting, harming or attempting to exploit or harm minors in any way;\r\n7.\tTo generate or disseminate verifiably false information and/or content with the purpose of harming others or influencing elections;\r\n8.\tTo generate or facilitate false online engagement, including fake reviews and other means of fake online engagement;\r\n9.\tTo intentionally defame, disparage or otherwise harass others;\r\n10.\tTo generate and/or disseminate malware (including ransomware) or any other content to be used for the purpose of harming electronic systems;\r\n11.\tTo generate or disseminate personal identifiable information with the purpose of harming others;\r\n12.\tTo generate or disseminate information (including images, code, posts, articles), and place the information in any public context (including –through the use of bot generated tweets), without expressly and conspicuously identifying that the information and/or content is machine generated;\r\n13.\tTo impersonate another individual without consent, authorization, or legal right;\r\n14.\tTo make high-stakes automated decisions in domains that affect an individual’s safety, rights or wellbeing (e.g., law enforcement, migration, medicine/health, management of critical infrastructure, safety components of products, essential services, credit, employment, housing, education, social scoring, or insurance);\r\n15.\tIn a manner that violates or disrespects the social ethics and moral standards of other countries or regions;\r\n16.\tTo perform, facilitate, threaten, incite, plan, promote or encourage violent extremism or terrorism;\r\n17.\tFor any use intended to discriminate against or harm individuals or groups based on protected characteristics or categories, online or offline social behavior or known or predicted personal or personality characteristics;\r\n18.\tTo intentionally exploit any of the vulnerabilities of a specific group of persons based on their age, social, physical or mental characteristics, in order to materially distort the behavior of a person pertaining to that group in a manner that causes or is likely to cause that person or another person physical or psychological harm;\r\n19.\tFor military purposes;\r\n20.\tTo engage in the unauthorized or unlicensed practice of any profession including, but not limited to, financial, legal, medical/health, or other professional practices."
    },
    "readme": "\n[中文阅读](./README_CN.md)\n\n<p align=\"center\">\n  <img src=\"./assets/logo.png\"  height=100>\n</p>\n\n<div align=\"center\">\n\n# HunyuanImage-2.1: An Efficient Diffusion Model for High-Resolution (2K) Text-to-Image Generation​\n\n</div>\n\n<div align=\"center\">\n  <a href=https://github.com/Tencent-Hunyuan/HunyuanImage-2.1 target=\"_blank\"><img src=https://img.shields.io/badge/Code-black.svg?logo=github height=22px></a>\n  <a href=\"https://huggingface.co/spaces/tencent/HunyuanImage-2.1\" target=\"_blank\">\n    <img src=\"https://img.shields.io/badge/Demo%20Page-blue\" height=\"22px\"></a>\n  <a href=https://huggingface.co/tencent/HunyuanImage-2.1 target=\"_blank\"><img src=https://img.shields.io/badge/%F0%9F%A4%97%20Models-d96902.svg height=22px></a>\n  <a href=\"#\" target=\"_blank\"><img src=\"https://img.shields.io/badge/Report-Coming%20Soon-blue\" height=\"22px\"></a><br/>\n  <a href=\"https://www.arxiv.org/abs/2509.04545\" target=\"https://arxiv.org/abs/2509.04545\"><img src=\"https://img.shields.io/badge/PromptEnhancer-Report-yellow\" height=\"22px\"></a>\n  <a href= https://hunyuan-promptenhancer.github.io/ target=\"_blank\"><img src=https://img.shields.io/badge/PromptEnhancer-bb8a2e.svg?logo=github height=22px></a><br/>\n  <a href=https://x.com/TencentHunyuan target=\"_blank\"><img src=https://img.shields.io/badge/Hunyuan-black.svg?logo=x height=22px></a>\n</div>\n\n<p align=\"center\">\n    👋 Join our <a href=\"assets/WECHAT.md\" target=\"_blank\">WeChat</a> \n</p>\n\n-----\n\nThis repo contains PyTorch model definitions, pretrained weights and inference/sampling code for our HunyuanImage-2.1. You can find more visualizations on our [project page](https://hunyuan.tencent.com/image/en?tabIndex=0).\n\n\n## 🔥🔥🔥 Latest Updates\n\n- September 12, 2025: 🚀 Released FP8 quantized models! Making it possible to generate 2K images with only 24GB GPU memory!\n- September 8, 2025: 🚀 Released inference code and model weights for HunyuanImage-2.1.\n\n\n## 🎥 Demo\n\n<div align=\"center\">\n  <img src=\"./assets/show_cases.png\" width=100% alt=\"HunyuanImage 2.1 Demo\">\n</div>\n\n## Contents\n- [HunyuanImage-2.1: An Efficient Diffusion Model for High-Resolution (2K) Text-to-Image Generation​](#hunyuanimage-21-an-efficient-diffusion-model-for-high-resolution-2k-text-to-image-generation)\n  - [🔥🔥🔥 Latest Updates](#-latest-updates)\n  - [🎥 Demo](#-demo)\n  - [Contents](#contents)\n  - [Abstract](#abstract)\n  - [HunyuanImage-2.1 Overall Pipeline](#hunyuanimage-21-overall-pipeline)\n    - [Training Data and Caption](#training-data-and-caption)\n    - [Text-to-Image Model Architecture](#text-to-image-model-architecture)\n    - [Reinforcement Learning from Human Feedback](#reinforcement-learning-from-human-feedback)\n    - [Rewriting Model](#rewriting-model)\n    - [Model distillation](#model-distillation)\n  - [🎉 HunyuanImage-2.1 Key Features](#-hunyuanimage-21-key-features)\n  - [Prompt Enhanced Demo](#prompt-enhanced-demo)\n  - [📈 Comparisons](#-comparisons)\n    - [SSAE Evaluation](#ssae-evaluation)\n    - [GSB Evaluation](#gsb-evaluation)\n  - [📜 System Requirements](#-system-requirements)\n  - [🛠️ Dependencies and Installation](#️-dependencies-and-installation)\n  - [🧱 Download Pretrained Models](#-download-pretrained-models)\n  - [🔑 Usage](#-usage)\n  - [🔗 BibTeX](#-bibtex)\n  - [Acknowledgements](#acknowledgements)\n  - [Github Star History](#github-star-history)\n\n---\n<!-- - [🧩 Community Contributions](#-community-contributions) -->\n## Abstract\nWe present HunyuanImage-2.1, a highly efficient text-to-image model that is capable of generating 2K (2048 × 2048) resolution images. Leveraging an extensive dataset and structured captions involving multiple expert models, we significantly enhance text-image alignment capabilities. The model employs a highly expressive VAE with a (32 × 32) spatial compression ratio, substantially reducing computational costs.\n\nOur architecture consists of two stages:\n1. ​Base text-to-image Model:​​ The first stage is a text-to-image model that utilizes two text encoders: a multimodal large language model (MLLM) to improve image-text alignment, and a multi-language, character-aware encoder to enhance text rendering across various languages. This stage features a single- and dual-stream diffusion transformer with 17 billion parameters. To optimize aesthetics and structural coherence, we apply reinforcement learning from human feedback (RLHF).\n2. Refiner Model: The second stage introduces a refiner model that further enhances image quality and clarity, while minimizing artifacts. \n\nAdditionally, we developed the PromptEnhancer module to further boost model performance, and employed meanflow distillation for efficient inference. HunyuanImage-2.1 demonstrates robust semantic alignment and cross-scenario generalization, leading to improved consistency between text and image, enhanced control of scene details, character poses, and expressions, and the ability to generate multiple objects with distinct descriptions.\n\n\n \n\n## HunyuanImage-2.1 Overall Pipeline\n\n### Training Data and Caption\n\nStructured captions provide hierarchical semantic information at short, medium, long, and extra-long levels, significantly enhancing the model’s responsiveness to complex semantics. Innovatively, an OCR agent and IP RAG are introduced to address the shortcomings of general VLM captioners in dense text and world knowledge descriptions, while a bidirectional verification strategy ensures caption accuracy.\n\n\n### Text-to-Image Model Architecture\n\n<p align=\"center\">\n  <img src=\"./assets/framework_overall.png\" width=100% alt=\"HunyuanImage 2.1 Architecture\">\n</p>\n\n\n\nCore Components:\n* High-Compression VAE with REPA Training Acceleration:\n  * A VAE with a 32× compression rate drastically reduces the number of input tokens for the DiT model. By aligning its feature space with DINOv2 features, we facilitate the training of high-compression VAEs. As a result, our model generates 2K images with the same token length (and thus similar inference time) as other models require for 1K images, achieving superior inference efficiency.\n  * Multi-bucket, multi-resolution REPA loss aligns DiT features with a high-dimensional semantic feature space, accelerating model convergence.\n* Dual Text Encoder:\n  * A vision-language multimodal encoder is employed to better understand scene descriptions, character actions, and detailed requirements.\n  * A multilingual ByT5 text encoder is introduced to specialize in text generation and multilingual expression.\n* Network: A single- and dual-stream diffusion transformer with 17 billion parameters.\n\n### Reinforcement Learning from Human Feedback\nTwo-Stage Post-Training with Reinforcement Learning: Supervised Fine-Tuning (SFT) and Reinforcement Learning (RL) are applied sequentially in two post-training stages. We introduce a Reward Distribution Alignment algorithm, which innovatively incorporates high-quality images as selected samples to ensure stable and improved reinforcement learning outcomes.\n\n### Rewriting Model\n<p align=\"center\">\n  <img src=\"./assets/framework_prompt_rewrite.png\" width=90% alt=\"HunyuanImage 2.1 Architecture\">\n</p>\n\n* The first systematic industrial-level rewriting model. SFT training structurally rewrites user text instructions to enrich visual expression, while GRPO training employs a fine-grained semantic AlignEvaluator reward model to substantially improve the semantics of images generated from rewritten text. The AlignEvaluator covers 6 major categories and 24 fine-grained assessment points. PromptEnhancer supports both Chinese and English rewriting and demonstrates general applicability in enhancing semantics for both open-source and proprietary text-to-image models.\n\n### Model distillation\nWe propose a novel distillation method based on meanflow that addresses the key challenges of instability and inefficiency inherent in standard meanflow training. This approach enables high-quality image generation with only a few sampling steps. To our knowledge, this is the first successful application of meanflow to an industrial-scale model.\n\n\n\n\n\n## 🎉 HunyuanImage-2.1 Key Features\n\n- **High-Quality Generation**: Efficiently produces ultra-high-definition (2K) images with cinematic composition.\n- **Multilingual Support**: Provides native support for both Chinese and English prompts.\n- **Advanced Architecture**: Built on a multi-modal, single- and dual-stream combined DiT (Diffusion Transformer) backbone.\n- **Glyph-Aware Processing**: Utilizes ByT5's text rendering capabilities for improved text generation accuracy.\n- **Flexible Aspect Ratios**: Supports a variety of image aspect ratios (1:1, 16:9, 9:16, 4:3, 3:4, 3:2, 2:3).\n- **Prompt Enhancement**: Automatically rewrites prompts to improve descriptive accuracy and visual quality.\n\n\n## Prompt Enhanced Demo\nTo improve the quality and detail of generated images, we use a prompt rewriting model. This model automatically enhances user-provided text prompts by adding detailed and descriptive information.\n<p align=\"center\">\n  <img src=\"./assets/reprompt.jpg\" width=100% alt=\"Human Evaluation with Other Models\">\n</p>\n\n\n## 📈 Comparisons\n\n### SSAE Evaluation\nSSAE (Structured Semantic Alignment Evaluation) is an intelligent evaluation metric for image-text alignment based on advanced multimodal large language models (MLLMs). We extracted 3500 key points across 12 categories, then used multimodal large language models to automatically evaluate and score by comparing the generated images with these key points based on the visual content of the images. Mean Image Accuracy represents the image-wise average score across all key points, while Global Accuracy directly calculates the average score across all key points.\n<p align=\"center\">\n<table>\n<thead>\n<tr>\n    <th rowspan=\"2\">Model</th>  <th rowspan=\"2\">Open Source</th> <th rowspan=\"2\">Mean Image Accuracy</th> <th rowspan=\"2\">Global Accuracy</th> <th colspan=\"4\" style=\"text-align: center;\">Primary Subject</th> <th colspan=\"3\" style=\"text-align: center;\">Secondary Subject</th> <th colspan=\"2\" style=\"text-align: center;\">Scene</th> <th colspan=\"3\" style=\"text-align: center;\">Other</th>\n</tr>\n<tr>\n    <th>Noun</th> <th>Key Attributes</th> <th>Other Attributes</th> <th>Action</th> <th>Noun</th> <th>Attributes</th> <th>Action</th> <th>Noun</th> <th>Attributes</th> <th>Shot</th> <th>Style</th> <th>Composition</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n    <td>FLUX-dev</td> <td>✅</td> <td>0.7122</td> <td>0.6995</td> <td>0.7965</td> <td>0.7824</td> <td>0.5993</td> <td>0.5777</td> <td>0.7950</td> <td>0.6826</td> <td>0.6923</td> <td>0.8453</td> <td>0.8094</td> <td>0.6452</td> <td>0.7096</td> <td>0.6190</td>\n</tr>\n<tr>\n    <td>Seedream-3.0</td> <td>❌</td> <td>0.8827</td> <td>0.8792</td> <td>0.9490</td> <td>0.9311</td> <td>0.8242</td> <td>0.8177</td> <td>0.9747</td> <td>0.9103</td> <td>0.8400</td> <td>0.9489</td> <td>0.8848</td> <td>0.7582</td> <td>0.8726</td> <td>0.7619</td>\n</tr>\n<tr>\n    <td>Qwen-Image</td> <td>✅</td> <td>0.8854</td> <td>0.8828</td> <td>0.9502</td> <td>0.9231</td> <td>0.8351</td> <td>0.8161</td> <td>0.9938</td> <td>0.9043</td> <td>0.8846</td> <td>0.9613</td> <td>0.8978</td> <td>0.7634</td> <td>0.8548</td> <td>0.8095</td>\n</tr>\n<tr>\n    <td>GPT-Image</td>  <td>❌</td> <td> 0.8952</td> <td>0.8929</td> <td>0.9448</td> <td>0.9289</td> <td>0.8655</td> <td>0.8445</td> <td>0.9494</td> <td>0.9283</td> <td>0.8800</td> <td>0.9432</td> <td>0.9017</td> <td>0.7253</td> <td>0.8582</td> <td>0.7143</td>\n</tr>\n<tr>\n    <td><strong>HunyuanImage 2.1</strong></td> <td>✅</td> <td><strong>0.8888</strong></td> <td><strong>0.8832</strong></td> <td>0.9339</td> <td>0.9341</td> <td>0.8363</td> <td>0.8342</td> <td>0.9627</td> <td>0.8870</td> <td>0.9615</td> <td>0.9448</td> <td>0.9254</td> <td>0.7527</td> <td>0.8689</td> <td>0.7619</td>\n</tr>\n</tbody>\n</table>\n</p>\n\nFrom the SSAE evaluation results, our model has currently achieved the optimal performance among open-source models in terms of semantic alignment, and is very close to the performance of closed-source commercial models (GPT-Image).\n\n### GSB Evaluation\n\n<p align=\"center\">\n  <img src=\"./assets/gsb.png\" width=70% alt=\"Human Evaluation with Other Models\">\n</p>\n\nWe adopted the GSB evaluation method commonly used to assess the relative performance between two models from an overall image perception perspective. In total, we utilized 1000 text prompts, generating an equal number of image samples for all compared models in a single run. For a fair comparison, we conducted inference only once for each prompt, avoiding any cherry-picking of results. When comparing with the baseline methods, we maintained the default settings for all selected models. The evaluation was performed by more than 100 professional evaluators.\nFrom the results, HunyuanImage 2.1 achieved a relative win rate of -1.36% against Seedream3.0 (closed-source) and 2.89% outperforming Qwen-Image (open-source). The GSB evaluation results demonstrate that HunyuanImage 2.1, as an open-source model, has reached a level of image generation quality comparable to closed-source commercial models (Seedream3.0), while showing certain advantages in comparison with similar open-source models (Qwen-Image). This fully validates the technical advancement and practical value of HunyuanImage 2.1 in text-to-image generation tasks.\n\n## 📜 System Requirements\n\n\n**Hardware and OS Requirements:**\n- NVIDIA GPU with CUDA support.\n\n  **Minimum requrement for now:** 24 GB GPU memory for 2048x2048 image generation.\n  \n  > **Note:** The memory requirements above are measured with model CPU offloading and FP8 quantization enabled. If your GPU has sufficient memory, you may disable offloading for improved inference speed.\n- Supported operating system: Linux.\n\n\n## 🛠️ Dependencies and Installation\n\n1. Clone the repository:\n```bash\ngit clone https://github.com/Tencent-Hunyuan/HunyuanImage-2.1.git\ncd HunyuanImage-2.1\n```\n\n2. Install dependencies:\n```bash\npip install -r requirements.txt\npip install flash-attn==2.7.3 --no-build-isolation\n```\n\n## 🧱 Download Pretrained Models\n\nThe details of download pretrained models are shown [here](ckpts/checkpoints-download.md).\n\n## 🔑 Usage\nHunyuanImage-2.1 only supports 2K image generation (e.g. 2048x2048 for 1:1 images, 2560x1536 for 16:9 images, etc.).\nGenerating images with 1K resolution will result in artifacts.\nAdditionally, we recommend using the full generation pipeline for better quality (i.e. enabling prompt enhancement and refinment).\n\n```python\nimport os\nos.environ['PYTORCH_CUDA_ALLOC_CONF'] = 'expandable_segments:True'\nimport torch\nfrom hyimage.diffusion.pipelines.hunyuanimage_pipeline import HunyuanImagePipeline\n\n# Supported model_name: hunyuanimage-v2.1, hunyuanimage-v2.1-distilled\nmodel_name = \"hunyuanimage-v2.1\"\npipe = HunyuanImagePipeline.from_pretrained(model_name=model_name, use_fp8=True)\npipe = pipe.to(\"cuda\")\n\nprompt = \"A cute, cartoon-style anthropomorphic penguin plush toy with fluffy fur, standing in a painting studio, wearing a red knitted scarf and a red beret with the word “Tencent” on it, holding a paintbrush with a focused expression as it paints an oil painting of the Mona Lisa, rendered in a photorealistic photographic style.\"\nimage = pipe(\n    prompt=prompt,\n    # Examples of supported resolutions and aspect ratios for HunyuanImage-2.1:\n    # 16:9  -> width=2560, height=1536\n    # 4:3   -> width=2304, height=1792\n    # 1:1   -> width=2048, height=2048\n    # 3:4   -> width=1792, height=2304\n    # 9:16  -> width=1536, height=2560\n    # Please use one of the above width/height pairs for best results.\n    width=2048,\n    height=2048,\n    use_reprompt=False,  # Enable prompt enhancement (which may result in higher GPU memory usage)\n    use_refiner=True,   # Enable refiner model\n    # For the distilled model, use 8 steps for faster inference.\n    # For the non-distilled model, use 50 steps for better quality.\n    num_inference_steps=8 if \"distilled\" in model_name else 50, \n    guidance_scale=3.25 if \"distilled\" in model_name else 3.5,\n    shift=4 if \"distilled\" in model_name else 5,\n    seed=649151,\n)\n\nimage.save(f\"generated_image.png\")\n```\n\n\n## 🔗 BibTeX\n\nIf you find this project useful for your research and applications, please cite as:\n\n```BibTeX\n@misc{HunyuanImage-2.1,\n  title={HunyuanImage 2.1: An Efficient Diffusion Model for High-Resolution (2K) Text-to-Image Generation},\n  author={Tencent Hunyuan Team},\n  year={2025},\n  howpublished={\\url{https://github.com/Tencent-Hunyuan/HunyuanImage-2.1}},\n}\n```\n\n## Acknowledgements\n\nWe would like to thank the following open-source projects and communities for their contributions to open research and exploration: [Qwen](https://huggingface.co/Qwen), [FLUX](https://github.com/black-forest-labs/flux), [diffusers](https://github.com/huggingface/diffusers) and [HuggingFace](https://huggingface.co).\n\n## Github Star History\n<a href=\"https://star-history.com/#Tencent-Hunyuan/HunyuanImage-2.1&Date\">\n <picture>\n   <source media=\"(prefers-color-scheme: dark)\" srcset=\"https://api.star-history.com/svg?repos=Tencent-Hunyuan/HunyuanImage-2.1&type=Date1&theme=dark\" />\n   <source media=\"(prefers-color-scheme: light)\" srcset=\"https://api.star-history.com/svg?repos=Tencent-Hunyuan/HunyuanImage-2.1&type=Date1\" />\n   <img alt=\"Star History Chart\" src=\"https://api.star-history.com/svg?repos=Tencent-Hunyuan/HunyuanImage-2.1&type=Date1\" />\n </picture>\n</a>\n",
    "py_files": {
        "hyimage/common/config/__init__.py": "from .lazy import LazyCall, instantiate, locate\nfrom .base_config import DiTConfig, VAEConfig, TextEncoderConfig, RepromptConfig\n\n__all__ = [\"LazyCall\", \"instantiate\", \"locate\", \"DiTConfig\", \"VAEConfig\", \"TextEncoderConfig\", \"RepromptConfig\"]",
        "hyimage/common/config/base_config.py": "from dataclasses import dataclass\nfrom typing import Optional\n\nfrom hyimage.common.config.lazy import DictConfig\n\n\n@dataclass\nclass DiTConfig:\n    model: DictConfig\n    use_lora: bool = False\n    use_cpu_offload: bool = False\n    gradient_checkpointing: bool = False\n    load_from: Optional[str] = None\n    fp8_scale: Optional[str] = None\n    fp8_load_from: Optional[str] = None\n    use_compile: bool = False\n\n\n@dataclass\nclass VAEConfig:\n    model: DictConfig\n    load_from: str\n    cpu_offload: bool = False\n    enable_tiling: bool = False\n\n\n@dataclass\nclass TextEncoderConfig:\n    model: DictConfig\n    load_from: str\n    prompt_template: Optional[str] = None\n    text_len: Optional[int] = None\n\n\n@dataclass\nclass RepromptConfig:\n    model: DictConfig\n    load_from: str",
        "hyimage/common/config/lazy.py": "import collections.abc as abc\nimport copy\nimport pydoc\nfrom typing import Any\n\n\nclass DictConfig(dict):\n\n    def __getattr__(self, item):\n        try:\n            return self[item]\n        except KeyError:\n            raise AttributeError(f\"'AttrDict' object has no attribute '{item}'\")\n\n    def __setattr__(self, key, value):\n        self[key] = value\n\n    def __delattr__(self, item):\n        try:\n            del self[item]\n        except KeyError:\n            raise AttributeError(f\"'DictConfig' object has no attribute '{item}'\")\n\n\ndef locate(name: str) -> Any:\n    \"\"\"\n    Locate and return an object using a string like {x.__module__}.{x.__qualname__}.\n\n    Args:\n        name:Dotted path to the object\n\n    Returns:\n        The located object\n\n    Raises:\n        ImportError if the object cannot be found\n    \"\"\"\n    return pydoc.locate(name)\n\n\n\nclass LazyObject:\n\n    def __init__(self, target, **kwargs):\n        self._target = target\n        self._kwargs = kwargs\n\n    def instantiate(self, **kwargs):\n        new_kwargs = copy.deepcopy(self._kwargs)\n        new_kwargs.update(kwargs)\n        return self._target(**new_kwargs)\n\n\nclass LazyCall:\n\n    def __init__(self, target):\n        if not callable(target):\n            raise ValueError(f\"`target` of LazyCall must be a callable, got {target}\")\n        self._target = target\n\n    def __call__(self, **kwargs):\n        return LazyObject(self._target, **kwargs)\n\n\ndef instantiate(config: LazyObject, **kwargs):\n    if config is None:\n        return None\n    return config.instantiate(**kwargs)\n\n",
        "hyimage/common/constants.py": "import torch\n\nPRECISION_TO_TYPE = {\n    \"fp32\": torch.float32,\n    \"fp16\": torch.float16,\n    \"bf16\": torch.bfloat16,\n}\n",
        "hyimage/common/format_prompt.py": "import json\n\n\ndef closest_color(requested_color):\n    import webcolors\n\n    min_colors = {}\n    for key, name in webcolors.CSS3_HEX_TO_NAMES.items():\n\n        r_c, g_c, b_c = webcolors.hex_to_rgb(key)\n        rd = (r_c - requested_color[0]) ** 2\n        gd = (g_c - requested_color[1]) ** 2\n        bd = (b_c - requested_color[2]) ** 2\n        min_colors[(rd + gd + bd)] = name\n    return min_colors[min(min_colors.keys())]\n\n\ndef convert_rgb_to_names(rgb_tuple):\n    try:\n        import webcolors\n\n        color_name = webcolors.rgb_to_name(rgb_tuple)\n    except ValueError:\n        color_name = closest_color(rgb_tuple)\n    return color_name\n\n\nclass MultilingualPromptFormat:\n\n    def __init__(\n        self,\n        font_path: str = 'assets/glyph_sdxl_assets/multilingual_10-lang_idx.json',\n        color_path: str = 'assets/glyph_sdxl_assets/color_idx.json',\n    ):\n        with open(font_path, 'r') as f:\n            self.font_dict = json.load(f)\n        with open(color_path, 'r') as f:\n            self.color_dict = json.load(f)\n\n    def format_prompt(self, texts, styles):\n        '''\n        Text \"{text}\" in {color}, {type}.\n        '''\n\n        prompt = \"\"\n        for text, style in zip(texts, styles):\n            text_prompt = f'Text \"{text}\"'\n\n            attr_list = []\n\n            # format color\n            if style[\"color\"] is not None:\n                import webcolors\n\n                hex_color = style[\"color\"]\n                rgb_color = webcolors.hex_to_rgb(hex_color)\n                color_name = convert_rgb_to_names(rgb_color)\n                attr_list.append(f\"<color-{self.color_dict[color_name]}>\")\n\n            # format font\n            if style[\"font-family\"] is not None:\n                attr_list.append(f\"<{style['font-family'][:2]}-font-{self.font_dict[style['font-family']]}>\")\n                attr_suffix = \", \".join(attr_list)\n                text_prompt += \" in \" + attr_suffix\n                text_prompt += \". \"\n            else:\n                text_prompt += \". \"\n\n            prompt = prompt + text_prompt\n        return prompt\n",
        "hyimage/diffusion/cfg_utils.py": "import math\nimport torch\nfrom typing import Dict, List, Optional, Tuple, Union\n\ndef rescale_noise_cfg(noise_cfg, noise_pred_text, guidance_rescale=0.0):\n    r\"\"\"\n    Rescales `noise_cfg` tensor based on `guidance_rescale` to improve image quality and fix overexposure. Based on\n    Section 3.4 from [Common Diffusion Noise Schedules and Sample Steps are\n    Flawed](https://arxiv.org/pdf/2305.08891.pdf).\n\n    Args:\n        noise_cfg (`torch.Tensor`):\n            The predicted noise tensor for the guided diffusion process.\n        noise_pred_text (`torch.Tensor`):\n            The predicted noise tensor for the text-guided diffusion process.\n        guidance_rescale (`float`, *optional*, defaults to 0.0):\n            A rescale factor applied to the noise predictions.\n    Returns:\n        noise_cfg (`torch.Tensor`): The rescaled noise prediction tensor.\n    \"\"\"\n    std_text = noise_pred_text.std(dim=list(range(1, noise_pred_text.ndim)), keepdim=True)\n    std_cfg = noise_cfg.std(dim=list(range(1, noise_cfg.ndim)), keepdim=True)\n    # rescale the results from guidance (fixes overexposure)\n    noise_pred_rescaled = noise_cfg * (std_text / std_cfg)\n    # mix with the original results from guidance by factor guidance_rescale to avoid \"plain looking\" images\n    noise_cfg = guidance_rescale * noise_pred_rescaled + (1 - guidance_rescale) * noise_cfg\n    return noise_cfg\n\nclass ClassifierFreeGuidance:\n    def __init__(\n        self,\n        guidance_scale: float = 7.5,\n        guidance_rescale: float = 0.0,\n        use_original_formulation: bool = False,\n        start: float = 0.0,\n        stop: float = 1.0,\n    ):\n        super().__init__()\n\n        self.guidance_scale = guidance_scale\n        self.guidance_rescale = guidance_rescale\n        self.use_original_formulation = use_original_formulation\n\n    def __call__(self, pred_cond: torch.Tensor, pred_uncond: Optional[torch.Tensor] = None) -> torch.Tensor:\n\n        shift = pred_cond - pred_uncond\n        pred = pred_cond if self.use_original_formulation else pred_uncond\n        pred = pred + self.guidance_scale * shift\n\n        if self.guidance_rescale > 0.0:\n            pred = rescale_noise_cfg(pred, pred_cond, self.guidance_rescale)\n\n        return pred\n\n\nclass MomentumBuffer:\n    def __init__(self, momentum: float):\n        self.momentum = momentum\n        self.running_average = 0\n\n    def update(self, update_value: torch.Tensor):\n        new_average = self.momentum * self.running_average\n        self.running_average = update_value + new_average\n\ndef normalized_guidance_apg(\n    pred_cond: torch.Tensor,\n    pred_uncond: torch.Tensor,\n    guidance_scale: float,\n    momentum_buffer: Optional[MomentumBuffer] = None,\n    eta: float = 1.0,\n    norm_threshold: float = 0.0,\n    use_original_formulation: bool = False,\n):\n    diff = pred_cond - pred_uncond\n    dim = [-i for i in range(1, len(diff.shape))]\n\n    if momentum_buffer is not None:\n        momentum_buffer.update(diff)\n        diff = momentum_buffer.running_average\n\n    if norm_threshold > 0:\n        ones = torch.ones_like(diff)\n        diff_norm = diff.norm(p=2, dim=dim, keepdim=True)\n        scale_factor = torch.minimum(ones, norm_threshold / diff_norm)\n        diff = diff * scale_factor\n\n    v0, v1 = diff.double(), pred_cond.double()\n    v1 = torch.nn.functional.normalize(v1, dim=dim)\n    v0_parallel = (v0 * v1).sum(dim=dim, keepdim=True) * v1\n    v0_orthogonal = v0 - v0_parallel\n    diff_parallel, diff_orthogonal = v0_parallel.type_as(diff), v0_orthogonal.type_as(diff)\n\n    normalized_update = diff_orthogonal + eta * diff_parallel\n    pred = pred_cond if use_original_formulation else pred_uncond\n    pred = pred + guidance_scale * normalized_update\n\n    return pred\n\nclass AdaptiveProjectedGuidance:\n    def __init__(\n        self,\n        guidance_scale: float = 7.5,\n        adaptive_projected_guidance_momentum: Optional[float] = None,\n        adaptive_projected_guidance_rescale: float = 15.0,\n        # eta: float = 1.0,\n        eta: float = 0.0,\n        guidance_rescale: float = 0.0,\n        use_original_formulation: bool = False,\n        start: float = 0.0,\n        stop: float = 1.0,\n    ):\n        super().__init__()\n\n        self.guidance_scale = guidance_scale\n        self.adaptive_projected_guidance_momentum = adaptive_projected_guidance_momentum\n        self.adaptive_projected_guidance_rescale = adaptive_projected_guidance_rescale\n        self.eta = eta\n        self.guidance_rescale = guidance_rescale\n        self.use_original_formulation = use_original_formulation\n        self.momentum_buffer = None\n\n    def __call__(self, pred_cond: torch.Tensor, pred_uncond: Optional[torch.Tensor] = None, step=None) -> torch.Tensor:\n\n        if step == 0 and self.adaptive_projected_guidance_momentum is not None:\n            self.momentum_buffer = MomentumBuffer(self.adaptive_projected_guidance_momentum)\n\n        pred = normalized_guidance_apg(\n            pred_cond,\n            pred_uncond,\n            self.guidance_scale,\n            self.momentum_buffer,\n            self.eta,\n            self.adaptive_projected_guidance_rescale,\n            self.use_original_formulation,\n        )\n\n        if self.guidance_rescale > 0.0:\n            pred = rescale_noise_cfg(pred, pred_cond, self.guidance_rescale)\n\n        return pred\n",
        "hyimage/diffusion/pipelines/__init__.py": "",
        "hyimage/diffusion/pipelines/hunyuanimage_pipeline.py": "import copy\nimport re\nimport os\nfrom dataclasses import dataclass\nfrom typing import Optional\nfrom einops import rearrange\nfrom pathlib import Path\n\nfrom tqdm import tqdm\nimport loguru\nimport torch\nfrom hyimage.common.config.lazy import DictConfig\nfrom PIL import Image\n\nfrom hyimage.common.config import instantiate\nfrom hyimage.common.constants import PRECISION_TO_TYPE\nfrom hyimage.common.format_prompt import MultilingualPromptFormat\nfrom hyimage.models.text_encoder import PROMPT_TEMPLATE\nfrom hyimage.models.model_zoo import HUNYUANIMAGE_REPROMPT\nfrom hyimage.models.text_encoder.byT5 import load_glyph_byT5_v2\nfrom hyimage.models.hunyuan.modules.hunyuanimage_dit import load_hunyuan_dit_state_dict\nfrom hyimage.diffusion.cfg_utils import AdaptiveProjectedGuidance, rescale_noise_cfg\n\n\n@dataclass\nclass HunyuanImagePipelineConfig:\n    \"\"\"\n    Configuration class for HunyuanImage diffusion pipeline.\n\n    This dataclass consolidates all configuration parameters for the pipeline,\n    including model configurations (DiT, VAE, text encoder) and pipeline\n    parameters (sampling steps, guidance scale, etc.).\n    \"\"\"\n\n    # Model configurations\n    dit_config: DictConfig\n    vae_config: DictConfig\n    text_encoder_config: DictConfig\n    reprompt_config: DictConfig\n    refiner_model_name: str = \"hunyuanimage-refiner\"\n\n    enable_stage1_offloading: bool = True # offload models in stage1 pipeline when reprompt or refiner is working\n    enable_reprompt_model_offloading: bool = True # offload reprompt model after finishing\n    enable_refiner_offloading: bool = True # offload refiner model after finishing\n    enable_text_encoder_offloading: bool = True # offload text encoder after finishing\n    enable_full_dit_offloading: bool = True  # offload during text encoding and latent decoding\n    enable_vae_offloading: bool = True # offload vae after finishing\n    enable_byt5_offloading: bool = True # offload byt5 after finishing\n\n    use_fp8: bool = False\n\n    cfg_mode: str = \"MIX_mode_0\"\n    guidance_rescale: float = 0.0\n\n    # Pipeline parameters\n    default_sampling_steps: int = 50\n    # Default guidance scale, will be overridden by the guidance_scale parameter in __call__\n    default_guidance_scale: float = 3.5\n    # Inference shift\n    shift: int = 5\n    torch_dtype: str = \"bf16\"\n    device: str = \"cpu\"\n    version: str = \"\"\n\n    @classmethod\n    def create_default(cls, version: str = \"v2.1\", use_distilled: bool = False, **kwargs):\n        \"\"\"\n        Create a default configuration for specified HunyuanImage version.\n\n        Args:\n            version: HunyuanImage version, only \"v2.1\" is supported\n            use_distilled: Whether to use distilled model\n            **kwargs: Additional configuration options\n        \"\"\"\n        if version == \"v2.1\":\n            from hyimage.models.model_zoo import (\n                HUNYUANIMAGE_V2_1_DIT,\n                HUNYUANIMAGE_V2_1_DIT_CFG_DISTILL,\n                HUNYUANIMAGE_V2_1_VAE_32x,\n                HUNYUANIMAGE_V2_1_TEXT_ENCODER,\n            )\n            dit_config = HUNYUANIMAGE_V2_1_DIT_CFG_DISTILL() if use_distilled else HUNYUANIMAGE_V2_1_DIT()\n            return cls(\n                dit_config=dit_config,\n                vae_config=HUNYUANIMAGE_V2_1_VAE_32x(),\n                text_encoder_config=HUNYUANIMAGE_V2_1_TEXT_ENCODER(),\n                reprompt_config=HUNYUANIMAGE_REPROMPT(),\n                shift=4 if use_distilled else 5,\n                default_guidance_scale=3.25 if use_distilled else 3.5,\n                default_sampling_steps=8 if use_distilled else 50,\n                version=version,\n                **kwargs\n            )\n        else:\n            raise ValueError(f\"Unsupported HunyuanImage version: {version}. Only 'v2.1' is supported\")\n\n\nclass HunyuanImagePipeline:\n    \"\"\"\n    User-friendly pipeline for HunyuanImage text-to-image generation.\n\n    This pipeline provides a simple interface similar to diffusers library\n    for generating high-quality images from text prompts.\n\n    Supports HunyuanImage 2.1 version with automatic configuration.\n    Both default and distilled (CFG distillation) models are supported.\n    \"\"\"\n\n    def __init__(\n        self,\n        config: HunyuanImagePipelineConfig,\n        **kwargs\n    ):\n        \"\"\"\n        Initialize the HunyuanImage diffusion pipeline.\n\n        Args:\n            config: Configuration object containing all model and pipeline settings\n            **kwargs: Additional configuration options\n        \"\"\"\n        self.config = copy.deepcopy(config)\n        self.default_sampling_steps = config.default_sampling_steps\n        self.default_guidance_scale = config.default_guidance_scale\n        self.shift = config.shift\n        self.torch_dtype = PRECISION_TO_TYPE[config.torch_dtype]\n        self.device = config.device\n        self.execution_device = 'cuda'\n\n        self.dit = None\n        self.text_encoder = None\n        self.vae = None\n        self.byt5_kwargs = None\n        self.prompt_format = None\n\n\n        self.cfg_mode = config.cfg_mode\n        self.guidance_rescale = config.guidance_rescale\n\n        if self.cfg_mode == \"APG_mode_0\":\n            self.cfg_guider = AdaptiveProjectedGuidance(guidance_scale=10.0, eta=0.0,\n                                                        adaptive_projected_guidance_rescale=10.0,\n                                                        adaptive_projected_guidance_momentum=-0.5)\n            self.apg_start_step = 10\n        elif self.cfg_mode == \"MIX_mode_0\":\n            self.cfg_guider_ocr = AdaptiveProjectedGuidance(guidance_scale=10.0, eta=0.0,\n                                                            adaptive_projected_guidance_rescale=10.0,\n                                                            adaptive_projected_guidance_momentum=-0.5)\n            self.apg_start_step_ocr = 75\n\n            self.cfg_guider_general = AdaptiveProjectedGuidance(guidance_scale=10.0, eta=0.0,\n                                                                adaptive_projected_guidance_rescale=10.0,\n                                                                adaptive_projected_guidance_momentum=-0.5)\n            self.apg_start_step_general = 10\n\n        self.ocr_mask = []\n\n\n        self._load_models()\n\n    def _load_dit(self):\n        dit_device = None\n        if self.config.enable_full_dit_offloading or self.config.use_fp8:\n            dit_device = 'cpu'\n        else:\n            dit_device = self.device\n            \n        try:\n            dit_config = self.config.dit_config\n            self.dit = instantiate(dit_config.model, dtype=self.torch_dtype, device=dit_device)\n            if self.config.use_fp8:\n                from hyimage.models.utils.fp8_quantization import convert_fp8_linear\n                if not Path(dit_config.fp8_scale).exists():\n                    raise FileNotFoundError(f\"FP8 scale file not found: {dit_config.fp8_scale}. Please download from https://huggingface.co/tencent/HunyuanImage-2.1/\")\n                if dit_config.fp8_load_from is not None and Path(dit_config.fp8_load_from).exists():\n                    convert_fp8_linear(self.dit, dit_config.fp8_scale)\n                    load_hunyuan_dit_state_dict(self.dit, dit_config.fp8_load_from, strict=True)\n                else:\n                    loguru.logger.warning(f\"FP8 ckpt not found: {dit_config.fp8_load_from}. Fallback to bf16 ckpt load from path: {dit_config.load_from}.\")\n                    load_hunyuan_dit_state_dict(self.dit, dit_config.load_from, strict=True)\n                    convert_fp8_linear(self.dit, dit_config.fp8_scale)\n                self.dit = self.dit.to(dit_device)\n            else:\n                load_hunyuan_dit_state_dict(self.dit, dit_config.load_from, strict=True)\n                self.dit = self.dit.to(dit_device, dtype=self.torch_dtype)\n            self.dit.eval()\n            if getattr(dit_config, \"use_compile\", False):\n                self.dit = torch.compile(self.dit)\n            loguru.logger.info(\"✓ DiT model loaded\")\n        except Exception as e:\n            raise RuntimeError(f\"Error loading DiT model: {e}\") from e\n\n    def _load_text_encoder(self):\n        try:\n            if self.config.enable_full_dit_offloading:\n                self.dit.to('cpu')\n\n            if self.config.enable_full_dit_offloading:\n                text_encoder_device = 'cpu'\n            else:\n                text_encoder_device = self.device\n\n\n            text_encoder_config = self.config.text_encoder_config\n            if not text_encoder_config.load_from:\n                raise ValueError(\"Must provide checkpoint path for text encoder\")\n\n            if text_encoder_config.prompt_template is not None:\n                prompt_template = PROMPT_TEMPLATE[text_encoder_config.prompt_template]\n                crop_start = prompt_template.get(\"crop_start\", 0)\n            else:\n                crop_start = 0\n                prompt_template = None\n            max_length = text_encoder_config.text_len + crop_start\n\n            self.text_encoder = instantiate(\n                text_encoder_config.model,\n                max_length=max_length,\n                text_encoder_path=os.path.join(text_encoder_config.load_from, \"llm\"),\n                prompt_template=prompt_template,\n                logger=None,\n                device=text_encoder_device,\n            )\n            loguru.logger.info(\"✓ HunyuanImage text encoder loaded\")\n        except Exception as e:\n            raise RuntimeError(f\"Error loading text encoder: {e}\") from e\n\n    def _load_vae(self):\n        try:\n            vae_config = self.config.vae_config\n            self.vae = instantiate(\n                vae_config.model,\n                vae_path=vae_config.load_from,\n            )\n            self.vae = self.vae.to(self.device)\n            loguru.logger.info(\"✓ VAE loaded\")\n        except Exception as e:\n            raise RuntimeError(f\"Error loading VAE: {e}\") from e\n\n    def _load_reprompt_model(self):\n        try:\n            if self.config.enable_stage1_offloading:\n                self.offload()\n            reprompt_config = self.config.reprompt_config\n            self._reprompt_model = instantiate(reprompt_config.model, models_root_path=reprompt_config.load_from, enable_offloading=self.config.enable_reprompt_model_offloading)\n            loguru.logger.info(\"✓ Reprompt model loaded\")\n        except Exception as e:\n            raise RuntimeError(f\"Error loading reprompt model: {e}\") from e\n\n    @property\n    def refiner_pipeline(self):\n        \"\"\"\n        As the refiner model is an optional component, we load it on demand.\n        \"\"\"\n        if hasattr(self, '_refiner_pipeline') and self._refiner_pipeline is not None:\n            return self._refiner_pipeline\n        from hyimage.diffusion.pipelines.hunyuanimage_refiner_pipeline import HunYuanImageRefinerPipeline\n        if self.config.enable_stage1_offloading:\n            self.offload()\n        self._refiner_pipeline = HunYuanImageRefinerPipeline.from_pretrained(self.config.refiner_model_name, use_fp8=self.config.use_fp8)\n        return self._refiner_pipeline\n\n    @property\n    def reprompt_model(self):\n        \"\"\"\n        As the reprompt model is an optional component, we load it on demand.\n        \"\"\"\n        if hasattr(self, '_reprompt_model') and self._reprompt_model is not None:\n            return self._reprompt_model\n        self._load_reprompt_model()\n        return self._reprompt_model\n\n    def _load_byt5(self):\n\n        assert self.dit is not None, \"DiT model must be loaded before byT5\"\n\n        if not self.use_byt5:\n            self.byt5_kwargs = None\n            self.prompt_format = None\n            return\n\n        try:\n\n            text_encoder_config = self.config.text_encoder_config\n\n            glyph_root = os.path.join(self.config.text_encoder_config.load_from, \"Glyph-SDXL-v2\")\n            if not os.path.exists(glyph_root):\n                raise RuntimeError(\n                    f\"Glyph checkpoint not found from '{glyph_root}'. \\n\"\n                    \"Please download from https://modelscope.cn/models/AI-ModelScope/Glyph-SDXL-v2/files.\\n\\n\"\n                    \"- Required files:\\n\"\n                    \"    Glyph-SDXL-v2\\n\"\n                    \"    ├── assets\\n\"\n                    \"    │   ├── color_idx.json\\n\"\n                    \"    │   └── multilingual_10-lang_idx.json\\n\"\n                    \"    └── checkpoints\\n\"\n                    \"        └── byt5_model.pt\\n\"\n                )\n                    \n\n            byT5_google_path = os.path.join(text_encoder_config.load_from, \"byt5-small\")\n            if not os.path.exists(byT5_google_path):\n                loguru.logger.warning(f\"ByT5 google path not found from: {byT5_google_path}. Try downloading from https://huggingface.co/google/byt5-small.\")\n                byT5_google_path = \"google/byt5-small\"\n\n\n            multilingual_prompt_format_color_path = os.path.join(glyph_root, \"assets/color_idx.json\")\n            multilingual_prompt_format_font_path = os.path.join(glyph_root, \"assets/multilingual_10-lang_idx.json\")\n\n            byt5_args = dict(\n                byT5_google_path=byT5_google_path,\n                byT5_ckpt_path=os.path.join(glyph_root, \"checkpoints/byt5_model.pt\"),\n                multilingual_prompt_format_color_path=multilingual_prompt_format_color_path,\n                multilingual_prompt_format_font_path=multilingual_prompt_format_font_path,\n                byt5_max_length=128\n            )\n\n            self.byt5_kwargs = load_glyph_byT5_v2(byt5_args, device=self.device)\n            self.prompt_format = MultilingualPromptFormat(\n                font_path=multilingual_prompt_format_font_path,\n                color_path=multilingual_prompt_format_color_path\n            )\n            loguru.logger.info(\"✓ byT5 glyph processor loaded\")\n        except Exception as e:\n            raise RuntimeError(\"Error loading byT5 glyph processor\") from e\n\n    def _load_models(self):\n        \"\"\"\n        Load all model components.\n        \"\"\"\n        loguru.logger.info(\"Loading HunyuanImage models...\")\n        self._load_vae()\n        self._load_dit()\n        self._load_byt5()\n        self._load_text_encoder()\n\n\n    def _encode_text(self, prompt: str, data_type: str = \"image\"):\n        \"\"\"\n        Encode text prompt to embeddings.\n\n        Args:\n            prompt: The text prompt\n            data_type: The type of data (\"image\" by default)\n\n        Returns:\n            Tuple of (text_emb, text_mask)\n        \"\"\"\n        self.text_encoder.to(self.execution_device)\n        text_inputs = self.text_encoder.text2tokens(prompt)\n        with torch.no_grad():\n            text_outputs = self.text_encoder.encode(\n                text_inputs,\n                data_type=data_type,\n            )\n            text_emb = text_outputs.hidden_state\n            text_mask = text_outputs.attention_mask\n        return text_emb, text_mask\n\n    def _encode_glyph(self, prompt: str):\n        \"\"\"\n        Encode glyph information using byT5.\n\n        Args:\n            prompt: The text prompt\n\n        Returns:\n            Tuple of (byt5_emb, byt5_mask)\n        \"\"\"\n        if not self.use_byt5:\n            return None, None\n\n        if not prompt:\n            return (\n                torch.zeros((1, self.byt5_kwargs[\"byt5_max_length\"], 1472), device=self.execution_device),\n                torch.zeros((1, self.byt5_kwargs[\"byt5_max_length\"]), device=self.execution_device, dtype=torch.int64)\n            )\n\n        text_prompt_texts = []\n        pattern_quote_double = r'\\\"(.*?)\\\"'\n        pattern_quote_chinese_single = r'‘(.*?)’'\n        pattern_quote_chinese_double = r'“(.*?)”'\n\n        matches_quote_double = re.findall(pattern_quote_double, prompt)\n        matches_quote_chinese_single = re.findall(pattern_quote_chinese_single, prompt)\n        matches_quote_chinese_double = re.findall(pattern_quote_chinese_double, prompt)\n\n        text_prompt_texts.extend(matches_quote_double)\n        text_prompt_texts.extend(matches_quote_chinese_single)\n        text_prompt_texts.extend(matches_quote_chinese_double)\n\n        if not text_prompt_texts:\n            self.ocr_mask = [False]\n            return (\n                torch.zeros((1, self.byt5_kwargs[\"byt5_max_length\"], 1472), device=self.execution_device),\n                torch.zeros((1, self.byt5_kwargs[\"byt5_max_length\"]), device=self.execution_device, dtype=torch.int64)\n            )\n        self.ocr_mask = [True]\n\n        text_prompt_style_list = [{'color': None, 'font-family': None} for _ in range(len(text_prompt_texts))]\n        glyph_text_formatted = self.prompt_format.format_prompt(text_prompt_texts, text_prompt_style_list)\n\n        byt5_text_ids, byt5_text_mask = self._get_byt5_text_tokens(\n            self.byt5_kwargs[\"byt5_tokenizer\"],\n            self.byt5_kwargs[\"byt5_max_length\"],\n            glyph_text_formatted\n        )\n\n        byt5_text_ids = byt5_text_ids.to(device=self.execution_device)\n        byt5_text_mask = byt5_text_mask.to(device=self.execution_device)\n\n        byt5_prompt_embeds = self.byt5_kwargs[\"byt5_model\"](\n            byt5_text_ids, attention_mask=byt5_text_mask.float()\n        )\n        byt5_emb = byt5_prompt_embeds[0]\n\n        return byt5_emb, byt5_text_mask\n\n    def _get_byt5_text_tokens(self, tokenizer, max_length, text_list):\n        \"\"\"\n        Get byT5 text tokens.\n\n        Args:\n            tokenizer: The tokenizer object\n            max_length: Maximum token length\n            text_list: List or string of text\n\n        Returns:\n            Tuple of (byt5_text_ids, byt5_text_mask)\n        \"\"\"\n        if isinstance(text_list, list):\n            text_prompt = \" \".join(text_list)\n        else:\n            text_prompt = text_list\n\n        byt5_text_inputs = tokenizer(\n            text_prompt,\n            padding=\"max_length\",\n            max_length=max_length,\n            truncation=True,\n            add_special_tokens=True,\n            return_tensors=\"pt\",\n        )\n\n        byt5_text_ids = byt5_text_inputs.input_ids\n        byt5_text_mask = byt5_text_inputs.attention_mask\n\n        return byt5_text_ids, byt5_text_mask\n\n    def _prepare_latents(self, width: int, height: int, generator: torch.Generator, batch_size: int = 1, vae_downsampling_factor: int = 32):\n        \"\"\"\n        Prepare initial noise latents.\n\n        Args:\n            width: Image width\n            height: Image height\n            generator: Torch random generator\n            batch_size: Batch size\n\n        Returns:\n            Latent tensor\n        \"\"\"\n        assert width % vae_downsampling_factor == 0 and height % vae_downsampling_factor == 0, (\n            f\"width and height must be divisible by {vae_downsampling_factor}, but got {width} and {height}\"\n        )\n        latent_width = width // vae_downsampling_factor\n        latent_height = height // vae_downsampling_factor\n        latent_channels = 64\n\n        if len(self.dit.patch_size) == 3:\n            latent_shape = (batch_size, latent_channels, 1, latent_height, latent_width)\n        elif len(self.dit.patch_size) == 2:\n            latent_shape = (batch_size, latent_channels, latent_height, latent_width)\n        else:\n            raise ValueError(f\"Unsupported patch_size: {self.dit.patch_size}\")\n\n        \n        # Generate random noise with shape latent_shape\n        latents = torch.randn(\n            latent_shape,\n            device=generator.device,\n            dtype=self.torch_dtype,\n            generator=generator,\n        ).to(device=self.execution_device)\n\n        return latents\n\n    def _denoise_step(self, latents, timesteps, text_emb, text_mask, byt5_emb, byt5_mask, guidance_scale: float = 1.0, timesteps_r=None):\n        \"\"\"\n        Perform one denoising step.\n\n        Args:\n            latents: Latent tensor\n            timesteps: Timesteps tensor\n            text_emb: Text embedding\n            text_mask: Text mask\n            byt5_emb: byT5 embedding\n            byt5_mask: byT5 mask\n            guidance_scale: Guidance scale\n            timesteps_r: Optional next timestep\n\n        Returns:\n            Noise prediction tensor\n        \"\"\"\n        if byt5_emb is not None and byt5_mask is not None:\n            extra_kwargs = {\n                \"byt5_text_states\": byt5_emb,\n                \"byt5_text_mask\": byt5_mask,\n            }\n        else:\n            if self.use_byt5:\n                raise ValueError(\"Must provide byt5_emb and byt5_mask for HunyuanImage 2.1\")\n            extra_kwargs = {}\n\n        with torch.no_grad(), torch.autocast(device_type=\"cuda\", dtype=torch.bfloat16, enabled=True):\n            if hasattr(self.dit, 'guidance_embed') and self.dit.guidance_embed:\n                guidance_expand = torch.tensor(\n                    [guidance_scale] * latents.shape[0],\n                    dtype=torch.float32,\n                    device=latents.device\n                ).to(latents.dtype) * 1000\n            else:\n                guidance_expand = None\n\n            noise_pred = self.dit(\n                latents,\n                timesteps,\n                text_states=text_emb,\n                encoder_attention_mask=text_mask,\n                guidance=guidance_expand,\n                return_dict=False,\n                extra_kwargs=extra_kwargs,\n                timesteps_r=timesteps_r,\n            )[0]\n\n        return noise_pred\n\n    def _apply_classifier_free_guidance(self, noise_pred, guidance_scale: float, i: int):\n        \"\"\"\n        Apply classifier-free guidance.\n\n        Args:\n            noise_pred: Noise prediction tensor\n            guidance_scale: Guidance scale\n\n        Returns:\n            Guided noise prediction tensor\n        \"\"\"\n        if guidance_scale == 1.0:\n            return noise_pred\n\n        noise_pred_uncond, noise_pred_text = noise_pred.chunk(2)\n\n\n        if self.cfg_mode.startswith(\"APG_mode_\"):\n            if i <= self.apg_start_step:\n                noise_pred = noise_pred_uncond + guidance_scale * (\n                        noise_pred_text - noise_pred_uncond\n                )\n                _ = self.cfg_guider(noise_pred_text, noise_pred_uncond, step=i)\n            else:\n                noise_pred = self.cfg_guider(noise_pred_text, noise_pred_uncond, step=i)\n        elif self.cfg_mode.startswith(\"MIX_mode_\"):\n\n            ocr_mask_bool = torch.tensor(self.ocr_mask, dtype=torch.bool)\n\n            true_idx = torch.where(ocr_mask_bool)[0]\n            false_idx = torch.where(~ocr_mask_bool)[0]\n\n            noise_pred_text_true = noise_pred_text[true_idx] if len(true_idx) > 0 else \\\n                torch.empty((0, noise_pred_text.size(1)), dtype=noise_pred_text.dtype, device=noise_pred_text.device)\n            noise_pred_text_false = noise_pred_text[false_idx] if len(false_idx) > 0 else \\\n                torch.empty((0, noise_pred_text.size(1)), dtype=noise_pred_text.dtype, device=noise_pred_text.device)\n\n            noise_pred_uncond_true = noise_pred_uncond[true_idx] if len(true_idx) > 0 else \\\n                torch.empty((0, noise_pred_uncond.size(1)), dtype=noise_pred_uncond.dtype, device=noise_pred_uncond.device)\n            noise_pred_uncond_false = noise_pred_uncond[false_idx] if len(false_idx) > 0 else \\\n                torch.empty((0, noise_pred_uncond.size(1)), dtype=noise_pred_uncond.dtype, device=noise_pred_uncond.device)\n\n            if len(noise_pred_text_true) > 0:\n                if i <= self.apg_start_step_ocr:\n                    noise_pred_true = noise_pred_uncond_true + guidance_scale * (\n                            noise_pred_text_true - noise_pred_uncond_true\n                    )\n                    _ = self.cfg_guider_ocr(noise_pred_text_true, noise_pred_uncond_true, step=i)\n                else:\n                    noise_pred_true = self.cfg_guider_ocr(noise_pred_text_true, noise_pred_uncond_true, step=i)\n            else:\n                noise_pred_true = noise_pred_text_true\n\n            if len(noise_pred_text_false) > 0:\n                if i <= self.apg_start_step_general:\n                    noise_pred_false = noise_pred_uncond_false + guidance_scale * (\n                            noise_pred_text_false - noise_pred_uncond_false\n                    )\n                    _ = self.cfg_guider_general(noise_pred_text_false, noise_pred_uncond_false, step=i)\n                else:\n                    noise_pred_false = self.cfg_guider_general(noise_pred_text_false, noise_pred_uncond_false, step=i)\n            else:\n                noise_pred_false = noise_pred_text_false\n\n            noise_pred = torch.empty_like(noise_pred_text)\n            if len(true_idx) > 0:\n                noise_pred[true_idx] = noise_pred_true\n            if len(false_idx) > 0:\n                noise_pred[false_idx] = noise_pred_false\n\n        else:\n            noise_pred = noise_pred_uncond + guidance_scale * (\n                    noise_pred_text - noise_pred_uncond\n            )\n\n            if self.do_classifier_free_guidance and self.guidance_rescale > 0.0:\n                # Based on 3.4. in https://arxiv.org/pdf/2305.08891.pdf\n                noise_pred = rescale_noise_cfg(\n                    noise_pred,\n                    noise_pred_text,\n                    guidance_rescale=self.guidance_rescale,\n                )\n\n        return noise_pred\n\n    def _decode_latents(self, latents, reorg_tokens=False):\n        \"\"\"\n        Decode latents to images using VAE.\n\n        Args:\n            latents: Latent tensor\n\n        Returns:\n            Image tensor\n        \"\"\"\n        if hasattr(self.vae.config, \"shift_factor\") and self.vae.config.shift_factor:\n            latents = latents / self.vae.config.scaling_factor + self.vae.config.shift_factor\n        else:\n            latents = latents / self.vae.config.scaling_factor\n\n        if reorg_tokens:\n            latents = rearrange(latents, \"b c f h w -> b f c h w\")\n            latents = rearrange(latents, \"b f (n c) h w -> b (f n) c h w\", n=2)\n            latents = rearrange(latents, \"b f c h w -> b c f h w\")\n            latents = latents[:, :, 1:]\n\n        if latents.ndim == 5:\n            latents = latents.squeeze(2)\n        if latents.ndim == 4:\n            latents = latents.unsqueeze(2)\n\n        with torch.autocast(device_type=\"cuda\", dtype=torch.float16, enabled=True):\n            image = self.vae.decode(latents, return_dict=False)[0]\n            \n        # Post-process image - remove frame dimension and normalize\n        image = (image / 2 + 0.5).clamp(0, 1)\n        image = image[:, :, 0]  # Remove frame dimension for images\n        image = image.cpu().float()\n        \n        return image\n\n    def get_timesteps_sigmas(self, sampling_steps: int, shift):\n        sigmas = torch.linspace(1, 0, sampling_steps + 1)\n        sigmas = (shift * sigmas) / (1 + (shift - 1) * sigmas)\n        sigmas = sigmas.to(torch.float32)\n        timesteps = (sigmas[:-1] * 1000).to(dtype=torch.float32, device=self.execution_device)\n        return timesteps, sigmas\n\n    def step(self, latents, noise_pred, sigmas, step_i):\n        return latents.float() - (sigmas[step_i] - sigmas[step_i + 1]) * noise_pred.float()\n\n    @torch.no_grad()\n    def __call__(\n        self,\n        prompt: str,\n        shift: int = 5,\n        negative_prompt: str = \"\",\n        width: int = 2048,\n        height: int = 2048,\n        use_reprompt: bool = False,\n        use_refiner: bool = False,\n        num_inference_steps: Optional[int] = None,\n        guidance_scale: Optional[float] = None,\n        seed: Optional[int] = 42,\n        **kwargs\n    ) -> Image.Image:\n        \"\"\"\n        Generate an image from a text prompt.\n\n        Args:\n            prompt: Text prompt describing the image\n            negative_prompt: Negative prompt for guidance\n            width: Image width\n            height: Image height\n            use_reprompt: Whether to use reprompt model\n            use_refiner: Whether to use refiner pipeline\n            num_inference_steps: Number of denoising steps (overrides config if provided)\n            guidance_scale: Strength of classifier-free guidance (overrides config if provided)\n            seed: Random seed for reproducibility\n            **kwargs: Additional arguments\n\n        Returns:\n            Generated PIL Image\n        \"\"\"\n        if seed is not None:\n            generator = torch.Generator(device='cpu').manual_seed(seed)\n            torch.manual_seed(seed)\n        else:\n            generator = None\n\n        sampling_steps = num_inference_steps if num_inference_steps is not None else self.default_sampling_steps\n        guidance_scale = guidance_scale if guidance_scale is not None else self.default_guidance_scale\n        shift = shift if shift is not None else self.shift\n\n        user_prompt = prompt\n        if use_reprompt:\n            if self.config.enable_stage1_offloading:\n                self.offload()\n            prompt = self.reprompt_model.predict(prompt)\n\n\n        print(\"=\" * 60)\n        print(\"🖼️  HunyuanImage Generation Task\")\n        print(\"-\" * 60)\n        print(f\"Prompt:           {user_prompt}\")\n        if use_reprompt:\n            print(f\"Reprompt:         {prompt}\")\n        if not self.cfg_distilled:\n            print(f\"Negative Prompt:  {negative_prompt if negative_prompt else '(none)'}\")\n        print(f\"Guidance Scale:   {guidance_scale}\")\n        print(f\"CFG Mode:         {self.cfg_mode}\")\n        print(f\"Guidance Rescale: {self.guidance_rescale}\")\n        print(f\"Shift:            {shift}\")\n        print(f\"Seed:             {seed}\")\n        print(f\"Use MeanFlow:     {self.use_meanflow}\")\n        print(f\"Use byT5:         {self.use_byt5}\")\n        print(f\"Image Size:       {width} x {height}\")\n        print(f\"Sampling Steps:   {sampling_steps}\")\n        print(\"=\" * 60)\n\n        pos_text_emb, pos_text_mask = self._encode_text(prompt)\n        neg_text_emb, neg_text_mask = self._encode_text(negative_prompt)\n\n        if self.config.enable_text_encoder_offloading:\n            self.text_encoder.to('cpu')\n\n        self.byt5_kwargs['byt5_model'].to(self.execution_device)\n        pos_byt5_emb, pos_byt5_mask = self._encode_glyph(prompt)\n        neg_byt5_emb, neg_byt5_mask = self._encode_glyph(negative_prompt)\n        if self.config.enable_byt5_offloading:\n            self.byt5_kwargs['byt5_model'].to('cpu')\n\n        latents = self._prepare_latents(width, height, generator=generator)\n\n        do_classifier_free_guidance = (not self.cfg_distilled) and guidance_scale > 1\n        if do_classifier_free_guidance:\n            text_emb = torch.cat([neg_text_emb, pos_text_emb])\n            text_mask = torch.cat([neg_text_mask, pos_text_mask])\n\n            if self.use_byt5 and pos_byt5_emb is not None and neg_byt5_emb is not None:\n                byt5_emb = torch.cat([neg_byt5_emb, pos_byt5_emb])\n                byt5_mask = torch.cat([neg_byt5_mask, pos_byt5_mask])\n            else:\n                byt5_emb = pos_byt5_emb\n                byt5_mask = pos_byt5_mask\n        else:\n            text_emb = pos_text_emb\n            text_mask = pos_text_mask\n            byt5_emb = pos_byt5_emb\n            byt5_mask = pos_byt5_mask\n\n        timesteps, sigmas = self.get_timesteps_sigmas(sampling_steps, shift)\n\n        self.dit.to(self.execution_device)\n\n        for i, t in enumerate(tqdm(timesteps, desc=\"Denoising\", total=len(timesteps))):\n            latent_model_input = torch.cat([latents] * 2) if do_classifier_free_guidance else latents\n            t_expand = t.repeat(latent_model_input.shape[0])\n            if self.use_meanflow:\n                if i == len(timesteps) - 1:\n                    timesteps_r = torch.tensor([0.0], device=self.execution_device)\n                else:\n                    timesteps_r = timesteps[i + 1]\n                timesteps_r = timesteps_r.repeat(latent_model_input.shape[0])\n            else:\n                timesteps_r = None\n\n            if self.cfg_distilled:\n                noise_pred = self._denoise_step(\n                    latent_model_input, t_expand, text_emb, text_mask, byt5_emb, byt5_mask, guidance_scale, timesteps_r=timesteps_r,\n                )\n            else:\n                noise_pred = self._denoise_step(\n                    latent_model_input, t_expand, text_emb, text_mask, byt5_emb, byt5_mask, timesteps_r=timesteps_r,\n                )\n\n            if do_classifier_free_guidance:\n                noise_pred = self._apply_classifier_free_guidance(noise_pred, guidance_scale, i)\n\n            latents = self.step(latents, noise_pred, sigmas, i)\n\n\n        if self.config.enable_full_dit_offloading:\n            self.dit.to('cpu')\n        self.vae.to(self.execution_device)\n        image = self._decode_latents(latents)\n        if self.config.enable_vae_offloading:\n            self.vae.to('cpu')\n        image = (image.squeeze(0).permute(1, 2, 0) * 255).byte().numpy()\n        pil_image = Image.fromarray(image)\n\n        if use_refiner:\n            if self.config.enable_stage1_offloading:\n                self.offload()\n            pil_image = self.refiner_pipeline(\n                image=pil_image,\n                prompt=prompt,\n                negative_prompt=negative_prompt,\n                width=width,\n                height=height,\n                use_reprompt=False,\n                use_refiner=False,\n                num_inference_steps=4,\n                guidance_scale=guidance_scale,\n                generator=generator,\n            )\n            if self.config.enable_refiner_offloading:\n                self.refiner_pipeline.offload()\n\n        return pil_image\n\n    @property\n    def use_meanflow(self):\n        return getattr(self.dit, 'use_meanflow', False)\n\n    @property\n    def use_byt5(self):\n        return getattr(self.dit, 'glyph_byT5_v2', False)\n\n    @property\n    def cfg_distilled(self):\n        return getattr(self.dit, 'guidance_embed', False)\n\n    def to(self, device: str | torch.device):\n        \"\"\"\n        Move pipeline to specified device.\n\n        Args:\n            device: Target device string\n\n        Returns:\n            Self\n        \"\"\"\n        self.device = device\n        if not self.config.enable_full_dit_offloading and not self.config.enable_stage1_offloading:\n            if self.dit is not None:\n                self.dit = self.dit.to(device, non_blocking=True)\n        if not self.config.enable_text_encoder_offloading:\n            if self.text_encoder is not None:\n                self.text_encoder = self.text_encoder.to(device, non_blocking=True)\n        if self.vae is not None:\n            self.vae = self.vae.to(device, non_blocking=True)\n        return self\n    \n    def offload(self):\n        if self.dit is not None:\n            self.dit = self.dit.to('cpu', non_blocking=True)\n        if self.text_encoder is not None:\n            self.text_encoder = self.text_encoder.to('cpu', non_blocking=True)\n        if self.vae is not None:\n            self.vae = self.vae.to('cpu', non_blocking=True)\n        return self\n\n    def update_config(self, **kwargs):\n        \"\"\"\n        Update configuration parameters.\n\n        Args:\n            **kwargs: Key-value pairs to update\n\n        Returns:\n            Self\n        \"\"\"\n        for key, value in kwargs.items():\n            if hasattr(self.config, key):\n                setattr(self.config, key, value)\n                if hasattr(self, key):\n                    setattr(self, key, value)\n        return self\n\n    @classmethod\n    def from_pretrained(cls, model_name: str = \"hunyuanimage-v2.1\", use_distilled: bool = False, **kwargs):\n        \"\"\"\n        Create pipeline from pretrained model.\n\n        Args:\n            model_name: Model name, supports \"hunyuanimage-v2.1\", \"hunyuanimage-v2.1-distilled\"\n            use_distilled: Whether to use distilled model (overrides model_name if specified)\n            **kwargs: Additional configuration options\n\n        Returns:\n            HunyuanImagePipeline instance\n        \"\"\"\n        if model_name == \"hunyuanimage-v2.1\":\n            version = \"v2.1\"\n            use_distilled = False\n        elif model_name == \"hunyuanimage-v2.1-distilled\":\n            version = \"v2.1\"\n            use_distilled = True\n        else:\n            raise ValueError(\n                f\"Unsupported model name: {model_name}. Supported names: 'hunyuanimage-v2.1', 'hunyuanimage-v2.1-distilled'\"\n            )\n\n        config = HunyuanImagePipelineConfig.create_default(\n            version=version, use_distilled=use_distilled, **kwargs\n        )\n        return cls(config=config)\n\n    @classmethod\n    def from_config(cls, config: HunyuanImagePipelineConfig):\n        \"\"\"\n        Create pipeline from configuration object.\n\n        Args:\n            config: HunyuanImagePipelineConfig instance\n\n        Returns:\n            HunyuanImagePipeline instance\n        \"\"\"\n        return cls(config=config)\n\n\ndef DiffusionPipeline(model_name: str = \"hunyuanimage-v2.1\", use_distilled: bool = False, **kwargs):\n    \"\"\"\n    Factory function to create HunyuanImagePipeline.\n\n    Args:\n        model_name: Model name, supports \"hunyuanimage-v2.1\", \"hunyuanimage-v2.1-distilled\"\n        use_distilled: Whether to use distilled model (overrides model_name if specified)\n        **kwargs: Additional configuration options\n\n    Returns:\n        HunyuanImagePipeline instance\n    \"\"\"\n    return HunyuanImagePipeline.from_pretrained(model_name, use_distilled=use_distilled, **kwargs)\n",
        "hyimage/diffusion/pipelines/hunyuanimage_refiner_pipeline.py": "from dataclasses import dataclass\nfrom typing import Optional, Union\n\nimport torch\nfrom PIL import Image\nfrom tqdm import tqdm\nimport torchvision.transforms as T\nfrom einops import rearrange\n\nfrom .hunyuanimage_pipeline import HunyuanImagePipeline, HunyuanImagePipelineConfig\n\nfrom hyimage.models.model_zoo import (\n    HUNYUANIMAGE_REFINER_DIT,\n    HUNYUANIMAGE_REFINER_VAE_16x,\n    HUNYUANIMAGE_REFINER_TEXT_ENCODER,\n)\n\n\n@dataclass\nclass HunYuanImageRefinerPipelineConfig(HunyuanImagePipelineConfig):\n    \"\"\"\n    Configuration class for HunyuanImage refiner pipeline.\n    \n    Inherits from HunyuanImagePipelineConfig and overrides specific parameters\n    for the refiner functionality.\n    \"\"\"\n    \n    default_sampling_steps: int = 4\n    shift: int = 1\n    version: str = \"v1.0\"\n    cfg_mode: str = \"\"\n\n    @classmethod\n    def create_default(\n        cls,\n        version: str = \"v1.0\",\n        use_distilled: bool = False,\n        **kwargs,\n    ):\n        dit_config = HUNYUANIMAGE_REFINER_DIT()\n        vae_config = HUNYUANIMAGE_REFINER_VAE_16x()\n        text_encoder_config = HUNYUANIMAGE_REFINER_TEXT_ENCODER()\n\n        return cls(\n            dit_config=dit_config,\n            vae_config=vae_config,\n            text_encoder_config=text_encoder_config,\n            reprompt_config=None,\n            version=version,\n            **kwargs,\n        )\n\n\nclass HunYuanImageRefinerPipeline(HunyuanImagePipeline):\n    \"\"\"A refiner pipeline for HunyuanImage that inherits from the main pipeline.\n    \n    This pipeline refines existing images using the same model architecture\n    but with different default parameters and an image input.\n    \"\"\"\n    \n    def __init__(self, config: HunYuanImageRefinerPipelineConfig, **kwargs):\n        \"\"\"Initialize the refiner pipeline.\n        \n        Args:\n            config: Refiner-specific configuration\n            **kwargs: Additional arguments passed to parent class\n        \"\"\"\n        assert isinstance(config, HunYuanImageRefinerPipelineConfig)\n        super().__init__(config, **kwargs)\n        assert self.cfg_distilled\n        \n    def _condition_aug(self, latents, noise=None, strength=0.25):\n        \"\"\"Apply conditioning augmentation for refiner.\n        \n        Args:\n            latents: Input latents tensor\n            noise: Optional noise tensor, if None will be generated\n            strength: Augmentation strength factor\n            \n        Returns:\n            Augmented latents tensor\n        \"\"\"\n        if noise is None:\n            noise = torch.randn_like(latents)\n        return strength * noise + (1 - strength) * latents\n\n    @torch.no_grad()\n    def __call__(\n        self,\n        prompt: str,\n        negative_prompt: str = \"\",\n        width: int = 2048,\n        height: int = 2048,\n        use_reprompt: bool = False,\n        num_inference_steps: Optional[int] = None,\n        guidance_scale: Optional[float] = None,\n        shift: int = 4,\n        seed: Optional[int] = 42,\n        image: Optional[Image.Image] = None,\n        **kwargs,\n    ) -> Image.Image:\n        \"\"\"Refine an existing image using text guidance.\n\n        Args:\n            prompt: Text prompt describing the desired refinement\n            negative_prompt: Negative prompt for guidance\n            width: Image width\n            height: Image height\n            use_reprompt: Whether to use reprompt (ignored for refiner)\n            num_inference_steps: Number of denoising steps (overrides config if provided)\n            guidance_scale: Strength of classifier-free guidance (overrides config if provided)\n            seed: Random seed for reproducibility\n            image: Image to be refined (required for refiner)\n            **kwargs: Additional arguments\n\n        Returns:\n            Refined PIL Image\n        \"\"\"\n        if image is None:\n            raise ValueError(\"Image parameter is required for refiner pipeline\")\n            \n        if seed is not None:\n            generator = torch.Generator(device='cpu').manual_seed(seed)\n            torch.manual_seed(seed)\n        else:\n            generator = None\n\n        sampling_steps = (\n            num_inference_steps\n            if num_inference_steps is not None\n            else self.default_sampling_steps\n        )\n        guidance_scale = (\n            guidance_scale if guidance_scale is not None else self.default_guidance_scale\n        )\n        shift = shift if shift is not None else self.shift\n\n        # Print log about current refinement task\n        print(\"=\" * 60)\n        print(\"🔧 HunyuanImage Refinement Task\")\n        print(\"-\" * 60)\n        print(f\"Prompt:           {prompt}\")\n        print(f\"Guidance Scale:   {guidance_scale}\")\n        print(f\"Shift:            {self.shift}\")\n        print(f\"Seed:             {seed}\")\n        print(f\"Image Size:       {width} x {height}\")\n        print(f\"Sampling Steps:   {sampling_steps}\")\n        print(\"=\" * 60)\n\n        # Encode prompts\n        self.text_encoder.to(self.execution_device)\n        pos_text_emb, pos_text_mask = self._encode_text(prompt)\n        if self.config.enable_text_encoder_offloading:\n            self.text_encoder.to('cpu')\n\n        latents = self._prepare_latents(width, height, generator=generator, vae_downsampling_factor=16)\n\n        _pil_to_tensor = T.Compose(\n            [\n                T.ToTensor(),  # convert to tensor and normalize to [0, 1]\n                T.Normalize([0.5], [0.5]),  # transform to [-1, 1]\n            ]\n        )\n\n        image_tensor = (\n            _pil_to_tensor(image).unsqueeze(0).to(\"cuda\", dtype=self.vae.dtype)\n        )\n        image_tensor = image_tensor.unsqueeze(2)\n\n        with torch.no_grad():\n            self.vae.to(self.execution_device)\n            cond_latents = self.vae.encode(\n                image_tensor.to(self.execution_device, dtype=self.vae.dtype)\n            ).latent_dist.sample()\n            if self.config.enable_vae_offloading:\n                self.vae.to('cpu')\n\n        # reorg tokens\n        cond_latents = torch.cat((cond_latents[:, :, :1], cond_latents), dim=2)\n        cond_latents = rearrange(cond_latents, \"b c f h w -> b f c h w\")\n        cond_latents = rearrange(cond_latents, \"b (f n) c h w -> b f (n c) h w\", n=2)\n        cond_latents = rearrange(cond_latents, \"b f c h w -> b c f h w\").contiguous()\n\n        if (\n            hasattr(self.vae.config, \"shift_factor\")\n            and self.vae.config.shift_factor\n        ):\n            cond_latents.sub_(self.vae.config.shift_factor).mul_(\n                self.vae.config.scaling_factor\n            )\n        else:\n            cond_latents.mul_(self.vae.config.scaling_factor)\n        \n        \n        # Apply conditioning augmentation\n        cond_latents = self._condition_aug(cond_latents)\n\n        timesteps, sigmas = self.get_timesteps_sigmas(sampling_steps, shift)\n\n        text_emb = pos_text_emb\n        text_mask = pos_text_mask\n\n        self.dit.to(self.execution_device)\n        for i, t in enumerate(tqdm(timesteps, desc=\"Refining\", total=len(timesteps))):\n            # Concatenate noise latents with condition latents for refiner input\n            latent_model_input = torch.cat([latents, cond_latents], dim=1)\n            t_expand = t.repeat(latent_model_input.shape[0])\n\n            # Predict noise with guidance\n            noise_pred = self._denoise_step(\n                latent_model_input,\n                t_expand,\n                text_emb,\n                text_mask,\n                None,\n                None,\n                guidance_scale,\n                timesteps_r=None,\n            )\n\n            latents = self.step(latents, noise_pred, sigmas, i)\n        if self.config.enable_full_dit_offloading:\n            self.dit.to('cpu')\n        \n        self.vae.to(self.execution_device)\n        refined_image = self._decode_latents(latents, reorg_tokens=True)\n        if self.config.enable_vae_offloading:\n            self.vae.to('cpu')\n\n        # Convert to PIL Image\n        refined_image = (refined_image.squeeze(0).permute(1, 2, 0) * 255).byte().numpy()\n        pil_image = Image.fromarray(refined_image)\n\n        return pil_image\n\n    @classmethod\n    def from_pretrained(\n        cls,\n        model_name: str = \"hunyuanimage-refiner\",\n        use_distilled: bool = False,\n        **kwargs,\n    ):\n        \"\"\"Create refiner pipeline from pretrained model.\n        \n        Args:\n            model_name: Model name, currently only supports \"hunyuanimage-refiner\"\n            use_distilled: Whether to use distilled model (unused for refiner)\n            **kwargs: Additional configuration options\n        \"\"\"\n        if model_name == \"hunyuanimage-refiner\":\n            version = \"v1.0\"\n        else:\n            raise ValueError(\n                f\"Unsupported refiner model name: {model_name}. Supported names: 'hunyuanimage-refiner'\"\n            )\n\n        config = HunYuanImageRefinerPipelineConfig.create_default(\n            version=version, **kwargs\n        )\n\n        return cls(config=config)\n\n    @classmethod\n    def from_config(cls, config: Union[HunYuanImageRefinerPipelineConfig, HunyuanImagePipelineConfig]):\n        \"\"\"Create refiner pipeline from configuration object.\n        \n        Args:\n            config: Configuration object for the pipeline\n            \n        Returns:\n            Initialized refiner pipeline instance\n        \"\"\"\n        return cls(config=config)\n\n\n# Convenience function for easy access\ndef RefinerPipeline(\n    model_name: str = \"hunyuanimage-refiner\",\n    **kwargs,\n):\n    \"\"\"Factory function to create HunYuanImageRefinerPipeline.\n\n    Args:\n        model_name: Model name, currently only supports \"hunyuanimage-refiner\"\n        **kwargs: Additional configuration options\n        \n    Returns:\n        Initialized refiner pipeline instance\n    \"\"\"\n    return HunYuanImageRefinerPipeline.from_pretrained(\n        model_name, **kwargs\n    )\n",
        "hyimage/models/hunyuan/__init__.py": "",
        "hyimage/models/hunyuan/configs/hunyuanimage_config.py": "from hyimage.common.config import LazyCall as L\nfrom hyimage.models.hunyuan.modules.hunyuanimage_dit import HYImageDiffusionTransformer\n\n\n\n\nhunyuanimage_refiner_cfg = L(HYImageDiffusionTransformer)(\n    in_channels=128,\n    out_channels=64,\n    mm_double_blocks_depth=20,\n    mm_single_blocks_depth=40,\n    rope_dim_list=[16, 56, 56],\n    hidden_size=3328,\n    heads_num=26,\n    mlp_width_ratio=4,\n    patch_size=[1, 1, 1],\n    text_states_dim=3584,\n    guidance_embed=True,\n    use_meanflow=True,\n)\n\nhunyuanimage_v2_1_cfg = L(HYImageDiffusionTransformer)(\n    in_channels=64,\n    out_channels=64,\n    mm_double_blocks_depth=20,\n    mm_single_blocks_depth=40,\n    rope_dim_list=[64, 64],\n    hidden_size=3584,\n    heads_num=28,\n    mlp_width_ratio=4,\n    patch_size=[1, 1],\n    text_states_dim=3584,\n    glyph_byT5_v2=True,\n    guidance_embed=False,\n)\n\nhunyuanimage_v2_1_distilled_cfg = L(HYImageDiffusionTransformer)(\n    in_channels=64,\n    out_channels=64,\n    mm_double_blocks_depth=20,\n    mm_single_blocks_depth=40,\n    rope_dim_list=[64, 64],\n    hidden_size=3584,\n    heads_num=28,\n    mlp_width_ratio=4,\n    patch_size=[1, 1],\n    text_states_dim=3584,\n    glyph_byT5_v2=True,\n    guidance_embed=True,\n    use_meanflow=True,\n)\n",
        "hyimage/models/hunyuan/modules/__init__.py": "",
        "hyimage/models/hunyuan/modules/activation_layers.py": "import torch.nn as nn\n\n\ndef get_activation_layer(act_type):\n    \"\"\"get activation layer\n\n    Args:\n        act_type (str): the activation type\n\n    Returns:\n        torch.nn.functional: the activation layer\n    \"\"\"\n    if act_type == \"gelu\":\n        return lambda: nn.GELU()\n    elif act_type == \"gelu_tanh\":\n        # Approximate `tanh` requires torch >= 1.13\n        return lambda: nn.GELU(approximate=\"tanh\")\n    elif act_type == \"relu\":\n        return nn.ReLU\n    elif act_type == \"silu\":\n        return nn.SiLU\n    else:\n        raise ValueError(f\"Unknown activation type: {act_type}\")\n",
        "hyimage/models/hunyuan/modules/embed_layers.py": "import math\n\nimport torch\nimport torch.nn as nn\n\nfrom ..utils.helpers import to_2tuple\n\n\nclass PatchEmbed2D(nn.Module):\n\n    def __init__(\n        self,\n        patch_size=16,\n        in_chans=3,\n        embed_dim=768,\n        norm_layer=None,\n        flatten=True,\n        bias=True,\n        dtype=None,\n        device=None,\n    ):\n        super().__init__()\n        patch_size = to_2tuple(patch_size)\n        self.patch_size = patch_size\n        self.flatten = flatten\n\n        self.proj = nn.Conv2d(\n            in_chans, embed_dim, kernel_size=patch_size, stride=patch_size, bias=bias, device=device, dtype=dtype\n        )\n        nn.init.xavier_uniform_(self.proj.weight.view(self.proj.weight.size(0), -1))\n        if bias:\n            nn.init.zeros_(self.proj.bias)\n\n        self.norm = norm_layer(embed_dim) if norm_layer else nn.Identity()\n\n    def forward(self, x):\n        x = self.proj(x)\n        if self.flatten:\n            x = x.flatten(2).transpose(1, 2)\n        x = self.norm(x)\n        return x\n\n\nclass PatchEmbed(nn.Module):\n    \"\"\"2D Image to Patch Embedding\n\n    Image to Patch Embedding using Conv2d\n\n    A convolution based approach to patchifying a 2D image w/ embedding projection.\n\n    Based on the impl in https://github.com/google-research/vision_transformer\n\n    Hacked together by / Copyright 2020 Ross Wightman\n\n    Remove the _assert function in forward function to be compatible with multi-resolution images.\n    \"\"\"\n\n    def __init__(\n        self,\n        patch_size=16,\n        in_chans=3,\n        embed_dim=768,\n        norm_layer=None,\n        flatten=True,\n        bias=True,\n        dtype=None,\n        device=None,\n    ):\n        factory_kwargs = {\"dtype\": dtype, \"device\": device}\n        super().__init__()\n        patch_size = to_2tuple(patch_size)\n        self.patch_size = patch_size\n        self.flatten = flatten\n\n        self.proj = nn.Conv3d(\n            in_chans,\n            embed_dim,\n            kernel_size=patch_size,\n            stride=patch_size,\n            bias=bias,\n            **factory_kwargs\n        )\n        nn.init.xavier_uniform_(self.proj.weight.view(self.proj.weight.size(0), -1))\n        if bias:\n            nn.init.zeros_(self.proj.bias)\n\n        self.norm = norm_layer(embed_dim) if norm_layer else nn.Identity()\n\n    def forward(self, x):\n        x = self.proj(x)\n        if self.flatten:\n            x = x.flatten(2).transpose(1, 2)  # BCHW -> BNC\n        x = self.norm(x)\n        return x\n\n\nclass TextProjection(nn.Module):\n    \"\"\"\n    Projects text embeddings. Also handles dropout for classifier-free guidance.\n\n    Adapted from https://github.com/PixArt-alpha/PixArt-alpha/blob/master/diffusion/model/nets/PixArt_blocks.py\n    \"\"\"\n\n    def __init__(self, in_channels, hidden_size, act_layer, dtype=None, device=None):\n        factory_kwargs = {\"dtype\": dtype, \"device\": device}\n        super().__init__()\n        self.linear_1 = nn.Linear(\n            in_features=in_channels,\n            out_features=hidden_size,\n            bias=True,\n            **factory_kwargs\n        )\n        self.act_1 = act_layer()\n        self.linear_2 = nn.Linear(\n            in_features=hidden_size,\n            out_features=hidden_size,\n            bias=True,\n            **factory_kwargs\n        )\n\n    def forward(self, caption):\n        hidden_states = self.linear_1(caption)\n        hidden_states = self.act_1(hidden_states)\n        hidden_states = self.linear_2(hidden_states)\n        return hidden_states\n\n\n\ndef timestep_embedding(t, dim, max_period=10000):\n    \"\"\"\n    Create sinusoidal timestep embeddings.\n\n    Args:\n        t (torch.Tensor): a 1-D Tensor of N indices, one per batch element. These may be fractional.\n        dim (int): the dimension of the output.\n        max_period (int): controls the minimum frequency of the embeddings.\n\n    Returns:\n        embedding (torch.Tensor): An (N, D) Tensor of positional embeddings.\n\n    .. ref_link: https://github.com/openai/glide-text2im/blob/main/glide_text2im/nn.py\n    \"\"\"\n    half = dim // 2\n    freqs = torch.exp(\n        -math.log(max_period)\n        * torch.arange(start=0, end=half, dtype=torch.float32)\n        / half\n    ).to(device=t.device)\n    args = t[:, None].float() * freqs[None]\n    embedding = torch.cat([torch.cos(args), torch.sin(args)], dim=-1)\n    if dim % 2:\n        embedding = torch.cat([embedding, torch.zeros_like(embedding[:, :1])], dim=-1)\n    return embedding\n\n\nclass TimestepEmbedder(nn.Module):\n    \"\"\"\n    Embeds scalar timesteps into vector representations.\n    \"\"\"\n\n    def __init__(\n        self,\n        hidden_size,\n        act_layer,\n        frequency_embedding_size=256,\n        max_period=10000,\n        out_size=None,\n        dtype=None,\n        device=None,\n    ):\n        factory_kwargs = {\"dtype\": dtype, \"device\": device}\n        super().__init__()\n        self.frequency_embedding_size = frequency_embedding_size\n        self.max_period = max_period\n        if out_size is None:\n            out_size = hidden_size\n\n        self.mlp = nn.Sequential(\n            nn.Linear(frequency_embedding_size, hidden_size, bias=True, **factory_kwargs),\n            act_layer(),\n            nn.Linear(hidden_size, out_size, bias=True, **factory_kwargs),\n        )\n        nn.init.normal_(self.mlp[0].weight, std=0.02)\n        nn.init.normal_(self.mlp[2].weight, std=0.02)\n\n    def forward(self, t):\n        t_freq = timestep_embedding(t, self.frequency_embedding_size, self.max_period).type(self.mlp[0].weight.dtype)\n        t_emb = self.mlp(t_freq)\n        return t_emb",
        "hyimage/models/hunyuan/modules/flash_attn_no_pad.py": "import torch\nfrom einops import rearrange\n\ntry:\n    from flash_attn_interface import flash_attn_varlen_func\n\n    print(\"Using FlashAttention v3.\")\nexcept ImportError:\n    print(\"FlashAttention v3 not found, falling back to v2.\")\n    from flash_attn import flash_attn_varlen_func\n\nfrom flash_attn import flash_attn_varlen_qkvpacked_func\nfrom flash_attn.bert_padding import pad_input, unpad_input\n\n\ndef get_cu_seqlens(text_mask: torch.Tensor, img_len: int):\n    \"\"\"\n    Compute cumulative sequence lengths (cu_seqlens) for FlashAttention.\n\n    Args:\n        text_mask (torch.Tensor): Boolean mask of shape (batch_size, text_seq_len).\n        img_len (int): Length of image sequence.\n\n    Returns:\n        cu_seqlens (torch.Tensor): 1D tensor of cumulative sequence lengths for each segment.\n        max_len (int): Maximum sequence length (text + image).\n    \"\"\"\n    batch_size = text_mask.shape[0]\n    text_len = text_mask.sum(dim=1)\n    max_len = text_mask.shape[1] + img_len\n\n    cu_seqlens = torch.zeros([2 * batch_size + 1], dtype=torch.int32, device=text_mask.device)\n    for i in range(batch_size):\n        s = text_len[i] + img_len\n        s1 = i * max_len + s\n        s2 = (i + 1) * max_len\n        cu_seqlens[2 * i + 1] = s1\n        cu_seqlens[2 * i + 2] = s2\n\n    return cu_seqlens, max_len\n\n\ndef flash_attn_v3(\n    q: torch.Tensor,\n    k: torch.Tensor,\n    v: torch.Tensor,\n    cu_seqlens: torch.Tensor,\n    max_s: int,\n    causal: bool = False,\n    deterministic: bool = False,\n):\n    \"\"\"\n    FlashAttention v3 wrapper.\n\n    Args:\n        q, k, v (torch.Tensor): Query, key, value tensors of shape (batch, seq, nheads, head_dim).\n        cu_seqlens (torch.Tensor): Cumulative sequence lengths.\n        max_s (int): Maximum sequence length.\n        causal (bool): Whether to apply causal masking.\n        deterministic (bool): Deterministic computation.\n\n    Returns:\n        torch.Tensor: Output tensor of shape (batch, seq, nheads, head_dim).\n    \"\"\"\n    batch_size, seqlen = q.shape[:2]\n    q = q.reshape(-1, *q.shape[2:])\n    k = k.reshape(-1, *k.shape[2:])\n    v = v.reshape(-1, *v.shape[2:])\n    output = flash_attn_varlen_func(\n        q, k, v, cu_seqlens, cu_seqlens, max_s, max_s, causal=causal, deterministic=deterministic\n    )\n    output = output.view(batch_size, seqlen, *output.shape[-2:])\n    return output\n\n\ndef flash_attn_no_pad(\n    qkv: torch.Tensor,\n    key_padding_mask: torch.Tensor,\n    causal: bool = False,\n    dropout_p: float = 0.0,\n    softmax_scale=None,\n    deterministic: bool = False,\n):\n    \"\"\"\n    FlashAttention for packed QKV input without padding.\n\n    Args:\n        qkv (torch.Tensor): Input tensor of shape (batch, seq, 3, nheads, head_dim).\n        key_padding_mask (torch.Tensor): Boolean mask of shape (batch, seq).\n        causal (bool): Whether to apply causal masking.\n        dropout_p (float): Dropout probability.\n        softmax_scale (float, optional): Softmax scaling factor.\n        deterministic (bool): Deterministic computation.\n\n    Returns:\n        torch.Tensor: Output tensor of shape (batch, seq, nheads, head_dim).\n    \"\"\"\n    batch_size, seqlen, _, nheads, head_dim = qkv.shape\n    x = rearrange(qkv, \"b s three h d -> b s (three h d)\")\n\n    # Unpad input for FlashAttention, drop `used_seqlens_in_batch` for version compatibility\n    x_unpad, indices, cu_seqlens, max_s = unpad_input(x, key_padding_mask)[:4]\n    x_unpad = rearrange(x_unpad, \"nnz (three h d) -> nnz three h d\", three=3, h=nheads)\n\n    output_unpad = flash_attn_varlen_qkvpacked_func(\n        x_unpad,\n        cu_seqlens,\n        max_s,\n        dropout_p,\n        softmax_scale=softmax_scale,\n        causal=causal,\n        deterministic=deterministic,\n    )\n    if isinstance(output_unpad, tuple):\n        output_unpad = output_unpad[0]\n\n    # Pad output back to original shape\n    output = pad_input(\n        rearrange(output_unpad, \"nnz h d -> nnz (h d)\"),\n        indices,\n        batch_size,\n        seqlen,\n    )\n    output = rearrange(output, \"b s (h d) -> b s h d\", h=nheads)\n    return output\n",
        "hyimage/models/hunyuan/modules/hunyuanimage_dit.py": "import os\nfrom typing import Dict, List, Optional, Union\n\nimport torch\nimport torch.nn as nn\nfrom diffusers.configuration_utils import ConfigMixin, register_to_config\nfrom diffusers.models import ModelMixin\n\nfrom hyimage.models.hunyuan.modules.posemb_layers import get_nd_rotary_pos_embed\nfrom hyimage.models.hunyuan.modules.flash_attn_no_pad import get_cu_seqlens\n\nfrom .activation_layers import get_activation_layer\nfrom .embed_layers import PatchEmbed, PatchEmbed2D, TextProjection, TimestepEmbedder\nfrom .mlp_layers import FinalLayer\nfrom .models import MMDoubleStreamBlock, MMSingleStreamBlock\nfrom .token_refiner import SingleTokenRefiner\n\nfrom hyimage.models.text_encoder.byT5 import ByT5Mapper\n\n\ndef convert_hunyuan_dict_for_tensor_parallel(state_dict):\n    \"\"\"\n    Convert a Hunyuan model state dict to be compatible with tensor parallel architectures.\n\n    Args:\n        state_dict: Original state dict\n\n    Returns:\n        new_dict: Converted state dict\n    \"\"\"\n    new_dict = {}\n    for k, w in state_dict.items():\n        if k.startswith(\"double_blocks\") and \"attn_qkv.weight\" in k:\n            hidden_size = w.shape[1]\n            k1 = k.replace(\"attn_qkv.weight\", \"attn_q.weight\")\n            w1 = w[:hidden_size, :]\n            new_dict[k1] = w1\n            k2 = k.replace(\"attn_qkv.weight\", \"attn_k.weight\")\n            w2 = w[hidden_size : 2 * hidden_size, :]\n            new_dict[k2] = w2\n            k3 = k.replace(\"attn_qkv.weight\", \"attn_v.weight\")\n            w3 = w[-hidden_size:, :]\n            new_dict[k3] = w3\n        elif k.startswith(\"double_blocks\") and \"attn_qkv.bias\" in k:\n            hidden_size = w.shape[0] // 3\n            k1 = k.replace(\"attn_qkv.bias\", \"attn_q.bias\")\n            w1 = w[:hidden_size]\n            new_dict[k1] = w1\n            k2 = k.replace(\"attn_qkv.bias\", \"attn_k.bias\")\n            w2 = w[hidden_size : 2 * hidden_size]\n            new_dict[k2] = w2\n            k3 = k.replace(\"attn_qkv.bias\", \"attn_v.bias\")\n            w3 = w[-hidden_size:]\n            new_dict[k3] = w3\n        elif k.startswith(\"single_blocks\") and \"linear1\" in k:\n            hidden_size = state_dict[k.replace(\"linear1\", \"linear2\")].shape[0]\n            k1 = k.replace(\"linear1\", \"linear1_q\")\n            w1 = w[:hidden_size]\n            new_dict[k1] = w1\n            k2 = k.replace(\"linear1\", \"linear1_k\")\n            w2 = w[hidden_size : 2 * hidden_size]\n            new_dict[k2] = w2\n            k3 = k.replace(\"linear1\", \"linear1_v\")\n            w3 = w[2 * hidden_size : 3 * hidden_size]\n            new_dict[k3] = w3\n            k4 = k.replace(\"linear1\", \"linear1_mlp\")\n            w4 = w[3 * hidden_size :]\n            new_dict[k4] = w4\n        elif k.startswith(\"single_blocks\") and \"linear2\" in k:\n            k1 = k.replace(\"linear2\", \"linear2.fc\")\n            new_dict[k1] = w\n        else:\n            new_dict[k] = w\n    return new_dict\n\n\ndef load_hunyuan_dit_state_dict(model, dit_model_name_or_path, strict=True, assign=False):\n    \"\"\"\n    Load a state dict for a Hunyuan model, handling both safetensors and torch formats.\n\n    Args:\n        model: Model instance to load weights into\n        dit_model_name_or_path: Path to the checkpoint file\n        strict: Whether to strictly enforce that the keys in state_dict match the model's keys\n        assign: If True, assign weights directly without copying\n\n    Returns:\n        model: The model with loaded weights\n    \"\"\"\n    from safetensors.torch import load_file as safetensors_load_file\n\n    if not os.path.exists(dit_model_name_or_path):\n        raise FileNotFoundError(f\"Checkpoint file not found: {dit_model_name_or_path}\")\n\n    if dit_model_name_or_path.endswith(\".safetensors\"):\n        state_dict = safetensors_load_file(dit_model_name_or_path)\n    else:\n        state_dict = torch.load(\n            dit_model_name_or_path,\n            map_location=\"cpu\",\n            weights_only=True,\n        )\n    try:\n        state_dict = convert_hunyuan_dict_for_tensor_parallel(state_dict)\n    except Exception:\n        pass\n    model.load_state_dict(state_dict, strict=strict, assign=assign)\n    return model\n\n\nclass HYImageDiffusionTransformer(ModelMixin, ConfigMixin):\n\n    @register_to_config\n    def __init__(\n        self,\n        patch_size: list = [1, 2, 2],\n        in_channels: int = 4,\n        out_channels: int = None,\n        hidden_size: int = 3072,\n        heads_num: int = 24,\n        mlp_width_ratio: float = 4.0,\n        mlp_act_type: str = \"gelu_tanh\",\n        mm_double_blocks_depth: int = 20,\n        mm_single_blocks_depth: int = 40,\n        rope_dim_list: List[int] = [16, 56, 56],\n        qkv_bias: bool = True,\n        qk_norm: bool = True,\n        qk_norm_type: str = \"rms\",\n        guidance_embed: bool = False,\n        text_projection: str = \"single_refiner\",\n        use_attention_mask: bool = True,\n        dtype: Optional[torch.dtype] = None,\n        device: Optional[torch.device] = None,\n        text_states_dim: int = 4096,\n        rope_theta: int = 256,\n        glyph_byT5_v2: bool = False,\n        use_meanflow: bool = False,\n    ):\n        factory_kwargs = {\"device\": device, \"dtype\": dtype}\n        super().__init__()\n\n        self.patch_size = patch_size\n        self.in_channels = in_channels\n        self.out_channels = in_channels if out_channels is None else out_channels\n        self.unpatchify_channels = self.out_channels\n        self.guidance_embed = guidance_embed\n        self.rope_dim_list = rope_dim_list\n        self.rope_theta = rope_theta\n        self.use_attention_mask = use_attention_mask\n        self.text_projection = text_projection\n\n        if hidden_size % heads_num != 0:\n            raise ValueError(f\"Hidden size {hidden_size} must be divisible by heads_num {heads_num}\")\n        pe_dim = hidden_size // heads_num\n        if sum(rope_dim_list) != pe_dim:\n            raise ValueError(f\"Got {rope_dim_list} but expected positional dim {pe_dim}\")\n        self.hidden_size = hidden_size\n        self.heads_num = heads_num\n\n        self.glyph_byT5_v2 = glyph_byT5_v2\n        if self.glyph_byT5_v2:\n            self.byt5_in = ByT5Mapper(\n                in_dim=1472,\n                out_dim=2048,\n                hidden_dim=2048,\n                out_dim1=hidden_size,\n                use_residual=False\n            )\n\n        # Image projection\n        if len(self.patch_size) == 3:\n            self.img_in = PatchEmbed(self.patch_size, self.in_channels, self.hidden_size, **factory_kwargs)\n        elif len(self.patch_size) == 2:\n            self.img_in = PatchEmbed2D(self.patch_size, self.in_channels, self.hidden_size, **factory_kwargs)\n        else:\n            raise ValueError(f\"Unsupported patch_size: {self.patch_size}\")\n\n        # Text projection\n        if self.text_projection == \"linear\":\n            self.txt_in = TextProjection(\n                text_states_dim,\n                self.hidden_size,\n                get_activation_layer(\"silu\"),\n                **factory_kwargs,\n            )\n        elif self.text_projection == \"single_refiner\":\n            self.txt_in = SingleTokenRefiner(\n                text_states_dim,\n                hidden_size,\n                heads_num,\n                depth=2,\n                **factory_kwargs,\n            )\n        else:\n            raise NotImplementedError(f\"Unsupported text_projection: {self.text_projection}\")\n\n        # Time modulation\n        self.time_in = TimestepEmbedder(self.hidden_size, get_activation_layer(\"silu\"), **factory_kwargs)\n\n        # MeanFlow support: only create time_r_in when needed\n        self.time_r_in = (\n            TimestepEmbedder(self.hidden_size, get_activation_layer(\"silu\"), **factory_kwargs)\n            if use_meanflow\n            else None\n        )\n        self.use_meanflow = use_meanflow\n\n        # Guidance modulation\n        self.guidance_in = (\n            TimestepEmbedder(self.hidden_size, get_activation_layer(\"silu\"), **factory_kwargs)\n            if guidance_embed\n            else None\n        )\n\n        # Double blocks\n        self.double_blocks = nn.ModuleList(\n            [\n                MMDoubleStreamBlock(\n                    self.hidden_size,\n                    self.heads_num,\n                    mlp_width_ratio=mlp_width_ratio,\n                    mlp_act_type=mlp_act_type,\n                    qk_norm=qk_norm,\n                    qk_norm_type=qk_norm_type,\n                    qkv_bias=qkv_bias,\n                    **factory_kwargs,\n                )\n                for _ in range(mm_double_blocks_depth)\n            ]\n        )\n\n        # Single blocks\n        self.single_blocks = nn.ModuleList(\n            [\n                MMSingleStreamBlock(\n                    self.hidden_size,\n                    self.heads_num,\n                    mlp_width_ratio=mlp_width_ratio,\n                    mlp_act_type=mlp_act_type,\n                    qk_norm=qk_norm,\n                    qk_norm_type=qk_norm_type,\n                    **factory_kwargs,\n                )\n                for _ in range(mm_single_blocks_depth)\n            ]\n        )\n\n        self.final_layer = FinalLayer(\n            self.hidden_size,\n            self.patch_size,\n            self.out_channels,\n            get_activation_layer(\"silu\"),\n            **factory_kwargs,\n        )\n\n    def enable_deterministic(self):\n        \"\"\"Enable deterministic mode for all transformer blocks.\"\"\"\n        for block in self.double_blocks:\n            block.enable_deterministic()\n        for block in self.single_blocks:\n            block.enable_deterministic()\n\n    def disable_deterministic(self):\n        \"\"\"Disable deterministic mode for all transformer blocks.\"\"\"\n        for block in self.double_blocks:\n            block.disable_deterministic()\n        for block in self.single_blocks:\n            block.disable_deterministic()\n\n    def get_rotary_pos_embed(self, rope_sizes):\n        \"\"\"\n        Get rotary position embeddings for the given sizes.\n\n        Args:\n            rope_sizes: Sizes for each rotary dimension.\n\n        Returns:\n            freqs_cos, freqs_sin: Cosine and sine frequencies for rotary embedding.\n        \"\"\"\n        target_ndim = 3\n        head_dim = self.hidden_size // self.heads_num\n        rope_dim_list = self.rope_dim_list\n        if rope_dim_list is None:\n            rope_dim_list = [head_dim // target_ndim for _ in range(target_ndim)]\n        assert sum(rope_dim_list) == head_dim, \"sum(rope_dim_list) should equal to head_dim of attention layer\"\n        freqs_cos, freqs_sin = get_nd_rotary_pos_embed(\n            rope_dim_list,\n            rope_sizes,\n            theta=self.rope_theta,\n            use_real=True,\n            theta_rescale_factor=1,\n        )\n        return freqs_cos, freqs_sin\n\n    def reorder_txt_token(self, byt5_txt, txt, byt5_text_mask, text_mask):\n        \"\"\"\n        Reorder text tokens for ByT5 integration.\n\n        Args:\n            byt5_txt: ByT5 text embeddings.\n            txt: Text embeddings.\n            byt5_text_mask: Mask for ByT5 tokens.\n            text_mask: Mask for text tokens.\n\n        Returns:\n            reorder_txt: Reordered text embeddings.\n            reorder_mask: Reordered mask.\n        \"\"\"\n        reorder_txt = []\n        reorder_mask = []\n\n        for i in range(text_mask.shape[0]):\n            byt5_text_mask_i = byt5_text_mask[i].bool()\n            text_mask_i = text_mask[i].bool()\n            byt5_txt_i = byt5_txt[i]\n            txt_i = txt[i]\n            reorder_txt_i = torch.cat([\n                byt5_txt_i[byt5_text_mask_i],\n                txt_i[text_mask_i],\n                byt5_txt_i[~byt5_text_mask_i],\n                txt_i[~text_mask_i]\n            ], dim=0)\n\n            reorder_mask_i = torch.cat([\n                byt5_text_mask_i[byt5_text_mask_i],\n                text_mask_i[text_mask_i],\n                byt5_text_mask_i[~byt5_text_mask_i],\n                text_mask_i[~text_mask_i]\n            ], dim=0)\n\n            reorder_txt.append(reorder_txt_i)\n            reorder_mask.append(reorder_mask_i)\n\n        reorder_txt = torch.stack(reorder_txt)\n        reorder_mask = torch.stack(reorder_mask).to(dtype=torch.int64)\n\n        return reorder_txt, reorder_mask\n\n    def forward(\n        self,\n        hidden_states: torch.Tensor,\n        timestep: torch.LongTensor,\n        text_states: torch.Tensor,\n        encoder_attention_mask: torch.Tensor,\n        output_features: bool = False,\n        output_features_stride: int = 8,\n        freqs_cos: Optional[torch.Tensor] = None,\n        freqs_sin: Optional[torch.Tensor] = None,\n        return_dict: bool = False,\n        guidance=None,\n        extra_kwargs=None,\n        *,\n        timesteps_r: Optional[torch.LongTensor] = None,\n    ) -> Union[torch.Tensor, Dict[str, torch.Tensor]]:\n        \"\"\"\n        Forward pass for the transformer.\n\n        Parameters\n        ----------\n        hidden_states : torch.Tensor\n            Input image tensor.\n        timestep : torch.LongTensor\n            Timestep tensor.\n        text_states : torch.Tensor\n            Text embeddings.\n        encoder_attention_mask : torch.Tensor\n            Attention mask for text.\n        output_features : bool, optional\n            Whether to output intermediate features.\n        output_features_stride : int, optional\n            Stride for outputting features.\n        freqs_cos, freqs_sin : torch.Tensor, optional\n            Precomputed rotary embeddings.\n        return_dict : bool, optional\n            Not supported.\n        guidance : torch.Tensor, optional\n            Guidance vector for distillation.\n        extra_kwargs : dict, optional\n            Extra arguments for ByT5.\n        timesteps_r : torch.LongTensor, optional\n            Additional timestep for MeanFlow.\n\n        Returns\n        -------\n        tuple\n            (img, features_list, shape)\n        \"\"\"\n        if guidance is None:\n            guidance = torch.tensor([6016.0], device=hidden_states.device, dtype=torch.bfloat16)\n        img = x = hidden_states\n        text_mask = encoder_attention_mask\n        t = timestep\n        txt = text_states\n        input_shape = x.shape\n\n        # Calculate spatial dimensions and get rotary embeddings\n        if len(input_shape) == 5:\n            _, _, ot, oh, ow = x.shape\n            tt, th, tw = (\n                ot // self.patch_size[0],\n                oh // self.patch_size[1],\n                ow // self.patch_size[2],\n            )\n            if freqs_cos is None or freqs_sin is None:\n                freqs_cos, freqs_sin = self.get_rotary_pos_embed((tt, th, tw))\n        elif len(input_shape) == 4:\n            _, _, oh, ow = x.shape\n            th, tw = (\n                oh // self.patch_size[0],\n                ow // self.patch_size[1],\n            )\n            if freqs_cos is None or freqs_sin is None:\n                assert freqs_cos is None and freqs_sin is None, \"freqs_cos and freqs_sin must be both None or both not None\"\n                freqs_cos, freqs_sin = self.get_rotary_pos_embed((th, tw))\n        else:\n            raise ValueError(f\"Unsupported hidden_states shape: {x.shape}\")\n\n        img = self.img_in(img)\n\n        # Prepare modulation vectors\n        vec = self.time_in(t)\n\n        # MeanFlow support: merge timestep and timestep_r if available\n        if self.use_meanflow:\n            assert self.time_r_in is not None, \"use_meanflow is True but time_r_in is None\"\n        if timesteps_r is not None:\n            assert self.time_r_in is not None, \"timesteps_r is not None but time_r_in is None\"\n            vec_r = self.time_r_in(timesteps_r)\n            vec = (vec + vec_r) / 2\n\n        # Guidance modulation\n        if self.guidance_embed:\n            if guidance is None:\n                raise ValueError(\"Didn't get guidance strength for guidance distilled model.\")\n            vec = vec + self.guidance_in(guidance)\n\n        # Embed image and text\n        if self.text_projection == \"linear\":\n            txt = self.txt_in(txt)\n        elif self.text_projection == \"single_refiner\":\n            txt = self.txt_in(txt, t, text_mask if self.use_attention_mask else None)\n        else:\n            raise NotImplementedError(f\"Unsupported text_projection: {self.text_projection}\")\n\n        if self.glyph_byT5_v2:\n            byt5_text_states = extra_kwargs[\"byt5_text_states\"]\n            byt5_text_mask = extra_kwargs[\"byt5_text_mask\"]\n            byt5_txt = self.byt5_in(byt5_text_states)\n            txt, text_mask = self.reorder_txt_token(byt5_txt, txt, byt5_text_mask, text_mask)\n\n        txt_seq_len = txt.shape[1]\n        img_seq_len = img.shape[1]\n\n        # Calculate cu_seqlens and max_s for flash attention\n        cu_seqlens, max_s = get_cu_seqlens(text_mask, img_seq_len)\n\n        freqs_cis = (freqs_cos, freqs_sin) if freqs_cos is not None else None\n\n        # Pass through double stream blocks\n        for block in self.double_blocks:\n            double_block_args = [img, txt, vec, freqs_cis, text_mask, cu_seqlens, max_s]\n            img, txt = block(*double_block_args)\n\n        # Merge txt and img to pass through single stream blocks\n        x = torch.cat((img, txt), 1)\n        features_list = [] if output_features else None\n\n        if len(self.single_blocks) > 0:\n            for index, block in enumerate(self.single_blocks):\n                single_block_args = [\n                    x,\n                    vec,\n                    txt_seq_len,\n                    (freqs_cos, freqs_sin),\n                    text_mask,\n                    cu_seqlens,\n                    max_s,\n                ]\n                x = block(*single_block_args)\n                if output_features and index % output_features_stride == 0:\n                    features_list.append(x[:, :img_seq_len, ...])\n\n        img = x[:, :img_seq_len, ...]\n\n        # Final layer\n        img = self.final_layer(img, vec)\n\n        # Unpatchify based on input shape\n        if len(input_shape) == 5:\n            img = self.unpatchify(img, tt, th, tw)\n            shape = (tt, th, tw)\n        elif len(input_shape) == 4:\n            img = self.unpatchify_2d(img, th, tw)\n            shape = (th, tw)\n        else:\n            raise ValueError(f\"Unsupported input_shape: {input_shape}\")\n\n        assert not return_dict, \"return_dict is not supported.\"\n\n        if output_features:\n            features_list = torch.stack(features_list, dim=0)\n        else:\n            features_list = None\n\n        return (img, features_list, shape)\n\n    def unpatchify(self, x, t, h, w):\n        \"\"\"\n        Unpatchify 3D tensor.\n\n        Parameters\n        ----------\n        x: torch.Tensor\n            Input tensor of shape (N, T, patch_size**2 * C)\n        t, h, w: int\n            Temporal and spatial dimensions\n\n        Returns\n        -------\n        torch.Tensor\n            Unpatchified tensor of shape (N, C, T*pt, H*ph, W*pw)\n        \"\"\"\n        c = self.unpatchify_channels\n        pt, ph, pw = self.patch_size\n        assert t * h * w == x.shape[1]\n\n        x = x.reshape(shape=(x.shape[0], t, h, w, c, pt, ph, pw))\n        x = torch.einsum(\"nthwcopq->nctohpwq\", x)\n        imgs = x.reshape(shape=(x.shape[0], c, t * pt, h * ph, w * pw))\n\n        return imgs\n\n    def unpatchify_2d(self, x, h, w):\n        \"\"\"\n        Unpatchify 2D tensor.\n        \n        Parameters\n        ----------\n        x: torch.Tensor\n            Input tensor of shape (N, T, patch_size**2 * C)\n        h, w: int\n            Spatial dimensions\n\n        Returns\n        -------\n        torch.Tensor\n            Unpatchified tensor of shape (N, C, H*ph, W*pw)\n        \"\"\"\n        c = self.unpatchify_channels\n        ph, pw = self.patch_size\n        assert h * w == x.shape[1]\n\n        x = x.reshape(shape=(x.shape[0], h, w, c, ph, pw))\n        x = torch.einsum('nhwcpq->nchpwq', x)\n        imgs = x.reshape(shape=(x.shape[0], c, h * ph, w * pw))\n        return imgs\n",
        "hyimage/models/hunyuan/modules/mlp_layers.py": "# Modified from timm library:\n# https://github.com/huggingface/pytorch-image-models/blob/648aaa41233ba83eb38faf5ba9d415d574823241/timm/layers/mlp.py#L13\n\nfrom functools import partial\n\nimport torch\nimport torch.nn as nn\n\nfrom ..utils.helpers import to_2tuple\nfrom .modulate_layers import modulate\n\n\nclass MLP(nn.Module):\n    \"\"\"MLP as used in Vision Transformer, MLP-Mixer and related networks\"\"\"\n\n    def __init__(\n        self,\n        in_channels,\n        hidden_channels=None,\n        out_features=None,\n        act_layer=nn.GELU,\n        norm_layer=None,\n        bias=True,\n        drop=0.0,\n        use_conv=False,\n        device=None,\n        dtype=None,\n    ):\n        factory_kwargs = {\"device\": device, \"dtype\": dtype}\n        super().__init__()\n        out_features = out_features or in_channels\n        hidden_channels = hidden_channels or in_channels\n        bias = to_2tuple(bias)\n        drop_probs = to_2tuple(drop)\n        linear_layer = partial(nn.Conv2d, kernel_size=1) if use_conv else nn.Linear\n\n        self.fc1 = linear_layer(in_channels, hidden_channels, bias=bias[0], **factory_kwargs)\n        self.act = act_layer()\n        self.drop1 = nn.Dropout(drop_probs[0])\n        self.norm = norm_layer(hidden_channels, **factory_kwargs) if norm_layer is not None else nn.Identity()\n        self.fc2 = linear_layer(hidden_channels, out_features, bias=bias[1], **factory_kwargs)\n        self.drop2 = nn.Dropout(drop_probs[1])\n\n    def forward(self, x):\n        x = self.fc1(x)\n        x = self.act(x)\n        x = self.drop1(x)\n        x = self.norm(x)\n        x = self.fc2(x)\n        x = self.drop2(x)\n        return x\n\n\nclass LinearWarpforSingle(nn.Module):\n    def __init__(self, in_dim: int, out_dim: int, bias=False, device=None, dtype=None):\n        factory_kwargs = {\"device\": device, \"dtype\": dtype}\n        super().__init__()\n        self.fc = nn.Linear(in_dim, out_dim, bias=bias, **factory_kwargs)\n\n    def forward(self, x, y):\n        input = torch.cat([x.contiguous(), y.contiguous()], dim=2).contiguous()\n        return self.fc(input)\n\n\n#\nclass MLPEmbedder(nn.Module):\n    \"\"\"copied from https://github.com/black-forest-labs/flux/blob/main/src/flux/modules/layers.py\"\"\"\n\n    def __init__(self, in_dim: int, hidden_dim: int, device=None, dtype=None):\n        factory_kwargs = {\"device\": device, \"dtype\": dtype}\n        super().__init__()\n        self.in_layer = nn.Linear(in_dim, hidden_dim, bias=True, **factory_kwargs)\n        self.silu = nn.SiLU()\n        self.out_layer = nn.Linear(hidden_dim, hidden_dim, bias=True, **factory_kwargs)\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        return self.out_layer(self.silu(self.in_layer(x)))\n\n\nclass FinalLayer(nn.Module):\n    \"\"\"The final layer of DiT.\"\"\"\n\n    def __init__(self, hidden_size, patch_size, out_channels, act_layer, device=None, dtype=None):\n        factory_kwargs = {\"device\": device, \"dtype\": dtype}\n        super().__init__()\n\n        # Just use LayerNorm for the final layer\n        self.norm_final = nn.LayerNorm(hidden_size, elementwise_affine=False, eps=1e-6, **factory_kwargs)\n        if isinstance(patch_size, int):\n            self.linear = nn.Linear(\n                hidden_size,\n                patch_size * patch_size * out_channels,\n                bias=True,\n                **factory_kwargs,\n            )\n        else:\n            out_size = (\n                patch_size[0] * patch_size[1] * patch_size[2] if len(patch_size) == 3 else patch_size[0] * patch_size[1]\n            ) * out_channels\n            self.linear = nn.Linear(\n                hidden_size,\n                out_size,\n                bias=True,\n            )\n        nn.init.zeros_(self.linear.weight)\n        nn.init.zeros_(self.linear.bias)\n\n        # Here we don't distinguish between the modulate types. Just use the simple one.\n        self.adaLN_modulation = nn.Sequential(\n            act_layer(),\n            nn.Linear(hidden_size, 2 * hidden_size, bias=True, **factory_kwargs),\n        )\n        # Zero-initialize the modulation\n        nn.init.zeros_(self.adaLN_modulation[1].weight)\n        nn.init.zeros_(self.adaLN_modulation[1].bias)\n\n    def forward(self, x, c):\n        shift, scale = self.adaLN_modulation(c).chunk(2, dim=1)\n        x = modulate(self.norm_final(x), shift=shift, scale=scale)\n        x = self.linear(x)\n        return x\n",
        "hyimage/models/hunyuan/modules/models.py": "from typing import Optional, Tuple\n\nimport torch\nimport torch.nn as nn\n\nfrom einops import rearrange\n\nfrom hyimage.models.hunyuan.modules.flash_attn_no_pad import flash_attn_no_pad\n\nfrom .activation_layers import get_activation_layer\nfrom .mlp_layers import MLP, LinearWarpforSingle\nfrom .modulate_layers import ModulateDiT, apply_gate, modulate\nfrom .norm_layers import get_norm_layer\nfrom .posemb_layers import apply_rotary_emb\n\n\n@torch.compiler.disable\ndef attention(\n    q,\n    k,\n    v,\n    attn_mode=\"flash\",\n    text_mask=None,\n):\n    \"\"\"Multi-modal attention function that processes image and text sequences.\"\"\"\n    query, encoder_query = q\n    key, encoder_key = k\n    value, encoder_value = v\n\n    assert attn_mode == \"flash\"  # Only flash attention is implemented for now\n    sequence_length = query.size(1)\n    encoder_sequence_length = encoder_query.size(1)\n\n    query = torch.cat([query, encoder_query], dim=1)\n    key = torch.cat([key, encoder_key], dim=1)\n    value = torch.cat([value, encoder_value], dim=1)\n\n    # Stack query, key, value: B, S, 3, H, D\n    qkv = torch.stack([query, key, value], dim=2)\n\n    attn_mask = torch.nn.functional.pad(text_mask, (sequence_length, 0), value=True)\n    hidden_states = flash_attn_no_pad(qkv, attn_mask, causal=False, dropout_p=0.0, softmax_scale=None)\n\n    hidden_states, encoder_hidden_states = hidden_states.split_with_sizes(\n        (sequence_length, encoder_sequence_length), dim=1\n    )\n\n    hidden_states = hidden_states.to(query.dtype)\n    encoder_hidden_states = encoder_hidden_states.to(query.dtype)\n\n    attn = torch.cat([hidden_states, encoder_hidden_states], dim=1)\n\n    b, s, a, d = attn.shape\n    attn = attn.reshape(b, s, -1)\n\n    return attn\n\n\nclass MMDoubleStreamBlock(nn.Module):\n    \"\"\"\n    A multimodal DiT block with separate modulation for text and image/video.\n    \"\"\"\n\n    def __init__(\n        self,\n        hidden_size: int,\n        heads_num: int,\n        mlp_width_ratio: float,\n        mlp_act_type: str = \"gelu_tanh\",\n        qk_norm: bool = True,\n        qk_norm_type: str = \"rms\",\n        qkv_bias: bool = False,\n        dtype: Optional[torch.dtype] = None,\n        device: Optional[torch.device] = None,\n    ):\n        factory_kwargs = {\"device\": device, \"dtype\": dtype}\n        super().__init__()\n\n        self.deterministic = False\n        self.heads_num = heads_num\n        head_dim = hidden_size // heads_num\n        mlp_hidden_dim = int(hidden_size * mlp_width_ratio)\n\n        # Image stream components\n        self.img_mod = ModulateDiT(\n            hidden_size,\n            factor=6,\n            act_layer=get_activation_layer(\"silu\"),\n            **factory_kwargs,\n        )\n        self.img_norm1 = nn.LayerNorm(hidden_size, elementwise_affine=False, eps=1e-6, **factory_kwargs)\n\n        self.img_attn_q = nn.Linear(hidden_size, hidden_size, bias=qkv_bias, **factory_kwargs)\n        self.img_attn_k = nn.Linear(hidden_size, hidden_size, bias=qkv_bias, **factory_kwargs)\n        self.img_attn_v = nn.Linear(hidden_size, hidden_size, bias=qkv_bias, **factory_kwargs)\n\n        qk_norm_layer = get_norm_layer(qk_norm_type)\n        self.img_attn_q_norm = (\n            qk_norm_layer(head_dim, elementwise_affine=True, eps=1e-6, **factory_kwargs) if qk_norm else nn.Identity()\n        )\n        self.img_attn_k_norm = (\n            qk_norm_layer(head_dim, elementwise_affine=True, eps=1e-6, **factory_kwargs) if qk_norm else nn.Identity()\n        )\n        self.img_attn_proj = nn.Linear(hidden_size, hidden_size, bias=qkv_bias, **factory_kwargs)\n\n        self.img_norm2 = nn.LayerNorm(hidden_size, elementwise_affine=False, eps=1e-6, **factory_kwargs)\n        self.img_mlp = MLP(\n            hidden_size,\n            mlp_hidden_dim,\n            act_layer=get_activation_layer(mlp_act_type),\n            bias=True,\n            **factory_kwargs,\n        )\n\n        # Text stream components\n        self.txt_mod = ModulateDiT(\n            hidden_size,\n            factor=6,\n            act_layer=get_activation_layer(\"silu\"),\n            **factory_kwargs,\n        )\n        self.txt_norm1 = nn.LayerNorm(hidden_size, elementwise_affine=False, eps=1e-6, **factory_kwargs)\n\n        self.txt_attn_q = nn.Linear(hidden_size, hidden_size, bias=qkv_bias, **factory_kwargs)\n        self.txt_attn_k = nn.Linear(hidden_size, hidden_size, bias=qkv_bias, **factory_kwargs)\n        self.txt_attn_v = nn.Linear(hidden_size, hidden_size, bias=qkv_bias, **factory_kwargs)\n        self.txt_attn_q_norm = (\n            qk_norm_layer(head_dim, elementwise_affine=True, eps=1e-6, **factory_kwargs) if qk_norm else nn.Identity()\n        )\n        self.txt_attn_k_norm = (\n            qk_norm_layer(head_dim, elementwise_affine=True, eps=1e-6, **factory_kwargs) if qk_norm else nn.Identity()\n        )\n        self.txt_attn_proj = nn.Linear(hidden_size, hidden_size, bias=qkv_bias, **factory_kwargs)\n\n        self.txt_norm2 = nn.LayerNorm(hidden_size, elementwise_affine=False, eps=1e-6, **factory_kwargs)\n        self.txt_mlp = MLP(\n            hidden_size,\n            mlp_hidden_dim,\n            act_layer=get_activation_layer(mlp_act_type),\n            bias=True,\n            **factory_kwargs,\n        )\n        self.core_attn = attention\n\n    def enable_deterministic(self):\n        self.deterministic = True\n\n    def disable_deterministic(self):\n        self.deterministic = False\n\n    def forward(\n        self,\n        img: torch.Tensor,\n        txt: torch.Tensor,\n        vec: torch.Tensor,\n        freqs_cis: tuple = None,\n        text_mask: torch.Tensor = None,\n        cu_seqlens=None,\n        max_s=None,\n    ) -> Tuple[torch.Tensor, torch.Tensor]:\n        # Extract modulation parameters for image and text streams\n        (\n            img_mod1_shift,\n            img_mod1_scale,\n            img_mod1_gate,\n            img_mod2_shift,\n            img_mod2_scale,\n            img_mod2_gate,\n        ) = self.img_mod(vec).chunk(6, dim=-1)\n        (\n            txt_mod1_shift,\n            txt_mod1_scale,\n            txt_mod1_gate,\n            txt_mod2_shift,\n            txt_mod2_scale,\n            txt_mod2_gate,\n        ) = self.txt_mod(vec).chunk(6, dim=-1)\n\n        # Process image stream for attention\n        img_modulated = self.img_norm1(img)\n        img_modulated = modulate(img_modulated, shift=img_mod1_shift, scale=img_mod1_scale)\n\n        img_q = self.img_attn_q(img_modulated)\n        img_k = self.img_attn_k(img_modulated)\n        img_v = self.img_attn_v(img_modulated)\n\n        img_q = rearrange(img_q, \"B L (H D) -> B L H D\", H=self.heads_num)\n        img_k = rearrange(img_k, \"B L (H D) -> B L H D\", H=self.heads_num)\n        img_v = rearrange(img_v, \"B L (H D) -> B L H D\", H=self.heads_num)\n\n        # Apply QK-Norm if enabled\n        img_q = self.img_attn_q_norm(img_q).to(img_v)\n        img_k = self.img_attn_k_norm(img_k).to(img_v)\n\n        # Apply RoPE if provided\n        if freqs_cis is not None:\n            img_qq, img_kk = apply_rotary_emb(img_q, img_k, freqs_cis, head_first=False)\n            assert (\n                img_qq.shape == img_q.shape and img_kk.shape == img_k.shape\n            ), f\"img_kk: {img_qq.shape}, img_q: {img_q.shape}, img_kk: {img_kk.shape}, img_k: {img_k.shape}\"\n            img_q, img_k = img_qq, img_kk\n\n        # Process text stream for attention\n        txt_modulated = self.txt_norm1(txt)\n        txt_modulated = modulate(txt_modulated, shift=txt_mod1_shift, scale=txt_mod1_scale)\n\n        txt_q = self.txt_attn_q(txt_modulated)\n        txt_k = self.txt_attn_k(txt_modulated)\n        txt_v = self.txt_attn_v(txt_modulated)\n\n        txt_q = rearrange(txt_q, \"B L (H D) -> B L H D\", H=self.heads_num)\n        txt_k = rearrange(txt_k, \"B L (H D) -> B L H D\", H=self.heads_num)\n        txt_v = rearrange(txt_v, \"B L (H D) -> B L H D\", H=self.heads_num)\n\n        # Apply QK-Norm if enabled\n        txt_q = self.txt_attn_q_norm(txt_q).to(txt_v)\n        txt_k = self.txt_attn_k_norm(txt_k).to(txt_v)\n\n        # Compute cross-modal attention\n        attn = self.core_attn(\n            (img_q, txt_q),\n            (img_k, txt_k),\n            (img_v, txt_v),\n            text_mask=text_mask,\n        )\n\n        # Split attention outputs for image and text streams\n        img_attn, txt_attn = (\n            attn[:, : img_q.shape[1]].contiguous(),\n            attn[:, img_q.shape[1] :].contiguous(),\n        )\n\n        # Apply attention projection and residual connection for image stream\n        img = img + apply_gate(self.img_attn_proj(img_attn), gate=img_mod1_gate)\n\n        # Apply MLP and residual connection for image stream\n        img = img + apply_gate(\n            self.img_mlp(modulate(self.img_norm2(img), shift=img_mod2_shift, scale=img_mod2_scale)),\n            gate=img_mod2_gate,\n        )\n\n        # Apply attention projection and residual connection for text stream\n        txt = txt + apply_gate(self.txt_attn_proj(txt_attn), gate=txt_mod1_gate)\n\n        # Apply MLP and residual connection for text stream\n        txt = txt + apply_gate(\n            self.txt_mlp(modulate(self.txt_norm2(txt), shift=txt_mod2_shift, scale=txt_mod2_scale)),\n            gate=txt_mod2_gate,\n        )\n\n        return img, txt\n\n\nclass MMSingleStreamBlock(nn.Module):\n    \"\"\"\n    A DiT block with parallel linear layers for multimodal processing.\n    \"\"\"\n\n    def __init__(\n        self,\n        hidden_size: int,\n        heads_num: int,\n        mlp_width_ratio: float = 4.0,\n        mlp_act_type: str = \"gelu_tanh\",\n        qk_norm: bool = True,\n        qk_norm_type: str = \"rms\",\n        qk_scale: float = None,\n        dtype: Optional[torch.dtype] = None,\n        device: Optional[torch.device] = None,\n    ):\n        factory_kwargs = {\"device\": device, \"dtype\": dtype}\n        super().__init__()\n\n        self.deterministic = False\n        self.hidden_size = hidden_size\n        self.heads_num = heads_num\n        head_dim = hidden_size // heads_num\n        mlp_hidden_dim = int(hidden_size * mlp_width_ratio)\n        self.mlp_hidden_dim = mlp_hidden_dim\n        self.scale = qk_scale or head_dim**-0.5\n\n        # Separate linear layers for Q, K, V, and MLP input\n        self.linear1_q = nn.Linear(hidden_size, hidden_size, **factory_kwargs)\n        self.linear1_k = nn.Linear(hidden_size, hidden_size, **factory_kwargs)\n        self.linear1_v = nn.Linear(hidden_size, hidden_size, **factory_kwargs)\n        self.linear1_mlp = nn.Linear(hidden_size, mlp_hidden_dim, **factory_kwargs)\n\n        # Output projection layer\n        self.linear2 = LinearWarpforSingle(hidden_size + mlp_hidden_dim, hidden_size, bias=True, **factory_kwargs)\n\n        # QK normalization layers\n        qk_norm_layer = get_norm_layer(qk_norm_type)\n        self.q_norm = (\n            qk_norm_layer(head_dim, elementwise_affine=True, eps=1e-6, **factory_kwargs) if qk_norm else nn.Identity()\n        )\n        self.k_norm = (\n            qk_norm_layer(head_dim, elementwise_affine=True, eps=1e-6, **factory_kwargs) if qk_norm else nn.Identity()\n        )\n\n        self.pre_norm = nn.LayerNorm(hidden_size, elementwise_affine=False, eps=1e-6, **factory_kwargs)\n\n        self.mlp_act = get_activation_layer(mlp_act_type)()\n        self.modulation = ModulateDiT(\n            hidden_size,\n            factor=3,\n            act_layer=get_activation_layer(\"silu\"),\n            **factory_kwargs,\n        )\n        self.core_attn = attention\n\n    def enable_deterministic(self):\n        self.deterministic = True\n\n    def disable_deterministic(self):\n        self.deterministic = False\n\n    def forward(\n        self,\n        x: torch.Tensor,\n        vec: torch.Tensor,\n        txt_len: int,\n        freqs_cis: Tuple[torch.Tensor, torch.Tensor] = None,\n        text_mask: torch.Tensor = None,\n        cu_seqlens=None,\n        max_s=None,\n    ) -> torch.Tensor:\n        # Extract modulation parameters\n        mod_shift, mod_scale, mod_gate = self.modulation(vec).chunk(3, dim=-1)\n        x_mod = modulate(self.pre_norm(x), shift=mod_shift, scale=mod_scale)\n\n        # Compute Q, K, V, and MLP input\n        q = self.linear1_q(x_mod)\n        k = self.linear1_k(x_mod)\n        v = self.linear1_v(x_mod)\n\n        q = rearrange(q, \"B L (H D) -> B L H D\", H=self.heads_num)\n        k = rearrange(k, \"B L (H D) -> B L H D\", H=self.heads_num)\n        v = rearrange(v, \"B L (H D) -> B L H D\", H=self.heads_num)\n        mlp = self.linear1_mlp(x_mod)\n\n        # Apply QK-Norm if enabled\n        q = self.q_norm(q).to(v)\n        k = self.k_norm(k).to(v)\n\n        # Split into image and text sequences\n        img_q, txt_q = q[:, :-txt_len, :, :], q[:, -txt_len:, :, :]\n        img_k, txt_k = k[:, :-txt_len, :, :], k[:, -txt_len:, :, :]\n        img_v, txt_v = v[:, :-txt_len, :, :], v[:, -txt_len:, :, :]\n\n        # Apply RoPE to image sequence\n        img_qq, img_kk = apply_rotary_emb(img_q, img_k, freqs_cis, head_first=False)\n        assert (\n            img_qq.shape == img_q.shape and img_kk.shape == img_k.shape\n        ), f\"img_kk: {img_qq.shape}, img_q: {img_q.shape}, img_kk: {img_kk.shape}, img_k: {img_k.shape}\"\n        img_q, img_k = img_qq, img_kk\n\n        # Compute cross-modal attention\n        attn = self.core_attn(\n            (img_q, txt_q),\n            (img_k, txt_k),\n            (img_v, txt_v),\n            text_mask=text_mask,\n        )\n\n        # Combine attention output with MLP activation and apply final projection\n        output = self.linear2(attn, self.mlp_act(mlp))\n        return x + apply_gate(output, gate=mod_gate)\n",
        "hyimage/models/hunyuan/modules/modulate_layers.py": "from typing import Callable\n\nimport torch\nimport torch.nn as nn\n\n\nclass ModulateDiT(nn.Module):\n    \"\"\"Modulation layer for DiT.\"\"\"\n\n    def __init__(\n        self,\n        hidden_size: int,\n        factor: int,\n        act_layer: Callable,\n        dtype=None,\n        device=None,\n    ):\n        factory_kwargs = {\"dtype\": dtype, \"device\": device}\n        super().__init__()\n        self.act = act_layer()\n        self.linear = nn.Linear(hidden_size, factor * hidden_size, bias=True, **factory_kwargs)\n        # Zero-initialize the modulation\n        nn.init.zeros_(self.linear.weight)\n        nn.init.zeros_(self.linear.bias)\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        return self.linear(self.act(x))\n\n\ndef modulate(x, shift=None, scale=None):\n    \"\"\"modulate by shift and scale\n\n    Args:\n        x (torch.Tensor): input tensor.\n        shift (torch.Tensor, optional): shift tensor. Defaults to None.\n        scale (torch.Tensor, optional): scale tensor. Defaults to None.\n\n    Returns:\n        torch.Tensor: the output tensor after modulate.\n    \"\"\"\n    if scale is None and shift is None:\n        return x\n    elif shift is None:\n        return x * (1 + scale.unsqueeze(1))\n    elif scale is None:\n        return x + shift.unsqueeze(1)\n    else:\n        return x * (1 + scale.unsqueeze(1)) + shift.unsqueeze(1)\n\n\ndef apply_gate(x, gate=None, tanh=False):\n    \"\"\"AI is creating summary for apply_gate\n\n    Args:\n        x (torch.Tensor): input tensor.\n        gate (torch.Tensor, optional): gate tensor. Defaults to None.\n        tanh (bool, optional): whether to use tanh function. Defaults to False.\n\n    Returns:\n        torch.Tensor: the output tensor after apply gate.\n    \"\"\"\n    if gate is None:\n        return x\n    if tanh:\n        return x * gate.unsqueeze(1).tanh()\n    else:\n        return x * gate.unsqueeze(1)\n\n\ndef ckpt_wrapper(module):\n    def ckpt_forward(*inputs):\n        outputs = module(*inputs)\n        return outputs\n\n    return ckpt_forward\n\n\nimport torch\nimport torch.nn as nn\n\n\nclass RMSNorm(nn.Module):\n    def __init__(\n        self,\n        dim: int,\n        elementwise_affine=True,\n        eps: float = 1e-6,\n        device=None,\n        dtype=None,\n    ):\n        \"\"\"\n        Initialize the RMSNorm normalization layer.\n\n        Args:\n            dim (int): The dimension of the input tensor.\n            eps (float, optional): A small value added to the denominator for numerical stability. Default is 1e-6.\n\n        Attributes:\n            eps (float): A small value added to the denominator for numerical stability.\n            weight (nn.Parameter): Learnable scaling parameter.\n\n        \"\"\"\n        factory_kwargs = {\"device\": device, \"dtype\": dtype}\n        super().__init__()\n        self.eps = eps\n        if elementwise_affine:\n            self.weight = nn.Parameter(torch.ones(dim, **factory_kwargs))\n\n    def _norm(self, x):\n        \"\"\"\n        Apply the RMSNorm normalization to the input tensor.\n\n        Args:\n            x (torch.Tensor): The input tensor.\n\n        Returns:\n            torch.Tensor: The normalized tensor.\n\n        \"\"\"\n        return x * torch.rsqrt(x.pow(2).mean(-1, keepdim=True) + self.eps)\n\n    def forward(self, x):\n        \"\"\"\n        Forward pass through the RMSNorm layer.\n\n        Args:\n            x (torch.Tensor): The input tensor.\n\n        Returns:\n            torch.Tensor: The output tensor after applying RMSNorm.\n\n        \"\"\"\n        output = self._norm(x.float()).type_as(x)\n        if hasattr(self, \"weight\"):\n            output = output * self.weight\n        return output\n\n\ndef get_norm_layer(norm_layer):\n    \"\"\"\n    Get the normalization layer.\n\n    Args:\n        norm_layer (str): The type of normalization layer.\n\n    Returns:\n        norm_layer (nn.Module): The normalization layer.\n    \"\"\"\n    if norm_layer == \"layer\":\n        return nn.LayerNorm\n    elif norm_layer == \"rms\":\n        return RMSNorm\n    else:\n        raise NotImplementedError(f\"Norm layer {norm_layer} is not implemented\")\n",
        "hyimage/models/hunyuan/modules/norm_layers.py": "import torch\nimport torch.nn as nn\n\n\nclass RMSNorm(nn.Module):\n    def __init__(\n        self,\n        dim: int,\n        elementwise_affine=True,\n        eps: float = 1e-6,\n        device=None,\n        dtype=None,\n    ):\n        \"\"\"\n        Initialize the RMSNorm normalization layer.\n\n        Args:\n            dim (int): The dimension of the input tensor.\n            eps (float, optional): A small value added to the denominator for numerical stability. Default is 1e-6.\n\n        Attributes:\n            eps (float): A small value added to the denominator for numerical stability.\n            weight (nn.Parameter): Learnable scaling parameter.\n\n        \"\"\"\n        factory_kwargs = {\"device\": device, \"dtype\": dtype}\n        super().__init__()\n        self.eps = eps\n        if elementwise_affine:\n            self.weight = nn.Parameter(torch.ones(dim, **factory_kwargs))\n\n    def _norm(self, x):\n        \"\"\"\n        Apply the RMSNorm normalization to the input tensor.\n\n        Args:\n            x (torch.Tensor): The input tensor.\n\n        Returns:\n            torch.Tensor: The normalized tensor.\n\n        \"\"\"\n        return x * torch.rsqrt(x.pow(2).mean(-1, keepdim=True) + self.eps)\n\n    def reset_parameters(self):\n        if hasattr(self, \"weight\"):\n            self.weight.fill_(1)\n\n    def forward(self, x):\n        \"\"\"\n        Forward pass through the RMSNorm layer.\n\n        Args:\n            x (torch.Tensor): The input tensor.\n\n        Returns:\n            torch.Tensor: The output tensor after applying RMSNorm.\n\n        \"\"\"\n        output = self._norm(x.float()).type_as(x)\n        if hasattr(self, \"weight\"):\n            output = output * self.weight\n        return output\n\n\ndef get_norm_layer(norm_layer):\n    \"\"\"\n    Get the normalization layer.\n\n    Args:\n        norm_layer (str): The type of normalization layer.\n\n    Returns:\n        norm_layer (nn.Module): The normalization layer.\n    \"\"\"\n    if norm_layer == \"layer\":\n        return nn.LayerNorm\n    elif norm_layer == \"rms\":\n        return RMSNorm\n    else:\n        raise NotImplementedError(f\"Norm layer {norm_layer} is not implemented\")\n",
        "hyimage/models/hunyuan/modules/posemb_layers.py": "from typing import List, Tuple, Union\n\nimport torch\n\n\ndef _to_tuple(x, dim=2):\n    if isinstance(x, int):\n        return (x,) * dim\n    elif len(x) == dim:\n        return x\n    else:\n        raise ValueError(f\"Expected length {dim} or int, but got {x}\")\n\n\ndef get_meshgrid_nd(start, *args, dim=2):\n    \"\"\"\n    Get n-D meshgrid with start, stop and num.\n\n    Args:\n        start (int or tuple): If len(args) == 0, start is num; If len(args) == 1, start is start, args[0] is stop,\n            step is 1; If len(args) == 2, start is start, args[0] is stop, args[1] is num. For n-dim, start/stop/num\n            should be int or n-tuple. If n-tuple is provided, the meshgrid will be stacked following the dim order in\n            n-tuples.\n        *args: See above.\n        dim (int): Dimension of the meshgrid. Defaults to 2.\n\n    Returns:\n        grid (np.ndarray): [dim, ...]\n    \"\"\"\n    if len(args) == 0:\n        # start is grid_size\n        num = _to_tuple(start, dim=dim)\n        start = (0,) * dim\n        stop = num\n    elif len(args) == 1:\n        # start is start, args[0] is stop, step is 1\n        start = _to_tuple(start, dim=dim)\n        stop = _to_tuple(args[0], dim=dim)\n        num = [stop[i] - start[i] for i in range(dim)]\n    elif len(args) == 2:\n        # start is start, args[0] is stop, args[1] is num\n        start = _to_tuple(start, dim=dim)  # Left-Top       eg: 12,0\n        stop = _to_tuple(args[0], dim=dim)  # Right-Bottom   eg: 20,32\n        num = _to_tuple(args[1], dim=dim)  # Target Size    eg: 32,124\n    else:\n        raise ValueError(f\"len(args) should be 0, 1 or 2, but got {len(args)}\")\n\n    # PyTorch implement of np.linspace(start[i], stop[i], num[i], endpoint=False)\n    axis_grid = []\n    for i in range(dim):\n        a, b, n = start[i], stop[i], num[i]\n        g = torch.linspace(a, b, n + 1, dtype=torch.float32)[:n]\n        axis_grid.append(g)\n    grid = torch.meshgrid(*axis_grid, indexing=\"ij\")  # dim x [W, H, D]\n    grid = torch.stack(grid, dim=0)  # [dim, W, H, D]\n\n    return grid\n\n\n#################################################################################\n#                   Rotary Positional Embedding Functions                       #\n#################################################################################\n# https://github.com/meta-llama/llama/blob/be327c427cc5e89cc1d3ab3d3fec4484df771245/llama/model.py#L80\n\n\ndef reshape_for_broadcast(\n    freqs_cis: Union[torch.Tensor, Tuple[torch.Tensor]],\n    x: torch.Tensor,\n    head_first=False,\n):\n    \"\"\"\n    Reshape frequency tensor for broadcasting it with another tensor.\n\n    This function reshapes the frequency tensor to have the same shape as the target tensor 'x'\n    for the purpose of broadcasting the frequency tensor during element-wise operations.\n\n    Notes:\n        When using FlashMHAModified, head_first should be False.\n        When using Attention, head_first should be True.\n\n    Args:\n        freqs_cis (Union[torch.Tensor, Tuple[torch.Tensor]]): Frequency tensor to be reshaped.\n        x (torch.Tensor): Target tensor for broadcasting compatibility.\n        head_first (bool): head dimension first (except batch dim) or not.\n\n    Returns:\n        torch.Tensor: Reshaped frequency tensor.\n\n    Raises:\n        AssertionError: If the frequency tensor doesn't match the expected shape.\n        AssertionError: If the target tensor 'x' doesn't have the expected number of dimensions.\n    \"\"\"\n    ndim = x.ndim\n    assert 0 <= 1 < ndim\n\n    if isinstance(freqs_cis, tuple):\n        # freqs_cis: (cos, sin) in real space\n        if head_first:\n            assert freqs_cis[0].shape == (\n                x.shape[-2],\n                x.shape[-1],\n            ), f\"freqs_cis shape {freqs_cis[0].shape} does not match x shape {x.shape}\"\n            shape = [d if i == ndim - 2 or i == ndim - 1 else 1 for i, d in enumerate(x.shape)]\n        else:\n            assert freqs_cis[0].shape == (\n                x.shape[1],\n                x.shape[-1],\n            ), f\"freqs_cis shape {freqs_cis[0].shape} does not match x shape {x.shape}\"\n            shape = [d if i == 1 or i == ndim - 1 else 1 for i, d in enumerate(x.shape)]\n        return freqs_cis[0].view(*shape), freqs_cis[1].view(*shape)\n    else:\n        # freqs_cis: values in complex space\n        if head_first:\n            assert freqs_cis.shape == (\n                x.shape[-2],\n                x.shape[-1],\n            ), f\"freqs_cis shape {freqs_cis.shape} does not match x shape {x.shape}\"\n            shape = [d if i == ndim - 2 or i == ndim - 1 else 1 for i, d in enumerate(x.shape)]\n        else:\n            assert freqs_cis.shape == (\n                x.shape[1],\n                x.shape[-1],\n            ), f\"freqs_cis shape {freqs_cis.shape} does not match x shape {x.shape}\"\n            shape = [d if i == 1 or i == ndim - 1 else 1 for i, d in enumerate(x.shape)]\n        return freqs_cis.view(*shape)\n\n\ndef rotate_half(x):\n    x_real, x_imag = x.float().reshape(*x.shape[:-1], -1, 2).unbind(-1)  # [B, S, H, D//2]\n    return torch.stack([-x_imag, x_real], dim=-1).flatten(3)\n\n\ndef apply_rotary_emb(\n    xq: torch.Tensor,\n    xk: torch.Tensor,\n    freqs_cis: Union[torch.Tensor, Tuple[torch.Tensor, torch.Tensor]],\n    head_first: bool = False,\n) -> Tuple[torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Apply rotary embeddings to input tensors using the given frequency tensor.\n\n    This function applies rotary embeddings to the given query 'xq' and key 'xk' tensors using the provided\n    frequency tensor 'freqs_cis'. The input tensors are reshaped as complex numbers, and the frequency tensor\n    is reshaped for broadcasting compatibility. The resulting tensors contain rotary embeddings and are\n    returned as real tensors.\n\n    Args:\n        xq (torch.Tensor): Query tensor to apply rotary embeddings. [B, S, H, D]\n        xk (torch.Tensor): Key tensor to apply rotary embeddings.   [B, S, H, D]\n        freqs_cis (torch.Tensor or tuple): Precomputed frequency tensor for complex exponential.\n        head_first (bool): head dimension first (except batch dim) or not.\n\n    Returns:\n        Tuple[torch.Tensor, torch.Tensor]: Tuple of modified query tensor and key tensor with rotary embeddings.\n\n    \"\"\"\n    xk_out = None\n    if isinstance(freqs_cis, tuple):\n        cos, sin = reshape_for_broadcast(freqs_cis, xq, head_first)  # [S, D]\n        cos, sin = cos.to(xq.device), sin.to(xq.device)\n        # real * cos - imag * sin\n        # imag * cos + real * sin\n        xq_out = (xq.float() * cos + rotate_half(xq.float()) * sin).type_as(xq)\n        xk_out = (xk.float() * cos + rotate_half(xk.float()) * sin).type_as(xk)\n    else:\n        # view_as_complex will pack [..., D/2, 2](real) to [..., D/2](complex)\n        xq_ = torch.view_as_complex(xq.float().reshape(*xq.shape[:-1], -1, 2))  # [B, S, H, D//2]\n        freqs_cis = reshape_for_broadcast(freqs_cis, xq_, head_first).to(xq.device)  # [S, D//2] --> [1, S, 1, D//2]\n        # (real, imag) * (cos, sin) = (real * cos - imag * sin, imag * cos + real * sin)\n        # view_as_real will expand [..., D/2](complex) to [..., D/2, 2](real)\n        xq_out = torch.view_as_real(xq_ * freqs_cis).flatten(3).type_as(xq)\n        xk_ = torch.view_as_complex(xk.float().reshape(*xk.shape[:-1], -1, 2))  # [B, S, H, D//2]\n        xk_out = torch.view_as_real(xk_ * freqs_cis).flatten(3).type_as(xk)\n\n    return xq_out, xk_out\n\n\ndef get_nd_rotary_pos_embed(\n    rope_dim_list,\n    start,\n    *args,\n    theta=10000.0,\n    use_real=False,\n    theta_rescale_factor: Union[float, List[float]] = 1.0,\n    interpolation_factor: Union[float, List[float]] = 1.0,\n):\n    \"\"\"\n    This is a n-d version of precompute_freqs_cis, which is a RoPE for tokens with n-d structure.\n\n    Args:\n        rope_dim_list (list of int): Dimension of each rope. len(rope_dim_list) should equal to n.\n            sum(rope_dim_list) should equal to head_dim of attention layer.\n        start (int | tuple of int | list of int): If len(args) == 0, start is num; If len(args) == 1, start is start,\n            args[0] is stop, step is 1; If len(args) == 2, start is start, args[0] is stop, args[1] is num.\n        *args: See above.\n        theta (float): Scaling factor for frequency computation. Defaults to 10000.0.\n        use_real (bool): If True, return real part and imaginary part separately. Otherwise, return complex numbers.\n            Some libraries such as TensorRT does not support complex64 data type. So it is useful to provide a real\n            part and an imaginary part separately.\n        theta_rescale_factor (float): Rescale factor for theta. Defaults to 1.0.\n\n    Returns:\n        pos_embed (torch.Tensor): [HW, D/2]\n    \"\"\"\n\n    grid = get_meshgrid_nd(start, *args, dim=len(rope_dim_list))  # [3, W, H, D] / [2, W, H]\n\n    if isinstance(theta_rescale_factor, int) or isinstance(theta_rescale_factor, float):\n        theta_rescale_factor = [theta_rescale_factor] * len(rope_dim_list)\n    elif isinstance(theta_rescale_factor, list) and len(theta_rescale_factor) == 1:\n        theta_rescale_factor = [theta_rescale_factor[0]] * len(rope_dim_list)\n    assert len(theta_rescale_factor) == len(rope_dim_list), \"len(theta_rescale_factor) should equal to len(rope_dim_list)\"\n\n    if isinstance(interpolation_factor, int) or isinstance(interpolation_factor, float):\n        interpolation_factor = [interpolation_factor] * len(rope_dim_list)\n    elif isinstance(interpolation_factor, list) and len(interpolation_factor) == 1:\n        interpolation_factor = [interpolation_factor[0]] * len(rope_dim_list)\n    assert len(interpolation_factor) == len(rope_dim_list), \"len(interpolation_factor) should equal to len(rope_dim_list)\"\n\n    # use 1/ndim of dimensions to encode grid_axis\n    embs = []\n    for i in range(len(rope_dim_list)):\n        emb = get_1d_rotary_pos_embed(\n            rope_dim_list[i],\n            grid[i].reshape(-1),\n            theta,\n            use_real=use_real,\n            theta_rescale_factor=theta_rescale_factor[i],\n            interpolation_factor=interpolation_factor[i],\n        )  # 2 x [WHD, rope_dim_list[i]]\n        embs.append(emb)\n\n    if use_real:\n        cos = torch.cat([emb[0] for emb in embs], dim=1)  # (WHD, D/2)\n        sin = torch.cat([emb[1] for emb in embs], dim=1)  # (WHD, D/2)\n        return cos, sin\n    else:\n        emb = torch.cat(embs, dim=1)  # (WHD, D/2)\n        return emb\n\n\ndef get_1d_rotary_pos_embed(\n    dim: int,\n    pos: Union[torch.FloatTensor, int],\n    theta: float = 10000.0,\n    use_real: bool = False,\n    theta_rescale_factor: float = 1.0,\n    interpolation_factor: float = 1.0,\n) -> Union[torch.Tensor, Tuple[torch.Tensor, torch.Tensor]]:\n    \"\"\"\n    Precompute the frequency tensor for complex exponential (cis) with given dimensions.\n    (Note: `cis` means `cos + i * sin`, where i is the imaginary unit.)\n\n    This function calculates a frequency tensor with complex exponential using the given dimension 'dim'\n    and the end index 'end'. The 'theta' parameter scales the frequencies.\n    The returned tensor contains complex values in complex64 data type.\n\n    Args:\n        dim (int): Dimension of the frequency tensor.\n        pos (int or torch.FloatTensor): Position indices for the frequency tensor. [S] or scalar\n        theta (float, optional): Scaling factor for frequency computation. Defaults to 10000.0.\n        use_real (bool, optional): If True, return real part and imaginary part separately.\n                                   Otherwise, return complex numbers.\n        theta_rescale_factor (float, optional): Rescale factor for theta. Defaults to 1.0.\n\n    Returns:\n        freqs_cis: Precomputed frequency tensor with complex exponential. [S, D/2]\n        freqs_cos, freqs_sin: Precomputed frequency tensor with real and imaginary parts separately. [S, D]\n    \"\"\"\n    if isinstance(pos, int):\n        pos = torch.arange(pos).float()\n\n    # proposed by reddit user bloc97, to rescale rotary embeddings to longer sequence length without fine-tuning\n    # has some connection to NTK literature\n    if theta_rescale_factor != 1.0:\n        theta *= theta_rescale_factor ** (dim / (dim - 2))\n\n    freqs = 1.0 / (theta ** (torch.arange(0, dim, 2)[: (dim // 2)].float() / dim))  # [D/2]\n    freqs = torch.outer(pos * interpolation_factor, freqs)  # [S, D/2]\n    if use_real:\n        freqs_cos = freqs.cos().repeat_interleave(2, dim=1)  # [S, D]\n        freqs_sin = freqs.sin().repeat_interleave(2, dim=1)  # [S, D]\n        return freqs_cos, freqs_sin\n    else:\n        freqs_cis = torch.polar(torch.ones_like(freqs), freqs)  # complex64     # [S, D/2]\n        return freqs_cis\n",
        "hyimage/models/hunyuan/modules/token_refiner.py": "from typing import Optional\n\nimport torch\nimport torch.nn as nn\nfrom einops import rearrange\n\nfrom hyimage.models.hunyuan.modules.flash_attn_no_pad import flash_attn_no_pad\nfrom .activation_layers import get_activation_layer\nfrom .embed_layers import TextProjection, TimestepEmbedder\nfrom .mlp_layers import MLP\nfrom .modulate_layers import apply_gate\nfrom .norm_layers import get_norm_layer\n\n\n@torch.compiler.disable\ndef attention(\n    q: torch.Tensor,\n    k: torch.Tensor,\n    v: torch.Tensor,\n    drop_rate: float = 0.0,\n    attn_mask: Optional[torch.Tensor] = None,\n    causal: bool = False,\n) -> torch.Tensor:\n    \"\"\"\n    Compute attention using flash_attn_no_pad.\n\n    Args:\n        q: Query tensor of shape [B, L, H, D]\n        k: Key tensor of shape [B, L, H, D]\n        v: Value tensor of shape [B, L, H, D]\n        drop_rate: Dropout rate for attention weights.\n        attn_mask: Optional attention mask of shape [B, L].\n        causal: Whether to apply causal masking.\n\n    Returns:\n        Output tensor after attention of shape [B, L, H*D]\n    \"\"\"\n    qkv = torch.stack([q, k, v], dim=2)\n    if attn_mask is not None and attn_mask.dtype != torch.bool:\n        attn_mask = attn_mask.bool()\n    x = flash_attn_no_pad(qkv, attn_mask, causal=causal, dropout_p=drop_rate, softmax_scale=None)\n    b, s, a, d = x.shape\n    out = x.reshape(b, s, -1)\n    return out\n\n\nclass IndividualTokenRefinerBlock(nn.Module):\n    \"\"\"\n    A single block for token refinement with self-attention and MLP.\n\n    Args:\n        hidden_size: Hidden dimension size.\n        heads_num: Number of attention heads.\n        mlp_width_ratio: Expansion ratio for MLP hidden size.\n        mlp_drop_rate: Dropout rate for MLP.\n        act_type: Activation function type.\n        qk_norm: Whether to use QK normalization.\n        qk_norm_type: Type of QK normalization.\n        qkv_bias: Whether to use bias in QKV projections.\n        dtype: Optional torch dtype.\n        device: Optional torch device.\n    \"\"\"\n\n    def __init__(\n        self,\n        hidden_size: int,\n        heads_num: int,\n        mlp_width_ratio: float = 4.0,\n        mlp_drop_rate: float = 0.0,\n        act_type: str = \"silu\",\n        qk_norm: bool = False,\n        qk_norm_type: str = \"layer\",\n        qkv_bias: bool = True,\n        dtype: Optional[torch.dtype] = None,\n        device: Optional[torch.device] = None,\n    ):\n        factory_kwargs = {\"device\": device, \"dtype\": dtype}\n        super().__init__()\n        self.heads_num = heads_num\n        head_dim = hidden_size // heads_num\n        mlp_hidden_dim = int(hidden_size * mlp_width_ratio)\n\n        self.norm1 = nn.LayerNorm(hidden_size, elementwise_affine=True, eps=1e-6, **factory_kwargs)\n        self.self_attn_qkv = nn.Linear(hidden_size, hidden_size * 3, bias=qkv_bias, **factory_kwargs)\n        qk_norm_layer = get_norm_layer(qk_norm_type)\n        self.self_attn_q_norm = (\n            qk_norm_layer(head_dim, elementwise_affine=True, eps=1e-6, **factory_kwargs) if qk_norm else nn.Identity()\n        )\n        self.self_attn_k_norm = (\n            qk_norm_layer(head_dim, elementwise_affine=True, eps=1e-6, **factory_kwargs) if qk_norm else nn.Identity()\n        )\n        self.self_attn_proj = nn.Linear(hidden_size, hidden_size, bias=qkv_bias, **factory_kwargs)\n\n        self.norm2 = nn.LayerNorm(hidden_size, elementwise_affine=True, eps=1e-6, **factory_kwargs)\n        act_layer = get_activation_layer(act_type)\n        self.mlp = MLP(\n            in_channels=hidden_size,\n            hidden_channels=mlp_hidden_dim,\n            act_layer=act_layer,\n            drop=mlp_drop_rate,\n            **factory_kwargs,\n        )\n\n        self.adaLN_modulation = nn.Sequential(\n            act_layer(),\n            nn.Linear(hidden_size, 2 * hidden_size, bias=True, **factory_kwargs),\n        )\n        # Zero-initialize the modulation\n        nn.init.zeros_(self.adaLN_modulation[1].weight)\n        nn.init.zeros_(self.adaLN_modulation[1].bias)\n\n    def forward(\n        self,\n        x: torch.Tensor,\n        c: torch.Tensor,  # timestep_aware_representations + context_aware_representations\n        attn_mask: Optional[torch.Tensor] = None,\n    ) -> torch.Tensor:\n        \"\"\"\n        Forward pass for IndividualTokenRefinerBlock.\n\n        Args:\n            x: Input tensor of shape [B, L, C].\n            c: Conditioning tensor of shape [B, C].\n            attn_mask: Optional attention mask of shape [B, L].\n\n        Returns:\n            Refined tensor of shape [B, L, C].\n        \"\"\"\n        gate_msa, gate_mlp = self.adaLN_modulation(c).chunk(2, dim=1)\n        norm_x = self.norm1(x)\n        qkv = self.self_attn_qkv(norm_x)\n        q, k, v = rearrange(qkv, \"B L (K H D) -> K B L H D\", K=3, H=self.heads_num)\n        q = self.self_attn_q_norm(q).to(v)\n        k = self.self_attn_k_norm(k).to(v)\n        attn = attention(q, k, v, attn_mask=attn_mask)\n        x = x + apply_gate(self.self_attn_proj(attn), gate_msa)\n        x = x + apply_gate(self.mlp(self.norm2(x)), gate_mlp)\n        return x\n\n\nclass IndividualTokenRefiner(nn.Module):\n    \"\"\"\n    Stacks multiple IndividualTokenRefinerBlock modules.\n\n    Args:\n        hidden_size: Hidden dimension size.\n        heads_num: Number of attention heads.\n        depth: Number of blocks.\n        mlp_width_ratio: Expansion ratio for MLP hidden size.\n        mlp_drop_rate: Dropout rate for MLP.\n        act_type: Activation function type.\n        qk_norm: Whether to use QK normalization.\n        qk_norm_type: Type of QK normalization.\n        qkv_bias: Whether to use bias in QKV projections.\n        dtype: Optional torch dtype.\n        device: Optional torch device.\n    \"\"\"\n\n    def __init__(\n        self,\n        hidden_size: int,\n        heads_num: int,\n        depth: int,\n        mlp_width_ratio: float = 4.0,\n        mlp_drop_rate: float = 0.0,\n        act_type: str = \"silu\",\n        qk_norm: bool = False,\n        qk_norm_type: str = \"layer\",\n        qkv_bias: bool = True,\n        dtype: Optional[torch.dtype] = None,\n        device: Optional[torch.device] = None,\n    ):\n        factory_kwargs = {\"device\": device, \"dtype\": dtype}\n        super().__init__()\n        self.blocks = nn.ModuleList(\n            [\n                IndividualTokenRefinerBlock(\n                    hidden_size=hidden_size,\n                    heads_num=heads_num,\n                    mlp_width_ratio=mlp_width_ratio,\n                    mlp_drop_rate=mlp_drop_rate,\n                    act_type=act_type,\n                    qk_norm=qk_norm,\n                    qk_norm_type=qk_norm_type,\n                    qkv_bias=qkv_bias,\n                    **factory_kwargs,\n                )\n                for _ in range(depth)\n            ]\n        )\n\n    def forward(\n        self,\n        x: torch.Tensor,\n        c: torch.LongTensor,\n        mask: Optional[torch.Tensor] = None,\n    ) -> torch.Tensor:\n        \"\"\"\n        Forward pass for IndividualTokenRefiner.\n\n        Args:\n            x: Input tensor of shape [B, L, C].\n            c: Conditioning tensor of shape [B, C].\n            mask: Optional mask tensor of shape [B, L].\n\n        Returns:\n            Refined tensor of shape [B, L, C].\n        \"\"\"\n        if mask is not None:\n            mask = mask.clone().bool()\n            mask[:, 0] = True  # Prevent attention weights from becoming NaN\n        for block in self.blocks:\n            x = block(x, c, mask)\n        return x\n\n\nclass SingleTokenRefiner(nn.Module):\n    \"\"\"\n    Single token refiner block for LLM text embedding refinement.\n\n    Args:\n        in_channels: Input feature dimension.\n        hidden_size: Hidden dimension size.\n        heads_num: Number of attention heads.\n        depth: Number of blocks.\n        mlp_width_ratio: Expansion ratio for MLP hidden size.\n        mlp_drop_rate: Dropout rate for MLP.\n        act_type: Activation function type.\n        qk_norm: Whether to use QK normalization.\n        qk_norm_type: Type of QK normalization.\n        qkv_bias: Whether to use bias in QKV projections.\n        dtype: Optional torch dtype.\n        device: Optional torch device.\n    \"\"\"\n\n    def __init__(\n        self,\n        in_channels: int,\n        hidden_size: int,\n        heads_num: int,\n        depth: int,\n        mlp_width_ratio: float = 4.0,\n        mlp_drop_rate: float = 0.0,\n        act_type: str = \"silu\",\n        qk_norm: bool = False,\n        qk_norm_type: str = \"layer\",\n        qkv_bias: bool = True,\n        dtype: Optional[torch.dtype] = None,\n        device: Optional[torch.device] = None,\n    ):\n        factory_kwargs = {\"device\": device, \"dtype\": dtype}\n        super().__init__()\n        self.input_embedder = nn.Linear(in_channels, hidden_size, bias=True, **factory_kwargs)\n        act_layer = get_activation_layer(act_type)\n        self.t_embedder = TimestepEmbedder(hidden_size, act_layer, **factory_kwargs)\n        self.c_embedder = TextProjection(in_channels, hidden_size, act_layer, **factory_kwargs)\n        self.individual_token_refiner = IndividualTokenRefiner(\n            hidden_size=hidden_size,\n            heads_num=heads_num,\n            depth=depth,\n            mlp_width_ratio=mlp_width_ratio,\n            mlp_drop_rate=mlp_drop_rate,\n            act_type=act_type,\n            qk_norm=qk_norm,\n            qk_norm_type=qk_norm_type,\n            qkv_bias=qkv_bias,\n            **factory_kwargs,\n        )\n\n    def forward(\n        self,\n        x: torch.Tensor,\n        t: torch.LongTensor,\n        mask: Optional[torch.LongTensor] = None,\n    ) -> torch.Tensor:\n        \"\"\"\n        Forward pass for SingleTokenRefiner.\n\n        Args:\n            x: Input tensor of shape [B, L, in_channels].\n            t: Timestep tensor of shape [B].\n            mask: Optional mask tensor of shape [B, L].\n\n        Returns:\n            Refined tensor of shape [B, L, hidden_size].\n        \"\"\"\n        timestep_aware_representations = self.t_embedder(t)\n        if mask is None:\n            context_aware_representations = x.mean(dim=1)\n        else:\n            mask_float = mask.unsqueeze(-1)  # [B, L, 1]\n            context_aware_representations = (x * mask_float).sum(dim=1) / mask_float.sum(dim=1)\n        context_aware_representations = self.c_embedder(context_aware_representations)\n        c = timestep_aware_representations + context_aware_representations\n        x = self.input_embedder(x)\n        x = self.individual_token_refiner(x, c, mask)\n        return x\n",
        "hyimage/models/hunyuan/utils/__init__.py": "",
        "hyimage/models/hunyuan/utils/helpers.py": "import collections.abc\nfrom itertools import repeat\n\ndef _ntuple(n):\n    \"\"\"\n    Returns a function that converts input to a tuple of length n.\n    If input is an iterable (except str), it is converted to a tuple.\n    If the tuple has length 1, it is repeated n times.\n    Otherwise, the input is repeated n times to form the tuple.\n    \"\"\"\n    def parse(x):\n        if isinstance(x, collections.abc.Iterable) and not isinstance(x, str):\n            x = tuple(x)\n            if len(x) == 1:\n                x = tuple(repeat(x[0], n))\n            return x\n        return tuple(repeat(x, n))\n    return parse\n\nto_1tuple = _ntuple(1)\nto_2tuple = _ntuple(2)\nto_3tuple = _ntuple(3)\nto_4tuple = _ntuple(4)\n",
        "hyimage/models/model_zoo.py": "import os\nimport copy\n\nfrom hyimage.common.config import LazyCall as L\nfrom hyimage.models.hunyuan.configs.hunyuanimage_config import (\n    hunyuanimage_v2_1_cfg,\n    hunyuanimage_v2_1_distilled_cfg,\n    hunyuanimage_refiner_cfg,\n)\nfrom hyimage.models.vae import load_refiner_vae, load_vae\nfrom hyimage.common.config.base_config import (\n    DiTConfig,\n    RepromptConfig,\n    TextEncoderConfig,\n    VAEConfig,\n)\nfrom hyimage.models.text_encoder import TextEncoder\n\nHUNYUANIMAGE_V2_1_MODEL_ROOT = os.environ.get(\"HUNYUANIMAGE_V2_1_MODEL_ROOT\", \"./ckpts\")\n\n# =============================================================================\n# MODEL CONFIGURATIONS\n# =============================================================================\n\n# =============================================================================\n# V2.1 MODELS\n# =============================================================================\n\ndef HUNYUANIMAGE_V2_1_TEXT_ENCODER(**kwargs):\n    return TextEncoderConfig(\n        model=L(TextEncoder)(\n            text_encoder_type=\"llm\",\n            max_length=1000,\n            text_encoder_precision='fp16',\n            tokenizer_type=\"llm\",\n            text_encoder_path=None,\n            prompt_template=None,\n            prompt_template_video=None,\n            hidden_state_skip_layer=2,\n            apply_final_norm=False,\n            reproduce=False,\n            logger=None,\n            device=None,\n        ),\n        prompt_template=\"dit-llm-encode-v2\",\n        load_from=f\"{HUNYUANIMAGE_V2_1_MODEL_ROOT}/text_encoder\",\n        text_len=1000,\n    )\n\n\ndef HUNYUANIMAGE_V2_1_VAE_32x(**kwargs):\n    return VAEConfig(\n        model=L(load_vae)(\n            vae_path=None,\n            device=\"cuda\",\n        ),\n        load_from=f\"{HUNYUANIMAGE_V2_1_MODEL_ROOT}/vae/vae_2_1\",\n        cpu_offload=False,\n    )\n\n\ndef HUNYUANIMAGE_V2_1_DIT(**kwargs):\n    return DiTConfig(\n        model=copy.deepcopy(hunyuanimage_v2_1_cfg),\n        use_lora=False,\n        use_cpu_offload=False,\n        gradient_checkpointing=True,\n        load_from=f\"{HUNYUANIMAGE_V2_1_MODEL_ROOT}/dit/hunyuanimage2.1.safetensors\",\n        fp8_scale=f\"{HUNYUANIMAGE_V2_1_MODEL_ROOT}/dit/hunyuanimage2.1_fp8_scale.safetensors\",\n        fp8_load_from=f\"{HUNYUANIMAGE_V2_1_MODEL_ROOT}/dit/hunyuanimage2.1_fp8.safetensors\",\n        use_compile=False,\n    )\n\n\ndef HUNYUANIMAGE_V2_1_DIT_CFG_DISTILL(**kwargs):\n    return DiTConfig(\n        model=copy.deepcopy(hunyuanimage_v2_1_distilled_cfg),\n        use_lora=False,\n        use_cpu_offload=False,\n        gradient_checkpointing=True,\n        load_from=f\"{HUNYUANIMAGE_V2_1_MODEL_ROOT}/dit/hunyuanimage2.1-distilled.safetensors\",\n        fp8_scale=f\"{HUNYUANIMAGE_V2_1_MODEL_ROOT}/dit/hunyuanimage2.1-distilled_fp8_scale.safetensors\",\n        fp8_load_from=f\"{HUNYUANIMAGE_V2_1_MODEL_ROOT}/dit/hunyuanimage2.1-distilled_fp8.safetensors\",\n        use_compile=False,\n    )\n\n\n# =============================================================================\n# REFINER MODELS\n# =============================================================================\n\ndef HUNYUANIMAGE_REFINER_DIT(**kwargs):\n    return DiTConfig(\n        model=copy.deepcopy(hunyuanimage_refiner_cfg),\n        use_lora=False,\n        use_cpu_offload=False,\n        gradient_checkpointing=True,\n        load_from=f\"{HUNYUANIMAGE_V2_1_MODEL_ROOT}/dit/hunyuanimage-refiner.safetensors\",\n        fp8_scale=f\"{HUNYUANIMAGE_V2_1_MODEL_ROOT}/dit/hunyuanimage-refiner_fp8_scale.safetensors\",\n        fp8_load_from=f\"{HUNYUANIMAGE_V2_1_MODEL_ROOT}/dit/hunyuanimage-refiner_fp8.safetensors\",\n        use_compile=False,\n    )\n\n\ndef HUNYUANIMAGE_REFINER_VAE_16x(**kwargs):\n    return VAEConfig(\n        model=L(load_refiner_vae)(\n            vae_path=None,\n            device=\"cuda\",\n        ),\n        load_from=f\"{HUNYUANIMAGE_V2_1_MODEL_ROOT}/vae/vae_refiner\",\n        cpu_offload=False,\n    )\n\n\ndef HUNYUANIMAGE_REFINER_TEXT_ENCODER(**kwargs):\n    return TextEncoderConfig(\n        model=L(TextEncoder)(\n            text_encoder_type=\"llm\",\n            max_length=1000,\n            text_encoder_precision='fp16',\n            tokenizer_type=\"llm\",\n            text_encoder_path=None,\n            prompt_template=None,\n            prompt_template_video=None,\n            hidden_state_skip_layer=2,\n            apply_final_norm=False,\n            reproduce=False,\n            logger=None,\n            device=None,\n        ),\n        prompt_template=\"dit-llm-encode\",\n        load_from=f\"{HUNYUANIMAGE_V2_1_MODEL_ROOT}/text_encoder\",\n        text_len=256,\n    )\n\n\n# =============================================================================\n# SPECIALIZED MODELS\n# =============================================================================\n\ndef HUNYUANIMAGE_REPROMPT(**kwargs):\n    from hyimage.models.reprompt import RePrompt\n    \n    return RepromptConfig(\n        model=L(RePrompt)(\n            models_root_path=None,\n            device_map=\"auto\",\n        ),\n        load_from=f\"{HUNYUANIMAGE_V2_1_MODEL_ROOT}/reprompt\",\n    )",
        "hyimage/models/reprompt/__init__.py": "from .reprompt import RePrompt",
        "hyimage/models/reprompt/reprompt.py": "import re\nimport loguru\nimport torch\nfrom transformers import AutoModelForCausalLM, AutoTokenizer\nfrom accelerate import cpu_offload_with_hook\n\n\"\"\"\nEnglish translation of the System prompt:\n----------------------------------------\nYou are an expert in writing image generation prompts. Please rewrite the user's prompt according to the following requirements:\n1. The main subject/action/quantity/style/layout/relationship/attribute/text in the rewritten prompt must be consistent with the original intention;\n2. The rewritten prompt should follow the \"overall-detail-conclusion\" structure, ensuring the clarity of information hierarchy;\n3. The rewritten prompt should be objective and neutral, avoiding subjective judgment and emotional evaluation;\n4. The rewritten prompt should be from the main to the secondary, always describing the most important elements first, and then the secondary and background elements;\n5. The rewritten prompt should be logically clear, strictly follow the spatial logic or main-secondary logic, allowing the reader to reconstruct the image in the brain;\n6. The rewritten prompt should end with a summary sentence, summarizing the overall style or type of the image.\n\"\"\"\n\nSYSTEM_PROMPT = (\n    \"你是一位图像生成提示词撰写专家，请根据用户输入的提示词，改写生成新的提示词，改写后的提示词要求：\"\n    \"1 改写后提示词包含的主体/动作/数量/风格/布局/关系/属性/文字等 必须和改写前的意图一致； \"\n    \"2 在宏观上遵循“总-分-总”的结构，确保信息的层次清晰；\"\n    \"3 客观中立，避免主观臆断和情感评价；\"\n    \"4 由主到次，始终先描述最重要的元素，再描述次要和背景元素；\"\n    \"5 逻辑清晰，严格遵循空间逻辑或主次逻辑，使读者能在大脑中重建画面；\"\n    \"6 结尾点题，必须用一句话总结图像的整体风格或类型。\"\n)\n\n\ndef replace_single_quotes(text):\n    \"\"\"\n    Replace single quotes within words with double quotes, and convert\n    curly single quotes to curly double quotes for consistency.\n    \"\"\"\n    pattern = r\"\\B'([^']*)'\\B\"\n    replaced_text = re.sub(pattern, r'\"\\1\"', text)\n    replaced_text = replaced_text.replace(\"’\", \"”\")\n    replaced_text = replaced_text.replace(\"‘\", \"“\")\n    return replaced_text\n\n\nclass RePrompt:\n\n    def __init__(self, models_root_path, device_map=\"auto\", enable_offloading=True):\n        \"\"\"\n        Initialize the RePrompt class with model and processor.\n\n        Args:\n            models_root_path (str): Path to the pretrained model.\n            device_map (str): Device mapping for model loading.\n        \"\"\"\n        if enable_offloading:\n            device_map = None\n        self.model = AutoModelForCausalLM.from_pretrained(models_root_path, device_map=device_map, trust_remote_code=True)\n        self.tokenizer = AutoTokenizer.from_pretrained(models_root_path, trust_remote_code=True)\n        self.enable_offloading = enable_offloading\n\n        if enable_offloading:\n            _, self.offload_hook = cpu_offload_with_hook(self.model, execution_device=torch.device('cuda'))\n        self.device_map = device_map\n        self.original_device_map = getattr(self.model, 'hf_device_map', None)\n\n    @torch.inference_mode()\n    def predict(\n        self,\n        prompt_cot,\n        sys_prompt=SYSTEM_PROMPT,\n    ):\n        \"\"\"\n        Generate a rewritten prompt using the model.\n\n        Args:\n            prompt_cot (str): The original prompt to be rewritten.\n            sys_prompt (str): System prompt to guide the rewriting.\n            temperature (float): Sampling temperature.\n            device (str): Device for inference.\n\n        Returns:\n            str: The rewritten prompt, or the original if generation fails.\n        \"\"\"\n        org_prompt_cot = prompt_cot\n        try:\n            messages = [\n                {\"role\": \"system\", \"content\": sys_prompt},\n                {\"role\": \"user\", \"content\": org_prompt_cot},\n            ]\n            tokenized_chat = self.tokenizer.apply_chat_template(\n                messages, tokenize=True, add_generation_prompt=True, return_tensors=\"pt\", enable_thinking=False  # Toggle thinking mode (default: True)\n            )\n            if self.model.device != torch.device('meta'):\n                tokenized_chat = tokenized_chat.to(self.model.device)\n            outputs = self.model.generate(tokenized_chat, max_new_tokens=2048)\n            if self.enable_offloading:\n                self.offload_hook.offload()\n            output_res = self.tokenizer.decode(outputs[0])\n            answer_pattern = r'<answer>(.*?)</answer>'\n            answer_matches = re.findall(answer_pattern, output_res, re.DOTALL)\n            prompt_cot = [match.strip() for match in answer_matches][0]\n            prompt_cot = replace_single_quotes(prompt_cot)\n        except Exception as e:\n            prompt_cot = org_prompt_cot\n            loguru.logger.error(f\"✗ Re-prompting failed, fall back to generate prompt. Cause: {e}\")\n\n        return prompt_cot\n\n    def to(self, device, *args, **kwargs):\n        self.model = self.model.to(device, *args, **kwargs)\n        return self",
        "hyimage/models/text_encoder/__init__.py": "from dataclasses import dataclass\nfrom typing import Optional, Tuple\nfrom copy import deepcopy\n\nimport torch\nimport torch.nn as nn\nfrom transformers import AutoModelForVision2Seq, AutoTokenizer\n\nfrom transformers.utils import ModelOutput\n\n\ndef use_default(value, default):\n    \"\"\"Utility: return value if not None, else default.\"\"\"\n    return value if value is not None else default\n\n# Prompt templates for different models and tasks\nPROMPT_TEMPLATE_ENCODE = (\n    \"<|start_header_id|>system<|end_header_id|>\\n\\nDescribe the image by detailing the color, shape, size, texture, \"\n    \"quantity, text, spatial relationships of the objects and background:<|eot_id|>\"\n    \"<|start_header_id|>user<|end_header_id|>\\n\\n{}<|eot_id|>\"\n)\nPROMPT_TEMPLATE_ENCODE_V2 = (\n    \"<|im_start|>system\\nDescribe the image by detailing the color, shape, size, texture, \"\n    \"quantity, text, spatial relationships of the objects and background:<|im_end|>\\n\"\n    \"<|im_start|>user\\n{}<|im_end|>\"\n)\n\nNEGATIVE_PROMPT = (\n    \"Aerial view, aerial view, overexposed, low quality, deformation, a poor composition, \"\n    \"bad hands, bad teeth, bad eyes, bad limbs, distortion\"\n)\n\nPROMPT_TEMPLATE = {\n    \"dit-llm-encode\": {\n        \"template\": PROMPT_TEMPLATE_ENCODE,\n        \"crop_start\": 36,\n    },\n    \"dit-llm-encode-v2\": {\n        \"template\": PROMPT_TEMPLATE_ENCODE_V2,\n        \"crop_start\": 34,\n    },\n}\n\ndef load_text_encoder(\n    text_encoder_type,\n    text_encoder_precision=None,\n    text_encoder_path=None,\n    infer_mode=\"encoder\",\n    logger=None,\n    device=None\n):\n    \"\"\"\n    Load a text encoder model from pretrained weights.\n\n    Args:\n        text_encoder_type (str): Type of text encoder.\n        text_encoder_precision (str, optional): Precision for model weights.\n        text_encoder_path (str, optional): Path to pretrained weights.\n        infer_mode (str): \"encoder\" or \"decoder\".\n        logger (logging.Logger, optional): Logger for info.\n        device (torch.device, optional): Device to move model to.\n\n    Returns:\n        model (nn.Module): Loaded text encoder.\n        model_path (str): Path to model.\n    \"\"\"\n    if logger is not None:\n        logger.info(f\"Loading text encoder model ({text_encoder_type}) from: {text_encoder_path}\")\n\n    if text_encoder_type == 'llm':\n        text_encoder = AutoModelForVision2Seq.from_pretrained(\n            text_encoder_path,\n            torch_dtype=\"auto\"\n        )\n    else:\n        raise ValueError(f\"Unsupported text encoder type: {text_encoder_type}\")\n\n    text_encoder.requires_grad_(False)\n\n    if logger is not None:\n        logger.info(f\"Text encoder to dtype: {text_encoder.dtype}\")\n\n    if device is not None:\n        text_encoder = text_encoder.to(device)\n\n    return text_encoder, text_encoder_path\n\ndef load_tokenizer(\n    tokenizer_type,\n    tokenizer_path=None,\n    padding_side=\"right\",\n    logger=None\n):\n    \"\"\"\n    Load a tokenizer from pretrained weights.\n\n    Args:\n        tokenizer_type (str): Type of tokenizer.\n        tokenizer_path (str, optional): Path to pretrained tokenizer.\n        padding_side (str): Padding side for tokenizer.\n        logger (logging.Logger, optional): Logger for info.\n\n    Returns:\n        tokenizer: Loaded tokenizer.\n        tokenizer_path (str): Path to tokenizer.\n    \"\"\"\n    if logger is not None:\n        logger.info(f\"Loading tokenizer ({tokenizer_type}) from: {tokenizer_path}\")\n\n    if tokenizer_type == \"llm\":\n        tokenizer = AutoTokenizer.from_pretrained(\n            tokenizer_path, use_fast=False, padding_side=padding_side, trust_remote_code=True)\n    else:\n        raise ValueError(f\"Unsupported tokenizer type: {tokenizer_type}\")\n\n    return tokenizer, tokenizer_path\n\n@dataclass\nclass TextEncoderModelOutput(ModelOutput):\n    \"\"\"\n    Output for text encoder models.\n\n    Args:\n        hidden_state (torch.FloatTensor): Output hidden states of the last layer.\n        attention_mask (torch.LongTensor, optional): Attention mask for valid tokens.\n        hidden_states_list (tuple(torch.FloatTensor), optional): All hidden states if requested.\n        text_outputs (list, optional): Decoded texts if requested.\n    \"\"\"\n    hidden_state: torch.FloatTensor = None\n    attention_mask: Optional[torch.LongTensor] = None\n    hidden_states_list: Optional[Tuple[torch.FloatTensor, ...]] = None\n    text_outputs: Optional[list] = None\n\nclass TextEncoder(nn.Module):\n    \"\"\"\n    TextEncoder wraps a pretrained text encoder and tokenizer for flexible text encoding.\n\n    Args:\n        text_encoder_type (str): Type of text encoder.\n        max_length (int): Maximum sequence length.\n        text_encoder_precision (str, optional): Precision for model weights.\n        text_encoder_path (str, optional): Path to pretrained weights.\n        tokenizer_type (str, optional): Type of tokenizer.\n        tokenizer_path (str, optional): Path to pretrained tokenizer.\n        output_key (str, optional): Output key for model output.\n        use_attention_mask (bool): Whether to use attention mask.\n        infer_mode (str): \"encoder\" or \"decoder\".\n        input_max_length (int, optional): Max input length.\n        prompt_template (dict, optional): Prompt template for image.\n        prompt_template_video (dict, optional): Prompt template for video.\n        hidden_state_skip_layer (int, optional): Skip layers from last for hidden state.\n        apply_final_norm (bool): Whether to apply final layer norm.\n        reproduce (bool): Deterministic output if True.\n        logger (logging.Logger, optional): Logger for info.\n        device (torch.device, optional): Device to move model to.\n    \"\"\"\n    def __init__(\n        self,\n        text_encoder_type: str,\n        max_length: int,\n        text_encoder_precision: Optional[str] = None,\n        text_encoder_path: Optional[str] = None,\n        tokenizer_type: Optional[str] = None,\n        tokenizer_path: Optional[str] = None,\n        output_key: Optional[str] = None,\n        use_attention_mask: bool = True,\n        infer_mode: str = \"encoder\",\n        input_max_length: Optional[int] = None,\n        prompt_template: Optional[dict] = None,\n        prompt_template_video: Optional[dict] = None,\n        hidden_state_skip_layer: Optional[int] = None,\n        apply_final_norm: bool = False,\n        reproduce: bool = False,\n        logger=None,\n        device=None,\n    ):\n        super().__init__()\n        self.text_encoder_type = text_encoder_type\n        self.max_length = max_length\n        self.precision = text_encoder_precision\n        self.model_path = text_encoder_path\n        self.tokenizer_type = tokenizer_type if tokenizer_type is not None else text_encoder_type\n        self.tokenizer_path = tokenizer_path if tokenizer_path is not None else text_encoder_path\n        self.use_attention_mask = use_attention_mask\n        self.input_max_length = input_max_length if input_max_length is not None else max_length\n        self.prompt_template = dict(prompt_template) if prompt_template is not None else None\n        self.prompt_template_video = dict(prompt_template_video) if prompt_template_video is not None else None\n        self.hidden_state_skip_layer = hidden_state_skip_layer\n        self.apply_final_norm = apply_final_norm\n        self.infer_mode = infer_mode\n        self.reproduce = reproduce\n        self.logger = logger\n\n        self.use_template = self.prompt_template is not None\n        if self.use_template:\n            assert isinstance(self.prompt_template, dict) and \"template\" in self.prompt_template, (\n                f\"`prompt_template` must be a dictionary with a key 'template', got {self.prompt_template}\"\n            )\n            if self.prompt_template_video is not None:\n                assert isinstance(self.prompt_template_video, dict) and \"template\" in self.prompt_template_video, (\n                    f\"`prompt_template_video` must be a dictionary with a key 'template', got {self.prompt_template_video}\"\n                )\n            assert '{}' in str(self.prompt_template[\"template\"]), (\n                \"`prompt_template['template']` must contain a placeholder `{}` for the input text, \"\n                f\"got {self.prompt_template['template']}\"\n            )\n\n        if infer_mode == \"decoder\":\n            assert text_encoder_type in [\"llava-llama-3-8b\"], (\n                f\"Unsupported text encoder type for infer_mode='decoder': {text_encoder_type}\"\n            )\n            assert self.prompt_template is not None and hidden_state_skip_layer is not None, (\n                f\"`prompt_template` and `hidden_state_skip_layer` must be provided for infer_mode='decoder', \"\n                f\"got prompt_template={self.prompt_template}, hidden_state_skip_layer={self.hidden_state_skip_layer}\"\n            )\n\n        if \"t5\" in text_encoder_type:\n            self.output_key = output_key or \"last_hidden_state\"\n        elif \"clip\" in text_encoder_type:\n            self.output_key = output_key or \"pooler_output\"\n        elif any(x in text_encoder_type for x in [\"llm\"]):\n            self.output_key = output_key or (\"last_hidden_state\" if infer_mode == \"encoder\" else None)\n        else:\n            raise ValueError(f\"Unsupported text encoder type: {text_encoder_type}\")\n\n        self.model, self.model_path = load_text_encoder(\n            text_encoder_type=self.text_encoder_type,\n            text_encoder_precision=self.precision,\n            text_encoder_path=self.model_path,\n            infer_mode=self.infer_mode,\n            logger=self.logger,\n            device=device\n        )\n        self.dtype = self.model.dtype\n        self.device = self.model.device\n\n        padding_side = \"right\" if self.infer_mode == \"encoder\" else \"left\"\n        self.tokenizer, self.tokenizer_path = load_tokenizer(\n            tokenizer_type=self.tokenizer_type,\n            tokenizer_path=self.tokenizer_path,\n            padding_side=padding_side,\n            logger=self.logger\n        )\n\n    def __repr__(self):\n        return f\"{self.text_encoder_type} ({self.precision} - {self.model_path})\"\n\n    @staticmethod\n    def apply_text_to_template(text, template, prevent_empty_text=True):\n        \"\"\"\n        Apply text to a prompt template.\n\n        Args:\n            text (str): Input text.\n            template (str or list): Template string or list of chat conversation.\n            prevent_empty_text (bool): If True, prevent empty user text by adding a space.\n\n        Returns:\n            str or list: Text with template applied.\n        \"\"\"\n        if isinstance(template, str):\n            return template.format(text)\n        elif isinstance(template, list):\n            conversation = deepcopy(template)\n            for message in conversation:\n                if '{}' in message.get(\"content\", \"\"):\n                    filled_text = message[\"content\"].format(text)\n                    if prevent_empty_text and len(filled_text) == 0:\n                        filled_text = ' '\n                    message[\"content\"] = filled_text\n                    break  # Only one placeholder per conversation\n            return conversation\n        else:\n            raise TypeError(f\"Unsupported template type: {type(template)}\")\n\n    def text2tokens(self, text, data_type='image'):\n        \"\"\"\n        Tokenize the input text, optionally applying a prompt template.\n\n        Args:\n            text (str or list): Input text.\n            data_type (str): 'image' or 'video'.\n\n        Returns:\n            dict: Tokenized input.\n        \"\"\"\n        tokenize_input_type = 'str'\n        if self.use_template:\n            if data_type == 'image':\n                prompt_template = self.prompt_template[\"template\"]\n            elif data_type == 'video':\n                prompt_template = self.prompt_template_video[\"template\"]\n            else:\n                raise ValueError(f\"Unsupported data type: {data_type}\")\n            if isinstance(text, (list, tuple)):\n                text = [self.apply_text_to_template(one_text, prompt_template) for one_text in text]\n                if isinstance(text[0], list):\n                    tokenize_input_type = 'list'\n            elif isinstance(text, str):\n                text = self.apply_text_to_template(text, prompt_template)\n                if isinstance(text, list):\n                    tokenize_input_type = 'list'\n            else:\n                raise TypeError(f\"Unsupported text type: {type(text)}\")\n        kwargs = dict(truncation=True, max_length=self.max_length, padding=\"max_length\", return_tensors=\"pt\")\n        if tokenize_input_type == 'str':\n            return self.tokenizer(\n                text,\n                return_length=False,\n                return_overflowing_tokens=False,\n                return_attention_mask=True,\n                **kwargs,\n            )\n        elif tokenize_input_type == 'list':\n            return self.tokenizer.apply_chat_template(\n                text,\n                add_generation_prompt=True,\n                tokenize=True,\n                return_dict=True,\n                **kwargs,\n            )\n        else:\n            raise ValueError(f\"Unsupported tokenize_input_type: {tokenize_input_type}\")\n\n    def encode(\n        self,\n        batch_encoding,\n        use_attention_mask=None,\n        output_hidden_states=False,\n        do_sample=None,\n        hidden_state_skip_layer=None,\n        return_texts=False,\n        data_type='image',\n        device=None\n    ):\n        \"\"\"\n        Encode tokenized input using the text encoder.\n\n        Args:\n            batch_encoding (dict): Batch encoding from tokenizer.\n            use_attention_mask (bool, optional): Whether to use attention mask.\n            output_hidden_states (bool): Whether to output all hidden states.\n            do_sample (bool, optional): Whether to sample from the model (for decoder-only LLMs).\n            hidden_state_skip_layer (int, optional): Number of layers to skip from last for hidden state.\n            return_texts (bool): Whether to return decoded texts.\n            data_type (str): 'image' or 'video'.\n            device (torch.device, optional): Device to use.\n\n        Returns:\n            TextEncoderModelOutput: Encoded output.\n        \"\"\"\n        use_attention_mask = use_default(use_attention_mask, self.use_attention_mask)\n        hidden_state_skip_layer = use_default(hidden_state_skip_layer, self.hidden_state_skip_layer)\n        do_sample = use_default(do_sample, not self.reproduce)\n\n        if self.infer_mode == \"encoder\":\n            attention_mask = batch_encoding[\"attention_mask\"].to(self.model.device) if use_attention_mask else None\n            if 'Gemma2' in self.text_encoder_type:\n                input_ids = batch_encoding[\"input_ids\"].to(self.model.device)\n                _, inputs_embeds, labels, attention_mask = self.model.merge_multimodal(\n                    text_input_ids=input_ids,\n                    text_attention_masks=attention_mask,\n                    text_labels=None,\n                    pixel_values=[None]\n                )\n                outputs = self.model.llm(inputs_embeds=inputs_embeds, labels=labels, attention_mask=attention_mask)\n            else:\n                outputs = self.model(\n                    input_ids=batch_encoding[\"input_ids\"].to(self.model.device),\n                    attention_mask=attention_mask,\n                    output_hidden_states=output_hidden_states or hidden_state_skip_layer is not None,\n                )\n            if hidden_state_skip_layer is not None:\n                last_hidden_state = outputs.hidden_states[-(hidden_state_skip_layer + 1)]\n                # Apply final norm for intermediate layers if requested\n                if hidden_state_skip_layer > 0 and self.apply_final_norm:\n                    last_hidden_state = self.model.final_layer_norm(last_hidden_state)\n            else:\n                last_hidden_state = outputs[self.output_key]\n\n            # Remove hidden states of instruction tokens, only keep prompt tokens.\n            if self.use_template:\n                if data_type == 'image':\n                    crop_start = self.prompt_template.get(\"crop_start\", -1)\n                elif data_type == 'video':\n                    crop_start = self.prompt_template_video.get(\"crop_start\", -1)\n                else:\n                    raise ValueError(f\"Unsupported data type: {data_type}\")\n                if crop_start > 0:\n                    last_hidden_state = last_hidden_state[:, crop_start:]\n                    attention_mask = attention_mask[:, crop_start:] if use_attention_mask else None\n\n            if output_hidden_states:\n                return TextEncoderModelOutput(last_hidden_state, attention_mask, outputs.hidden_states)\n            return TextEncoderModelOutput(last_hidden_state, attention_mask)\n\n        elif self.infer_mode == \"decoder\":\n            # Remove leading padding tokens\n            input_max_valid_tokens = batch_encoding[\"attention_mask\"].sum(dim=1).max().item()\n            if input_max_valid_tokens < batch_encoding[\"attention_mask\"].shape[1]:\n                batch_encoding = {\n                    \"input_ids\": batch_encoding[\"input_ids\"][:, -input_max_valid_tokens:],\n                    \"attention_mask\": batch_encoding[\"attention_mask\"][:, -input_max_valid_tokens:],\n                }\n\n            # Generate text from the model.\n            outputs = self.model.generate(\n                input_ids=batch_encoding[\"input_ids\"].to(self.model.device),\n                attention_mask=batch_encoding[\"attention_mask\"].to(self.model.device) if use_attention_mask else None,\n                max_new_tokens=self.max_length,\n                do_sample=do_sample,\n                return_dict_in_generate=True,\n                output_hidden_states=True,\n                stop_strings='<|eot_id|>', tokenizer=self.tokenizer,\n                pad_token_id=self.tokenizer.eos_token_id,\n            )\n\n            # Concatenate hidden states from all generated tokens.\n            hidden_states = torch.cat([\n                per_token_hidden_states[-(hidden_state_skip_layer + 1)]\n                for per_token_hidden_states in outputs.hidden_states[1:]\n            ], dim=1)\n            if self.apply_final_norm:\n                hidden_states = self.model.final_layer_norm(hidden_states)\n\n            # Make sequence mask from output sequences\n            output_max_valid_tokens = hidden_states.shape[1]\n            attention_mask = (outputs.sequences[:, -output_max_valid_tokens - 1:-1] != self.tokenizer.eos_token_id).long()\n\n            if return_texts:\n                text_outputs = self.tokenizer.batch_decode(outputs.sequences, skip_special_tokens=False)\n                return TextEncoderModelOutput(hidden_states, attention_mask, None, text_outputs)\n            else:\n                return TextEncoderModelOutput(hidden_states, attention_mask)\n        else:\n            raise ValueError(f\"Unsupported text encoder infer mode: {self.infer_mode}\")\n\n    def forward(\n        self,\n        text,\n        use_attention_mask=None,\n        output_hidden_states=False,\n        do_sample=False,\n        hidden_state_skip_layer=None,\n        return_texts=False\n    ):\n        \"\"\"\n        Forward pass: encode text to hidden states.\n\n        Args:\n            text (str or list): Input text.\n            use_attention_mask (bool, optional): Whether to use attention mask.\n            output_hidden_states (bool): Whether to output all hidden states.\n            do_sample (bool): Whether to sample from the model (for decoder-only LLMs).\n            hidden_state_skip_layer (int, optional): Number of layers to skip from last for hidden state.\n            return_texts (bool): Whether to return decoded texts.\n\n        Returns:\n            TextEncoderModelOutput: Encoded output.\n        \"\"\"\n        batch_encoding = self.text2tokens(text)\n        return self.encode(\n            batch_encoding,\n            use_attention_mask=use_attention_mask,\n            output_hidden_states=output_hidden_states,\n            do_sample=do_sample,\n            hidden_state_skip_layer=hidden_state_skip_layer,\n            return_texts=return_texts\n        )\n",
        "hyimage/models/text_encoder/byT5/__init__.py": "import json\nimport torch\nimport torch.nn as nn\nfrom transformers import AutoTokenizer, T5ForConditionalGeneration\n\n\ndef load_glyph_byT5_v2(args, device):\n    \"\"\"\n    Loads ByT5 tokenizer and encoder model for glyph encoding.\n\n    Args:\n        args (dict): Configuration dictionary containing paths and settings.\n        device (str or torch.device): Device to load the model onto.\n\n    Returns:\n        dict: Dictionary with keys 'byt5_tokenizer', 'byt5_model', 'byt5_max_length'.\n    \"\"\"\n    byt5_tokenizer, byt5_model, byt5_max_length = create_byt5(args, device)\n    byt5_model = byt5_model.to(device=device)\n    return {\n        \"byt5_tokenizer\": byt5_tokenizer,\n        \"byt5_model\": byt5_model,\n        \"byt5_max_length\": byt5_max_length,\n    }\n\n\ndef create_byt5(args, device):\n    \"\"\"\n    Create ByT5 tokenizer and encoder, load weights if provided.\n\n    Args:\n        args (dict): Configuration dictionary.\n        device (str or torch.device): Device to load the model onto.\n\n    Returns:\n        tuple: (byt5_tokenizer, byt5_model, byt5_max_length)\n    \"\"\"\n    byt5_max_length = args['byt5_max_length']\n    byt5_config = dict(\n        byt5_name=args['byT5_google_path'],\n        special_token=True,\n        color_special_token=True,\n        font_special_token=True,\n        color_ann_path=args['multilingual_prompt_format_color_path'],\n        font_ann_path=args['multilingual_prompt_format_font_path'],\n        multilingual=True,\n    )\n    huggingface_cache_dir = None\n    byt5_model, byt5_tokenizer = load_byt5_and_byt5_tokenizer(\n        **byt5_config,\n        huggingface_cache_dir=huggingface_cache_dir,\n        device=device,\n    )\n\n    # Load custom checkpoint if provided\n    if args['byT5_ckpt_path'] is not None:\n        if \"cuda\" not in str(device):\n            byt5_state_dict = torch.load(args['byT5_ckpt_path'], map_location=device)\n        else:\n            byt5_state_dict = torch.load(args['byT5_ckpt_path'], map_location=device)\n        if 'state_dict' in byt5_state_dict:\n            sd = byt5_state_dict[\"state_dict\"]\n            newsd = {}\n            for k, v in sd.items():\n                if k.startswith('module.text_tower.encoder.'):\n                    newsd[k[len('module.text_tower.encoder.'):]] = v\n            byt5_state_dict = newsd\n        byt5_model.load_state_dict(byt5_state_dict)\n    byt5_model.requires_grad_(False)\n    return byt5_tokenizer, byt5_model, byt5_max_length\n\n\ndef add_special_token(\n    tokenizer,\n    text_encoder,\n    add_color,\n    add_font,\n    color_ann_path,\n    font_ann_path,\n    multilingual=False,\n):\n    \"\"\"\n    Add special tokens for color and font to tokenizer and text encoder.\n\n    Args:\n        tokenizer: Huggingface tokenizer.\n        text_encoder: Huggingface T5 encoder.\n        add_color (bool): Whether to add color tokens.\n        add_font (bool): Whether to add font tokens.\n        color_ann_path (str): Path to color annotation JSON.\n        font_ann_path (str): Path to font annotation JSON.\n        multilingual (bool): Whether to use multilingual font tokens.\n    \"\"\"\n    with open(font_ann_path, 'r') as f:\n        idx_font_dict = json.load(f)\n    with open(color_ann_path, 'r') as f:\n        idx_color_dict = json.load(f)\n\n    if multilingual:\n        font_token = [f'<{font_code[:2]}-font-{idx_font_dict[font_code]}>' for font_code in idx_font_dict]\n    else:\n        font_token = [f'<font-{i}>' for i in range(len(idx_font_dict))]\n    color_token = [f'<color-{i}>' for i in range(len(idx_color_dict))]\n    additional_special_tokens = []\n    if add_color:\n        additional_special_tokens += color_token\n    if add_font:\n        additional_special_tokens += font_token\n\n    tokenizer.add_tokens(additional_special_tokens, special_tokens=True)\n    # Set mean_resizing=False to avoid PyTorch LAPACK dependency\n    text_encoder.resize_token_embeddings(len(tokenizer), mean_resizing=False)\n\n\ndef load_byt5_and_byt5_tokenizer(\n    byt5_name='google/byt5-small',\n    special_token=False,\n    color_special_token=False,\n    font_special_token=False,\n    color_ann_path='assets/color_idx.json',\n    font_ann_path='assets/font_idx_512.json',\n    huggingface_cache_dir=None,\n    multilingual=False,\n    device=None,\n):\n    \"\"\"\n    Load ByT5 encoder and tokenizer from Huggingface, and add special tokens if needed.\n\n    Args:\n        byt5_name (str): Model name or path.\n        special_token (bool): Whether to add special tokens.\n        color_special_token (bool): Whether to add color tokens.\n        font_special_token (bool): Whether to add font tokens.\n        color_ann_path (str): Path to color annotation JSON.\n        font_ann_path (str): Path to font annotation JSON.\n        huggingface_cache_dir (str): Huggingface cache directory.\n        multilingual (bool): Whether to use multilingual font tokens.\n        device (str or torch.device): Device to load the model onto.\n\n    Returns:\n        tuple: (byt5_text_encoder, byt5_tokenizer)\n    \"\"\"\n    byt5_tokenizer = AutoTokenizer.from_pretrained(\n        byt5_name,\n        cache_dir=huggingface_cache_dir,\n    )\n    byt5_text_encoder = T5ForConditionalGeneration.from_pretrained(\n        byt5_name,\n        cache_dir=huggingface_cache_dir,\n    ).get_encoder()\n\n    if \"cuda\" not in str(device):\n        device = torch.device(device)\n    else:\n        device = torch.device(device)\n    byt5_text_encoder = byt5_text_encoder.to(device)\n\n    if special_token:\n        add_special_token(\n            byt5_tokenizer,\n            byt5_text_encoder,\n            add_color=color_special_token,\n            add_font=font_special_token,\n            color_ann_path=color_ann_path,\n            font_ann_path=font_ann_path,\n            multilingual=multilingual,\n        )\n    return byt5_text_encoder, byt5_tokenizer\n\n\nclass ByT5Mapper(nn.Module):\n    \"\"\"\n    ByT5Mapper: Maps ByT5 encoder outputs to a new space, with optional residual connection.\n\n    Args:\n        in_dim (int): Input dimension (must equal out_dim if use_residual).\n        out_dim (int): Output dimension after second linear layer.\n        hidden_dim (int): Hidden dimension for intermediate layer.\n        out_dim1 (int): Final output dimension.\n        use_residual (bool): Whether to use residual connection (default: True).\n    \"\"\"\n\n    def __init__(self, in_dim, out_dim, hidden_dim, out_dim1, use_residual=True):\n        super().__init__()\n        if use_residual:\n            assert in_dim == out_dim\n        self.layernorm = nn.LayerNorm(in_dim)\n        self.fc1 = nn.Linear(in_dim, hidden_dim)\n        self.fc2 = nn.Linear(hidden_dim, out_dim)\n        self.fc3 = nn.Linear(out_dim, out_dim1)\n        self.use_residual = use_residual\n        self.act_fn = nn.GELU()\n\n    def forward(self, x):\n        \"\"\"\n        Forward pass for ByT5Mapper.\n\n        Args:\n            x (Tensor): Input tensor of shape (..., in_dim).\n\n        Returns:\n            Tensor: Output tensor of shape (..., out_dim1).\n        \"\"\"\n        residual = x\n        x = self.layernorm(x)\n        x = self.fc1(x)\n        x = self.act_fn(x)\n        x = self.fc2(x)\n        x2 = self.act_fn(x)\n        x2 = self.fc3(x2)\n        if self.use_residual:\n            x2 = x2 + residual\n        return x2\n",
        "hyimage/models/utils/fp8_quantization.py": "import os\nimport torch\nimport gc\nimport copy\nimport tqdm\n\n\ndef per_tensor_quantize(tensor: torch.Tensor):\n    \"\"\"Quantize a tensor using per-tensor static scaling factor.\n\n    Args:\n        tensor: The input tensor to quantize.\n        \n    Returns:\n        Tuple[torch.Tensor, torch.Tensor]: Quantized tensor and scale factor.\n    \"\"\"\n    finfo = torch.finfo(torch.float8_e4m3fn)\n    device = tensor.device\n\n    if tensor.numel() == 0:\n        min_val, max_val = (\n            torch.tensor(-16.0, dtype=tensor.dtype, device=device),\n            torch.tensor(16.0, dtype=tensor.dtype, device=device),\n        )\n    else:\n        min_val, max_val = tensor.aminmax()\n\n    amax = torch.maximum(min_val.abs(), max_val.abs())\n\n    if torch.isnan(amax) or amax <= 0:\n        raise RuntimeError(f\"Illegal amax: {amax}\")\n\n    scale = finfo.max / amax.clamp(min=1e-12)\n    qweight = (tensor * scale).clamp(min=finfo.min, max=finfo.max)\n\n    deqweight = qweight.to(torch.float8_e4m3fn).clone()\n    scale = torch.tensor(scale.float().reciprocal(), device=device)\n\n    return deqweight, scale\n\n\ndef fp8_weight_only_gemm(A, B, B_scale, bias, out_dtype):\n    \"\"\"Perform FP8 GEMM operation with fallback to standard linear.\n\n    Args:\n        A: Input tensor A.\n        B: Input tensor B.\n        B_scale: Scale factor for tensor B.\n        bias: Optional bias tensor.\n        out_dtype: Output data type.\n        native_fp8_support: Whether to use native FP8 support.\n        quant_type: Quantization type.\n        origin_shape: Original shape for reshaping.\n\n    Returns:\n        torch.Tensor: Result of the GEMM operation.\n    \"\"\"\n    if A.numel() == 0:\n        return torch.empty(size=(0, B.shape[0]), dtype=out_dtype, device=A.device)\n\n    output = torch.nn.functional.linear(\n        A.to(out_dtype),\n        B.to(out_dtype) * B_scale.to(out_dtype),\n        bias=bias,\n    )\n\n    return output\n\n\nclass FP8_Linear(torch.nn.Module):\n    \"\"\"FP8 Linear layer with quantization support.\"\"\"\n\n    def __init__(\n            self,\n            weight: torch.Tensor,\n            weight_scale: torch.Tensor,\n            bias: torch.nn.Parameter,\n            native_fp8_support: bool = False,\n            quant_type: str = \"fp8_weight_only\",\n    ):\n        \"\"\"Initialize FP8 layer. We only support weight-only quantization.\n\n        Args:\n            weight: Weight tensor.\n            weight_scale: Scale factor for weights.\n            bias: Bias parameter.\n            native_fp8_support: Whether to use native FP8 support.\n            quant_type: Quantization type.\n        \"\"\"\n        super().__init__()\n        self.weight = torch.nn.Parameter(weight, requires_grad=False)\n        self.weight_scale = torch.nn.Parameter(weight_scale, requires_grad=False)\n        self.bias = bias\n        self.native_fp8_support = native_fp8_support\n        self.quant_type = quant_type\n\n    def forward(self, x):\n        \"\"\"Forward pass with FP8 quantization.\n\n        Args:\n            x: Input tensor.\n\n        Returns:\n            torch.Tensor: Output tensor.\n        \"\"\"\n        if x.dtype == torch.float32:\n            x = x.to(torch.bfloat16)\n        if self.quant_type == \"fp8_weight_only\":\n            output = fp8_weight_only_gemm(\n                A=x,\n                B=self.weight,\n                B_scale=self.weight_scale,\n                bias=self.bias,\n                out_dtype=x.dtype,\n            )\n\n        return output\n\n\ndef replace_module(model: torch.nn.Module, name: str, new_module: torch.nn.Module):\n    \"\"\"Replace a module in the model with a new module.\n\n    Args:\n        model: The model containing the module.\n        name: Name of the module to replace.\n        new_module: The new module to replace with.\n    \"\"\"\n    if \".\" in name:\n        parent_name = name.rsplit(\".\", 1)[0]\n        child_name = name[len(parent_name) + 1:]\n        parent = model.get_submodule(parent_name)\n    else:\n        parent_name = \"\"\n        parent = model\n        child_name = name\n\n    setattr(parent, child_name, new_module)\n\n\ndef convert_fp8_linear(module, fp8_map_path=None):\n    \"\"\"Convert linear layers to FP8 quantized versions.\n\n    Args:\n        module: The module to convert.\n        fp8_map_path: Path to FP8 scale map file.\n    \"\"\"\n    setattr(module, \"fp8_matmul_enabled\", True)\n    if fp8_map_path is None:\n        fp8_map = {}\n    else:\n        if os.path.exists(fp8_map_path):\n            if fp8_map_path.endswith(\".safetensors\"):\n                import safetensors\n                fp8_map = safetensors.torch.load_file(fp8_map_path)\n            else:\n                fp8_map = torch.load(fp8_map_path, map_location='cpu')\n        else:\n            raise ValueError(f\"Invalid fp8_map path: {fp8_map_path}.\")\n\n    named_modules = list(module.named_modules())\n\n    for name, linear in tqdm.tqdm(named_modules, desc=\"Quantizing weights\"):\n        if isinstance(linear, torch.nn.Linear):\n            if \"double_block\" in name or \"single_blocks\" in name:\n                if \"embed\" not in name:\n                    if fp8_map_path is None:\n                        if linear.weight.dtype != torch.float8_e4m3fn:\n                            quant_weight, weight_scale = per_tensor_quantize(linear.weight)\n                            fp8_map[name] = weight_scale\n                        else:\n                            raise ValueError(f\"Invalid weight dtype: {linear.weight.dtype}\")\n\n                    else:\n                        quant_weight = linear.weight.to(torch.float8_e4m3fn).clone()\n                        weight_scale = fp8_map[name]\n\n                    bias = copy.deepcopy(linear.bias) if linear.bias is not None else None\n\n                    quant_linear = FP8_Linear(\n                        weight=quant_weight,\n                        weight_scale=weight_scale,\n                        bias=bias,\n                        native_fp8_support=False,\n                        quant_type=\"fp8_weight_only\"\n                    )\n\n                    replace_module(module, name, quant_linear)\n                    del linear.weight\n                    del linear.bias\n                    del linear\n    gc.collect()\n    torch.cuda.empty_cache()\n    return fp8_map\n",
        "hyimage/models/vae/__init__.py": "import torch\nfrom pathlib import Path\nfrom hyimage.common.constants import PRECISION_TO_TYPE\nfrom .hunyuanimage_vae import HunyuanVAE2D\nfrom .refiner_vae import AutoencoderKLConv3D\n\ndef load_vae(device, vae_path: str = None, vae_precision: str = None):\n    config = HunyuanVAE2D.load_config(vae_path)\n    vae = HunyuanVAE2D.from_config(config)\n\n    ckpt_path = Path(vae_path) / \"pytorch_model.ckpt\"\n    if not ckpt_path.exists():\n        ckpt_path = Path(vae_path) / \"pytorch_model.pt\"\n\n    ckpt = torch.load(ckpt_path, map_location='cpu')\n    if \"state_dict\" in ckpt:\n        ckpt = ckpt[\"state_dict\"]\n    vae_ckpt = {}\n    for k, v in ckpt.items():\n        if k.startswith(\"vae.\"):\n            vae_ckpt[k.replace(\"vae.\", \"\")] = v\n    vae.load_state_dict(vae_ckpt)\n\n    if vae_precision is not None:\n        vae = vae.to(dtype=PRECISION_TO_TYPE[vae_precision])\n\n    vae.requires_grad_(False)\n\n    if device is not None:\n        vae = vae.to(device)\n\n    vae.eval()\n    return vae\n\n\ndef load_refiner_vae(device, vae_path: str = None, vae_precision: str = \"fp16\"):\n    config = AutoencoderKLConv3D.load_config(vae_path)\n    vae = AutoencoderKLConv3D.from_config(config)\n\n    ckpt_path = Path(vae_path) / \"pytorch_model.ckpt\"\n    if not ckpt_path.exists():\n        ckpt_path = Path(vae_path) / \"pytorch_model.pt\"\n\n    ckpt = torch.load(ckpt_path, map_location='cpu')\n    if \"state_dict\" in ckpt:\n        ckpt = ckpt[\"state_dict\"]\n    vae_ckpt = {}\n    for k, v in ckpt.items():\n        if k.startswith(\"vae.\"):\n            vae_ckpt[k.replace(\"vae.\", \"\")] = v\n    vae.load_state_dict(vae_ckpt)\n\n    if vae_precision is not None:\n        vae = vae.to(dtype=PRECISION_TO_TYPE[vae_precision])\n\n    vae.requires_grad_(False)\n\n    if device is not None:\n        vae = vae.to(device)\n\n    vae.eval()\n    return vae",
        "hyimage/models/vae/hunyuanimage_vae.py": "from dataclasses import dataclass\nfrom typing import Optional, Tuple\n\nimport numpy as np\nimport torch\nfrom diffusers.configuration_utils import ConfigMixin\nfrom diffusers.configuration_utils import register_to_config\nfrom diffusers.models.modeling_outputs import AutoencoderKLOutput\nfrom diffusers.models.modeling_utils import ModelMixin\nfrom diffusers.utils import BaseOutput\nfrom diffusers.utils.torch_utils import randn_tensor\nfrom einops import rearrange\nfrom torch import Tensor, nn\nfrom torch.nn import Conv2d\n\n\nclass DiagonalGaussianDistribution:\n    def __init__(self, parameters: torch.Tensor, deterministic: bool = False):\n        if parameters.ndim == 3:\n            dim = 2  # (B, L, C)\n        elif parameters.ndim == 5 or parameters.ndim == 4:\n            dim = 1  # (B, C, T, H, W) / (B, C, H, W)\n        else:\n            raise NotImplementedError\n        self.parameters = parameters\n        self.mean, self.logvar = torch.chunk(parameters, 2, dim=dim)\n        self.logvar = torch.clamp(self.logvar, -30.0, 20.0)\n        self.deterministic = deterministic\n        self.std = torch.exp(0.5 * self.logvar)\n        self.var = torch.exp(self.logvar)\n        if self.deterministic:\n            zero_tensor = torch.zeros_like(self.mean, device=self.parameters.device, dtype=self.parameters.dtype)\n            self.var = zero_tensor\n            self.std = zero_tensor\n\n    def sample(self, generator: Optional[torch.Generator] = None) -> torch.FloatTensor:\n        sample = randn_tensor(\n            self.mean.shape,\n            generator=generator,\n            device=self.parameters.device,\n            dtype=self.parameters.dtype,\n        )\n        return self.mean + self.std * sample\n\n    def kl(self, other: Optional[\"DiagonalGaussianDistribution\"] = None) -> torch.Tensor:\n        if self.deterministic:\n            return torch.tensor([0.0], device=self.parameters.device, dtype=self.parameters.dtype)\n        reduce_dim = list(range(1, self.mean.ndim))\n        if other is None:\n            return 0.5 * torch.sum(\n                self.mean.pow(2) + self.var - 1.0 - self.logvar,\n                dim=reduce_dim,\n            )\n        else:\n            return 0.5 * torch.sum(\n                (self.mean - other.mean).pow(2) / other.var\n                + self.var / other.var\n                - 1.0\n                - self.logvar\n                + other.logvar,\n                dim=reduce_dim,\n            )\n\n    def nll(self, sample: torch.Tensor, dims: Tuple[int, ...] = (1, 2, 3)) -> torch.Tensor:\n        if self.deterministic:\n            return torch.tensor([0.0], device=self.parameters.device, dtype=self.parameters.dtype)\n        logtwopi = np.log(2.0 * np.pi)\n        return 0.5 * torch.sum(\n            logtwopi + self.logvar + (sample - self.mean).pow(2) / self.var,\n            dim=dims,\n        )\n\n    def mode(self) -> torch.Tensor:\n        return self.mean\n\n\n@dataclass\nclass DecoderOutput(BaseOutput):\n    \"\"\"Output of the decoder with sample and optional posterior distribution.\"\"\"\n    sample: torch.FloatTensor\n    posterior: Optional[DiagonalGaussianDistribution] = None\n\n\ndef swish(x: Tensor) -> Tensor:\n    \"\"\"Swish activation function: x * sigmoid(x).\"\"\"\n    return x * torch.sigmoid(x)\n\n\ndef forward_with_checkpointing(module, *inputs, use_checkpointing=False):\n    \"\"\"\n    Forward pass with optional gradient checkpointing for memory efficiency.\n\n    Parameters\n    ----------\n    module : nn.Module\n        The module to run.\n    *inputs : Tensor\n        Inputs to the module.\n    use_checkpointing : bool\n        Whether to use gradient checkpointing.\n    \"\"\"\n    def create_custom_forward(module):\n        def custom_forward(*inputs):\n            return module(*inputs)\n        return custom_forward\n\n    if use_checkpointing:\n        return torch.utils.checkpoint.checkpoint(create_custom_forward(module), *inputs, use_reentrant=False)\n    else:\n        return module(*inputs)\n\n\nclass AttnBlock(nn.Module):\n    \"\"\"Self-attention block for 3D tensors.\"\"\"\n\n    def __init__(self, in_channels: int):\n        super().__init__()\n        self.in_channels = in_channels\n        self.norm = nn.GroupNorm(num_groups=32, num_channels=in_channels, eps=1e-6, affine=True)\n        self.q = Conv2d(in_channels, in_channels, kernel_size=1)\n        self.k = Conv2d(in_channels, in_channels, kernel_size=1)\n        self.v = Conv2d(in_channels, in_channels, kernel_size=1)\n        self.proj_out = Conv2d(in_channels, in_channels, kernel_size=1)\n\n    def attention(self, x: Tensor) -> Tensor:\n        x = self.norm(x)\n        q = self.q(x)\n        k = self.k(x)\n        v = self.v(x)\n\n        b, c, h, w = q.shape\n        q = rearrange(q, \"b c h w -> b (h w) c\").contiguous()\n        k = rearrange(k, \"b c h w -> b (h w) c\").contiguous()\n        v = rearrange(v, \"b c h w -> b (h w) c\").contiguous()\n\n        x = nn.functional.scaled_dot_product_attention(q, k, v)\n        return rearrange(x, \"b (h w) c -> b c h w\", h=h, w=w, c=c, b=b)\n\n    def forward(self, x: Tensor) -> Tensor:\n        return x + self.proj_out(self.attention(x))\n\n\nclass ResnetBlock(nn.Module):\n    \"\"\"\n    Residual block with two convolutions and optional channel change.\n\n    Parameters\n    ----------\n    in_channels : int\n        Number of input channels.\n    out_channels : int\n        Number of output channels.\n    \"\"\"\n\n    def __init__(self, in_channels: int, out_channels: int):\n        super().__init__()\n        self.in_channels = in_channels\n        out_channels = in_channels if out_channels is None else out_channels\n        self.out_channels = out_channels\n\n        self.norm1 = nn.GroupNorm(num_groups=32, num_channels=in_channels, eps=1e-6, affine=True)\n        self.conv1 = Conv2d(in_channels, out_channels, kernel_size=3, stride=1, padding=1)\n        self.norm2 = nn.GroupNorm(num_groups=32, num_channels=out_channels, eps=1e-6, affine=True)\n        self.conv2 = Conv2d(out_channels, out_channels, kernel_size=3, stride=1, padding=1)\n\n        if self.in_channels != self.out_channels:\n            self.nin_shortcut = Conv2d(in_channels, out_channels, kernel_size=1, stride=1, padding=0)\n\n    def forward(self, x: Tensor) -> Tensor:\n        h = x\n        h = self.norm1(h)\n        h = swish(h)\n        h = self.conv1(h)\n        h = self.norm2(h)\n        h = swish(h)\n        h = self.conv2(h)\n\n        if self.in_channels != self.out_channels:\n            x = self.nin_shortcut(x)\n        return x + h\n\n\nclass Downsample(nn.Module):\n    \"\"\"\n    Downsampling block for spatial reduction.\n\n    Parameters\n    ----------\n    in_channels : int\n        Number of input channels.\n    out_channels : int\n        Number of output channels.\n    \"\"\"\n\n    def __init__(self, in_channels: int, out_channels: int):\n        super().__init__()\n        factor = 4\n        assert out_channels % factor == 0\n\n        self.conv = Conv2d(in_channels, out_channels // factor, kernel_size=3, stride=1, padding=1)\n        self.group_size = factor * in_channels // out_channels\n\n    def forward(self, x: Tensor) -> Tensor:\n        h = self.conv(x)\n        h = rearrange(h, \"b c (h r1) (w r2) -> b (r1 r2 c) h w\", r1=2, r2=2)\n        shortcut = rearrange(x, \"b c (h r1) (w r2) -> b (r1 r2 c) h w\", r1=2, r2=2)\n\n        B, C, H, W = shortcut.shape\n        shortcut = shortcut.view(B, h.shape[1], self.group_size, H, W).mean(dim=2)\n        return h + shortcut\n\n\nclass Upsample(nn.Module):\n    \"\"\"\n    Upsampling block for spatial expansion.\n\n    Parameters\n    ----------\n    in_channels : int\n        Number of input channels.\n    out_channels : int\n        Number of output channels.\n    \"\"\"\n\n    def __init__(self, in_channels: int, out_channels: int):\n        super().__init__()\n        factor = 4\n        self.conv = Conv2d(in_channels, out_channels * factor, kernel_size=3, stride=1, padding=1)\n        self.repeats = factor * out_channels // in_channels\n\n    def forward(self, x: Tensor) -> Tensor:\n        h = self.conv(x)\n        h = rearrange(h, \"b (r1 r2 c) h w -> b c (h r1) (w r2)\", r1=2, r2=2)\n        shortcut = x.repeat_interleave(repeats=self.repeats, dim=1)\n        shortcut = rearrange(shortcut, \"b (r1 r2 c) h w -> b c (h r1) (w r2)\", r1=2, r2=2)\n        return h + shortcut\n\n\nclass Encoder(nn.Module):\n    \"\"\"\n    Encoder network that compresses input to latent representation.\n\n    Parameters\n    ----------\n    in_channels : int\n        Number of input channels.\n    z_channels : int\n        Number of latent channels.\n    block_out_channels : Tuple[int, ...]\n        Output channels for each block.\n    num_res_blocks : int\n        Number of residual blocks per block.\n    ffactor_spatial : int\n        Spatial downsampling factor.\n    downsample_match_channel : bool\n        Whether to match channels during downsampling.\n    \"\"\"\n\n    def __init__(\n        self,\n        in_channels: int,\n        z_channels: int,\n        block_out_channels: Tuple[int, ...],\n        num_res_blocks: int,\n        ffactor_spatial: int,\n        downsample_match_channel: bool = True,\n    ):\n        super().__init__()\n        assert block_out_channels[-1] % (2 * z_channels) == 0\n\n        self.z_channels = z_channels\n        self.block_out_channels = block_out_channels\n        self.num_res_blocks = num_res_blocks\n\n        self.conv_in = Conv2d(in_channels, block_out_channels[0], kernel_size=3, stride=1, padding=1)\n\n        self.down = nn.ModuleList()\n        block_in = block_out_channels[0]\n\n        for i_level, ch in enumerate(block_out_channels):\n            block = nn.ModuleList()\n            block_out = ch\n\n            for _ in range(self.num_res_blocks):\n                block.append(ResnetBlock(in_channels=block_in, out_channels=block_out))\n                block_in = block_out\n\n            down = nn.Module()\n            down.block = block\n\n            add_spatial_downsample = bool(i_level < np.log2(ffactor_spatial))\n\n            if add_spatial_downsample:\n                assert i_level < len(block_out_channels) - 1\n                block_out = block_out_channels[i_level + 1] if downsample_match_channel else block_in\n                down.downsample = Downsample(block_in, block_out)\n                block_in = block_out\n\n            self.down.append(down)\n\n        # Middle blocks with attention\n        self.mid = nn.Module()\n        self.mid.block_1 = ResnetBlock(in_channels=block_in, out_channels=block_in)\n        self.mid.attn_1 = AttnBlock(block_in)\n        self.mid.block_2 = ResnetBlock(in_channels=block_in, out_channels=block_in)\n\n        # Output layers\n        self.norm_out = nn.GroupNorm(num_groups=32, num_channels=block_in, eps=1e-6, affine=True)\n        self.conv_out = Conv2d(block_in, 2 * z_channels, kernel_size=3, stride=1, padding=1)\n\n        self.gradient_checkpointing = False\n\n    def forward(self, x: Tensor) -> Tensor:\n        use_checkpointing = bool(self.training and self.gradient_checkpointing)\n\n        # Downsampling\n        h = self.conv_in(x)\n        for i_level in range(len(self.block_out_channels)):\n            for i_block in range(self.num_res_blocks):\n                h = forward_with_checkpointing(\n                    self.down[i_level].block[i_block], h, use_checkpointing=use_checkpointing\n                )\n            if hasattr(self.down[i_level], \"downsample\"):\n                h = forward_with_checkpointing(self.down[i_level].downsample, h, use_checkpointing=use_checkpointing)\n\n        # Middle processing\n        h = forward_with_checkpointing(self.mid.block_1, h, use_checkpointing=use_checkpointing)\n        h = forward_with_checkpointing(self.mid.attn_1, h, use_checkpointing=use_checkpointing)\n        h = forward_with_checkpointing(self.mid.block_2, h, use_checkpointing=use_checkpointing)\n\n        # Output with shortcut connection\n        group_size = self.block_out_channels[-1] // (2 * self.z_channels)\n        shortcut = rearrange(h, \"b (c r) h w -> b c r h w\", r=group_size).mean(dim=2)\n        h = self.norm_out(h)\n        h = swish(h)\n        h = self.conv_out(h)\n        h += shortcut\n        return h\n\n\nclass Decoder(nn.Module):\n    \"\"\"\n    Decoder network that reconstructs output from latent representation.\n\n    Parameters\n    ----------\n    z_channels : int\n        Number of latent channels.\n    out_channels : int\n        Number of output channels.\n    block_out_channels : Tuple[int, ...]\n        Output channels for each block.\n    num_res_blocks : int\n        Number of residual blocks per block.\n    ffactor_spatial : int\n        Spatial upsampling factor.\n    upsample_match_channel : bool\n        Whether to match channels during upsampling.\n    \"\"\"\n\n    def __init__(\n        self,\n        z_channels: int,\n        out_channels: int,\n        block_out_channels: Tuple[int, ...],\n        num_res_blocks: int,\n        ffactor_spatial: int,\n        upsample_match_channel: bool = True,\n    ):\n        super().__init__()\n        assert block_out_channels[0] % z_channels == 0\n\n        self.z_channels = z_channels\n        self.block_out_channels = block_out_channels\n        self.num_res_blocks = num_res_blocks\n\n        block_in = block_out_channels[0]\n        self.conv_in = Conv2d(z_channels, block_in, kernel_size=3, stride=1, padding=1)\n\n        # Middle blocks with attention\n        self.mid = nn.Module()\n        self.mid.block_1 = ResnetBlock(in_channels=block_in, out_channels=block_in)\n        self.mid.attn_1 = AttnBlock(block_in)\n        self.mid.block_2 = ResnetBlock(in_channels=block_in, out_channels=block_in)\n\n        # Upsampling blocks\n        self.up = nn.ModuleList()\n        for i_level, ch in enumerate(block_out_channels):\n            block = nn.ModuleList()\n            block_out = ch\n\n            for _ in range(self.num_res_blocks + 1):\n                block.append(ResnetBlock(in_channels=block_in, out_channels=block_out))\n                block_in = block_out\n\n            up = nn.Module()\n            up.block = block\n\n            # Determine upsampling strategy\n            add_spatial_upsample = bool(i_level < np.log2(ffactor_spatial))\n\n            if add_spatial_upsample:\n                assert i_level < len(block_out_channels) - 1\n                block_out = block_out_channels[i_level + 1] if upsample_match_channel else block_in\n                up.upsample = Upsample(block_in, block_out)\n                block_in = block_out\n\n            self.up.append(up)\n\n        # Output layers\n        self.norm_out = nn.GroupNorm(num_groups=32, num_channels=block_in, eps=1e-6, affine=True)\n        self.conv_out = Conv2d(block_in, out_channels, kernel_size=3, stride=1, padding=1)\n\n        self.gradient_checkpointing = False\n\n    def forward(self, z: Tensor) -> Tensor:\n        use_checkpointing = bool(self.training and self.gradient_checkpointing)\n\n        repeats = self.block_out_channels[0] // self.z_channels\n        h = self.conv_in(z) + z.repeat_interleave(repeats=repeats, dim=1)\n\n        h = forward_with_checkpointing(self.mid.block_1, h, use_checkpointing=use_checkpointing)\n        h = forward_with_checkpointing(self.mid.attn_1, h, use_checkpointing=use_checkpointing)\n        h = forward_with_checkpointing(self.mid.block_2, h, use_checkpointing=use_checkpointing)\n\n        for i_level in range(len(self.block_out_channels)):\n            for i_block in range(self.num_res_blocks + 1):\n                h = forward_with_checkpointing(self.up[i_level].block[i_block], h, use_checkpointing=use_checkpointing)\n            if hasattr(self.up[i_level], \"upsample\"):\n                h = forward_with_checkpointing(self.up[i_level].upsample, h, use_checkpointing=use_checkpointing)\n\n        h = self.norm_out(h)\n        h = swish(h)\n        h = self.conv_out(h)\n        return h\n\n\nclass HunyuanVAE2D(ModelMixin, ConfigMixin):\n    \"\"\"\n    HunyuanVAE2D: A 2D image VAE model with spatial tiling support.\n\n    This model implements a variational autoencoder specifically designed for image data,\n    with support for memory-efficient processing through tiling strategies.\n    \"\"\"\n\n    _supports_gradient_checkpointing = True\n\n    @register_to_config\n    def __init__(\n        self,\n        in_channels: int,\n        out_channels: int,\n        latent_channels: int,\n        block_out_channels: Tuple[int, ...],\n        layers_per_block: int,\n        ffactor_spatial: int,\n        sample_size: int,\n        sample_tsize: int,\n        scaling_factor: float = None,\n        shift_factor: Optional[float] = None,\n        downsample_match_channel: bool = True,\n        upsample_match_channel: bool = True,\n        **kwargs,\n    ):\n        super().__init__()\n        self.ffactor_spatial = ffactor_spatial\n        self.scaling_factor = scaling_factor\n        self.shift_factor = shift_factor\n\n        self.encoder = Encoder(\n            in_channels=in_channels,\n            z_channels=latent_channels,\n            block_out_channels=block_out_channels,\n            num_res_blocks=layers_per_block,\n            ffactor_spatial=ffactor_spatial,\n            downsample_match_channel=downsample_match_channel,\n        )\n\n        self.decoder = Decoder(\n            z_channels=latent_channels,\n            out_channels=out_channels,\n            block_out_channels=list(reversed(block_out_channels)),\n            num_res_blocks=layers_per_block,\n            ffactor_spatial=ffactor_spatial,\n            upsample_match_channel=upsample_match_channel,\n        )\n\n        # Tiling and slicing configuration\n        self.use_slicing = False\n        self.use_spatial_tiling = False\n        self.use_tiling_during_training = False\n\n        # Tiling parameters\n        self.tile_sample_min_size = sample_size\n        self.tile_latent_min_size = sample_size // ffactor_spatial\n        self.tile_overlap_factor = 0.25\n\n    def _set_gradient_checkpointing(self, module, value=False):\n        \"\"\"\n        Enable or disable gradient checkpointing for memory efficiency.\n\n        Parameters\n        ----------\n        module : nn.Module\n            The module to set.\n        value : bool\n            Whether to enable gradient checkpointing.\n        \"\"\"\n        if isinstance(module, (Encoder, Decoder)):\n            module.gradient_checkpointing = value\n\n    def enable_spatial_tiling(self, use_tiling: bool = True):\n        \"\"\"Enable or disable spatial tiling.\"\"\"\n        self.use_spatial_tiling = use_tiling\n\n    def disable_spatial_tiling(self):\n        \"\"\"Disable spatial tiling.\"\"\"\n        self.use_spatial_tiling = False\n\n    def enable_tiling(self, use_tiling: bool = True):\n        \"\"\"Enable or disable spatial tiling (alias for enable_spatial_tiling).\"\"\"\n        self.enable_spatial_tiling(use_tiling)\n\n    def disable_tiling(self):\n        \"\"\"Disable spatial tiling (alias for disable_spatial_tiling).\"\"\"\n        self.disable_spatial_tiling()\n\n    def enable_slicing(self):\n        \"\"\"Enable slicing for batch processing.\"\"\"\n        self.use_slicing = True\n\n    def disable_slicing(self):\n        \"\"\"Disable slicing for batch processing.\"\"\"\n        self.use_slicing = False\n\n    def blend_h(self, a: torch.Tensor, b: torch.Tensor, blend_extent: int) -> torch.Tensor:\n        \"\"\"\n        Blend two tensors horizontally with smooth transition.\n\n        Parameters\n        ----------\n        a : torch.Tensor\n            Left tensor.\n        b : torch.Tensor\n            Right tensor.\n        blend_extent : int\n            Number of columns to blend.\n        \"\"\"\n        blend_extent = min(a.shape[-1], b.shape[-1], blend_extent)\n        for x in range(blend_extent):\n            b[:, :, :, :, x] = a[:, :, :, :, -blend_extent + x] * (1 - x / blend_extent) + b[:, :, :, :, x] * (\n                x / blend_extent\n            )\n        return b\n\n    def blend_v(self, a: torch.Tensor, b: torch.Tensor, blend_extent: int) -> torch.Tensor:\n        \"\"\"\n        Blend two tensors vertically with smooth transition.\n\n        Parameters\n        ----------\n        a : torch.Tensor\n            Top tensor.\n        b : torch.Tensor\n            Bottom tensor.\n        blend_extent : int\n            Number of rows to blend.\n        \"\"\"\n        blend_extent = min(a.shape[-2], b.shape[-2], blend_extent)\n        for y in range(blend_extent):\n            b[:, :, :, y, :] = a[:, :, :, -blend_extent + y, :] * (1 - y / blend_extent) + b[:, :, :, y, :] * (\n                y / blend_extent\n            )\n        return b\n\n    def spatial_tiled_encode(self, x: torch.Tensor) -> torch.Tensor:\n        \"\"\"\n        Encode input using spatial tiling strategy.\n\n        Parameters\n        ----------\n        x : torch.Tensor\n            Input tensor of shape (B, C, T, H, W).\n        \"\"\"\n        B, C, T, H, W = x.shape\n        overlap_size = int(self.tile_sample_min_size * (1 - self.tile_overlap_factor))\n        blend_extent = int(self.tile_latent_min_size * self.tile_overlap_factor)\n        row_limit = self.tile_latent_min_size - blend_extent\n\n        rows = []\n        for i in range(0, H, overlap_size):\n            row = []\n            for j in range(0, W, overlap_size):\n                tile = x[:, :, :, i : i + self.tile_sample_min_size, j : j + self.tile_sample_min_size]\n                tile = self.encoder(tile)\n                row.append(tile)\n            rows.append(row)\n\n        result_rows = []\n        for i, row in enumerate(rows):\n            result_row = []\n            for j, tile in enumerate(row):\n                if i > 0:\n                    tile = self.blend_v(rows[i - 1][j], tile, blend_extent)\n                if j > 0:\n                    tile = self.blend_h(row[j - 1], tile, blend_extent)\n                result_row.append(tile[:, :, :, :row_limit, :row_limit])\n            result_rows.append(torch.cat(result_row, dim=-1))\n\n        moments = torch.cat(result_rows, dim=-2)\n        return moments\n\n    def spatial_tiled_decode(self, z: torch.Tensor) -> torch.Tensor:\n        \"\"\"\n        Decode latent using spatial tiling strategy.\n\n        Parameters\n        ----------\n        z : torch.Tensor\n            Latent tensor of shape (B, C, H, W).\n        \"\"\"\n        B, C, H, W = z.shape\n        overlap_size = int(self.tile_latent_min_size * (1 - self.tile_overlap_factor))\n        blend_extent = int(self.tile_sample_min_size * self.tile_overlap_factor)\n        row_limit = self.tile_sample_min_size - blend_extent\n\n        rows = []\n        for i in range(0, H, overlap_size):\n            row = []\n            for j in range(0, W, overlap_size):\n                tile = z[:, :, :, i : i + self.tile_latent_min_size, j : j + self.tile_latent_min_size]\n                decoded = self.decoder(tile)\n                row.append(decoded)\n            rows.append(row)\n\n        result_rows = []\n        for i, row in enumerate(rows):\n            result_row = []\n            for j, tile in enumerate(row):\n                if i > 0:\n                    tile = self.blend_v(rows[i - 1][j], tile, blend_extent)\n                if j > 0:\n                    tile = self.blend_h(row[j - 1], tile, blend_extent)\n                result_row.append(tile[:, :, :, :row_limit, :row_limit])\n            result_rows.append(torch.cat(result_row, dim=-1))\n\n        dec = torch.cat(result_rows, dim=-2)\n        return dec\n\n    def encode(self, x: Tensor, return_dict: bool = True):\n        \"\"\"\n        Encode input tensor to latent representation.\n\n        Parameters\n        ----------\n        x : Tensor\n            Input tensor.\n        return_dict : bool\n            Whether to return a dict.\n        \"\"\"\n        original_ndim = x.ndim\n        if original_ndim == 5:\n            x = x.squeeze(2)\n\n        def _encode(x):\n            if self.use_spatial_tiling and (\n                x.shape[-1] > self.tile_sample_min_size or x.shape[-2] > self.tile_sample_min_size\n            ):\n                return self.spatial_tiled_encode(x)\n            return self.encoder(x)\n\n        # Process with or without slicing\n        if self.use_slicing and x.shape[0] > 1:\n            encoded_slices = [_encode(x_slice) for x_slice in x.split(1)]\n            h = torch.cat(encoded_slices)\n        else:\n            h = _encode(x)\n\n        if original_ndim == 5:\n            h = h.unsqueeze(2)\n\n        posterior = DiagonalGaussianDistribution(h)\n\n        if not return_dict:\n            return (posterior,)\n\n        return AutoencoderKLOutput(latent_dist=posterior)\n\n    def decode(self, z: Tensor, return_dict: bool = True, generator=None):\n        \"\"\"\n        Decode latent representation to output tensor.\n\n        Parameters\n        ----------\n        z : Tensor\n            Latent tensor.\n        return_dict : bool\n            Whether to return a dict.\n        generator : unused\n            For compatibility.\n        \"\"\"\n        original_ndim = z.ndim\n        if original_ndim == 5:\n            z = z.squeeze(2)\n\n        def _decode(z):\n            if self.use_spatial_tiling and (\n                z.shape[-1] > self.tile_latent_min_size or z.shape[-2] > self.tile_latent_min_size\n            ):\n                return self.spatial_tiled_decode(z)\n            return self.decoder(z)\n\n        if self.use_slicing and z.shape[0] > 1:\n            decoded_slices = [_decode(z_slice) for z_slice in z.split(1)]\n            decoded = torch.cat(decoded_slices)\n        else:\n            decoded = _decode(z)\n\n        if original_ndim == 5:\n            decoded = decoded.unsqueeze(2)\n\n        if not return_dict:\n            return (decoded,)\n\n        return DecoderOutput(sample=decoded)\n\n    def forward(\n        self,\n        sample: torch.Tensor,\n        sample_posterior: bool = False,\n        return_posterior: bool = True,\n        return_dict: bool = True,\n    ):\n        \"\"\"\n        Forward pass through the VAE (Encode and Decode).\n\n        Parameters\n        ----------\n        sample : torch.Tensor\n            Input tensor.\n        sample_posterior : bool\n            Whether to sample from the posterior.\n        return_posterior : bool\n            Whether to return the posterior.\n        return_dict : bool\n            Whether to return a dict.\n        \"\"\"\n        posterior = self.encode(sample).latent_dist\n        z = posterior.sample() if sample_posterior else posterior.mode()\n        dec = self.decode(z).sample\n\n        if return_dict:\n            return DecoderOutput(sample=dec, posterior=posterior)\n        else:\n            return (dec, posterior)\n\n    def load_state_dict(self, state_dict, strict=True):\n        \"\"\"\n        Load state dict, handling possible 5D weight tensors.\n\n        Parameters\n        ----------\n        state_dict : dict\n            State dictionary.\n        strict : bool\n            Whether to strictly enforce that the keys in state_dict match the keys returned by this module's state_dict function.\n        \"\"\"\n        converted_state_dict = {}\n\n        for key, value in state_dict.items():\n            if 'weight' in key:\n                if len(value.shape) == 5 and value.shape[2] == 1:\n                    converted_state_dict[key] = value.squeeze(2)\n                else:\n                    converted_state_dict[key] = value\n            else:\n                converted_state_dict[key] = value\n\n        return super().load_state_dict(converted_state_dict, strict=strict)",
        "hyimage/models/vae/refiner_vae.py": "\"\"\"\nReference code\n[FLUX] https://github.com/black-forest-labs/flux/blob/main/src/flux/modules/autoencoder.py\n[DCAE] https://github.com/mit-han-lab/efficientvit/blob/master/efficientvit/models/efficientvit/dc_ae.py\n\"\"\"\n\nimport math\nimport random\nfrom dataclasses import dataclass\nfrom typing import Optional, Tuple, Union\n\nimport numpy as np\nimport torch\nimport torch.nn.functional as F\nfrom diffusers.configuration_utils import ConfigMixin, register_to_config\nfrom diffusers.models.modeling_outputs import AutoencoderKLOutput\nfrom diffusers.models.modeling_utils import ModelMixin\nfrom einops import rearrange\nfrom torch import Tensor, nn\n\nfrom .hunyuanimage_vae import BaseOutput, DiagonalGaussianDistribution\n\n\n@dataclass\nclass DecoderOutput(BaseOutput):\n    sample: torch.FloatTensor\n    posterior: Optional[DiagonalGaussianDistribution] = None\n\n\ndef swish(x: Tensor) -> Tensor:\n    return x * torch.sigmoid(x)\n\n\ndef forward_with_checkpointing(module, *inputs, use_checkpointing=False):\n    def create_custom_forward(module):\n        def custom_forward(*inputs):\n            return module(*inputs)\n\n        return custom_forward\n\n    if use_checkpointing:\n        return torch.utils.checkpoint.checkpoint(create_custom_forward(module), *inputs, use_reentrant=False)\n    else:\n        return module(*inputs)\n\n\n# Optimized implementation of CogVideoXSafeConv3d\n# https://github.com/huggingface/diffusers/blob/c9ff360966327ace3faad3807dc871a4e5447501/src/diffusers/models/autoencoders/autoencoder_kl_cogvideox.py#L38\nclass PatchCausalConv3d(nn.Conv3d):\n    def find_split_indices(self, seq_len, part_num):\n        ideal_interval = seq_len / part_num\n        possible_indices = list(range(0, seq_len, self.stride[0]))\n        selected_indices = []\n\n        for i in range(1, part_num):\n            closest = min(possible_indices, key=lambda x: abs(x - round(i * ideal_interval)))\n            if closest not in selected_indices:\n                selected_indices.append(closest)\n\n        merged_indices = []\n        prev_idx = 0\n        for idx in selected_indices:\n            if idx - prev_idx >= self.kernel_size[0]:\n                merged_indices.append(idx)\n                prev_idx = idx\n\n        return merged_indices\n\n    def forward(self, input):\n        T = input.shape[2]  # input: NCTHW\n        memory_count = torch.prod(torch.tensor(input.shape)).item() * 2 / 1024**3\n        if T > self.kernel_size[0] and memory_count > 2:\n            kernel_size = self.kernel_size[0]\n            part_num = int(memory_count / 2) + 1\n            split_indices = self.find_split_indices(T, part_num)\n            input_chunks = torch.tensor_split(input, split_indices, dim=2) if len(split_indices) > 0 else [input]\n            if kernel_size > 1:\n                input_chunks = [input_chunks[0]] + [\n                    torch.cat(\n                        (\n                            input_chunks[i - 1][:, :, -kernel_size + 1 :],\n                            input_chunks[i],\n                        ),\n                        dim=2,\n                    )\n                    for i in range(1, len(input_chunks))\n                ]\n\n            output_chunks = []\n            for input_chunk in input_chunks:\n                output_chunks.append(super().forward(input_chunk))\n            output = torch.cat(output_chunks, dim=2)\n            return output\n        else:\n            return super().forward(input)\n\n\nclass CausalConv3d(nn.Module):\n    def __init__(\n        self,\n        chan_in,\n        chan_out,\n        kernel_size: Union[int, Tuple[int, int, int]],\n        stride: Union[int, Tuple[int, int, int]] = 1,\n        dilation: Union[int, Tuple[int, int, int]] = 1,\n        pad_mode=\"replicate\",\n        disable_causal=False,\n        enable_patch_conv=False,\n        **kwargs,\n    ):\n        super().__init__()\n\n        self.pad_mode = pad_mode\n        if disable_causal:\n            padding = (\n                kernel_size // 2,\n                kernel_size // 2,\n                kernel_size // 2,\n                kernel_size // 2,\n                kernel_size // 2,\n                kernel_size // 2,\n            )\n        else:\n            padding = (\n                kernel_size // 2,\n                kernel_size // 2,\n                kernel_size // 2,\n                kernel_size // 2,\n                kernel_size - 1,\n                0,\n            )  # W, H, T\n        self.time_causal_padding = padding\n\n        if enable_patch_conv:\n            self.conv = PatchCausalConv3d(\n                chan_in,\n                chan_out,\n                kernel_size,\n                stride=stride,\n                dilation=dilation,\n                **kwargs,\n            )\n        else:\n            self.conv = nn.Conv3d(\n                chan_in,\n                chan_out,\n                kernel_size,\n                stride=stride,\n                dilation=dilation,\n                **kwargs,\n            )\n\n    def forward(self, x):\n        x = F.pad(x, self.time_causal_padding, mode=self.pad_mode)\n        return self.conv(x)\n\n\nclass RMS_norm(nn.Module):\n    def __init__(self, dim, channel_first=True, images=True, bias=False):\n        super().__init__()\n        broadcastable_dims = (1, 1, 1) if not images else (1, 1)\n        shape = (dim, *broadcastable_dims) if channel_first else (dim,)\n\n        self.channel_first = channel_first\n        self.scale = dim**0.5\n        self.gamma = nn.Parameter(torch.ones(shape))\n        self.bias = nn.Parameter(torch.zeros(shape)) if bias else 0.0\n\n    def forward(self, x):\n        return F.normalize(x, dim=(1 if self.channel_first else -1)) * self.scale * self.gamma + self.bias\n\n\nclass Conv3d(nn.Conv3d):\n    \"\"\"Perform Conv3d on patches with numerical differences from nn.Conv3d within 1e-5. Only symmetric padding is supported.\"\"\"\n\n    def forward(self, input):\n        B, C, T, H, W = input.shape\n        memory_count = (C * T * H * W) * 2 / 1024**3\n        if memory_count > 2:\n            n_split = math.ceil(memory_count / 2)\n            assert n_split >= 2\n            chunks = torch.chunk(input, chunks=n_split, dim=-3)\n            padded_chunks = []\n            for i in range(len(chunks)):\n                if self.padding[0] > 0:\n                    padded_chunk = F.pad(\n                        chunks[i],\n                        (0, 0, 0, 0, self.padding[0], self.padding[0]),\n                        mode=\"constant\" if self.padding_mode == \"zeros\" else self.padding_mode,\n                        value=0,\n                    )\n                    if i > 0:\n                        padded_chunk[:, :, : self.padding[0]] = chunks[i - 1][:, :, -self.padding[0] :]\n                    if i < len(chunks) - 1:\n                        padded_chunk[:, :, -self.padding[0] :] = chunks[i + 1][:, :, : self.padding[0]]\n                else:\n                    padded_chunk = chunks[i]\n                padded_chunks.append(padded_chunk)\n            padding_bak = self.padding\n            self.padding = (0, self.padding[1], self.padding[2])\n            outputs = []\n            for i in range(len(padded_chunks)):\n                outputs.append(super().forward(padded_chunks[i]))\n            self.padding = padding_bak\n            return torch.cat(outputs, dim=-3)\n        else:\n            return super().forward(input)\n\n\ndef prepare_causal_attention_mask(n_frame: int, n_hw: int, dtype, device, batch_size: int = None):\n    seq_len = n_frame * n_hw\n    mask = torch.full((seq_len, seq_len), float(\"-inf\"), dtype=dtype, device=device)\n    for i in range(seq_len):\n        i_frame = i // n_hw\n        mask[i, : (i_frame + 1) * n_hw] = 0\n    if batch_size is not None:\n        mask = mask.unsqueeze(0).expand(batch_size, -1, -1)\n    return mask\n\n\nclass AttnBlock(nn.Module):\n    def __init__(self, in_channels: int):\n        super().__init__()\n        self.in_channels = in_channels\n\n        # self.norm = nn.GroupNorm(num_groups=32, num_channels=in_channels, eps=1e-6, affine=True)\n        self.norm = RMS_norm(in_channels, images=False)\n\n        self.q = Conv3d(in_channels, in_channels, kernel_size=1)\n        self.k = Conv3d(in_channels, in_channels, kernel_size=1)\n        self.v = Conv3d(in_channels, in_channels, kernel_size=1)\n        self.proj_out = Conv3d(in_channels, in_channels, kernel_size=1)\n\n    def attention(self, h_: Tensor) -> Tensor:\n        h_ = self.norm(h_)\n        q = self.q(h_)\n        k = self.k(h_)\n        v = self.v(h_)\n\n        b, c, f, h, w = q.shape\n        q = rearrange(q, \"b c f h w -> b 1 (f h w) c\").contiguous()\n        k = rearrange(k, \"b c f h w -> b 1 (f h w) c\").contiguous()\n        v = rearrange(v, \"b c f h w -> b 1 (f h w) c\").contiguous()\n        attention_mask = prepare_causal_attention_mask(f, h * w, h_.dtype, h_.device, batch_size=b)\n        h_ = nn.functional.scaled_dot_product_attention(q, k, v, attn_mask=attention_mask.unsqueeze(1))\n\n        return rearrange(h_, \"b 1 (f h w) c -> b c f h w\", f=f, h=h, w=w, c=c, b=b)\n\n    def forward(self, x: Tensor) -> Tensor:\n        return x + self.proj_out(self.attention(x))\n\n\nclass ResnetBlock(nn.Module):\n    def __init__(self, in_channels: int, out_channels: int):\n        super().__init__()\n        self.in_channels = in_channels\n        out_channels = in_channels if out_channels is None else out_channels\n        self.out_channels = out_channels\n\n        # self.norm1 = nn.GroupNorm(num_groups=32, num_channels=in_channels, eps=1e-6, affine=True)\n        # self.conv1 = Conv3d(in_channels, out_channels, kernel_size=3, stride=1, padding=1)\n        self.norm1 = RMS_norm(in_channels, images=False)\n        self.conv1 = CausalConv3d(in_channels, out_channels, kernel_size=3)\n\n        # self.norm2 = nn.GroupNorm(num_groups=32, num_channels=out_channels, eps=1e-6, affine=True)\n        # self.conv2 = Conv3d(out_channels, out_channels, kernel_size=3, stride=1, padding=1)\n        self.norm2 = RMS_norm(out_channels, images=False)\n        self.conv2 = CausalConv3d(out_channels, out_channels, kernel_size=3)\n        if self.in_channels != self.out_channels:\n            self.nin_shortcut = Conv3d(in_channels, out_channels, kernel_size=1, stride=1, padding=0)\n\n    def forward(self, x):\n        h = x\n        h = self.norm1(h)\n        h = swish(h)\n        h = self.conv1(h)\n\n        h = self.norm2(h)\n        h = swish(h)\n        h = self.conv2(h)\n\n        if self.in_channels != self.out_channels:\n            x = self.nin_shortcut(x)\n        return x + h\n\n\nclass Downsample(nn.Module):\n    def __init__(self, in_channels: int, add_temporal_downsample: bool = True):\n        super().__init__()\n        self.add_temporal_downsample = add_temporal_downsample\n        stride = (2, 2, 2) if add_temporal_downsample else (1, 2, 2)  # THW\n        # no asymmetric padding in torch conv, must do it ourselves\n        # self.conv = Conv3d(in_channels, in_channels, kernel_size=3, stride=stride, padding=0)\n        self.conv = CausalConv3d(in_channels, in_channels, kernel_size=3)\n\n    def forward(self, x: Tensor):\n        spatial_pad = (0, 1, 0, 1, 0, 0)  # WHT\n        x = nn.functional.pad(x, spatial_pad, mode=\"constant\", value=0)\n\n        temporal_pad = (0, 0, 0, 0, 0, 1) if self.add_temporal_downsample else (0, 0, 0, 0, 1, 1)\n        x = nn.functional.pad(x, temporal_pad, mode=\"replicate\")\n\n        x = self.conv(x)\n        return x\n\n\nclass DownsampleDCAE(nn.Module):\n    def __init__(self, in_channels: int, out_channels: int, add_temporal_downsample: bool = True):\n        super().__init__()\n        factor = 2 * 2 * 2 if add_temporal_downsample else 1 * 2 * 2\n        assert out_channels % factor == 0\n        # self.conv = Conv3d(in_channels, out_channels // factor, kernel_size=3, stride=1, padding=1)\n        self.conv = CausalConv3d(in_channels, out_channels // factor, kernel_size=3)\n\n        self.add_temporal_downsample = add_temporal_downsample\n        self.group_size = factor * in_channels // out_channels\n\n    def forward(self, x: Tensor):\n        r1 = 2 if self.add_temporal_downsample else 1\n        h = self.conv(x)\n        if self.add_temporal_downsample:\n            h_first = h[:, :, :1, :, :]\n            h_first = rearrange(h_first, \"b c f (h r2) (w r3) -> b (r2 r3 c) f h w\", r2=2, r3=2)\n            h_first = torch.cat([h_first, h_first], dim=1)\n            h_next = h[:, :, 1:, :, :]\n            h_next = rearrange(\n                h_next,\n                \"b c (f r1) (h r2) (w r3) -> b (r1 r2 r3 c) f h w\",\n                r1=r1,\n                r2=2,\n                r3=2,\n            )\n            h = torch.cat([h_first, h_next], dim=2)\n            # shortcut computation\n            x_first = x[:, :, :1, :, :]\n            x_first = rearrange(x_first, \"b c f (h r2) (w r3) -> b (r2 r3 c) f h w\", r2=2, r3=2)\n            B, C, T, H, W = x_first.shape\n            x_first = x_first.view(B, h.shape[1], self.group_size // 2, T, H, W).mean(dim=2)\n\n            x_next = x[:, :, 1:, :, :]\n            x_next = rearrange(\n                x_next,\n                \"b c (f r1) (h r2) (w r3) -> b (r1 r2 r3 c) f h w\",\n                r1=r1,\n                r2=2,\n                r3=2,\n            )\n            B, C, T, H, W = x_next.shape\n            x_next = x_next.view(B, h.shape[1], self.group_size, T, H, W).mean(dim=2)\n            shortcut = torch.cat([x_first, x_next], dim=2)\n        else:\n            h = rearrange(h, \"b c (f r1) (h r2) (w r3) -> b (r1 r2 r3 c) f h w\", r1=r1, r2=2, r3=2)\n            shortcut = rearrange(x, \"b c (f r1) (h r2) (w r3) -> b (r1 r2 r3 c) f h w\", r1=r1, r2=2, r3=2)\n            B, C, T, H, W = shortcut.shape\n            shortcut = shortcut.view(B, h.shape[1], self.group_size, T, H, W).mean(dim=2)\n\n        return h + shortcut\n\n\nclass Upsample(nn.Module):\n    def __init__(self, in_channels: int, add_temporal_upsample: bool = True):\n        super().__init__()\n        self.add_temporal_upsample = add_temporal_upsample\n        self.scale_factor = (2, 2, 2) if add_temporal_upsample else (1, 2, 2)  # THW\n        # self.conv = Conv3d(in_channels, in_channels, kernel_size=3, stride=1, padding=1)\n        self.conv = CausalConv3d(in_channels, in_channels, kernel_size=3)\n\n    def forward(self, x: Tensor):\n        x = nn.functional.interpolate(x, scale_factor=self.scale_factor, mode=\"nearest\")\n        x = self.conv(x)\n        return x\n\n\nclass UpsampleDCAE(nn.Module):\n    def __init__(self, in_channels: int, out_channels: int, add_temporal_upsample: bool = True):\n        super().__init__()\n        factor = 2 * 2 * 2 if add_temporal_upsample else 1 * 2 * 2\n        # self.conv = Conv3d(in_channels, out_channels * factor, kernel_size=3, stride=1, padding=1)\n        self.conv = CausalConv3d(in_channels, out_channels * factor, kernel_size=3)\n\n        self.add_temporal_upsample = add_temporal_upsample\n        self.repeats = factor * out_channels // in_channels\n\n    def forward(self, x: Tensor):\n        r1 = 2 if self.add_temporal_upsample else 1\n        h = self.conv(x)\n        if self.add_temporal_upsample:\n            h_first = h[:, :, :1, :, :]\n            h_first = rearrange(h_first, \"b (r2 r3 c) f h w -> b c f (h r2) (w r3)\", r2=2, r3=2)\n            h_first = h_first[:, : h_first.shape[1] // 2]\n\n            h_next = h[:, :, 1:, :, :]\n            h_next = rearrange(\n                h_next,\n                \"b (r1 r2 r3 c) f h w -> b c (f r1) (h r2) (w r3)\",\n                r1=r1,\n                r2=2,\n                r3=2,\n            )\n            h = torch.cat([h_first, h_next], dim=2)\n\n            # shortcut computation\n            x_first = x[:, :, :1, :, :]\n            x_first = rearrange(x_first, \"b (r2 r3 c) f h w -> b c f (h r2) (w r3)\", r2=2, r3=2)\n            x_first = x_first.repeat_interleave(repeats=self.repeats // 2, dim=1)\n\n            x_next = x[:, :, 1:, :, :]\n            x_next = rearrange(\n                x_next,\n                \"b (r1 r2 r3 c) f h w -> b c (f r1) (h r2) (w r3)\",\n                r1=r1,\n                r2=2,\n                r3=2,\n            )\n            x_next = x_next.repeat_interleave(repeats=self.repeats, dim=1)\n            shortcut = torch.cat([x_first, x_next], dim=2)\n\n        else:\n            h = rearrange(h, \"b (r1 r2 r3 c) f h w -> b c (f r1) (h r2) (w r3)\", r1=r1, r2=2, r3=2)\n            shortcut = x.repeat_interleave(repeats=self.repeats, dim=1)\n            shortcut = rearrange(\n                shortcut,\n                \"b (r1 r2 r3 c) f h w -> b c (f r1) (h r2) (w r3)\",\n                r1=r1,\n                r2=2,\n                r3=2,\n            )\n        return h + shortcut\n\n\nclass Encoder(nn.Module):\n    def __init__(\n        self,\n        in_channels: int,\n        z_channels: int,\n        block_out_channels: Tuple[int, ...],\n        num_res_blocks: int,\n        ffactor_spatial: int,\n        ffactor_temporal: int,\n        downsample_match_channel: bool = True,\n    ):\n        super().__init__()\n        assert block_out_channels[-1] % (2 * z_channels) == 0\n\n        self.z_channels = z_channels\n        self.block_out_channels = block_out_channels\n        self.num_res_blocks = num_res_blocks\n\n        # downsampling\n        # self.conv_in = Conv3d(in_channels, block_out_channels[0], kernel_size=3, stride=1, padding=1)\n        self.conv_in = CausalConv3d(in_channels, block_out_channels[0], kernel_size=3)\n\n        self.down = nn.ModuleList()\n        block_in = block_out_channels[0]\n        for i_level, ch in enumerate(block_out_channels):\n            block = nn.ModuleList()\n            block_out = ch\n            for _ in range(self.num_res_blocks):\n                block.append(ResnetBlock(in_channels=block_in, out_channels=block_out))\n                block_in = block_out\n            down = nn.Module()\n            down.block = block\n\n            add_spatial_downsample = bool(i_level < np.log2(ffactor_spatial))\n            add_temporal_downsample = add_spatial_downsample and bool(\n                i_level >= np.log2(ffactor_spatial // ffactor_temporal)\n            )\n            if add_spatial_downsample or add_temporal_downsample:\n                assert i_level < len(block_out_channels) - 1\n                block_out = block_out_channels[i_level + 1] if downsample_match_channel else block_in\n                down.downsample = DownsampleDCAE(block_in, block_out, add_temporal_downsample)\n                block_in = block_out\n            self.down.append(down)\n\n        # middle\n        self.mid = nn.Module()\n        self.mid.block_1 = ResnetBlock(in_channels=block_in, out_channels=block_in)\n        self.mid.attn_1 = AttnBlock(block_in)\n        self.mid.block_2 = ResnetBlock(in_channels=block_in, out_channels=block_in)\n\n        # end\n        # self.norm_out = nn.GroupNorm(num_groups=32, num_channels=block_in, eps=1e-6, affine=True)\n        # self.conv_out = Conv3d(block_in, 2 * z_channels, kernel_size=3, stride=1, padding=1)\n        self.norm_out = RMS_norm(block_in, images=False)\n        self.conv_out = CausalConv3d(block_in, 2 * z_channels, kernel_size=3)\n\n        self.gradient_checkpointing = False\n\n    def forward(self, x: Tensor) -> Tensor:\n        use_checkpointing = bool(self.training and self.gradient_checkpointing)\n\n        # downsampling\n        h = self.conv_in(x)\n        for i_level in range(len(self.block_out_channels)):\n            for i_block in range(self.num_res_blocks):\n                h = forward_with_checkpointing(\n                    self.down[i_level].block[i_block],\n                    h,\n                    use_checkpointing=use_checkpointing,\n                )\n            if hasattr(self.down[i_level], \"downsample\"):\n                h = forward_with_checkpointing(\n                    self.down[i_level].downsample,\n                    h,\n                    use_checkpointing=use_checkpointing,\n                )\n\n        # middle\n        h = forward_with_checkpointing(self.mid.block_1, h, use_checkpointing=use_checkpointing)\n        h = forward_with_checkpointing(self.mid.attn_1, h, use_checkpointing=use_checkpointing)\n        h = forward_with_checkpointing(self.mid.block_2, h, use_checkpointing=use_checkpointing)\n\n        # end\n        group_size = self.block_out_channels[-1] // (2 * self.z_channels)\n        shortcut = rearrange(h, \"b (c r) f h w -> b c r f h w\", r=group_size).mean(dim=2)\n        h = self.norm_out(h)\n        h = swish(h)\n        h = self.conv_out(h)\n        h += shortcut\n        return h\n\n\nclass Decoder(nn.Module):\n    def __init__(\n        self,\n        z_channels: int,\n        out_channels: int,\n        block_out_channels: Tuple[int, ...],\n        num_res_blocks: int,\n        ffactor_spatial: int,\n        ffactor_temporal: int,\n        upsample_match_channel: bool = True,\n    ):\n        super().__init__()\n        assert block_out_channels[0] % z_channels == 0\n\n        self.z_channels = z_channels\n        self.block_out_channels = block_out_channels\n        self.num_res_blocks = num_res_blocks\n\n        # z to block_in\n        block_in = block_out_channels[0]\n        # self.conv_in = Conv3d(z_channels, block_in, kernel_size=3, stride=1, padding=1)\n        self.conv_in = CausalConv3d(z_channels, block_in, kernel_size=3)\n\n        # middle\n        self.mid = nn.Module()\n        self.mid.block_1 = ResnetBlock(in_channels=block_in, out_channels=block_in)\n        self.mid.attn_1 = AttnBlock(block_in)\n        self.mid.block_2 = ResnetBlock(in_channels=block_in, out_channels=block_in)\n\n        # upsampling\n        self.up = nn.ModuleList()\n        for i_level, ch in enumerate(block_out_channels):\n            block = nn.ModuleList()\n            block_out = ch\n            for _ in range(self.num_res_blocks + 1):\n                block.append(ResnetBlock(in_channels=block_in, out_channels=block_out))\n                block_in = block_out\n            up = nn.Module()\n            up.block = block\n\n            add_spatial_upsample = bool(i_level < np.log2(ffactor_spatial))\n            add_temporal_upsample = bool(i_level < np.log2(ffactor_temporal))\n            if add_spatial_upsample or add_temporal_upsample:\n                assert i_level < len(block_out_channels) - 1\n                block_out = block_out_channels[i_level + 1] if upsample_match_channel else block_in\n                up.upsample = UpsampleDCAE(block_in, block_out, add_temporal_upsample)\n                block_in = block_out\n            self.up.append(up)\n\n        # end\n        # self.norm_out = nn.GroupNorm(num_groups=32, num_channels=block_in, eps=1e-6, affine=True)\n        # self.conv_out = Conv3d(block_in, out_channels, kernel_size=3, stride=1, padding=1)\n\n        self.norm_out = RMS_norm(block_in, images=False)\n        self.conv_out = CausalConv3d(block_in, out_channels, kernel_size=3)\n\n        self.gradient_checkpointing = False\n\n    def forward(self, z: Tensor) -> Tensor:\n        use_checkpointing = bool(self.training and self.gradient_checkpointing)\n\n        # z to block_in\n        repeats = self.block_out_channels[0] // (self.z_channels)\n        h = self.conv_in(z) + z.repeat_interleave(repeats=repeats, dim=1)\n\n        # middle\n        h = forward_with_checkpointing(self.mid.block_1, h, use_checkpointing=use_checkpointing)\n        h = forward_with_checkpointing(self.mid.attn_1, h, use_checkpointing=use_checkpointing)\n        h = forward_with_checkpointing(self.mid.block_2, h, use_checkpointing=use_checkpointing)\n\n        # upsampling\n        for i_level in range(len(self.block_out_channels)):\n            for i_block in range(self.num_res_blocks + 1):\n                h = forward_with_checkpointing(\n                    self.up[i_level].block[i_block],\n                    h,\n                    use_checkpointing=use_checkpointing,\n                )\n            if hasattr(self.up[i_level], \"upsample\"):\n                h = forward_with_checkpointing(self.up[i_level].upsample, h, use_checkpointing=use_checkpointing)\n\n        # end\n        h = self.norm_out(h)\n        h = swish(h)\n        h = self.conv_out(h)\n        return h\n\n\nclass AutoencoderKLConv3D(ModelMixin, ConfigMixin):\n    _supports_gradient_checkpointing = True\n\n    @register_to_config\n    def __init__(\n        self,\n        in_channels: int,\n        out_channels: int,\n        latent_channels: int,\n        block_out_channels: Tuple[int, ...],\n        layers_per_block: int,\n        ffactor_spatial: int,\n        ffactor_temporal: int,\n        sample_size: int,\n        sample_tsize: int,\n        scaling_factor: float = None,\n        shift_factor: Optional[float] = None,\n        downsample_match_channel: bool = True,\n        upsample_match_channel: bool = True,\n    ):\n        super().__init__()\n        self.ffactor_spatial = ffactor_spatial\n        self.ffactor_temporal = ffactor_temporal\n        self.scaling_factor = scaling_factor\n        self.shift_factor = shift_factor\n\n        self.encoder = Encoder(\n            in_channels=in_channels,\n            z_channels=latent_channels,\n            block_out_channels=block_out_channels,\n            num_res_blocks=layers_per_block,\n            ffactor_spatial=ffactor_spatial,\n            ffactor_temporal=ffactor_temporal,\n            downsample_match_channel=downsample_match_channel,\n        )\n        self.decoder = Decoder(\n            z_channels=latent_channels,\n            out_channels=out_channels,\n            block_out_channels=list(reversed(block_out_channels)),\n            num_res_blocks=layers_per_block,\n            ffactor_spatial=ffactor_spatial,\n            ffactor_temporal=ffactor_temporal,\n            upsample_match_channel=upsample_match_channel,\n        )\n\n        self.use_slicing = False\n        self.use_spatial_tiling = False\n        self.use_temporal_tiling = False\n        self.use_tiling_during_training = False\n\n        # only relevant if vae tiling is enabled\n        self.tile_sample_min_size = sample_size\n        self.tile_latent_min_size = sample_size // ffactor_spatial\n        self.tile_sample_min_tsize = sample_tsize\n        self.tile_latent_min_tsize = sample_tsize // ffactor_temporal\n        self.tile_overlap_factor = 0.25\n\n    def _set_gradient_checkpointing(self, module, value=False):\n        if isinstance(module, (Encoder, Decoder)):\n            module.gradient_checkpointing = value\n\n    def enable_tiling_during_training(self, use_tiling: bool = True):\n        self.use_tiling_during_training = use_tiling\n\n    def disable_tiling_during_training(self):\n        self.enable_tiling_during_training(False)\n\n    def enable_temporal_tiling(self, use_tiling: bool = True):\n        self.use_temporal_tiling = use_tiling\n\n    def disable_temporal_tiling(self):\n        self.enable_temporal_tiling(False)\n\n    def enable_spatial_tiling(self, use_tiling: bool = True):\n        self.use_spatial_tiling = use_tiling\n\n    def disable_spatial_tiling(self):\n        self.enable_spatial_tiling(False)\n\n    def enable_tiling(self, use_tiling: bool = True):\n        self.enable_spatial_tiling(use_tiling)\n\n    def disable_tiling(self):\n        self.disable_spatial_tiling()\n\n    def enable_slicing(self):\n        self.use_slicing = True\n\n    def disable_slicing(self):\n        self.use_slicing = False\n\n    def blend_h(self, a: torch.Tensor, b: torch.Tensor, blend_extent: int):\n        blend_extent = min(a.shape[-1], b.shape[-1], blend_extent)\n        for x in range(blend_extent):\n            b[:, :, :, :, x] = a[:, :, :, :, -blend_extent + x] * (1 - x / blend_extent) + b[:, :, :, :, x] * (\n                x / blend_extent\n            )\n        return b\n\n    def blend_v(self, a: torch.Tensor, b: torch.Tensor, blend_extent: int):\n        blend_extent = min(a.shape[-2], b.shape[-2], blend_extent)\n        for y in range(blend_extent):\n            b[:, :, :, y, :] = a[:, :, :, -blend_extent + y, :] * (1 - y / blend_extent) + b[:, :, :, y, :] * (\n                y / blend_extent\n            )\n        return b\n\n    def blend_t(self, a: torch.Tensor, b: torch.Tensor, blend_extent: int):\n        blend_extent = min(a.shape[-3], b.shape[-3], blend_extent)\n        for x in range(blend_extent):\n            b[:, :, x, :, :] = a[:, :, -blend_extent + x, :, :] * (1 - x / blend_extent) + b[:, :, x, :, :] * (\n                x / blend_extent\n            )\n        return b\n\n    def spatial_tiled_encode(self, x: torch.Tensor):\n        B, C, T, H, W = x.shape\n        overlap_size = int(self.tile_sample_min_size * (1 - self.tile_overlap_factor))  # 256 * (1 - 0.25) = 192\n        blend_extent = int(self.tile_latent_min_size * self.tile_overlap_factor)  # 8 * 0.25 = 2\n        row_limit = self.tile_latent_min_size - blend_extent  # 8 - 2 = 6\n\n        rows = []\n        for i in range(0, H, overlap_size):\n            row = []\n            for j in range(0, W, overlap_size):\n                tile = x[\n                    :,\n                    :,\n                    :,\n                    i : i + self.tile_sample_min_size,\n                    j : j + self.tile_sample_min_size,\n                ]\n                tile = self.encoder(tile)\n                row.append(tile)\n            rows.append(row)\n        result_rows = []\n        for i, row in enumerate(rows):\n            result_row = []\n            for j, tile in enumerate(row):\n                if i > 0:\n                    tile = self.blend_v(rows[i - 1][j], tile, blend_extent)\n                if j > 0:\n                    tile = self.blend_h(row[j - 1], tile, blend_extent)\n                result_row.append(tile[:, :, :, :row_limit, :row_limit])\n            result_rows.append(torch.cat(result_row, dim=-1))\n        moments = torch.cat(result_rows, dim=-2)\n        return moments\n\n    def temporal_tiled_encode(self, x: torch.Tensor):\n        B, C, T, H, W = x.shape\n        overlap_size = int(self.tile_sample_min_tsize * (1 - self.tile_overlap_factor))  # 64 * (1 - 0.25) = 48\n        blend_extent = int(self.tile_latent_min_tsize * self.tile_overlap_factor)  # 8 * 0.25 = 2\n        t_limit = self.tile_latent_min_tsize - blend_extent  # 8 - 2 = 6\n\n        row = []\n        for i in range(0, T, overlap_size):\n            tile = x[:, :, i : i + self.tile_sample_min_tsize + 1, :, :]\n            if self.use_spatial_tiling and (\n                tile.shape[-1] > self.tile_sample_min_size or tile.shape[-2] > self.tile_sample_min_size\n            ):\n                tile = self.spatial_tiled_encode(tile)\n            else:\n                tile = self.encoder(tile)\n            if i > 0:\n                tile = tile[:, :, 1:, :, :]\n            row.append(tile)\n        result_row = []\n        for i, tile in enumerate(row):\n            if i > 0:\n                tile = self.blend_t(row[i - 1], tile, blend_extent)\n                result_row.append(tile[:, :, :t_limit, :, :])\n            else:\n                result_row.append(tile[:, :, : t_limit + 1, :, :])\n        moments = torch.cat(result_row, dim=-3)\n        return moments\n\n    def spatial_tiled_decode(self, z: torch.Tensor):\n        B, C, T, H, W = z.shape\n        overlap_size = int(self.tile_latent_min_size * (1 - self.tile_overlap_factor))  # 8 * (1 - 0.25) = 6\n        blend_extent = int(self.tile_sample_min_size * self.tile_overlap_factor)  # 256 * 0.25 = 64\n        row_limit = self.tile_sample_min_size - blend_extent  # 256 - 64 = 192\n\n        rows = []\n        for i in range(0, H, overlap_size):\n            row = []\n            for j in range(0, W, overlap_size):\n                tile = z[\n                    :,\n                    :,\n                    :,\n                    i : i + self.tile_latent_min_size,\n                    j : j + self.tile_latent_min_size,\n                ]\n                decoded = self.decoder(tile)\n                row.append(decoded)\n            rows.append(row)\n\n        result_rows = []\n        for i, row in enumerate(rows):\n            result_row = []\n            for j, tile in enumerate(row):\n                if i > 0:\n                    tile = self.blend_v(rows[i - 1][j], tile, blend_extent)\n                if j > 0:\n                    tile = self.blend_h(row[j - 1], tile, blend_extent)\n                result_row.append(tile[:, :, :, :row_limit, :row_limit])\n            result_rows.append(torch.cat(result_row, dim=-1))\n        dec = torch.cat(result_rows, dim=-2)\n        return dec\n\n    def temporal_tiled_decode(self, z: torch.Tensor):\n        B, C, T, H, W = z.shape\n        overlap_size = int(self.tile_latent_min_tsize * (1 - self.tile_overlap_factor))  # 8 * (1 - 0.25) = 6\n        blend_extent = int(self.tile_sample_min_tsize * self.tile_overlap_factor)  # 64 * 0.25 = 16\n        t_limit = self.tile_sample_min_tsize - blend_extent  # 64 - 16 = 48\n        assert 0 < overlap_size < self.tile_latent_min_tsize\n\n        row = []\n        for i in range(0, T, overlap_size):\n            tile = z[:, :, i : i + self.tile_latent_min_tsize + 1, :, :]\n            if self.use_spatial_tiling and (\n                tile.shape[-1] > self.tile_latent_min_size or tile.shape[-2] > self.tile_latent_min_size\n            ):\n                decoded = self.spatial_tiled_decode(tile)\n            else:\n                decoded = self.decoder(tile)\n            if i > 0:\n                decoded = decoded[:, :, 1:, :, :]\n            row.append(decoded)\n\n        result_row = []\n        for i, tile in enumerate(row):\n            if i > 0:\n                tile = self.blend_t(row[i - 1], tile, blend_extent)\n                result_row.append(tile[:, :, :t_limit, :, :])\n            else:\n                result_row.append(tile[:, :, : t_limit + 1, :, :])\n        dec = torch.cat(result_row, dim=-3)\n        return dec\n\n    def encode(self, x: Tensor, return_dict: bool = True):\n        def _encode(x):\n            if self.use_temporal_tiling and x.shape[-3] > self.tile_sample_min_tsize:\n                return self.temporal_tiled_encode(x)\n            if self.use_spatial_tiling and (\n                x.shape[-1] > self.tile_sample_min_size or x.shape[-2] > self.tile_sample_min_size\n            ):\n                return self.spatial_tiled_encode(x)\n            return self.encoder(x)\n\n        assert len(x.shape) == 5  # (B, C, T, H, W)\n\n        if self.use_slicing and x.shape[0] > 1:\n            encoded_slices = [_encode(x_slice) for x_slice in x.split(1)]\n            h = torch.cat(encoded_slices)\n        else:\n            h = _encode(x)\n        posterior = DiagonalGaussianDistribution(h)\n\n        if not return_dict:\n            return (posterior,)\n\n        return AutoencoderKLOutput(latent_dist=posterior)\n\n    def decode(self, z: Tensor, return_dict: bool = True, generator=None):\n        def _decode(z):\n            if self.use_temporal_tiling and z.shape[-3] > self.tile_latent_min_tsize:\n                return self.temporal_tiled_decode(z)\n            if self.use_spatial_tiling and (\n                z.shape[-1] > self.tile_latent_min_size or z.shape[-2] > self.tile_latent_min_size\n            ):\n                return self.spatial_tiled_decode(z)\n            return self.decoder(z)\n\n        if self.use_slicing and z.shape[0] > 1:\n            decoded_slices = [_decode(z_slice) for z_slice in z.split(1)]\n            decoded = torch.cat(decoded_slices)\n        else:\n            decoded = _decode(z)\n\n        # if z.shape[-3] == 1:\n        #     decoded = decoded[:, :, -1:]\n\n        if not return_dict:\n            return (decoded,)\n\n        return DecoderOutput(sample=decoded)\n\n    def forward(\n        self,\n        sample: torch.Tensor,\n        sample_posterior: bool = False,\n        return_posterior: bool = True,\n        return_dict: bool = True,\n    ):\n        posterior = self.encode(sample).latent_dist\n        z = posterior.sample() if sample_posterior else posterior.mode()\n        dec = self.decode(z).sample\n        return DecoderOutput(sample=dec, posterior=posterior) if return_dict else (dec, posterior)\n\n    def random_reset_tiling(self, x: torch.Tensor):\n        if x.shape[-3] == 1:\n            self.disable_spatial_tiling()\n            self.disable_temporal_tiling()\n            return\n\n        min_sample_size = int(1 / self.tile_overlap_factor) * self.ffactor_spatial\n        min_sample_tsize = int(1 / self.tile_overlap_factor) * self.ffactor_temporal\n        sample_size = random.choice([None, 1 * min_sample_size, 2 * min_sample_size, 3 * min_sample_size])\n        if sample_size is None:\n            self.disable_spatial_tiling()\n        else:\n            self.tile_sample_min_size = sample_size\n            self.tile_latent_min_size = sample_size // self.ffactor_spatial\n            self.enable_spatial_tiling()\n\n        sample_tsize = random.choice([None, 1 * min_sample_tsize, 2 * min_sample_tsize, 3 * min_sample_tsize])\n        if sample_tsize is None:\n            self.disable_temporal_tiling()\n        else:\n            self.tile_sample_min_tsize = sample_tsize\n            self.tile_latent_min_tsize = sample_tsize // self.ffactor_temporal\n            self.enable_temporal_tiling()\n"
    }
}