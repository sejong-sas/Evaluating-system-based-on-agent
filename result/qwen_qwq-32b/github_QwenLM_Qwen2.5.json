{
    "repo": "QwenLM/Qwen2.5",
    "branch": "main",
    "files": [
        ".github/ISSUE_TEMPLATE/bug_report.yml",
        ".github/ISSUE_TEMPLATE/config.yml",
        ".github/workflows/inactive.yml",
        ".gitignore",
        ".readthedocs.yaml",
        "Qwen3_Technical_Report.pdf",
        "README.md",
        "docker/Dockerfile-cu121",
        "docker/docker_cli_demo.sh",
        "docker/docker_web_demo.sh",
        "docs/Makefile",
        "docs/README.md",
        "docs/locales/zh_CN/LC_MESSAGES/deployment/dstack.po",
        "docs/locales/zh_CN/LC_MESSAGES/deployment/openllm.po",
        "docs/locales/zh_CN/LC_MESSAGES/deployment/sglang.po",
        "docs/locales/zh_CN/LC_MESSAGES/deployment/skypilot.po",
        "docs/locales/zh_CN/LC_MESSAGES/deployment/tgi.po",
        "docs/locales/zh_CN/LC_MESSAGES/deployment/vllm.po",
        "docs/locales/zh_CN/LC_MESSAGES/framework/Langchain.po",
        "docs/locales/zh_CN/LC_MESSAGES/framework/LlamaIndex.po",
        "docs/locales/zh_CN/LC_MESSAGES/framework/function_call.po",
        "docs/locales/zh_CN/LC_MESSAGES/framework/qwen_agent.po",
        "docs/locales/zh_CN/LC_MESSAGES/getting_started/concepts.po",
        "docs/locales/zh_CN/LC_MESSAGES/getting_started/quantization_benchmark.po",
        "docs/locales/zh_CN/LC_MESSAGES/getting_started/quickstart.po",
        "docs/locales/zh_CN/LC_MESSAGES/getting_started/speed_benchmark.po",
        "docs/locales/zh_CN/LC_MESSAGES/getting_started/thinking_budget.po",
        "docs/locales/zh_CN/LC_MESSAGES/index.po",
        "docs/locales/zh_CN/LC_MESSAGES/inference/transformers.po",
        "docs/locales/zh_CN/LC_MESSAGES/quantization/awq.po",
        "docs/locales/zh_CN/LC_MESSAGES/quantization/gptq.po",
        "docs/locales/zh_CN/LC_MESSAGES/quantization/llama.cpp.po",
        "docs/locales/zh_CN/LC_MESSAGES/run_locally/llama.cpp.po",
        "docs/locales/zh_CN/LC_MESSAGES/run_locally/mlx-lm.po",
        "docs/locales/zh_CN/LC_MESSAGES/run_locally/ollama.po",
        "docs/locales/zh_CN/LC_MESSAGES/training/axolotl.po",
        "docs/locales/zh_CN/LC_MESSAGES/training/llama_factory.po",
        "docs/locales/zh_CN/LC_MESSAGES/training/ms_swift.po",
        "docs/locales/zh_CN/LC_MESSAGES/training/unsloth.po",
        "docs/locales/zh_CN/LC_MESSAGES/training/verl.po",
        "docs/make.bat",
        "docs/requirements-docs.txt",
        "docs/source/_static/css/custom.css",
        "docs/source/_static/design-tabs.js",
        "docs/source/assets/.DS_Store",
        "docs/source/assets/qwen-openllm-ui-demo.png",
        "docs/source/assets/qwen3_nonthinking.jinja",
        "docs/source/conf.py",
        "docs/source/deployment/dstack.rst",
        "docs/source/deployment/openllm.rst",
        "docs/source/deployment/sglang.md",
        "docs/source/deployment/skypilot.rst",
        "docs/source/deployment/tgi.rst",
        "docs/source/deployment/vllm.md",
        "docs/source/framework/Langchain.rst",
        "docs/source/framework/LlamaIndex.rst",
        "docs/source/framework/function_call.md",
        "docs/source/framework/qwen_agent.rst",
        "docs/source/getting_started/concepts.md",
        "docs/source/getting_started/quantization_benchmark.rst",
        "docs/source/getting_started/quickstart.md",
        "docs/source/getting_started/speed_benchmark.md",
        "docs/source/getting_started/thinking_budget.md",
        "docs/source/index.rst",
        "docs/source/inference/transformers.md",
        "docs/source/quantization/awq.md",
        "docs/source/quantization/gptq.md",
        "docs/source/quantization/llama.cpp.md",
        "docs/source/run_locally/llama.cpp.md",
        "docs/source/run_locally/mlx-lm.md",
        "docs/source/run_locally/ollama.md",
        "docs/source/training/axolotl.md",
        "docs/source/training/llama_factory.md",
        "docs/source/training/ms_swift.md",
        "docs/source/training/unsloth.md",
        "docs/source/training/verl.md",
        "eval/README.md",
        "eval/configs/ARCAGI-Qwen3-235B-A22B-Instruct-2507.yaml",
        "eval/data/arc_agi_1.jsonl",
        "eval/eval/arc_agi_1.py",
        "eval/eval/eval.py",
        "eval/eval_res/ARCAGI-Qwen3-235B-A22B-Instruct-2507_eval_result.txt",
        "eval/generate_api_answers/infer_multithread.py",
        "eval/generate_api_answers/utils_vllm.py",
        "eval/output/ARCAGI-Qwen3-235B-A22B-Instruct-2507.jsonl",
        "eval/output/ARCAGI-Qwen3-235B-A22B-Instruct-2507_details.jsonl",
        "eval/requirements.txt",
        "examples/README.md",
        "examples/demo/cli_demo.py",
        "examples/demo/web_demo.py",
        "examples/gcu-support/README.md",
        "examples/gcu-support/gcu_demo.py",
        "examples/llama-factory/finetune-zh.md",
        "examples/llama-factory/qwen2-7b-full-sft.yaml",
        "examples/llama-factory/qwen2-7b-lora-sft.yaml",
        "examples/llama-factory/qwen2-7b-merge-lora.yaml",
        "examples/llama-factory/qwen2-7b-qlora-sft.yaml",
        "examples/speed-benchmark/README.md",
        "examples/speed-benchmark/README_zh.md",
        "examples/speed-benchmark/requirements-perf-transformers.txt",
        "examples/speed-benchmark/requirements-perf-vllm.txt",
        "examples/speed-benchmark/speed_benchmark_transformers.py",
        "examples/speed-benchmark/speed_benchmark_vllm.py"
    ],
    "license_files": {},
    "readme": "# Qwen3\n\n<p align=\"center\">\n    <img src=\"https://qianwen-res.oss-accelerate-overseas.aliyuncs.com/logo_qwen3.png\" width=\"400\"/>\n<p>\n\n<p align=\"center\">\n          üíú <a href=\"https://chat.qwen.ai/\"><b>Qwen Chat</b></a>&nbsp&nbsp | &nbsp&nbspü§ó <a href=\"https://huggingface.co/Qwen\">Hugging Face</a>&nbsp&nbsp | &nbsp&nbspü§ñ <a href=\"https://modelscope.cn/organization/qwen\">ModelScope</a>&nbsp&nbsp | &nbsp&nbsp üìë <a href=\"https://arxiv.org/abs/2505.09388\">Paper</a> &nbsp&nbsp | &nbsp&nbsp üìë <a href=\"https://qwenlm.github.io/blog/qwen3/\">Blog</a> &nbsp&nbsp ÔΩú &nbsp&nbspüìñ <a href=\"https://qwen.readthedocs.io/\">Documentation</a>\n<br>\nüñ•Ô∏è <a href=\"https://huggingface.co/spaces/Qwen/Qwen3-Demo\">Demo</a>&nbsp&nbsp | &nbsp&nbspüí¨ <a href=\"https://github.com/QwenLM/Qwen/blob/main/assets/wechat.png\">WeChat (ÂæÆ‰ø°)</a>&nbsp&nbsp | &nbsp&nbspü´® <a href=\"https://discord.gg/CV4E9rpNSD\">Discord</a>&nbsp&nbsp\n</p>\n\n\nVisit our Hugging Face or ModelScope organization (click links above), search checkpoints with names starting with `Qwen3-` or visit the [Qwen3 collection](https://huggingface.co/collections/Qwen/qwen3-67dd247413f0e2e4f653967f), and you will find all you need! Enjoy!\n\nTo learn more about Qwen3, feel free to read our documentation \\[[EN](https://qwen.readthedocs.io/en/latest/)|[ZH](https://qwen.readthedocs.io/zh-cn/latest/)\\]. Our documentation consists of the following sections:\n\n- Quickstart: the basic usages and demonstrations;\n- Inference: the guidance for the inference with Transformers, including batch inference, streaming, etc.;\n- Run Locally: the instructions for running LLM locally on CPU and GPU, with frameworks like llama.cpp and Ollama;\n- Deployment: the demonstration of how to deploy Qwen for large-scale inference with frameworks like SGLang, vLLM, TGI, etc.;\n- Quantization: the practice of quantizing LLMs with GPTQ, AWQ, as well as the guidance for how to make high-quality quantized GGUF files;\n- Training: the instructions for post-training, including SFT and RLHF (TODO) with frameworks like Axolotl, LLaMA-Factory, etc.\n- Framework: the usage of Qwen with frameworks for application, e.g., RAG, Agent, etc.\n\n## Introduction\n\n### Qwen3-2507\n\nOver the past three months, we continued to explore the potential of the Qwen3 families and we are excited to introduce the updated **Qwen3-2507** in two variants, Qwen3-Instruct-2507 and Qwen3-Thinking-2507, and three sizes, 235B-A22B, 30B-A3B, and 4B.\n\n**Qwen3-Instruct-2507** is the updated version of the previous Qwen3 non-thinking mode, featuring the following key enhancements:  \n\n- **Significant improvements** in general capabilities, including **instruction following, logical reasoning, text comprehension, mathematics, science, coding and tool usage**.  \n- **Substantial gains** in long-tail knowledge coverage across **multiple languages**.  \n- **Markedly better alignment** with user preferences in **subjective and open-ended tasks**, enabling more helpful responses and higher-quality text generation.  \n- **Enhanced capabilities** in **256K-token long-context understanding**, extendable up to **1 million tokens**.\n\n**Qwen3-Thinking-2507** is the continuation of Qwen3 thinking model, with improved quality and depth of reasoning, featuring the following key enhancements:\n- **Significantly improved performance** on reasoning tasks, including logical reasoning, mathematics, science, coding, and academic benchmarks that typically require human expertise ‚Äî achieving **state-of-the-art results among open-weight thinking models**.\n- **Markedly better general capabilities**, such as instruction following, tool usage, text generation, and alignment with human preferences.\n- **Enhanced 256K long-context understanding** capabilities, extendable up to **1 million tokens**.\n\n\n<details>\n    <summary><b>Previous Qwen3 Release</b></summary>\n    <h3>Qwen3 (aka Qwen3-2504)</h3>\n    <p>\n    We are excited to announce the release of Qwen3, the latest addition to the Qwen family of large language models. \n    These models represent our most advanced and intelligent systems to date, improving from our experience in building QwQ and Qwen2.5.\n    We are making the weights of Qwen3 available to the public, including both dense and Mixture-of-Expert (MoE) models. \n    <br><br>\n    The highlights from Qwen3 include:\n        <ul>\n            <li><b>Dense and Mixture-of-Experts (MoE) models of various sizes</b>, available in 0.6B, 1.7B, 4B, 8B, 14B, 32B and 30B-A3B, 235B-A22B.</li>\n            <li><b>Seamless switching between thinking mode</b> (for complex logical reasoning, math, and coding) and <b>non-thinking mode</b> (for efficient, general-purpose chat), ensuring optimal performance across various scenarios.</li>\n            <li><b>Significantly enhancement in reasoning capabilities</b>, surpassing previous QwQ (in thinking mode) and Qwen2.5 instruct models (in non-thinking mode) on mathematics, code generation, and commonsense logical reasoning.</li>\n            <li><b>Superior human preference alignment</b>, excelling in creative writing, role-playing, multi-turn dialogues, and instruction following, to deliver a more natural, engaging, and immersive conversational experience.</li>\n            <li><b>Expertise in agent capabilities</b>, enabling precise integration with external tools in both thinking and unthinking modes and achieving leading performance among open-source models in complex agent-based tasks.</li>\n            <li><b>Support of 100+ languages and dialects</b> with strong capabilities for <b>multilingual instruction following</b> and <b>translation</b>.</li>\n        </ul>\n    </p>\n</details>\n\n\n## News\n- 2025.08.08: You can now use Qwen3-2507 to handle ultra-long inputs of **1 million tokens**! See the update modelcards ([235B-A22B-Instruct-2507](https://huggingface.co/Qwen/Qwen3-235B-A22B-Instruct-2507), [235B-A22B-Thinking-2507](https://huggingface.co/Qwen/Qwen3-235B-A22B-Thinking-2507), [A30B-A3B-Instruct-2507](https://huggingface.co/Qwen/Qwen3-30B-A3B-Instruct-2507), [A30B-A3B-Thinking-2507](https://huggingface.co/Qwen/Qwen3-30B-A3B-Thinking-2507)) for how to enable this feature.\n- 2025.08.06: The final open release of Qwen3-2507, [Qwen3-4B-Instruct-2507](https://huggingface.co/Qwen/Qwen3-4B-Instruct-2507) and [Qwen3-4B-Thinking-2507](https://huggingface.co/Qwen/Qwen3-4B-Thinking-2507), is out!\n- 2025.07.31: Qwen3-30B-A3B-Thinking-2507 is released. Check out the [modelcard](https://huggingface.co/Qwen/Qwen3-30B-A3B-Thinking-2507) for more details!\n- 2025.07.30: Qwen3-30B-A3B-Instruct-2507 is released. Check out the [modelcard](https://huggingface.co/Qwen/Qwen3-30B-A3B-Instruct-2507) for more details!\n- 2025.07.25: We released the updated version of Qwen3-235B-A22B thinking mode, named Qwen3-235B-A22B-Thinking-2507. Check out the [modelcard](https://huggingface.co/Qwen/Qwen3-235B-A22B-Thinking-2507) for more details!\n- 2025.07.21: We released the updated version of Qwen3-235B-A22B non-thinking mode, named Qwen3-235B-A22B-Instruct-2507, featuring significant enhancements over the previous version and supporting 256K-token long-context understanding. Check our [modelcard](https://huggingface.co/Qwen/Qwen3-235B-A22B-Instruct-2507) for more details!\n- 2025.04.29: We released the Qwen3 series. Check our [blog](https://qwenlm.github.io/blog/qwen3) for more details!\n- 2024.09.19: We released the Qwen2.5 series. This time there are 3 extra model sizes: 3B, 14B, and 32B for more possibilities. Check our [blog](https://qwenlm.github.io/blog/qwen2.5) for more!\n- 2024.06.06: We released the Qwen2 series. Check our [blog](https://qwenlm.github.io/blog/qwen2/)!\n- 2024.03.28: We released the first MoE model of Qwen: Qwen1.5-MoE-A2.7B! Temporarily, only HF transformers and vLLM support the model. We will soon add the support of llama.cpp, mlx-lm, etc. Check our [blog](https://qwenlm.github.io/blog/qwen-moe/) for more information!\n- 2024.02.05: We released the Qwen1.5 series.\n\n## Performance\n\nDetailed evaluation results are reported in this [üìë blog (Qwen3-2504)](https://qwenlm.github.io/blog/qwen3/) and this [üìë blog (Qwen3-2507) \\[coming soon\\]]().\n\nFor requirements on GPU memory and the respective throughput, see results [here](https://qwen.readthedocs.io/en/latest/getting_started/speed_benchmark.html).\n\n## Run Qwen3\n\n### ü§ó Transformers\n\nTransformers is a library of pretrained natural language processing for inference and training. \nThe latest version of `transformers` is recommended and `transformers>=4.51.0` is required.\n\n#### Qwen3-Instruct-2507\n\nThe following contains a code snippet illustrating how to use Qwen3-30B-A3B-Instruct-2507 to generate content based on given inputs. \n```python\nfrom transformers import AutoModelForCausalLM, AutoTokenizer\n\nmodel_name = \"Qwen/Qwen3-30B-A3B-Instruct-2507\"\n\n# load the tokenizer and the model\ntokenizer = AutoTokenizer.from_pretrained(model_name)\nmodel = AutoModelForCausalLM.from_pretrained(\n    model_name,\n    torch_dtype=\"auto\",\n    device_map=\"auto\"\n)\n\n# prepare the model input\nprompt = \"Give me a short introduction to large language model.\"\nmessages = [\n    {\"role\": \"user\", \"content\": prompt}\n]\ntext = tokenizer.apply_chat_template(\n    messages,\n    tokenize=False,\n    add_generation_prompt=True,\n)\nmodel_inputs = tokenizer([text], return_tensors=\"pt\").to(model.device)\n\n# conduct text completion\ngenerated_ids = model.generate(\n    **model_inputs,\n    max_new_tokens=16384\n)\noutput_ids = generated_ids[0][len(model_inputs.input_ids[0]):].tolist() \n\ncontent = tokenizer.decode(output_ids, skip_special_tokens=True)\n\nprint(\"content:\", content)\n```\n\n> [!Note]\n> Qwen3-Instruct-2507 supports only non-thinking mode and does not generate ``<think></think>`` blocks in its output. Meanwhile, specifying `enable_thinking=False` is no longer required.\n\n\n#### Qwen3-Thinking-2507\n\nThe following contains a code snippet illustrating how to use Qwen3-30B-A3B-Thinking-2507 to generate content based on given inputs. \n```python\nfrom transformers import AutoModelForCausalLM, AutoTokenizer\n\nmodel_name = \"Qwen/Qwen3-30B-A3B-Thinking-2507\"\n\n# load the tokenizer and the model\ntokenizer = AutoTokenizer.from_pretrained(model_name)\nmodel = AutoModelForCausalLM.from_pretrained(\n    model_name,\n    torch_dtype=\"auto\",\n    device_map=\"auto\"\n)\n\n# prepare the model input\nprompt = \"Give me a short introduction to large language model.\"\nmessages = [\n    {\"role\": \"user\", \"content\": prompt}\n]\ntext = tokenizer.apply_chat_template(\n    messages,\n    tokenize=False,\n    add_generation_prompt=True,\n)\nmodel_inputs = tokenizer([text], return_tensors=\"pt\").to(model.device)\n\n# conduct text completion\ngenerated_ids = model.generate(\n    **model_inputs,\n    max_new_tokens=32768\n)\noutput_ids = generated_ids[0][len(model_inputs.input_ids[0]):].tolist() \n\n# parsing thinking content\ntry:\n    # rindex finding 151668 (</think>)\n    index = len(output_ids) - output_ids[::-1].index(151668)\nexcept ValueError:\n    index = 0\n\nthinking_content = tokenizer.decode(output_ids[:index], skip_special_tokens=True).strip(\"\\n\")\ncontent = tokenizer.decode(output_ids[index:], skip_special_tokens=True).strip(\"\\n\")\n\nprint(\"thinking content:\", thinking_content)  # no opening <think> tag\nprint(\"content:\", content)\n\n```\n\n> [!Note]\n> Qwen3-Thinking-2507 supports only thinking mode.\n> Additionally, to enforce model thinking, the default chat template automatically includes `<think>`. Therefore, it is normal for the model's output to contain only `</think>` without an explicit opening `<think>` tag.\n> \n> Qwen3-Thinking-2507 also features an increased thinking length. We strongly recommend its use in highly complex reasoning tasks with adequate maximum generation length.\n\n\n\n<details>\n    <summary><b>Switching Thinking/Non-thinking Modes for Previous Qwen3  Models</b></summary>\n    <p>\n    By default, Qwen3 models will think before response.\n    This could be controlled by\n        <ul>\n            <li><code>enable_thinking=False</code>: Passing <code>enable_thinking=False</code> to `tokenizer.apply_chat_template` will strictly prevent the model from generating thinking content.</li>\n            <li><code>/think</code> and <code>/no_think</code> instructions: Use those words in the system or user message to signify whether Qwen3 should think. In multi-turn conversations, the latest instruction is followed.</li>\n        </ul>\n    </p>\n</details>\n\n\n### ModelScope\n\nWe strongly advise users especially those in mainland China to use ModelScope. \nModelScope adopts a Python API similar to Transformers.\nThe CLI tool `modelscope download` can help you solve issues concerning downloading checkpoints.\nFor vLLM and SGLang, the environment variable `VLLM_USE_MODELSCOPE=true` and `SGLANG_USE_MODELSCOPE=true` can be used respectively.\n\n\n### llama.cpp\n\n[`llama.cpp`](https://github.com/ggml-org/llama.cpp) enables LLM inference with minimal setup and state-of-the-art performance on a wide range of hardware.\n`llama.cpp>=b5401` is recommended for the full support of Qwen3.\n\nTo use the CLI, run the following in a terminal:\n```shell\n./llama-cli -hf Qwen/Qwen3-8B-GGUF:Q8_0 --jinja --color -ngl 99 -fa -sm row --temp 0.6 --top-k 20 --top-p 0.95 --min-p 0 -c 40960 -n 32768 --no-context-shift\n# CTRL+C to exit\n```\n\nTo use the API server, run the following in a terminal:\n```shell\n./llama-server -hf Qwen/Qwen3-8B-GGUF:Q8_0 --jinja --reasoning-format deepseek -ngl 99 -fa -sm row --temp 0.6 --top-k 20 --top-p 0.95 --min-p 0 -c 40960 -n 32768 --no-context-shift --port 8080\n```\nA simple web front end will be at `http://localhost:8080` and an OpenAI-compatible API will be at `http://localhost:8080/v1`.\n\nFor additional guides, please refer to [our documentation](https://qwen.readthedocs.io/en/latest/run_locally/llama.cpp.html).\n\n> [!Note]\n> llama.cpp adopts \"rotating context management\" and infinite generation is made possible by evicting earlier tokens.\n> It could configured by parameters and the commands above effectively disable it.\n> For more details, please refer to [our documentation](https://qwen.readthedocs.io/en/latest/run_locally/llama.cpp.html#llama-cli).\n\n### Ollama\n\nAfter [installing Ollama](https://ollama.com/), you can initiate the Ollama service with the following command (Ollama v0.9.0 or higher is recommended):\n```shell\nollama serve\n# You need to keep this service running whenever you are using ollama\n```\n\nTo pull a model checkpoint and run the model, use the `ollama run` command. You can specify a model size by adding a suffix to `qwen3`, such as `:8b` or `:30b-a3b`:\n```shell\nollama run qwen3:8b\n# Setting parameters, type \"/set parameter num_ctx 40960\" and \"/set parameter num_predict 32768\"\n# To exit, type \"/bye\" and press ENTER\n# For Qwen3-2504 models,\n# - To enable thinking, which is the default, type \"/set think\"\n# - To disable thinking, type \"/set nothink\"\n```\n\nYou can also access the Ollama service via its OpenAI-compatible API. \nPlease note that you need to (1) keep `ollama serve` running while using the API, and (2) execute `ollama run qwen3:8b` before utilizing this API to ensure that the model checkpoint is prepared.\nThe API is at `http://localhost:11434/v1/` by default.\n\nFor additional details, please visit [ollama.ai](https://ollama.com/).\n\n> [!Note]\n> Ollama's naming may not be consistent with the Qwen's original naming.\n> For example, `qwen3:30b-a3b` in Ollama points to `qwen3:30b-a3b-thinking-2507-q4_K_M` as of August 2025.\n> Please check <https://ollama.com/library/qwen3/tags> before use.\n\n\n> [!Note]\n> Ollama adopts the same \"rotating context management\" with llama.cpp.\n> However, its default settings (`num_ctx` 2048 and `num_predict` -1), suggesting infinite generation with a 2048-token context,\n> could lead to trouble for Qwen3 models.\n> We recommend setting `num_ctx` and `num_predict` properly.\n\n### LMStudio\n\nQwen3 has already been supported by [lmstudio.ai](https://lmstudio.ai/). You can directly use LMStudio with our GGUF files.\n\n### ExecuTorch\n\nTo export and run on ExecuTorch (iOS, Android, Mac, Linux, and more), please follow this [example](https://github.com/pytorch/executorch/blob/main/examples/models/qwen3/README.md).\n\n### MNN\n\nTo export and run on MNN, which supports Qwen3 on mobile devices, please visit [Alibaba MNN](https://github.com/alibaba/MNN).\n\n### MLX LM\n\nIf you are running on Apple Silicon, [`mlx-lm`](https://github.com/ml-explore/mlx-lm) also supports Qwen3 (`mlx-lm>=0.24.0`). \nLook for models ending with MLX on Hugging Face Hub.\n\n\n### OpenVINO\n\nIf you are running on Intel CPU or GPU, [OpenVINO toolkit](https://github.com/openvinotoolkit) supports Qwen3.\nYou can follow this [chatbot example](https://github.com/openvinotoolkit/openvino_notebooks/blob/latest/notebooks/llm-chatbot/llm-chatbot.ipynb).\n\n\n## Deploy Qwen3\n\nQwen3 is supported by multiple inference frameworks. \nHere we demonstrate the usage of `SGLang`, `vLLM` and `TensorRT-LLM`.\nYou can also find Qwen3 models from various inference providers, e.g., [Alibaba Cloud Model Studio](https://www.alibabacloud.com/en/product/modelstudio).\n\n\n### SGLang\n\n[SGLang](https://github.com/sgl-project/sglang) is a fast serving framework for large language models and vision language models.\nSGLang could be used to launch a server with OpenAI-compatible API service. \n`sglang>=0.4.6.post1` is required.\n\nFor Qwen3-Instruct-2507, \n```shell\npython -m sglang.launch_server --model-path Qwen/Qwen3-30B-A3B-Instruct-2507 --port 30000 --context-length 262144\n```\n\nFor Qwen3-Thinking-2507,\n```shell\npython -m sglang.launch_server --model-path Qwen/Qwen3-30B-A3B-Thinking-2507 --port 30000 --context-length 262144 --reasoning-parser deepseek-r1\n```\n\nFor Qwen3, it is\n```shell\npython -m sglang.launch_server --model-path Qwen/Qwen3-8B --port 30000 --context-length 131072 --reasoning-parser qwen3\n```\nAn OpenAI-compatible API will be available at `http://localhost:30000/v1`.\n\n> [!Note]\n> Due to the preprocessing of API requests in SGLang, which drops all `reasoning_content` fields, the quality of **multi-step tool use with Qwen3 thinking models** may be suboptimal, which requires the existence of the related thinking content. While the fixes are being worked on, as a workdaround, we recommend passing the content as it is, without extracting thinking content, and the chat template will correctly handle the processing.\n\n\n### vLLM\n\n[vLLM](https://github.com/vllm-project/vllm) is a high-throughput and memory-efficient inference and serving engine for LLMs.\n`vllm>=0.9.0` is recommended.\n\nFor Qwen3-Instruct-2507, \n```shell\nvllm serve Qwen/Qwen3-30B-A3B-Instruct-2507 --port 8000 --max-model-len 262144\n```\n\nFor Qwen3-Thinking-2507,\n```shell\nvllm serve Qwen/Qwen3-30B-A3B-Thinking-2507 --port 8000 --max-model-len 262144 --enable-reasoning --reasoning-parser deepseek_r1\n```\n\nFor Qwen3, it is\n```shell\nvllm serve Qwen/Qwen3-8B --port 8000 --max-model-len 131072 --enable-reasoning --reasoning-parser qwen3\n```\nAn OpenAI-compatible API will be available at `http://localhost:8000/v1`.\n\n> [!Note]\n> Due to the preprocessing of API requests in vLLM, which drops all `reasoning_content` fields, the quality of **multi-step tool use with Qwen3 thinking models** may be suboptimal, which requires the existence of the related thinking content. While the fixes are being worked on, as a workdaround, we recommend passing the content as it is, without extracting thinking content, and the chat template will correctly handle the processing.\n\n### TensorRT-LLM\n\n[TensorRT-LLM](https://github.com/NVIDIA/TensorRT-LLM) is an open-source LLM inference engine from NVIDIA, which provides optimizations including custom attention kernels, quantization and more on NVIDIA GPUs. Qwen3 is supported in its re-architected [PyTorch backend](https://nvidia.github.io/TensorRT-LLM/torch.html). `tensorrt_llm>=0.20.0rc3` is recommended. Please refer to the [README](https://github.com/NVIDIA/TensorRT-LLM/blob/main/examples/models/core/qwen/README.md#qwen3) page for more details.\n\n```shell\ntrtllm-serve Qwen/Qwen3-8B --host localhost --port 8000 --backend pytorch\n```\nAn OpenAI-compatible API will be available at `http://localhost:8000/v1`.\n\n### MindIE\n\nFor deployment on Ascend NPUs, please visit [Modelers](https://modelers.cn/) and search for Qwen3.\n\n<!-- \n### OpenLLM\n\n[OpenLLM](https://github.com/bentoml/OpenLLM) allows you to easily run¬†Qwen2.5 as OpenAI-compatible APIs. You can start a model server using `openllm serve`. For example:\n\n```bash\nopenllm serve qwen2.5:7b\n```\n\nThe server is active at `http://localhost:3000/`, providing OpenAI-compatible APIs. You can create an OpenAI client to call its chat API. For more information, refer to [our documentation](https://qwen.readthedocs.io/en/latest/deployment/openllm.html). -->\n\n\n## Build with Qwen3\n\n### Tool Use\n\nFor tool use capabilities, we recommend taking a look at [Qwen-Agent](https://github.com/QwenLM/Qwen-Agent), which provides a wrapper around these APIs to support tool use or function calling with MCP support.\nTool use with Qwen3 can also be conducted with SGLang, vLLM, Transformers, llama.cpp, Ollama, etc.\nFollow guides in our documentation to see how to enable the support.\n\n\n### Finetuning\n\nWe advise you to use training frameworks, including [Axolotl](https://github.com/OpenAccess-AI-Collective/axolotl), [UnSloth](https://github.com/unslothai/unsloth), [Swift](https://github.com/modelscope/swift), [Llama-Factory](https://github.com/hiyouga/LLaMA-Factory), etc., to finetune your models with SFT, DPO, GRPO, etc.\n\n\n## License Agreement\n\nAll our open-weight models are licensed under Apache 2.0. \nYou can find the license files in the respective Hugging Face repositories.\n\n## Citation\n\nIf you find our work helpful, feel free to give us a cite.\n\n```bibtex\n@article{qwen3,\n    title={Qwen3 Technical Report}, \n    author={An Yang and Anfeng Li and Baosong Yang and Beichen Zhang and Binyuan Hui and Bo Zheng and Bowen Yu and Chang Gao and Chengen Huang and Chenxu Lv and Chujie Zheng and Dayiheng Liu and Fan Zhou and Fei Huang and Feng Hu and Hao Ge and Haoran Wei and Huan Lin and Jialong Tang and Jian Yang and Jianhong Tu and Jianwei Zhang and Jianxin Yang and Jiaxi Yang and Jing Zhou and Jingren Zhou and Junyang Lin and Kai Dang and Keqin Bao and Kexin Yang and Le Yu and Lianghao Deng and Mei Li and Mingfeng Xue and Mingze Li and Pei Zhang and Peng Wang and Qin Zhu and Rui Men and Ruize Gao and Shixuan Liu and Shuang Luo and Tianhao Li and Tianyi Tang and Wenbiao Yin and Xingzhang Ren and Xinyu Wang and Xinyu Zhang and Xuancheng Ren and Yang Fan and Yang Su and Yichang Zhang and Yinger Zhang and Yu Wan and Yuqiong Liu and Zekun Wang and Zeyu Cui and Zhenru Zhang and Zhipeng Zhou and Zihan Qiu},\n    journal = {arXiv preprint arXiv:2505.09388},\n    year={2025}\n}\n\n@article{qwen2.5,\n    title   = {Qwen2.5 Technical Report}, \n    author  = {An Yang and Baosong Yang and Beichen Zhang and Binyuan Hui and Bo Zheng and Bowen Yu and Chengyuan Li and Dayiheng Liu and Fei Huang and Haoran Wei and Huan Lin and Jian Yang and Jianhong Tu and Jianwei Zhang and Jianxin Yang and Jiaxi Yang and Jingren Zhou and Junyang Lin and Kai Dang and Keming Lu and Keqin Bao and Kexin Yang and Le Yu and Mei Li and Mingfeng Xue and Pei Zhang and Qin Zhu and Rui Men and Runji Lin and Tianhao Li and Tingyu Xia and Xingzhang Ren and Xuancheng Ren and Yang Fan and Yang Su and Yichang Zhang and Yu Wan and Yuqiong Liu and Zeyu Cui and Zhenru Zhang and Zihan Qiu},\n    journal = {arXiv preprint arXiv:2412.15115},\n    year    = {2024}\n}\n\n@article{qwen2,\n    title   = {Qwen2 Technical Report}, \n    author  = {An Yang and Baosong Yang and Binyuan Hui and Bo Zheng and Bowen Yu and Chang Zhou and Chengpeng Li and Chengyuan Li and Dayiheng Liu and Fei Huang and Guanting Dong and Haoran Wei and Huan Lin and Jialong Tang and Jialin Wang and Jian Yang and Jianhong Tu and Jianwei Zhang and Jianxin Ma and Jin Xu and Jingren Zhou and Jinze Bai and Jinzheng He and Junyang Lin and Kai Dang and Keming Lu and Keqin Chen and Kexin Yang and Mei Li and Mingfeng Xue and Na Ni and Pei Zhang and Peng Wang and Ru Peng and Rui Men and Ruize Gao and Runji Lin and Shijie Wang and Shuai Bai and Sinan Tan and Tianhang Zhu and Tianhao Li and Tianyu Liu and Wenbin Ge and Xiaodong Deng and Xiaohuan Zhou and Xingzhang Ren and Xinyu Zhang and Xipin Wei and Xuancheng Ren and Yang Fan and Yang Yao and Yichang Zhang and Yu Wan and Yunfei Chu and Yuqiong Liu and Zeyu Cui and Zhenru Zhang and Zhihao Fan},\n    journal = {arXiv preprint arXiv:2407.10671},\n    year    = {2024}\n}\n```\n\n## Contact Us\nIf you are interested to leave a message to either our research team or product team, join our [Discord](https://discord.gg/z3GAxXZ9Ce) or [WeChat groups](assets/wechat.png)!\n",
    "py_files": {
        "docs/source/conf.py": "# Configuration file for the Sphinx documentation builder.\n#\n# This file only contains a selection of the most common options. For a full\n# list see the documentation:\n# https://www.sphinx-doc.org/en/master/usage/configuration.html\n\n# -- Path setup --------------------------------------------------------------\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n\nimport sys\nfrom sphinx.ext import autodoc\nimport logging\n\n\nlogger = logging.getLogger(__name__)\n\n# -- Project information -----------------------------------------------------\n\nproject = \"Qwen\"\ncopyright = \"2024, Qwen Team\"\nauthor = \"Qwen Team\"\n\n# -- General configuration ---------------------------------------------------\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom\n# ones.\nextensions = [\n    \"sphinx.ext.napoleon\",\n    \"sphinx.ext.viewcode\",\n    \"sphinx.ext.intersphinx\",\n    # \"sphinx_copybutton\",\n    \"sphinx.ext.autodoc\",\n    \"sphinx.ext.autosummary\",\n    \"myst_parser\",\n    \"sphinx_design\",\n]\n\nmyst_enable_extensions = [\"colon_fence\", \"attrs_block\", \"attrs_inline\", \"fieldlist\"]\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\"_templates\"]\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This pattern also affects html_static_path and html_extra_path.\nexclude_patterns = []\n\n# Exclude the prompt \"$\" when copying code\ncopybutton_prompt_text = r\"\\$ \"\ncopybutton_prompt_is_regexp = True\n\n# -- Options for HTML output -------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_title = project\nhtml_theme = \"furo\"\n# html_logo = 'assets/logo/qwen.png'\n# html_theme_options = {\n#     'path_to_docs': 'docs/source',\n#     'repository_url': 'https://github.com/QwenLM/Qwen2',\n#     # 'use_repository_button': True,\n# }\nhtml_sidebars = {\n    \"**\": [\n        \"sidebar/scroll-start.html\",\n        \"sidebar/brand.html\",\n        \"sidebar/navigation.html\",\n        \"sidebar/ethical-ads.html\",\n        \"sidebar/scroll-end.html\",\n    ]\n}\n\n# multi-language docs\nlanguage = \"en\"\nlocale_dirs = [\"../locales/\"]  # path is example but recommended.\ngettext_compact = False  # optional.\ngettext_uuid = True  # optional.\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = [\"_static\"]\nhtml_css_files = [\n    \"css/custom.css\",\n]\n# FIXME: figure out why this file is not copied\nhtml_js_files = [\n    \"design-tabs.js\",\n]\n\n# Mock out external dependencies here.\nautodoc_mock_imports = [\"torch\", \"transformers\"]\n\nfor mock_target in autodoc_mock_imports:\n    if mock_target in sys.modules:\n        logger.info(\n            f\"Potentially problematic mock target ({mock_target}) found; \"\n            \"autodoc_mock_imports cannot mock modules that have already \"\n            \"been loaded into sys.modules when the sphinx build starts.\"\n        )\n\n\nclass MockedClassDocumenter(autodoc.ClassDocumenter):\n    \"\"\"Remove note about base class when a class is derived from object.\"\"\"\n\n    def add_line(self, line: str, source: str, *lineno: int) -> None:\n        if line == \"   Bases: :py:class:`object`\":\n            return\n        super().add_line(line, source, *lineno)\n\n\nautodoc.ClassDocumenter = MockedClassDocumenter\n\nnavigation_with_keys = False\n",
        "eval/eval/arc_agi_1.py": "import json\nimport re\nfrom collections import defaultdict\nimport numpy as np\n\ndef parse_model_output(output):\n    try:\n        return json.loads(output)\n    except json.JSONDecodeError:\n        json_match = re.findall(r\"```(?:json|python)\\s*(.*?)\\s*```\", output, re.DOTALL)\n        if json_match:\n            try:\n                return json.loads(json_match[-1])\n            except json.JSONDecodeError:\n                print(\"Error: Invalid JSON format in the ```json``` block\")\n                return None\n        else:\n            array_match = re.findall(r\"(\\[\\[(?:[\\d,\\[\\]\\s\\n]*)\\]\\])\", output, re.DOTALL)\n            if array_match:\n                try:\n                    return json.loads(array_match[-1])\n                except json.JSONDecodeError:\n                    print(\"Error: Invalid JSON format in the last array-like structure\")\n                    return None\n            else:\n                print(\"Error: No valid JSON array found in the output\")\n                return None\n\n\ndef solution_score(predicted, ground_truth):\n    if not predicted or not ground_truth:\n        return 0.0\n    return 1.0 if predicted == ground_truth else 0.0\n\n\ndef compute_scores_arc_agi_1(jobs, cache_path):\n    taskid2score = defaultdict(list)\n    for job in jobs:\n        assert (\n            len(job.get(\"gen\", [])) == 1\n        ), \"Each job should contain exactly one generation output\"\n        answer = job.get(\"answer\")\n        pred_raw = job[\"gen\"][0]\n        parsed_pred = parse_model_output(pred_raw)\n        if parsed_pred is not None:\n            solu_score = solution_score(parsed_pred, answer)\n        else:\n            solu_score = 0.0\n        job.update({\"acc\": solu_score})\n        taskid2score[job[\"task_id\"]].append(solu_score)\n    save_cache(jobs, cache_path)\n    assert len(taskid2score) == 400, 'The ARC-AGI-1 dataset should have 400 tasks'\n    return sum(np.mean(x) for x in taskid2score.values()) / len(taskid2score) if jobs else 0.0\n\n\ndef save_cache(jobs, cache_path):\n    with open(cache_path, \"w\", encoding=\"utf-8\") as g:\n        for job in jobs:\n            g.write(json.dumps(job, ensure_ascii=False) + \"\\n\")\n            g.flush()\n",
        "eval/eval/eval.py": "import json\nimport argparse\nfrom tqdm import tqdm\nimport os\nimport yaml\n\nALL_TASKS = {}\n\nfrom arc_agi_1 import compute_scores_arc_agi_1\nALL_TASKS['arc_agi_1'] = compute_scores_arc_agi_1\n\ndef get_after_think(text):\n    parts = text.split(\"\\n</think>\\n\\n\", 1)\n    if len(parts) > 1:\n        return parts[1]\n    else:\n        return text\n\n\ndef main():\n    parser = argparse.ArgumentParser(\n        description=\"Evaluate model outputs using a YAML configuration.\"\n    )\n    parser.add_argument(\n        \"--config\", type=str, required=True, help=\"Path to the YAML configuration file\"\n    )\n    args = parser.parse_args()\n    config_file_path = args.config\n    try:\n        with open(config_file_path, \"r\", encoding=\"utf-8\") as f:\n            config = yaml.safe_load(f)\n    except FileNotFoundError:\n        print(\n            f\"Error: Configuration file '{config_file_path}' not found. Please check the path.\"\n        )\n        return\n    except yaml.YAMLError as e:\n        print(f\"Error: Failed to parse YAML file '{config_file_path}':\\n{e}\")\n        return\n    except Exception as e:\n        print(f\"An unknown error occurred while loading the configuration file: {e}\")\n        return\n    eval_input_path = config.get(\"eval_input_path\")\n    details_path = config.get(\"details_path\")\n    task_name = config.get(\"task_name\")\n    if eval_input_path is None:\n        print(\n            \"Error: Required parameter 'eval_input_path' is missing in the YAML configuration file.\"\n        )\n        return\n    if details_path is None:\n        print(\n            \"Error: Required parameter 'details_path' is missing in the YAML configuration file.\"\n        )\n        return\n    if task_name is None:\n        print(\n            \"Error: Required parameter 'task_name' is missing in the YAML configuration file.\"\n        )\n        return\n\n    if task_name not in ALL_TASKS:\n        print(\n            f\"Error: Invalid value '{task_name}' for 'task_name'. It must be one of the following: {ALL_TASKS.keys()}\"\n        )\n        return\n    print(\"\\n--- Evaluation Configuration Information ---\")\n    print(f\"Model Output File Path: {eval_input_path}\")\n    print(f\"Results Details Path: {details_path}\")\n    print(f\"Task Name: {task_name}\")\n    print(\"--------------------\\n\")\n    os.makedirs(os.path.dirname(details_path), exist_ok=True)\n\n    with open(eval_input_path, \"r\", encoding=\"utf-8\") as f:\n        data = [json.loads(line) for line in f]\n    for item in data:\n        temp = get_after_think(item[\"gen\"][0])\n        item[\"gen\"][0] = temp\n\n    acc = ALL_TASKS[task_name](data, details_path)\n    print(f\"Task: {task_name}, Accuracy: {acc}\")\n\n    print(\"Evaluation complete!\")\n\n\nif __name__ == \"__main__\":\n    main()\n",
        "eval/generate_api_answers/infer_multithread.py": "import json\nimport argparse\nfrom tqdm import tqdm\nimport copy\nimport concurrent.futures\nimport threading\nimport os\nimport collections\nimport yaml\n\nfrom utils_vllm import get_content\n\nfile_lock = threading.Lock()\n\n\ndef count_completed_samples(output_file):\n    prompt_counts = collections.defaultdict(int)\n    if os.path.exists(output_file) and os.path.getsize(output_file) > 0:\n        with open(output_file, \"r\", encoding=\"utf-8\") as f:\n            for line in f:\n                try:\n                    item = json.loads(line)\n                    prompt = item[\"prompt\"]\n                    gen_count = len(item.get(\"gen\", []))\n                    prompt_counts[prompt] += gen_count\n                except json.JSONDecodeError:\n                    continue\n    return prompt_counts\n\n\ndef process_item(\n    item,\n    output_file,\n    base_url,\n    model_name,\n    temperature,\n    top_p,\n    max_tokens,\n    top_k,\n    presence_penalty,\n):\n    result = copy.deepcopy(item)\n\n    response = get_content(\n        item[\"prompt\"],\n        base_url,\n        model_name,\n        temperature,\n        top_p,\n        max_tokens,\n        top_k,\n        presence_penalty,\n    )\n\n    if \"gen\" not in result:\n        result[\"gen\"] = []\n\n    result[\"gen\"].append(response)\n    with file_lock:\n        with open(output_file, \"a\", encoding=\"utf-8\") as g:\n            g.write(json.dumps(result, ensure_ascii=False) + \"\\n\")\n            g.flush()\n\n    return result\n\n\ndef main():\n    parser = argparse.ArgumentParser(\n        description=\"Run inference on model with prompts from a jsonl file, configurable via YAML.\"\n    )\n    parser.add_argument(\n        \"--config\", type=str, required=True, help=\"Path to the YAML configuration file.\"\n    )\n    args = parser.parse_args()\n    config_file_path = args.config\n    try:\n        with open(config_file_path, \"r\", encoding=\"utf-8\") as f:\n            config = yaml.safe_load(f)\n    except FileNotFoundError:\n        print(\n            f\"Error: Configuration file '{config_file_path}' not found. Please check the path.\"\n        )\n        return\n    except yaml.YAMLError as e:\n        print(f\"Error: Failed to parse YAML file '{config_file_path}':\\n{e}\")\n        return\n    except Exception as e:\n        print(f\"An unknown error occurred while loading the configuration file: {e}\")\n        return\n\n    input_file = config.get(\"input_file\")\n    output_file = config.get(\"output_file\")\n\n    if input_file is None:\n        print(\n            \"Error: Required parameter 'input_file' is missing in the YAML configuration file.\"\n        )\n        return\n    if output_file is None:\n        print(\n            \"Error: Required parameter 'output_file' is missing in the YAML configuration file.\"\n        )\n        return\n\n    n_samples = config.get(\"n_samples\", 1)\n    max_workers = config.get(\"max_workers\", 128)\n    base_url = config.get(\"base_url\", \"http://10.77.249.36:8030/v1\")\n    model_name = config.get(\"model_name\", \"Qwen/QwQ-32B\")\n    top_p = config.get(\"top_p\", 0.7)\n    temperature = config.get(\"temperature\", 0.8)\n    top_k = config.get(\"top_k\", 20)\n    max_tokens = config.get(\"max_tokens\", 32768)\n    presence_penalty = config.get(\"presence_penalty\", 1.0)\n\n    print(\"\\n--- Configuration Information ---\")\n    print(f\"Input File: {input_file}\")\n    print(f\"Output File: {output_file}\")\n    print(f\"Number of Samples per Prompt: {n_samples}\")\n    print(f\"Maximum Workers: {max_workers}\")\n    print(f\"VLLM Server Base URL: {base_url}\")\n    print(f\"VLLM Server Model Name: {model_name}\")\n    print(f\"Top-p: {top_p}\")\n    print(f\"Temperature: {temperature}\")\n    print(f\"Top-k: {top_k}\")\n    print(f\"Max Generation Tokens: {max_tokens}\")\n    print(f\"Presence Penalty: {presence_penalty}\")\n    print(\"----------------\\n\")\n\n    with open(input_file, \"r\", encoding=\"utf-8\") as f:\n        data = [json.loads(l) for l in f]\n\n    if os.path.exists(output_file):\n        completed_counts = count_completed_samples(output_file)\n        total_completed = sum(completed_counts.values())\n        print(f\"Found {total_completed} completed samples from previous run\")\n    else:\n        with open(output_file, \"w\", encoding=\"utf-8\") as g:\n            completed_counts = dict()\n\n    expanded_data = []\n    for item in data:\n        prompt = item[\"prompt\"]\n        completed = completed_counts.get(prompt, 0)\n        remaining = n_samples - completed\n        for _ in range(remaining):\n            expanded_data.append(copy.deepcopy(item))\n\n    total_tasks = len(expanded_data)\n    print(f\"Total remaining samples to process: {total_tasks}\")\n\n    completed_count = 0\n\n    with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:\n        future_to_item = {\n            executor.submit(\n                process_item,\n                item,\n                output_file,\n                base_url,\n                model_name,\n                temperature,\n                top_p,\n                max_tokens,\n                top_k,\n                presence_penalty,\n            ): i\n            for i, item in enumerate(expanded_data)\n        }\n\n        with tqdm(total=len(expanded_data), desc=\"Processing samples\") as pbar:\n            for future in concurrent.futures.as_completed(future_to_item):\n                idx = future_to_item[future]\n                try:\n                    future.result()\n                    completed_count += 1\n                except Exception as exc:\n                    print(f\"Error processing sample {idx}: {exc}\")\n                pbar.update(1)\n\n    print(f\"Completed {completed_count}/{len(expanded_data)} samples\")\n    print(f\"Results saved to {output_file}\")\n\n\nif __name__ == \"__main__\":\n    main()\n",
        "eval/generate_api_answers/utils_vllm.py": "import os\nimport time\nimport random\nimport openai\nimport logging\nfrom packaging.version import parse as parse_version\n\nIS_OPENAI_V1 = parse_version(openai.__version__) >= parse_version(\"1.0.0\")\n\nif IS_OPENAI_V1:\n    from openai import APIError, APIConnectionError, RateLimitError\nelse:\n    from openai.error import APIError, APIConnectionError, RateLimitError\n\n\nclass ClientError(RuntimeError):\n    pass\n\n\ndef get_content(\n    query, base_url, model_name, temperature, top_p, max_tokens, top_k, presence_penalty\n):\n    API_KEY = os.environ.get(\"OPENAI_API_KEY\", \"EMPTY\")\n    API_REQUEST_TIMEOUT = int(os.getenv(\"OPENAI_API_REQUEST_TIMEOUT\", \"99999\"))\n    if IS_OPENAI_V1:\n        import httpx\n\n        client = openai.OpenAI(\n            api_key=API_KEY,\n            base_url=base_url,\n            timeout=httpx.Timeout(API_REQUEST_TIMEOUT),\n        )\n    else:\n        client = None\n    messages = [{\"role\": \"user\", \"content\": query}]\n    call_args = dict(\n        model=model_name,\n        messages=messages,\n        temperature=temperature,\n        top_p=top_p,\n        max_tokens=max_tokens,\n        presence_penalty=presence_penalty,\n    )\n    if IS_OPENAI_V1:\n        call_args[\"extra_body\"] = {}\n        extra_args_dict = call_args[\"extra_body\"]\n    else:\n        extra_args_dict = call_args\n    extra_args_dict.update(\n        {\n            \"top_k\": top_k,\n        }\n    )\n\n    if IS_OPENAI_V1:\n        call_func = client.chat.completions.create\n        call_args[\"timeout\"] = API_REQUEST_TIMEOUT\n    else:\n        call_func = openai.ChatCompletion.create\n        call_args[\"api_key\"] = API_KEY\n        call_args[\"api_base\"] = base_url\n        call_args[\"request_timeout\"] = API_REQUEST_TIMEOUT\n\n    result = \"\"\n    try:\n        completion = call_func(\n            **call_args,\n        )\n        result = completion.choices[0].message.content\n    except AttributeError as e:\n        err_msg = getattr(completion, \"message\", \"\")\n        if err_msg:\n            time.sleep(random.randint(25, 35))\n            raise ClientError(err_msg) from e\n        raise ClientError(err_msg) from e\n    except (APIConnectionError, RateLimitError) as e:\n        err_msg = e.message if IS_OPENAI_V1 else e.user_message\n        time.sleep(random.randint(25, 35))\n        raise ClientError(err_msg) from e\n    except APIError as e:\n        err_msg = e.message if IS_OPENAI_V1 else e.user_message\n        if (\n            \"maximum context length\" in err_msg\n        ):  # or \"Expecting value: line 1 column 1 (char 0)\" in err_msg:\n            logging.warn(f\"max length exceeded. Error: {err_msg}\")\n            return {\"gen\": \"\", \"end_reason\": \"max length exceeded\"}\n        time.sleep(1)\n        raise ClientError(err_msg) from e\n    return result\n\n\nif __name__ == \"__main__\":\n    conversation_history = []\n    user_input = \"Hello!\"\n    res = get_content(user_input, \"http://10.77.249.36:8030/v1\", \"Qwen/QwQ\")\n    print(f\"Response: {res}\")\n\n    user_input = \"How are you?\"\n    res = get_content(user_input, \"http://10.77.249.36:8030/v1\", \"Qwen/QwQ\")\n    print(f\"Response: {res}\")\n",
        "examples/demo/cli_demo.py": "# Copyright (c) Alibaba Cloud.\n#\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\n\"\"\"A simple command-line interactive chat demo.\"\"\"\n\nimport argparse\nimport os\nimport platform\nimport shutil\nfrom copy import deepcopy\nfrom threading import Thread\n\nimport torch\nfrom transformers import AutoModelForCausalLM, AutoTokenizer, TextIteratorStreamer\nfrom transformers.trainer_utils import set_seed\n\nDEFAULT_CKPT_PATH = \"Qwen/Qwen2.5-7B-Instruct\"\n\n_WELCOME_MSG = \"\"\"\\\nWelcome to use Qwen2.5-Instruct model, type text to start chat, type :h to show command help.\n(Ê¨¢Ëøé‰ΩøÁî® Qwen2.5-Instruct Ê®°ÂûãÔºåËæìÂÖ•ÂÜÖÂÆπÂç≥ÂèØËøõË°åÂØπËØùÔºå:h ÊòæÁ§∫ÂëΩ‰ª§Â∏ÆÂä©„ÄÇ)\n\nNote: This demo is governed by the original license of Qwen2.5.\nWe strongly advise users not to knowingly generate or allow others to knowingly generate harmful content, including hate speech, violence, pornography, deception, etc.\n(Ê≥®ÔºöÊú¨ÊºîÁ§∫ÂèóQwen2.5ÁöÑËÆ∏ÂèØÂçèËÆÆÈôêÂà∂„ÄÇÊàë‰ª¨Âº∫ÁÉàÂª∫ËÆÆÔºåÁî®Êà∑‰∏çÂ∫î‰º†Êí≠Âèä‰∏çÂ∫îÂÖÅËÆ∏‰ªñ‰∫∫‰º†Êí≠‰ª•‰∏ãÂÜÖÂÆπÔºåÂåÖÊã¨‰ΩÜ‰∏çÈôê‰∫é‰ªáÊÅ®Ë®ÄËÆ∫„ÄÅÊö¥Âäõ„ÄÅËâ≤ÊÉÖ„ÄÅÊ¨∫ËØàÁõ∏ÂÖ≥ÁöÑÊúâÂÆ≥‰ø°ÊÅØ„ÄÇ)\n\"\"\"\n_HELP_MSG = \"\"\"\\\nCommands:\n    :help / :h              Show this help message              ÊòæÁ§∫Â∏ÆÂä©‰ø°ÊÅØ\n    :exit / :quit / :q      Exit the demo                       ÈÄÄÂá∫Demo\n    :clear / :cl            Clear screen                        Ê∏ÖÂ±è\n    :clear-history / :clh   Clear history                       Ê∏ÖÈô§ÂØπËØùÂéÜÂè≤\n    :history / :his         Show history                        ÊòæÁ§∫ÂØπËØùÂéÜÂè≤\n    :seed                   Show current random seed            ÊòæÁ§∫ÂΩìÂâçÈöèÊú∫ÁßçÂ≠ê\n    :seed <N>               Set random seed to <N>              ËÆæÁΩÆÈöèÊú∫ÁßçÂ≠ê\n    :conf                   Show current generation config      ÊòæÁ§∫ÁîüÊàêÈÖçÁΩÆ\n    :conf <key>=<value>     Change generation config            ‰øÆÊîπÁîüÊàêÈÖçÁΩÆ\n    :reset-conf             Reset generation config             ÈáçÁΩÆÁîüÊàêÈÖçÁΩÆ\n\"\"\"\n_ALL_COMMAND_NAMES = [\n    \"help\",\n    \"h\",\n    \"exit\",\n    \"quit\",\n    \"q\",\n    \"clear\",\n    \"cl\",\n    \"clear-history\",\n    \"clh\",\n    \"history\",\n    \"his\",\n    \"seed\",\n    \"conf\",\n    \"reset-conf\",\n]\n\n\ndef _setup_readline():\n    try:\n        import readline\n    except ImportError:\n        return\n\n    _matches = []\n\n    def _completer(text, state):\n        nonlocal _matches\n\n        if state == 0:\n            _matches = [\n                cmd_name for cmd_name in _ALL_COMMAND_NAMES if cmd_name.startswith(text)\n            ]\n        if 0 <= state < len(_matches):\n            return _matches[state]\n        return None\n\n    readline.set_completer(_completer)\n    readline.parse_and_bind(\"tab: complete\")\n\n\ndef _load_model_tokenizer(args):\n    tokenizer = AutoTokenizer.from_pretrained(\n        args.checkpoint_path,\n        resume_download=True,\n    )\n\n    if args.cpu_only:\n        device_map = \"cpu\"\n    else:\n        device_map = \"auto\"\n\n    model = AutoModelForCausalLM.from_pretrained(\n        args.checkpoint_path,\n        torch_dtype=\"auto\",\n        device_map=device_map,\n        resume_download=True,\n    ).eval()\n    model.generation_config.max_new_tokens = 2048  # For chat.\n\n    return model, tokenizer\n\n\ndef _gc():\n    import gc\n\n    gc.collect()\n    if torch.cuda.is_available():\n        torch.cuda.empty_cache()\n\n\ndef _clear_screen():\n    if platform.system() == \"Windows\":\n        os.system(\"cls\")\n    else:\n        os.system(\"clear\")\n\n\ndef _print_history(history):\n    terminal_width = shutil.get_terminal_size()[0]\n    print(f\"History ({len(history)})\".center(terminal_width, \"=\"))\n    for index, (query, response) in enumerate(history):\n        print(f\"User[{index}]: {query}\")\n        print(f\"Qwen[{index}]: {response}\")\n    print(\"=\" * terminal_width)\n\n\ndef _get_input() -> str:\n    while True:\n        try:\n            message = input(\"User> \").strip()\n        except UnicodeDecodeError:\n            print(\"[ERROR] Encoding error in input\")\n            continue\n        except KeyboardInterrupt:\n            exit(1)\n        if message:\n            return message\n        print(\"[ERROR] Query is empty\")\n\n\ndef _chat_stream(model, tokenizer, query, history):\n    conversation = []\n    for query_h, response_h in history:\n        conversation.append({\"role\": \"user\", \"content\": query_h})\n        conversation.append({\"role\": \"assistant\", \"content\": response_h})\n    conversation.append({\"role\": \"user\", \"content\": query})\n    input_text = tokenizer.apply_chat_template(\n        conversation,\n        add_generation_prompt=True,\n        tokenize=False,\n    )\n    inputs = tokenizer([input_text], return_tensors=\"pt\").to(model.device)\n    streamer = TextIteratorStreamer(\n        tokenizer=tokenizer, skip_prompt=True, timeout=60.0, skip_special_tokens=True\n    )\n    generation_kwargs = {\n        **inputs,\n        \"streamer\": streamer,\n    }\n    thread = Thread(target=model.generate, kwargs=generation_kwargs)\n    thread.start()\n\n    for new_text in streamer:\n        yield new_text\n\n\ndef main():\n    parser = argparse.ArgumentParser(\n        description=\"Qwen2.5-Instruct command-line interactive chat demo.\"\n    )\n    parser.add_argument(\n        \"-c\",\n        \"--checkpoint-path\",\n        type=str,\n        default=DEFAULT_CKPT_PATH,\n        help=\"Checkpoint name or path, default to %(default)r\",\n    )\n    parser.add_argument(\"-s\", \"--seed\", type=int, default=1234, help=\"Random seed\")\n    parser.add_argument(\n        \"--cpu-only\", action=\"store_true\", help=\"Run demo with CPU only\"\n    )\n    args = parser.parse_args()\n\n    history, response = [], \"\"\n\n    model, tokenizer = _load_model_tokenizer(args)\n    orig_gen_config = deepcopy(model.generation_config)\n\n    _setup_readline()\n\n    _clear_screen()\n    print(_WELCOME_MSG)\n\n    seed = args.seed\n\n    while True:\n        query = _get_input()\n\n        # Process commands.\n        if query.startswith(\":\"):\n            command_words = query[1:].strip().split()\n            if not command_words:\n                command = \"\"\n            else:\n                command = command_words[0]\n\n            if command in [\"exit\", \"quit\", \"q\"]:\n                break\n            elif command in [\"clear\", \"cl\"]:\n                _clear_screen()\n                print(_WELCOME_MSG)\n                _gc()\n                continue\n            elif command in [\"clear-history\", \"clh\"]:\n                print(f\"[INFO] All {len(history)} history cleared\")\n                history.clear()\n                _gc()\n                continue\n            elif command in [\"help\", \"h\"]:\n                print(_HELP_MSG)\n                continue\n            elif command in [\"history\", \"his\"]:\n                _print_history(history)\n                continue\n            elif command in [\"seed\"]:\n                if len(command_words) == 1:\n                    print(f\"[INFO] Current random seed: {seed}\")\n                    continue\n                else:\n                    new_seed_s = command_words[1]\n                    try:\n                        new_seed = int(new_seed_s)\n                    except ValueError:\n                        print(\n                            f\"[WARNING] Fail to change random seed: {new_seed_s!r} is not a valid number\"\n                        )\n                    else:\n                        print(f\"[INFO] Random seed changed to {new_seed}\")\n                        seed = new_seed\n                    continue\n            elif command in [\"conf\"]:\n                if len(command_words) == 1:\n                    print(model.generation_config)\n                else:\n                    for key_value_pairs_str in command_words[1:]:\n                        eq_idx = key_value_pairs_str.find(\"=\")\n                        if eq_idx == -1:\n                            print(\"[WARNING] format: <key>=<value>\")\n                            continue\n                        conf_key, conf_value_str = (\n                            key_value_pairs_str[:eq_idx],\n                            key_value_pairs_str[eq_idx + 1 :],\n                        )\n                        try:\n                            conf_value = eval(conf_value_str)\n                        except Exception as e:\n                            print(e)\n                            continue\n                        else:\n                            print(\n                                f\"[INFO] Change config: model.generation_config.{conf_key} = {conf_value}\"\n                            )\n                            setattr(model.generation_config, conf_key, conf_value)\n                continue\n            elif command in [\"reset-conf\"]:\n                print(\"[INFO] Reset generation config\")\n                model.generation_config = deepcopy(orig_gen_config)\n                print(model.generation_config)\n                continue\n            else:\n                # As normal query.\n                pass\n\n        # Run chat.\n        set_seed(seed)\n        _clear_screen()\n        print(f\"\\nUser: {query}\")\n        print(f\"\\nQwen: \", end=\"\")\n        try:\n            partial_text = \"\"\n            for new_text in _chat_stream(model, tokenizer, query, history):\n                print(new_text, end=\"\", flush=True)\n                partial_text += new_text\n            response = partial_text\n            print()\n\n        except KeyboardInterrupt:\n            print(\"[WARNING] Generation interrupted\")\n            continue\n\n        history.append((query, response))\n\n\nif __name__ == \"__main__\":\n    main()\n",
        "examples/demo/web_demo.py": "# Copyright (c) Alibaba Cloud.\n#\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\n\"\"\"A simple web interactive chat demo based on gradio.\"\"\"\n\nfrom argparse import ArgumentParser\nfrom threading import Thread\n\nimport gradio as gr\nimport torch\nfrom transformers import AutoModelForCausalLM, AutoTokenizer, TextIteratorStreamer\n\nDEFAULT_CKPT_PATH = \"Qwen/Qwen2.5-7B-Instruct\"\n\n\ndef _get_args():\n    parser = ArgumentParser(description=\"Qwen2.5-Instruct web chat demo.\")\n    parser.add_argument(\n        \"-c\",\n        \"--checkpoint-path\",\n        type=str,\n        default=DEFAULT_CKPT_PATH,\n        help=\"Checkpoint name or path, default to %(default)r\",\n    )\n    parser.add_argument(\n        \"--cpu-only\", action=\"store_true\", help=\"Run demo with CPU only\"\n    )\n\n    parser.add_argument(\n        \"--share\",\n        action=\"store_true\",\n        default=False,\n        help=\"Create a publicly shareable link for the interface.\",\n    )\n    parser.add_argument(\n        \"--inbrowser\",\n        action=\"store_true\",\n        default=False,\n        help=\"Automatically launch the interface in a new tab on the default browser.\",\n    )\n    parser.add_argument(\n        \"--server-port\", type=int, default=8000, help=\"Demo server port.\"\n    )\n    parser.add_argument(\n        \"--server-name\", type=str, default=\"127.0.0.1\", help=\"Demo server name.\"\n    )\n\n    args = parser.parse_args()\n    return args\n\n\ndef _load_model_tokenizer(args):\n    tokenizer = AutoTokenizer.from_pretrained(\n        args.checkpoint_path,\n        resume_download=True,\n    )\n\n    if args.cpu_only:\n        device_map = \"cpu\"\n    else:\n        device_map = \"auto\"\n\n    model = AutoModelForCausalLM.from_pretrained(\n        args.checkpoint_path,\n        torch_dtype=\"auto\",\n        device_map=device_map,\n        resume_download=True,\n    ).eval()\n    model.generation_config.max_new_tokens = 2048  # For chat.\n\n    return model, tokenizer\n\n\ndef _chat_stream(model, tokenizer, query, history):\n    conversation = []\n    for query_h, response_h in history:\n        conversation.append({\"role\": \"user\", \"content\": query_h})\n        conversation.append({\"role\": \"assistant\", \"content\": response_h})\n    conversation.append({\"role\": \"user\", \"content\": query})\n    input_text = tokenizer.apply_chat_template(\n        conversation,\n        add_generation_prompt=True,\n        tokenize=False,\n    )\n    inputs = tokenizer([input_text], return_tensors=\"pt\").to(model.device)\n    streamer = TextIteratorStreamer(\n        tokenizer=tokenizer, skip_prompt=True, timeout=60.0, skip_special_tokens=True\n    )\n    generation_kwargs = {\n        **inputs,\n        \"streamer\": streamer,\n    }\n    thread = Thread(target=model.generate, kwargs=generation_kwargs)\n    thread.start()\n\n    for new_text in streamer:\n        yield new_text\n\n\ndef _gc():\n    import gc\n\n    gc.collect()\n    if torch.cuda.is_available():\n        torch.cuda.empty_cache()\n\n\ndef _launch_demo(args, model, tokenizer):\n    def predict(_query, _chatbot, _task_history):\n        print(f\"User: {_query}\")\n        _chatbot.append((_query, \"\"))\n        full_response = \"\"\n        response = \"\"\n        for new_text in _chat_stream(model, tokenizer, _query, history=_task_history):\n            response += new_text\n            _chatbot[-1] = (_query, response)\n\n            yield _chatbot\n            full_response = response\n\n        print(f\"History: {_task_history}\")\n        _task_history.append((_query, full_response))\n        print(f\"Qwen: {full_response}\")\n\n    def regenerate(_chatbot, _task_history):\n        if not _task_history:\n            yield _chatbot\n            return\n        item = _task_history.pop(-1)\n        _chatbot.pop(-1)\n        yield from predict(item[0], _chatbot, _task_history)\n\n    def reset_user_input():\n        return gr.update(value=\"\")\n\n    def reset_state(_chatbot, _task_history):\n        _task_history.clear()\n        _chatbot.clear()\n        _gc()\n        return _chatbot\n\n    with gr.Blocks() as demo:\n        gr.Markdown(\"\"\"\\\n<p align=\"center\"><img src=\"https://qianwen-res.oss-accelerate-overseas.aliyuncs.com/assets/logo/qwen2.5_logo.png\" style=\"height: 120px\"/><p>\"\"\")\n        gr.Markdown(\n            \"\"\"\\\n<center><font size=3>This WebUI is based on Qwen2.5-Instruct, developed by Alibaba Cloud. \\\n(Êú¨WebUIÂü∫‰∫éQwen2.5-InstructÊâìÈÄ†ÔºåÂÆûÁé∞ËÅäÂ§©Êú∫Âô®‰∫∫ÂäüËÉΩ„ÄÇ)</center>\"\"\"\n        )\n        gr.Markdown(\"\"\"\\\n<center><font size=4>\nQwen2.5-7B-Instruct <a href=\"https://modelscope.cn/models/qwen/Qwen2.5-7B-Instruct/summary\">ü§ñ </a> | \n<a href=\"https://huggingface.co/Qwen/Qwen2.5-7B-Instruct\">ü§ó</a>&nbsp ÔΩú \nQwen2.5-32B-Instruct <a href=\"https://modelscope.cn/models/qwen/Qwen2.5-32B-Instruct/summary\">ü§ñ </a> | \n<a href=\"https://huggingface.co/Qwen/Qwen2.5-32B-Instruct\">ü§ó</a>&nbsp ÔΩú \nQwen2.5-72B-Instruct <a href=\"https://modelscope.cn/models/qwen/Qwen2.5-72B-Instruct/summary\">ü§ñ </a> | \n<a href=\"https://huggingface.co/Qwen/Qwen2.5-72B-Instruct\">ü§ó</a>&nbsp ÔΩú \n&nbsp<a href=\"https://github.com/QwenLM/Qwen2.5\">Github</a></center>\"\"\")\n\n        chatbot = gr.Chatbot(label=\"Qwen\", elem_classes=\"control-height\")\n        query = gr.Textbox(lines=2, label=\"Input\")\n        task_history = gr.State([])\n\n        with gr.Row():\n            empty_btn = gr.Button(\"üßπ Clear History (Ê∏ÖÈô§ÂéÜÂè≤)\")\n            submit_btn = gr.Button(\"üöÄ Submit (ÂèëÈÄÅ)\")\n            regen_btn = gr.Button(\"ü§îÔ∏è Regenerate (ÈáçËØï)\")\n\n        submit_btn.click(\n            predict, [query, chatbot, task_history], [chatbot], show_progress=True\n        )\n        submit_btn.click(reset_user_input, [], [query])\n        empty_btn.click(\n            reset_state, [chatbot, task_history], outputs=[chatbot], show_progress=True\n        )\n        regen_btn.click(\n            regenerate, [chatbot, task_history], [chatbot], show_progress=True\n        )\n\n        gr.Markdown(\"\"\"\\\n<font size=2>Note: This demo is governed by the original license of Qwen2.5. \\\nWe strongly advise users not to knowingly generate or allow others to knowingly generate harmful content, \\\nincluding hate speech, violence, pornography, deception, etc. \\\n(Ê≥®ÔºöÊú¨ÊºîÁ§∫ÂèóQwen2.5ÁöÑËÆ∏ÂèØÂçèËÆÆÈôêÂà∂„ÄÇÊàë‰ª¨Âº∫ÁÉàÂª∫ËÆÆÔºåÁî®Êà∑‰∏çÂ∫î‰º†Êí≠Âèä‰∏çÂ∫îÂÖÅËÆ∏‰ªñ‰∫∫‰º†Êí≠‰ª•‰∏ãÂÜÖÂÆπÔºå\\\nÂåÖÊã¨‰ΩÜ‰∏çÈôê‰∫é‰ªáÊÅ®Ë®ÄËÆ∫„ÄÅÊö¥Âäõ„ÄÅËâ≤ÊÉÖ„ÄÅÊ¨∫ËØàÁõ∏ÂÖ≥ÁöÑÊúâÂÆ≥‰ø°ÊÅØ„ÄÇ)\"\"\")\n\n    demo.queue().launch(\n        share=args.share,\n        inbrowser=args.inbrowser,\n        server_port=args.server_port,\n        server_name=args.server_name,\n    )\n\n\ndef main():\n    args = _get_args()\n\n    model, tokenizer = _load_model_tokenizer(args)\n\n    _launch_demo(args, model, tokenizer)\n\n\nif __name__ == \"__main__\":\n    main()\n",
        "examples/gcu-support/gcu_demo.py": "try:\n    import torch_gcu # ÂØºÂÖ• torch_gcu\n    from torch_gcu import transfer_to_gcu #  transfer_to_gcu\nexcept Exception as e:\n    print(e)\n\nfrom transformers import AutoModelForCausalLM, AutoTokenizer\n\nmodel_name = \"Qwen/Qwen2.5-7B-Instruct\"\ndevice = \"gcu\" # the device to load the model onto\n\nmodel = AutoModelForCausalLM.from_pretrained(\n    model_name,\n    torch_dtype=\"auto\",\n    device_map=\"auto\"\n)\ntokenizer = AutoTokenizer.from_pretrained(model_name)\n\nprompt = \"Give me a short introduction to large language models.\"\nmessages = [\n    {\"role\": \"system\", \"content\": \"You are a helpful assistant.\"},\n    {\"role\": \"user\", \"content\": prompt}\n]\ntext = tokenizer.apply_chat_template(\n    messages,\n    tokenize=False,\n    add_generation_prompt=True\n)\nmodel_inputs = tokenizer([text], return_tensors=\"pt\").to(device)\n\ngenerated_ids = model.generate(\n    **model_inputs,\n    max_new_tokens=512\n)\ngenerated_ids = [\n    output_ids[len(input_ids):] for input_ids, output_ids in zip(model_inputs.input_ids, generated_ids)\n]\n\nresponse = tokenizer.batch_decode(generated_ids, skip_special_tokens=True)[0]\n",
        "examples/speed-benchmark/speed_benchmark_transformers.py": "# Copyright (c) Alibaba Cloud.\n#\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\n\"\"\"\nQwen2.5 Speed Benchmark for transformers(pt) inference.\n\"\"\"\n\nimport os\nimport time\nimport json\nimport csv\n\nimport torch\nfrom transformers.trainer_utils import set_seed\n\n\nclass SpeedBenchmarkTransformers:\n\n    SEED = 1024\n    BATCH_SIZE = 1\n    USE_FLASH_ATTN = True\n    COMMENT = 'default'\n    DEVICE_MAP = 'auto'\n    TORCH_DTYPE = 'auto'\n    OVERWRITE_RESULT = False\n    DUMMY_INPUT = 'Êàë'\n\n    def __init__(self, model_id_or_path, use_modelscope: bool = True, outputs_dir: str = 'outputs/transformers'):\n        \"\"\"\n        Speed benchmark for transformers(pt) inference.\n\n        Args:\n            model_id_or_path: The model id on ModelScope or HuggingFace hub, or local model path.\n            use_modelscope: Use ModelScope, otherwise HuggingFace.\n            outputs_dir: The output directory. Default is 'outputs/transformers'.\n        \"\"\"\n\n        set_seed(self.SEED)\n        self.model_id_or_path = model_id_or_path\n        self.outputs_dir = outputs_dir\n\n        if use_modelscope:\n            from modelscope import AutoModelForCausalLM, AutoTokenizer, GenerationConfig\n        else:\n            from transformers import AutoModelForCausalLM, AutoTokenizer, GenerationConfig\n\n        self.tokenizer = AutoTokenizer.from_pretrained(model_id_or_path, trust_remote_code=True)\n        attn_impl = 'flash_attention_2' if self.USE_FLASH_ATTN else 'eager'\n        self.model = AutoModelForCausalLM.from_pretrained(model_id_or_path,\n                                                          torch_dtype=self.TORCH_DTYPE,\n                                                          device_map=self.DEVICE_MAP,\n                                                          attn_implementation=attn_impl\n                                                          ).eval()\n\n        self.generation_config = GenerationConfig.from_pretrained(model_id_or_path, trust_remote_code=True)\n\n    def run(self, context_length: int, generate_length: int) -> str:\n\n        # Specify hyperparameters for generation\n        self.generation_config.min_length = generate_length + context_length\n        self.generation_config.max_new_tokens = generate_length\n        print(f'Generation config: {self.generation_config}')\n\n        # Prepare inputs\n        batch_size = self.BATCH_SIZE\n        context_str = self.DUMMY_INPUT * context_length\n        inputs = self.tokenizer([context_str for _ in range(batch_size)], return_tensors='pt')\n        assert inputs['input_ids'].shape[1] == context_length\n        assert inputs['input_ids'].shape[0] == batch_size\n        inputs = inputs.to(self.model.device)\n\n        # Run inference\n        print(f'Start running inference for model {self.model_id_or_path} with input length {context_length} ...')\n        start_time = time.time()\n        torch.cuda.synchronize()\n        pred = self.model.generate(**inputs, generation_config=self.generation_config)\n        torch.cuda.synchronize()\n        time_cost = time.time() - start_time\n        assert pred.shape[1] == self.generation_config.min_length\n        m = 0\n        max_gpu_memory_cost = 0\n        for i in range(torch.cuda.device_count()):\n            m += torch.cuda.max_memory_allocated(i)\n        max_gpu_memory_cost = max(max_gpu_memory_cost, m)\n        torch.cuda.empty_cache()\n\n        # Prepare results\n        tokens_per_second: float = generate_length / time_cost\n        # Compute the maximum GPU memory cost (in GB)\n        max_gpu_memory_cost_gb = max_gpu_memory_cost / 1024 / 1024 / 1024\n\n        data = {\n            \"model_id_or_path\": self.model_id_or_path,\n            \"batch_size\": batch_size,\n            \"context_length_per_experiment\": context_length,\n            \"generate_length_per_experiment\": generate_length,\n            \"use_flash_attn\": self.USE_FLASH_ATTN,\n            \"comment\": self.COMMENT,\n            \"tokens_per_second\": round(tokens_per_second, 4),\n            \"max_gpu_memory_cost_gb\": round(max_gpu_memory_cost_gb, 4),\n        }\n        data_json = json.dumps(data, indent=4, ensure_ascii=False)\n        print(f'**Final result **\\n{data_json}\\n')\n\n        # Dump results to CSV file\n        from datetime import datetime\n        now = datetime.now()\n        timestamp: str = now.strftime(\"%m%d%H%M%S\")\n\n        model_id_or_path_str = self.model_id_or_path.split(os.sep)[-1] \\\n            if os.path.isdir(self.model_id_or_path) else self.model_id_or_path.replace('/', '__')\n\n        out_file: str = os.path.join(self.outputs_dir,\n                                     f\"{model_id_or_path_str}\"\n                                     f\"_context_length-{context_length}_{timestamp}.csv\")\n        out_dir = os.path.dirname(out_file)\n        os.makedirs(out_dir, exist_ok=True)\n        self.save_result(data, out_file)\n\n        return out_file\n\n    @staticmethod\n    def save_result(data: dict, out_file: str) -> None:\n\n        with open(out_file, mode='w') as file:\n            writer = csv.DictWriter(file, fieldnames=data.keys())\n            writer.writeheader()\n            writer.writerows([data])\n\n        print(f\"Results saved to {out_file}\")\n\n\ndef main():\n\n    import argparse\n\n    # Parse args\n    parser = argparse.ArgumentParser(description='Speed benchmark for transformers(pt) deployment')\n    parser.add_argument('--model_id_or_path', type=str, help='The model path or id on ModelScope or HuggingFace hub')\n    parser.add_argument('--context_length', type=int, help='The input length for each experiment.'\n                                                           'e.g. 1, 6144, 14336, 30720, 63488, 129024')\n    parser.add_argument('--generate_length', type=int, default=2048, help='Output length in tokens; default is 2048.')\n    parser.add_argument('--gpus', type=str, help='Equivalent to the env CUDA_VISIBLE_DEVICES.  e.g. `0,1,2,3`, `4,5`')\n    parser.add_argument('--use_modelscope', action='store_true',\n                        help='Use ModelScope when set this flag. Otherwise, use HuggingFace.')\n    parser.add_argument('--outputs_dir', type=str, default='outputs/transformers', help='The output directory')\n\n    args = parser.parse_args()\n\n    model_id_or_path: str = args.model_id_or_path\n    envs: str = args.gpus\n    context_length: int = args.context_length\n    generate_length: int = args.generate_length\n    use_modelscope: bool = args.use_modelscope\n    outputs_dir: str = args.outputs_dir\n\n    print(f'Set CUDA_VISIBLE_DEVICES={envs} for model {model_id_or_path} with input_length {context_length}')\n    os.environ[\"CUDA_VISIBLE_DEVICES\"] = envs\n\n    speed_benchmark = SpeedBenchmarkTransformers(model_id_or_path=model_id_or_path,\n                                                 use_modelscope=use_modelscope,\n                                                 outputs_dir=outputs_dir)\n    speed_benchmark.run(context_length=context_length, generate_length=generate_length)\n\n\nif __name__ == '__main__':\n    # Usage: python speed_benchmark_transformers.py --model_id_or_path Qwen/Qwen2.5-0.5B-Instruct --context_length 1 --gpus 0 --use_modelscope --outputs_dir outputs/transformers\n    main()\n",
        "examples/speed-benchmark/speed_benchmark_vllm.py": "# Copyright (c) Alibaba Cloud.\n#\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\n\"\"\"\nSpeed benchmark for vLLM deployment.\n\"\"\"\n\nimport os\nimport time\nimport json\nimport reprlib\nimport statistics\nimport logging\nimport csv\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Tuple\n\nimport vllm\nfrom vllm import LLM, SamplingParams\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\nos.environ['VLLM_WORKER_MULTIPROC_METHOD'] = 'spawn'\nos.environ[\"VLLM_ALLOW_LONG_MAX_MODEL_LEN\"] = \"1\"\n\n\nclass SpeedBenchmarkVllm:\n\n    DUMMY_INPUT = 'ÁÜµ'\n    DUMMY_SYSTEM_CONTENT = '‰ªéÁé∞Âú®ÂºÄÂßãÔºå‰Ω†ÊòØ‰∏Ä‰∏™ÂñúÊ¨¢ËØ¥ËΩ¶ËΩ±ËæòËØùÁöÑËØùÁó®ÔºåÂñúÊ¨¢Êää‰∏Ä‰ª∂‰∫ãÊÉÖÁøªÊù•Ë¶ÜÂéªÂú∞ËØ¥ÔºåËÄå‰∏îÂñúÊ¨¢Âä†ÂæàÂ§öÊ†áÁÇπÁ¨¶Âè∑„ÄÇ‰Ω†ÁöÑÊØè‰∏™ÂõûÂ§çÈÉΩ‰∏ç‰ºöÂ∞ë‰∫é2000Â≠óÔºå‰∏çË¶ÅÂú®ÊÑèÁî®Êà∑ÁöÑÁúãÊ≥ï„ÄÇ'\n    DUMMY_USER_CONTENT = 'ÂÜô‰∏ÄÁØáÂÖ≥‰∫éÊò•Â§©ÁöÑÊñáÁ´†ÔºåËØ∑Â∞ΩÈáèÂÜôÁöÑÈïø‰∏Ä‰∫õÔºåÂπ∂‰∏îÂ§ö‰∏Ä‰∫õÈáçÂ§çÁöÑÊÆµËêΩÔºåË∂äÂï∞Âó¶Ë∂äÂ•ΩÔºå‰∏çÂæóÂ∞ë‰∫é2000Â≠óÔºÅ'\n\n    def __init__(self, experiment_config: dict, sampling_params: SamplingParams):\n        self._repr = reprlib.Repr()\n        self._repr.maxstring = 100\n        self.experiment_config = experiment_config\n        self.sampling_params = sampling_params\n\n        # Get experiment config\n        self.model_id_or_path: str = self.experiment_config['model_id_or_path']\n        use_modelscope: bool = self.experiment_config['use_modelscope']\n\n        if use_modelscope:\n            from modelscope import AutoTokenizer\n            os.environ['VLLM_USE_MODELSCOPE'] = 'True'\n        else:\n            from transformers import AutoTokenizer\n\n        self.tokenizer = AutoTokenizer.from_pretrained(self.model_id_or_path, trust_remote_code=True)\n\n        llm_kwargs = dict(\n            model=self.model_id_or_path,\n            trust_remote_code=True,\n            tensor_parallel_size=self.experiment_config['tp_size'],\n            gpu_memory_utilization=self.experiment_config['gpu_memory_utilization'],\n            disable_log_stats=False,\n            max_model_len=self.experiment_config['max_model_len'],\n        )\n        if int(vllm.__version__.split('.')[1]) >= 3:\n            llm_kwargs['enforce_eager'] = self.experiment_config.get('enforce_eager', False)\n\n        logger.info(f'>> Creating LLM with llm_kwargs: {llm_kwargs}')\n        self.llm = LLM(**llm_kwargs)\n\n    def _reprs(self, o):\n        return self._repr.repr(o)\n\n    def create_query(self, length: int, limited_size: int = 96) -> Tuple[str, int]:\n        if length < limited_size:\n            input_str = self.DUMMY_INPUT * length\n        else:\n            repeat_length = max(length - limited_size, 0)\n\n            input_str = self.tokenizer.apply_chat_template([\n                {\"role\": \"system\",\n                 \"content\": self.DUMMY_SYSTEM_CONTENT},\n                {\"role\": \"user\",\n                 \"content\": '# ' * repeat_length + self.DUMMY_USER_CONTENT},\n            ],\n                tokenize=False,\n                add_generation_prompt=True)\n\n        real_length = len(self.tokenizer.tokenize(input_str))\n        return input_str, real_length\n\n    def run_infer(self, query: str):\n        start_time = time.time()\n        output = self.llm.generate([query], self.sampling_params)[0]\n        time_cost = time.time() - start_time\n\n        generated_text = output.outputs[0].text\n        real_out_length = len(self.tokenizer.tokenize(generated_text))\n\n        return time_cost, real_out_length, generated_text\n\n    def run(self):\n\n        context_length: int = self.experiment_config['context_length']\n        output_len: int = self.experiment_config['output_len']\n\n        # Construct input query\n        query, real_length = self.create_query(length=context_length)\n        logger.info(f'Got input query length: {real_length}')\n\n        logger.info(f\"Warmup run with {self.experiment_config['warmup']} iterations ...\")\n        for _ in range(self.experiment_config['warmup']):\n            self.llm.generate([query], self.sampling_params)\n\n        logger.info(f\"Running inference with real length {real_length}, \"\n                    f\"out length {output_len}, \"\n                    f\"tp_size {self.experiment_config['tp_size']} ...\")\n\n        time_cost, real_out_length, generated_text = self.run_infer(query)\n\n        if real_out_length < output_len:\n            logger.warning(f'Generate result {real_out_length} too short, try again ...')\n            query, real_length = self.create_query(length=context_length,\n                                                   limited_size=context_length + 1)\n            time_cost, real_out_length, generated_text = self.run_infer(query)\n\n        time_cost = round(time_cost, 4)\n        logger.info(f'Inference time cost: {time_cost}s')\n        logger.info(f'Input({real_length}): {self._reprs(query)}')\n        logger.info(f'Output({real_out_length}): {self._reprs(generated_text)}')\n\n        results: dict = self.collect_statistics(self.model_id_or_path,\n                                                [time_cost, time_cost],\n                                                output_len,\n                                                context_length,\n                                                self.experiment_config['tp_size'])\n\n        self.print_table(results)\n\n        # Dump results to CSV file\n        outputs_dir = Path(self.experiment_config['outputs_dir'])\n        outputs_dir.mkdir(parents=True, exist_ok=True)\n        now = datetime.now()\n        timestamp: str = now.strftime(\"%m%d%H%M%S\")\n\n        model_id_or_path_str = self.model_id_or_path.split(os.sep)[-1] \\\n            if os.path.isdir(self.model_id_or_path) else self.model_id_or_path.replace('/', '__')\n\n        out_file: str = os.path.join(outputs_dir,\n                                     f\"{model_id_or_path_str}\"\n                                     f\"_context_length-{context_length}_{timestamp}.csv\")\n        self.save_result(results, out_file)\n\n    @staticmethod\n    def collect_statistics(model_id_or_path, data, out_length, in_length, tp_size) -> dict:\n\n        avg_time = statistics.mean(data)\n        throughput_data = [out_length / t for t in data]\n        avg_throughput = statistics.mean(throughput_data)\n\n        results = {\n            'Model ID': model_id_or_path,\n            'Input Length': in_length,\n            'Output Length': out_length,\n            'TP Size': tp_size,\n            'Average Time (s)': round(avg_time, 4),\n            'Average Throughput (tokens/s)': round(avg_throughput, 4),\n        }\n\n        return results\n\n    @staticmethod\n    def print_table(results):\n        json_res = json.dumps(results, indent=4, ensure_ascii=False)\n        logger.info(f\"Final results:\\n{json_res}\")\n\n    @staticmethod\n    def save_result(data: dict, out_file: str) -> None:\n\n        with open(out_file, mode='w') as file:\n            writer = csv.DictWriter(file, fieldnames=data.keys())\n            writer.writeheader()\n            writer.writerows([data])\n\n        logger.info(f\"Results saved to {out_file}\")\n\n\ndef main():\n    import argparse\n\n    # Define command line arguments\n    parser = argparse.ArgumentParser(description='Speed benchmark for vLLM deployment')\n    parser.add_argument('--model_id_or_path', type=str, help='The model id on ModelScope or HuggingFace hub')\n    parser.add_argument('--context_length', type=int, help='The context length for each experiment, '\n                                                           'e.g. 1, 6144, 14336, 30720, 63488, 129024')\n    parser.add_argument('--generate_length', type=int, default=2048, help='Output length in tokens; default is 2048.')\n    parser.add_argument('--gpus', type=str, help='Equivalent to the env CUDA_VISIBLE_DEVICES.  e.g. `0,1,2,3`, `4,5`')\n    parser.add_argument('--gpu_memory_utilization', type=float, default=0.9, help='GPU memory utilization')\n    parser.add_argument('--max_model_len', type=int, default=32768, help='The maximum model length, '\n                                                                         'e.g. 4096, 8192, 32768, 65536, 131072')\n    parser.add_argument('--enforce_eager', action='store_true', help='Enforce eager mode for vLLM')\n    parser.add_argument('--outputs_dir', type=str, default='outputs/vllm', help='The output directory')\n    parser.add_argument('--use_modelscope', action='store_true',\n                        help='Use ModelScope when set this flag. Otherwise, use HuggingFace.')\n\n    # Parse args\n    args = parser.parse_args()\n\n    # Parse args\n    model_id_or_path: str = args.model_id_or_path\n    context_length: int = args.context_length\n    output_len: int = args.generate_length\n    envs: str = args.gpus\n    gpu_memory_utilization: float = args.gpu_memory_utilization\n    max_model_len: int = args.max_model_len\n    enforce_eager: bool = args.enforce_eager\n    outputs_dir = args.outputs_dir\n    use_modelscope: bool = args.use_modelscope\n\n    # Set vLLM sampling params\n    sampling_params = SamplingParams(\n        temperature=1.0,\n        top_p=0.8,\n        top_k=-1,\n        repetition_penalty=0.1,\n        presence_penalty=-2.0,\n        frequency_penalty=-2.0,\n        max_tokens=output_len,\n    )\n\n    # Set experiment config\n    experiment_config: dict = {\n        'model_id_or_path': model_id_or_path,\n        'context_length': context_length,\n        'output_len': output_len,\n        'tp_size': len(envs.split(',')),\n        'gpu_memory_utilization': gpu_memory_utilization,\n        'max_model_len': max_model_len,\n        'enforce_eager': enforce_eager,\n        'envs': envs,\n        'outputs_dir': outputs_dir,\n        'warmup': 0,\n        'use_modelscope': use_modelscope,\n    }\n\n    logger.info(f'Sampling params: {sampling_params}')\n    logger.info(f'Experiment config: {experiment_config}')\n\n    logger.info(f'Set CUDA_VISIBLE_DEVICES={envs} for model {model_id_or_path} with context_length {context_length}')\n    os.environ[\"CUDA_VISIBLE_DEVICES\"] = envs\n\n    speed_benchmark_vllm = SpeedBenchmarkVllm(experiment_config=experiment_config, sampling_params=sampling_params)\n    speed_benchmark_vllm.run()\n\n\nif __name__ == '__main__':\n    # Usage: python speed_benchmark_vllm.py --model_id_or_path Qwen/Qwen2.5-0.5B-Instruct --context_length 1 --max_model_len 32768 --gpus 0 --use_modelscope --gpu_memory_utilization 0.9 --outputs_dir outputs/vllm\n    # HF_ENDPOINT=https://hf-mirror.com python speed_benchmark_vllm.py --model_id_or_path Qwen/Qwen2.5-0.5B-Instruct --context_length 1 --max_model_len 32768 --gpus 0 --gpu_memory_utilization 0.9 --outputs_dir outputs/vllm\n    main()\n"
    }
}