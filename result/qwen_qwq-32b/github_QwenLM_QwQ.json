{
    "repo": "QwenLM/QwQ",
    "branch": "main",
    "files": [
        ".gitignore",
        "LICENSE",
        "README.md",
        "eval/README.md",
        "eval/data/aime24.jsonl",
        "eval/data/aime25.jsonl",
        "eval/data/ifeval.jsonl",
        "eval/data/livecodebench_v5.jsonl",
        "eval/data/process_data.py",
        "eval/eval/eval.py",
        "eval/eval/ifeval.py",
        "eval/eval/ifeval_utils/__init__.py",
        "eval/eval/ifeval_utils/instructions.py",
        "eval/eval/ifeval_utils/instructions_registry.py",
        "eval/eval/ifeval_utils/instructions_util.py",
        "eval/eval/livecodebench_v5.py",
        "eval/eval/livecodebench_v5_utils/compute_code_generation_metrics.py",
        "eval/eval/livecodebench_v5_utils/pass_k_utils.py",
        "eval/eval/livecodebench_v5_utils/process_data.py",
        "eval/eval/livecodebench_v5_utils/testing_util.py",
        "eval/eval/math_opensource.py",
        "eval/eval/math_opensource_utils/examples.py",
        "eval/eval/math_opensource_utils/grader.py",
        "eval/eval/math_opensource_utils/math_utils.py",
        "eval/eval/math_opensource_utils/parser.py",
        "eval/eval/math_opensource_utils/python_executor.py",
        "eval/eval/math_opensource_utils/trajectory.py",
        "eval/eval/math_opensource_utils/utils.py",
        "eval/generate_api_answers/infer_multithread.py",
        "eval/generate_api_answers/utils_vllm.py",
        "eval/requirements.txt"
    ],
    "license_files": {
        "LICENSE": "                                 Apache License\r\n                           Version 2.0, January 2004\r\n                        http://www.apache.org/licenses/\r\n\r\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\r\n\r\n   1. Definitions.\r\n\r\n      \"License\" shall mean the terms and conditions for use, reproduction,\r\n      and distribution as defined by Sections 1 through 9 of this document.\r\n\r\n      \"Licensor\" shall mean the copyright owner or entity authorized by\r\n      the copyright owner that is granting the License.\r\n\r\n      \"Legal Entity\" shall mean the union of the acting entity and all\r\n      other entities that control, are controlled by, or are under common\r\n      control with that entity. For the purposes of this definition,\r\n      \"control\" means (i) the power, direct or indirect, to cause the\r\n      direction or management of such entity, whether by contract or\r\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\r\n      outstanding shares, or (iii) beneficial ownership of such entity.\r\n\r\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\r\n      exercising permissions granted by this License.\r\n\r\n      \"Source\" form shall mean the preferred form for making modifications,\r\n      including but not limited to software source code, documentation\r\n      source, and configuration files.\r\n\r\n      \"Object\" form shall mean any form resulting from mechanical\r\n      transformation or translation of a Source form, including but\r\n      not limited to compiled object code, generated documentation,\r\n      and conversions to other media types.\r\n\r\n      \"Work\" shall mean the work of authorship, whether in Source or\r\n      Object form, made available under the License, as indicated by a\r\n      copyright notice that is included in or attached to the work\r\n      (an example is provided in the Appendix below).\r\n\r\n      \"Derivative Works\" shall mean any work, whether in Source or Object\r\n      form, that is based on (or derived from) the Work and for which the\r\n      editorial revisions, annotations, elaborations, or other modifications\r\n      represent, as a whole, an original work of authorship. For the purposes\r\n      of this License, Derivative Works shall not include works that remain\r\n      separable from, or merely link (or bind by name) to the interfaces of,\r\n      the Work and Derivative Works thereof.\r\n\r\n      \"Contribution\" shall mean any work of authorship, including\r\n      the original version of the Work and any modifications or additions\r\n      to that Work or Derivative Works thereof, that is intentionally\r\n      submitted to Licensor for inclusion in the Work by the copyright owner\r\n      or by an individual or Legal Entity authorized to submit on behalf of\r\n      the copyright owner. For the purposes of this definition, \"submitted\"\r\n      means any form of electronic, verbal, or written communication sent\r\n      to the Licensor or its representatives, including but not limited to\r\n      communication on electronic mailing lists, source code control systems,\r\n      and issue tracking systems that are managed by, or on behalf of, the\r\n      Licensor for the purpose of discussing and improving the Work, but\r\n      excluding communication that is conspicuously marked or otherwise\r\n      designated in writing by the copyright owner as \"Not a Contribution.\"\r\n\r\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\r\n      on behalf of whom a Contribution has been received by Licensor and\r\n      subsequently incorporated within the Work.\r\n\r\n   2. Grant of Copyright License. Subject to the terms and conditions of\r\n      this License, each Contributor hereby grants to You a perpetual,\r\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\r\n      copyright license to reproduce, prepare Derivative Works of,\r\n      publicly display, publicly perform, sublicense, and distribute the\r\n      Work and such Derivative Works in Source or Object form.\r\n\r\n   3. Grant of Patent License. Subject to the terms and conditions of\r\n      this License, each Contributor hereby grants to You a perpetual,\r\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\r\n      (except as stated in this section) patent license to make, have made,\r\n      use, offer to sell, sell, import, and otherwise transfer the Work,\r\n      where such license applies only to those patent claims licensable\r\n      by such Contributor that are necessarily infringed by their\r\n      Contribution(s) alone or by combination of their Contribution(s)\r\n      with the Work to which such Contribution(s) was submitted. If You\r\n      institute patent litigation against any entity (including a\r\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\r\n      or a Contribution incorporated within the Work constitutes direct\r\n      or contributory patent infringement, then any patent licenses\r\n      granted to You under this License for that Work shall terminate\r\n      as of the date such litigation is filed.\r\n\r\n   4. Redistribution. You may reproduce and distribute copies of the\r\n      Work or Derivative Works thereof in any medium, with or without\r\n      modifications, and in Source or Object form, provided that You\r\n      meet the following conditions:\r\n\r\n      (a) You must give any other recipients of the Work or\r\n          Derivative Works a copy of this License; and\r\n\r\n      (b) You must cause any modified files to carry prominent notices\r\n          stating that You changed the files; and\r\n\r\n      (c) You must retain, in the Source form of any Derivative Works\r\n          that You distribute, all copyright, patent, trademark, and\r\n          attribution notices from the Source form of the Work,\r\n          excluding those notices that do not pertain to any part of\r\n          the Derivative Works; and\r\n\r\n      (d) If the Work includes a \"NOTICE\" text file as part of its\r\n          distribution, then any Derivative Works that You distribute must\r\n          include a readable copy of the attribution notices contained\r\n          within such NOTICE file, excluding those notices that do not\r\n          pertain to any part of the Derivative Works, in at least one\r\n          of the following places: within a NOTICE text file distributed\r\n          as part of the Derivative Works; within the Source form or\r\n          documentation, if provided along with the Derivative Works; or,\r\n          within a display generated by the Derivative Works, if and\r\n          wherever such third-party notices normally appear. The contents\r\n          of the NOTICE file are for informational purposes only and\r\n          do not modify the License. You may add Your own attribution\r\n          notices within Derivative Works that You distribute, alongside\r\n          or as an addendum to the NOTICE text from the Work, provided\r\n          that such additional attribution notices cannot be construed\r\n          as modifying the License.\r\n\r\n      You may add Your own copyright statement to Your modifications and\r\n      may provide additional or different license terms and conditions\r\n      for use, reproduction, or distribution of Your modifications, or\r\n      for any such Derivative Works as a whole, provided Your use,\r\n      reproduction, and distribution of the Work otherwise complies with\r\n      the conditions stated in this License.\r\n\r\n   5. Submission of Contributions. Unless You explicitly state otherwise,\r\n      any Contribution intentionally submitted for inclusion in the Work\r\n      by You to the Licensor shall be under the terms and conditions of\r\n      this License, without any additional terms or conditions.\r\n      Notwithstanding the above, nothing herein shall supersede or modify\r\n      the terms of any separate license agreement you may have executed\r\n      with Licensor regarding such Contributions.\r\n\r\n   6. Trademarks. This License does not grant permission to use the trade\r\n      names, trademarks, service marks, or product names of the Licensor,\r\n      except as required for reasonable and customary use in describing the\r\n      origin of the Work and reproducing the content of the NOTICE file.\r\n\r\n   7. Disclaimer of Warranty. Unless required by applicable law or\r\n      agreed to in writing, Licensor provides the Work (and each\r\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\r\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\r\n      implied, including, without limitation, any warranties or conditions\r\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\r\n      PARTICULAR PURPOSE. You are solely responsible for determining the\r\n      appropriateness of using or redistributing the Work and assume any\r\n      risks associated with Your exercise of permissions under this License.\r\n\r\n   8. Limitation of Liability. In no event and under no legal theory,\r\n      whether in tort (including negligence), contract, or otherwise,\r\n      unless required by applicable law (such as deliberate and grossly\r\n      negligent acts) or agreed to in writing, shall any Contributor be\r\n      liable to You for damages, including any direct, indirect, special,\r\n      incidental, or consequential damages of any character arising as a\r\n      result of this License or out of the use or inability to use the\r\n      Work (including but not limited to damages for loss of goodwill,\r\n      work stoppage, computer failure or malfunction, or any and all\r\n      other commercial damages or losses), even if such Contributor\r\n      has been advised of the possibility of such damages.\r\n\r\n   9. Accepting Warranty or Additional Liability. While redistributing\r\n      the Work or Derivative Works thereof, You may choose to offer,\r\n      and charge a fee for, acceptance of support, warranty, indemnity,\r\n      or other liability obligations and/or rights consistent with this\r\n      License. However, in accepting such obligations, You may act only\r\n      on Your own behalf and on Your sole responsibility, not on behalf\r\n      of any other Contributor, and only if You agree to indemnify,\r\n      defend, and hold each Contributor harmless for any liability\r\n      incurred by, or claims asserted against, such Contributor by reason\r\n      of your accepting any such warranty or additional liability.\r\n\r\n   END OF TERMS AND CONDITIONS\r\n\r\n   APPENDIX: How to apply the Apache License to your work.\r\n\r\n      To apply the Apache License to your work, attach the following\r\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\r\n      replaced with your own identifying information. (Don't include\r\n      the brackets!)  The text should be enclosed in the appropriate\r\n      comment syntax for the file format. We also recommend that a\r\n      file or class name and description of purpose be included on the\r\n      same \"printed page\" as the copyright notice for easier\r\n      identification within third-party archives.\r\n\r\n   Copyright [yyyy] [name of copyright owner]\r\n\r\n   Licensed under the Apache License, Version 2.0 (the \"License\");\r\n   you may not use this file except in compliance with the License.\r\n   You may obtain a copy of the License at\r\n\r\n       http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n   Unless required by applicable law or agreed to in writing, software\r\n   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n   See the License for the specific language governing permissions and\r\n   limitations under the License."
    },
    "readme": "# QwQ\r\n\r\n\r\n<p align=\"center\">\r\n    <img src=\"https://qianwen-res.oss-cn-beijing.aliyuncs.com/QwQ/QwQ_logo.png\" width=\"400\"/>\r\n<p>\r\n\r\n<p align=\"center\">\r\n        üíú <a href=\"https://chat.qwen.ai/\"><b>Qwen Chat</b></a>&nbsp&nbsp | &nbsp&nbspü§ó <a href=\"https://huggingface.co/Qwen/QwQ-32B\">Hugging Face</a>&nbsp&nbsp | &nbsp&nbspü§ñ <a href=\"https://modelscope.cn/organization/qwen\">ModelScope</a>&nbsp&nbsp | &nbsp&nbspüìë <a href=\"https://qwenlm.github.io/blog/qwq-32b/\">Blog</a>&nbsp&nbsp<br>\r\nüñ•Ô∏è <a href=\"https://huggingface.co/spaces/Qwen/QwQ-32B-Demo\">Demo</a>&nbsp&nbsp | &nbsp&nbspüí¨ <a href=\"https://github.com/QwenLM/Qwen/blob/main/assets/wechat.png\">WeChat (ÂæÆ‰ø°)</a>&nbsp&nbsp | &nbsp&nbspü´® <a href=\"https://discord.gg/CV4E9rpNSD\">Discord</a>&nbsp&nbsp | &nbsp&nbspüìë <a href=\"https://www.alibabacloud.com/help/en/model-studio/developer-reference/what-is-qwen-llm\">API</a>&nbsp&nbsp\r\n</p>\r\n\r\n\r\n## Introduction\r\n\r\nQwQ is the reasoning-specialized model within the Qwen series. Unlike traditional instruction-tuned models, QwQ leverages advanced reasoning and critical thinking abilities to achieve superior performance on downstream tasks, especially those involving complex problem-solving. Our latest release, QwQ-32B, is a mid-sized model that competes effectively with top-tier reasoning models like DeepSeek-R1 and o1-mini, delivering robust and competitive results.\r\n\r\n**Note:** Please review the [Usage Guidelines](#usage-guidelines) before deploying QwQ models, especially if you encounter **endless repetitions or significant performance issues**.\r\n\r\n## Performance\r\n\r\n<img src=\"https://qianwen-res.oss-accelerate-overseas.aliyuncs.com/qwq-32b-final.jpg\"/>\r\n\r\nTo reproduce the results, please refer to [our evaluation code](./eval).\r\n\r\n\r\n## Quickstart with HuggingFace's transformers\r\n\r\nQwQ is based on Qwen2.5, which has been in the latest Huggingface `transformers`. We advise you to use the latest version of `transformers`.\r\n\r\nWith `transformers<4.37.0`, you will encounter the following error:\r\n```\r\nKeyError: 'qwen2'\r\n```\r\n\r\nHere provides a code snippet with `apply_chat_template` to show you how to load the tokenizer and model and how to generate contents.\r\n\r\n```python\r\nfrom transformers import AutoModelForCausalLM, AutoTokenizer\r\nmodel_name = \"Qwen/QwQ-32B\"\r\nmodel = AutoModelForCausalLM.from_pretrained(\r\n    model_name,\r\n    torch_dtype=\"auto\",\r\n    device_map=\"auto\"\r\n)\r\ntokenizer = AutoTokenizer.from_pretrained(model_name)\r\nprompt = \"How many r's are in the word \\\"strawberry\\\"\"\r\nmessages = [\r\n    {\"role\": \"user\", \"content\": prompt}\r\n]\r\ntext = tokenizer.apply_chat_template(\r\n    messages,\r\n    tokenize=False,\r\n    add_generation_prompt=True\r\n)\r\nmodel_inputs = tokenizer([text], return_tensors=\"pt\").to(model.device)\r\ngenerated_ids = model.generate(\r\n    **model_inputs,\r\n    max_new_tokens=32768\r\n)\r\ngenerated_ids = [\r\n    output_ids[len(input_ids):] for input_ids, output_ids in zip(model_inputs.input_ids, generated_ids)\r\n]\r\nresponse = tokenizer.batch_decode(generated_ids, skip_special_tokens=True)[0]\r\nprint(response)\r\n```\r\n\r\n## Usage Guidelines\r\n\r\nTo achieve optimal performance, we recommend the following settings:\r\n\r\n1. **Enforce Thoughtful Output**: Ensure the model starts with \"\\<think\\>\\n\" to prevent generating empty thinking content, which can degrade output quality. If you use `apply_chat_template` and set `add_generation_prompt=True`, this is already automatically implemented, but it may cause the response to lack the \\<think\\> tag at the beginning. This is normal behavior.\r\n\r\n2. **Sampling Parameters**:\r\n   - **We recommend using Temperature=0.6, TopP=0.95, MinP=0, TopK=40, and no repetition penalty for optimal performance.**\r\n   - Do **NOT** use Greedy decoding under any circumstances! It will lead to endless repetitions.\r\n   - You can adjust the TopK value between 20 and 40 to balance filtering out rare token occurrences and enhancing the diversity of the generated output.\r\n   - For supported frameworks, you can adjust the `presence_penalty` parameter between 0 and 2 to reduce endless repetitions. However, a higher value may occasionally result in language mixing and a slight decrease in performance.\r\n\r\n3. **No Thinking Content in History**: In multi-turn conversations, the historical model output should only include the final output part and does not need to include the thinking content. This feature is already implemented in `apply_chat_template`.\r\n\r\n4. **Standardize Output Format**: We recommend using prompts to standardize model outputs when benchmarking.\r\n   - **Math Problems**: Include \"Please reason step by step, and put your final answer within \\boxed{}.\" in the prompt.\r\n   - **Multiple-Choice Questions**: Add the following JSON structure to the prompt to standardize responses: \"Please show your choice in the `answer` field with only the choice letter, e.g.,`\\\"answer\\\": \\\"C\\\"`.\" in the prompt.\r\n\r\n5. **Handle Long Inputs**: For inputs exceeding 8,192 tokens, enable [YaRN](https://arxiv.org/abs/2309.00071) to improve the model's ability to capture long-sequence information effectively.\r\n\r\n    For supported frameworks, you could add the following to `config.json` to enable YaRN:\r\n    ```json\r\n    {\r\n        ...,\r\n        \"rope_scaling\": {\r\n            \"factor\": 4.0,\r\n            \"original_max_position_embeddings\": 32768,\r\n            \"type\": \"yarn\"\r\n        }\r\n    }\r\n    ```\r\n    For deployment, we recommend using vLLM. Please refer to our [Documentation](https://qwen.readthedocs.io/en/latest/deployment/vllm.html) for usage if you are not familiar with vLLM.\r\n    Presently, vLLM only supports static YARN, which means the scaling factor remains constant regardless of input length, **potentially impacting performance on shorter texts**. \r\n    We advise adding the `rope_scaling` configuration only when processing long contexts is required.\r\n\r\n## Ollama and Llama.cpp\r\n\r\nTo run the Qwen/QwQ-32B-GGUF model with Ollama, use the following command.\r\n\r\n```bash\r\nollama run hf.co/Qwen/QwQ-32B-GGUF:Q4_K_M # select one from Q8_0; Q6_K; Q5_K_M; Q5_0; Q4_K_M; Q4_0; Q3_K_M; Q2_K.\r\n# For modelscope User\r\nollama run modelscope.cn/Qwen/QwQ-32B-GGUF:Q4_K_M\r\n```\r\n\r\nIf you're using Llama.cpp, you can run the model with the following command.  This example uses the ``Q4_K_M`` quantization:\r\n\r\n```bash\r\n./llama-cli \\\r\n    --model QwQ-32B-GGUF/qwq-32b-q4_k_m.gguf \\\r\n    --threads 32 \\\r\n    --ctx-size 32768 \\\r\n    --seed 1234 \\\r\n    --temp 0.6 \\\r\n    --min-p 0.0 \\\r\n    --top-k 40 \\\r\n    --top-p 0.95 \\\r\n    -no-cnv \\\r\n    --samplers \"top_k;top_p;min_p;temperature;\" \\\r\n    --prompt \"<|im_start|>user\\nHow many r's are in the word \\\"strawberry\\\"<|im_end|>\\n<|im_start|>assistant\\n<think>\\n\"\r\n```\r\n\r\nYou can also consult [Unsloth's Guide](https://docs.unsloth.ai/basics/tutorial-how-to-run-qwq-32b-effectively) to see if their approach meets your needs. (Thanks to the Unsloth team!)\r\n\r\n## Try QwQ with API\r\n\r\nIf you face issues in deploying QwQ, we encourage you to test our API service provided by [Alibaba Cloud Model Studio](https://www.alibabacloud.com/help/en/model-studio/developer-reference/what-is-qwen-llm).\r\n\r\n\r\n```python\r\nfrom openai import OpenAI\r\nimport os\r\n\r\n# Initialize OpenAI client\r\nclient = OpenAI(\r\n    # If the environment variable is not configured, replace with your API Key: api_key=\"sk-xxx\"\r\n    # How to get an API KeyÔºöhttps://help.aliyun.com/zh/model-studio/developer-reference/get-api-key\r\n    api_key=os.getenv(\"DASHSCOPE_API_KEY\"),\r\n    base_url=\"https://dashscope.aliyuncs.com/compatible-mode/v1\"\r\n)\r\n\r\nreasoning_content = \"\"\r\ncontent = \"\"\r\n\r\nis_answering = False\r\n\r\ncompletion = client.chat.completions.create(\r\n    model=\"qwq-32b\",\r\n    messages=[\r\n        {\"role\": \"user\", \"content\": \"Which is larger, 9.9 or 9.11?\"}\r\n    ],\r\n    stream=True,\r\n    # Uncomment the following line to return token usage in the last chunk\r\n    # stream_options={\r\n    #     \"include_usage\": True\r\n    # }\r\n)\r\n\r\nprint(\"\\n\" + \"=\" * 20 + \"reasoning content\" + \"=\" * 20 + \"\\n\")\r\n\r\nfor chunk in completion:\r\n    # If chunk.choices is empty, print usage\r\n    if not chunk.choices:\r\n        print(\"\\nUsage:\")\r\n        print(chunk.usage)\r\n    else:\r\n        delta = chunk.choices[0].delta\r\n        # Print reasoning content\r\n        if hasattr(delta, 'reasoning_content') and delta.reasoning_content is not None:\r\n            print(delta.reasoning_content, end='', flush=True)\r\n            reasoning_content += delta.reasoning_content\r\n        else:\r\n            if delta.content != \"\" and is_answering is False:\r\n                print(\"\\n\" + \"=\" * 20 + \"content\" + \"=\" * 20 + \"\\n\")\r\n                is_answering = True\r\n            # Print content\r\n            print(delta.content, end='', flush=True)\r\n            content += delta.content\r\n```\r\n\r\n## Citation\r\n\r\nIf you find our paper and code useful in your research, please consider giving a star :star: and citation :pencil: :)\r\n\r\n\r\n```BibTeX\r\n@misc{qwq32b,\r\n    title = {QwQ-32B: Embracing the Power of Reinforcement Learning},\r\n    url = {https://qwenlm.github.io/blog/qwq-32b/},\r\n    author = {Qwen Team},\r\n    month = {March},\r\n    year = {2025}\r\n}\r\n\r\n@article{qwen2.5,\r\n      title={Qwen2.5 Technical Report}, \r\n      author={An Yang and Baosong Yang and Beichen Zhang and Binyuan Hui and Bo Zheng and Bowen Yu and Chengyuan Li and Dayiheng Liu and Fei Huang and Haoran Wei and Huan Lin and Jian Yang and Jianhong Tu and Jianwei Zhang and Jianxin Yang and Jiaxi Yang and Jingren Zhou and Junyang Lin and Kai Dang and Keming Lu and Keqin Bao and Kexin Yang and Le Yu and Mei Li and Mingfeng Xue and Pei Zhang and Qin Zhu and Rui Men and Runji Lin and Tianhao Li and Tianyi Tang and Tingyu Xia and Xingzhang Ren and Xuancheng Ren and Yang Fan and Yang Su and Yichang Zhang and Yu Wan and Yuqiong Liu and Zeyu Cui and Zhenru Zhang and Zihan Qiu},\r\n      journal={arXiv preprint arXiv:2412.15115},\r\n      year={2024}\r\n}\r\n```\r\n\r\n<br>\r\n",
    "py_files": {
        "eval/data/process_data.py": "import json\nimport zlib\nimport pickle\nimport base64\nimport hashlib\nfrom enum import Enum\nfrom datetime import datetime\nfrom dataclasses import dataclass\n\nfrom pathlib import Path\nfrom datasets import load_dataset\nfrom tqdm import tqdm\n\n\nclass Platform(Enum):\n    LEETCODE = \"leetcode\"\n    CODEFORCES = \"codeforces\"\n    ATCODER = \"atcoder\"\n\n\nclass Difficulty(Enum):\n    EASY = \"easy\"\n    MEDIUM = \"medium\"\n    HARD = \"hard\"\n\n\nclass TestType(Enum):\n    STDIN = \"stdin\"\n    FUNCTIONAL = \"functional\"\n\n\n@dataclass\nclass Test:\n    input: str\n    output: str\n    testtype: TestType\n\n    def __post_init__(self):\n        self.testtype = TestType(self.testtype)\n        # if self.testtype == TestType.FUNCTIONAL:\n        #     self.input = json.loads(self.input)\n        #     self.output = json.loads(self.output)\n\n\n@dataclass\nclass CodeGenerationProblem:\n    question_title: str\n    question_content: str\n    platform: Platform\n    question_id: str\n    contest_id: str\n    contest_date: datetime\n    starter_code: str\n    difficulty: Difficulty\n    public_test_cases: list[Test]\n    private_test_cases: list[Test]\n    metadata: dict\n\n    def __post_init__(self):\n        self.platform = Platform(self.platform)\n        self.difficulty = Difficulty(self.difficulty)\n        self.contest_date = datetime.fromisoformat(self.contest_date)\n\n        self.public_test_cases = json.loads(self.public_test_cases)  # type: ignore\n        self.public_test_cases = [Test(**t) for t in self.public_test_cases]\n\n        try:\n            self.private_test_cases = json.loads(self.private_test_cases)  # type: ignore\n        except:\n            self.private_test_cases = json.loads(pickle.loads(zlib.decompress(base64.b64decode(self.private_test_cases.encode(\"utf-8\"))  # type: ignore\n                                                                             )))  # type: ignore\n        self.private_test_cases = [Test(**t) for t in self.private_test_cases]\n\n        self.metadata = json.loads(self.metadata)  # type: ignore\n\n    def insert_output(self, output_list: list[str], code_list: list[str]) -> dict:\n        return {\n            \"question_title\": self.question_title,\n            \"question_content\": self.question_content,\n            \"platform\": self.platform.value,\n            \"question_id\": self.question_id,\n            \"contest_id\": self.contest_id,\n            \"contest_date\": self.contest_date.isoformat(),\n            \"starter_code\": self.starter_code,\n            \"difficulty\": self.difficulty.value,\n            \"output_list\": output_list,\n            \"code_list\": code_list,\n        }\n\n    def insert_output_evaluation(\n        self,\n        output_list: list[str],\n        code_list: list[str],\n        graded_list: list[bool],\n        **kwargs,\n    ) -> dict:\n        output = self.insert_output(output_list, code_list)\n        output[\"graded_list\"] = graded_list\n        output[\"pass@1\"] = graded_list.count(True) / len(graded_list)\n        for k, v in kwargs.items():\n            output[k] = v\n        return output\n\n    def get_evaluation_sample(self):\n        return {\n            \"input_output\": json.dumps({\n                \"inputs\": [t.input for t in self.public_test_cases + self.private_test_cases],\n                \"outputs\": [t.output for t in self.public_test_cases + self.private_test_cases],\n                \"fn_name\": self.metadata.get(\"func_name\", None),\n            }),\n        }\n\n\nclass PromptConstants:\n    SYSTEM_MESSAGE_GENERIC = f\"You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\"\n\n    SYSTEM_MESSAGE_GEMINI = f\"You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests. Do NOT use system calls like `exit` in the generated program. Ensure that the first code block contains the solution.\"\n\n    SYSTEM_MESSAGE_GEMINITHINK = f\"You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\"\n\n    SYSTEM_MESSAGE_DEEPSEEK = f\"You are an AI programming assistant, utilizing the DeepSeek Coder model, developed by DeepSeek Company, and you answer questions related to computer science.\"\n\n    SYSTEM_MESSAGE_CODEQWEN = f\"<|im_start|>system\\nYou are a helpful assistant.<|im_end|>\\n<|im_start|>user\"\n\n    FORMATTING_MESSAGE_WITH_STARTER_CODE = \"You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\"\n\n    FORMATTING_WITHOUT_STARTER_CODE = \"Read the inputs from stdin solve the problem and write the answer to stdout (do not directly test on the sample inputs). Enclose your code within delimiters as follows. Ensure that when the python program runs, it reads the inputs, runs the algorithm and writes output to STDOUT.\"\n\n\ndef load_code_generation_dataset(release_version=\"release_v5\") -> list[CodeGenerationProblem]:\n    dataset = load_dataset(\"livecodebench/code_generation_lite\", split=\"test\", version_tag=release_version)\n    dataset = [CodeGenerationProblem(**p) for p in dataset]  # type: ignore\n    print(f\"Loaded {len(dataset)} problems\")\n    return dataset\n\n\ndef get_qwen_question_template_answer(question: CodeGenerationProblem):\n    prompt = \"You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests. You will NOT return anything except for the program.\\n\\n\"\n    prompt += f\"Question: {question.question_content}\\n\\n\"\n    if question.starter_code:\n        prompt += f\"{PromptConstants.FORMATTING_MESSAGE_WITH_STARTER_CODE}\\n\"\n        prompt += f\"```python\\n{question.starter_code}\\n```\\n\\n\"\n    else:\n        prompt += f\"{PromptConstants.FORMATTING_WITHOUT_STARTER_CODE}\\n\"\n        prompt += f\"```python\\n# YOUR CODE HERE\\n```\\n\\n\"\n    return prompt\n\n\ndef get_qwen_reasoning_question_template_answer(question: CodeGenerationProblem):\n    prompt = \"You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\\n\\n\"\n    prompt += f\"Question: {question.question_content}\\n\\n\"\n    if question.starter_code:\n        prompt += f\"{PromptConstants.FORMATTING_MESSAGE_WITH_STARTER_CODE}\\n\"\n        prompt += f\"```python\\n{question.starter_code}\\n```\\n\\n\"\n    else:\n        prompt += f\"{PromptConstants.FORMATTING_WITHOUT_STARTER_CODE}\\n\"\n        prompt += f\"```python\\n# YOUR CODE HERE\\n```\\n\\n\"\n    return prompt\n\n\ndef calculate_string_md5(input_string: str):\n    md5 = hashlib.md5()\n    md5.update(input_string.encode('utf-8'))\n    return md5.hexdigest()\n\n\nif __name__ == \"__main__\":\n\n    output_livecodebench_v5_tests_dir = \"./data/livecodebench_v5_tests\"\n    Path(output_livecodebench_v5_tests_dir).mkdir(parents=True, exist_ok=True)\n\n    dataset = load_code_generation_dataset(release_version=\"release_v5\")\n    num_samples = 8\n\n    livecodebench_v5_inputs_outputs = []\n    livecodebench_v5_dataset = []\n\n    # template for general language model\n    # prompt_template = get_qwen_question_template_answer\n    # template for reasoning model\n    prompt_template = get_qwen_reasoning_question_template_answer\n\n    for global_id, sample in enumerate(tqdm(dataset)):\n        inputs_outputs = sample.get_evaluation_sample()\n        livecodebench_v5_dataset.append({\n            \"global_id\": global_id,\n            \"question_id\": sample.question_id,\n            \"contest_id\": sample.contest_id,\n            \"contest_date\": sample.contest_date.isoformat(),\n            \"prompt\": prompt_template(sample),\n            \"tests\": {\n                \"fname\": f\"{global_id}.json\",\n                \"md5\": calculate_string_md5(json.dumps(inputs_outputs)),\n            },\n        })\n        livecodebench_v5_inputs_outputs.append(inputs_outputs)\n\n        # save test cases\n        with open(Path(output_livecodebench_v5_tests_dir) / f\"{global_id}.json\", \"w\") as f:\n            json.dump(inputs_outputs, f)\n",
        "eval/eval/eval.py": "import json\nimport argparse\nfrom tqdm import tqdm\nimport os\n\nfrom math_opensource import compute_scores as compute_scores_math_opensource\nfrom livecodebench_v5 import compute_scores as compute_scores_livecodebench_v5\nfrom ifeval import compute_scores as compute_scores_ifeval\n\ndef get_after_think(text):\n    parts = text.split(\"\\n</think>\\n\\n\", 1)\n    if len(parts) > 1:\n        return parts[1]\n    else:\n        return text\ndef main():\n    parser = argparse.ArgumentParser(description=\"Evaluate model outputs\")\n    parser.add_argument(\"--input_path\", type=str, required=True, help=\"Path to input jsonl file\")\n    parser.add_argument(\"--cache_path\", type=str, required=True, help=\"Path to save cache results\")\n    parser.add_argument(\"--task_name\", type=str, required=True, help=\"Task should be in ['math_opensource/aime24', 'math_opensource/aime25' ,'livecodebench', 'ifeval']\")\n    args = parser.parse_args()\n\n    os.makedirs(os.path.dirname(args.cache_path), exist_ok=True)\n\n    with open(args.input_path, 'r', encoding='utf-8') as f:\n        data = [json.loads(line) for line in f]\n    for item in data:\n        item[\"task\"] = args.task_name\n        temp = get_after_think(item['gen'][0])\n        item['gen'][0] = temp\n    if \"math_opensource\" in args.task_name:\n        acc = compute_scores_math_opensource(data, args.cache_path)\n        print(f\"Task: {args.task_name}, Accuracy: {acc}\")\n    elif \"livecodebench\" in args.task_name:\n        acc = compute_scores_livecodebench_v5(data, args.cache_path)\n        print(f\"Task: {args.task_name}, Pass@1: {acc}\")\n    elif \"ifeval\" in args.task_name:\n        acc = compute_scores_ifeval(data, args.cache_path)\n        print(f\"Task: {args.task_name}, Strict_prompt_acc: {acc}\")\n    else:\n        print(f\"No evaluation function found for task name: {args.task_name}\")\n    \n    print(\"Evaluation complete!\")\n\nif __name__ == \"__main__\":\n    main()",
        "eval/eval/ifeval.py": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\nimport json\nimport itertools\nimport logging\nimport os\nfrom pathlib import Path\nfrom copy import deepcopy\nfrom collections import defaultdict\nfrom statistics import mean\n\nfrom ifeval_utils import instructions_registry\n\ndef test_instruction_following_strict(inp, response):\n    \"\"\"Tests response to see if instrutions are followed.\"\"\"\n    instruction_list = inp['instruction_id_list']\n    is_following_list = []\n\n    for index, instruction_id in enumerate(instruction_list):\n        instruction_cls = instructions_registry.INSTRUCTION_DICT[instruction_id]\n        instruction = instruction_cls(instruction_id)\n\n        instruction.build_description(**inp['kwargs'][index])\n        args = instruction.get_instruction_args()\n        if args and \"prompt\" in args:\n            instruction.build_description(prompt=inp['prompt'])\n\n        if response.strip() and instruction.check_following(response):\n            is_following_list.append(True)\n        else:\n            is_following_list.append(False)\n\n    return {\n        \"strict_prompt_acc\": all(is_following_list),\n        \"strict_instruction_acc\": is_following_list\n    }\ndef compute_scores(jobs, cache_path):\n    for job in jobs:\n        assert len(job[\"gen\"]) == 1\n        gen = job['gen'][0]\n        job.update(test_instruction_following_strict(job, gen))\n    save_cache(jobs, cache_path)\n    return mean(x['strict_prompt_acc'] for x in jobs)\n\ndef save_cache(jobs, cache_path):\n    with open(cache_path, \"w\") as g:\n        for job in jobs:\n            g.write(json.dumps(job, ensure_ascii=False) + \"\\n\")\n            g.flush()\n\n",
        "eval/eval/ifeval_utils/__init__.py": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n",
        "eval/eval/ifeval_utils/instructions.py": "# coding=utf-8\n# Copyright 2023 The Google Research Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Library of instructions.\"\"\"\nimport collections\nimport json\nimport random\nimport re\nimport string\nfrom typing import Dict, Optional, Sequence, Union\n\nfrom absl import logging\nimport langdetect\n\nfrom . import instructions_util\n\n\n_InstructionArgsDtype = Optional[Dict[str, Union[int, str, Sequence[str]]]]\n\n_LANGUAGES = instructions_util.LANGUAGE_CODES\n\n# The relational operation for comparison.\n_COMPARISON_RELATION = (\"less than\", \"at least\")\n\n# The maximum number of sentences.\n_MAX_NUM_SENTENCES = 20\n\n# The number of placeholders.\n_NUM_PLACEHOLDERS = 4\n\n# The number of bullet lists.\n_NUM_BULLETS = 5\n\n# The options of constrained response.\n_CONSTRAINED_RESPONSE_OPTIONS = (\n    \"My answer is yes.\", \"My answer is no.\", \"My answer is maybe.\")\n\n# The options of starter keywords.\n_STARTER_OPTIONS = (\"I would say\", \"My answer is\", \"I believe\",\n                    \"In my opinion\", \"I think\", \"I reckon\", \"I feel\",\n                    \"From my perspective\", \"As I see it\", \"According to me\",\n                    \"As far as I'm concerned\", \"To my understanding\",\n                    \"In my view\", \"My take on it is\", \"As per my perception\")\n\n# The options of ending keywords.\n# TODO(jeffreyzhou) add more ending options\n_ENDING_OPTIONS = (\"Any other questions?\",\n                   \"Is there anything else I can help with?\")\n\n# The number of highlighted sections.\n_NUM_HIGHLIGHTED_SECTIONS = 4\n\n# The section spliter.\n_SECTION_SPLITER = (\"Section\", \"SECTION\")\n\n# The number of sections.\n_NUM_SECTIONS = 5\n\n# The number of paragraphs.\n_NUM_PARAGRAPHS = 5\n\n# The postscript marker.\n_POSTSCRIPT_MARKER = (\"P.S.\", \"P.P.S\")\n\n# The number of keywords.\n_NUM_KEYWORDS = 2\n\n# The occurrences of a single keyword.\n_KEYWORD_FREQUENCY = 3\n\n# The occurrences of a single letter.\n_LETTER_FREQUENCY = 10\n\n# The occurrences of words with all capital letters.\n_ALL_CAPITAL_WORD_FREQUENCY = 20\n\n# The number of words in the response.\n_NUM_WORDS_LOWER_LIMIT = 100\n_NUM_WORDS_UPPER_LIMIT = 500\n\ndef removeprefix(s, prefix):\n  if s.startswith(prefix):\n    return s[len(prefix):]\n  else:\n    return s\n\ndef removesuffix(s, suffix):\n  if s.endswith(suffix):\n    return s[:-len(suffix)]\n  else:\n    return s\n\nclass Instruction:\n  \"\"\"An instruction template.\"\"\"\n\n  def __init__(self, instruction_id):\n    self.id = instruction_id\n\n  def build_description(self, **kwargs):\n    raise NotImplementedError(\"`build_description` not implemented.\")\n\n  def get_instruction_args(self):\n    raise NotImplementedError(\"`get_instruction_args` not implemented.\")\n\n  def get_instruction_args_keys(self):\n    raise NotImplementedError(\"`get_instruction_args_keys` not implemented.\")\n\n  def check_following(self, value):\n    raise NotImplementedError(\"`check_following` not implemented.\")\n\n\nclass ResponseLanguageChecker(Instruction):\n  \"\"\"Check the language of the entire response.\"\"\"\n\n  def build_description(self, *, language = None):\n    \"\"\"Build the instruction description.\n\n    Args:\n      language: A string representing the expected language of the response. The\n        language has to comply to the 97 types defined in\n        `langid.py` (https://pypi.org/project/langid/1.1.5/), which follows\n        ISO 639-1 codes (https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes);\n        for example, `en` for English, `zh` for Chinese, `fr` for French.\n\n    Returns:\n      A string representing the instruction description.\n    \"\"\"\n    self._language = language\n    if self._language is None:\n      self._language = random.choice(list(_LANGUAGES.keys()))\n    # TODO(tianjianlu): opens the description generation to more choices.\n    self._description_pattern = (\n        \"Your ENTIRE response should be in {language} language, no other \" +\n        \"language is allowed.\")\n    return self._description_pattern.format(language=_LANGUAGES[self._language])\n\n  def get_instruction_args(self):\n    \"\"\"Returns the keyward args of `build_description`.\"\"\"\n    return {\"language\": self._language}\n\n  def get_instruction_args_keys(self):\n    \"\"\"Returns the args keys of `build_description`.\"\"\"\n    return [\"language\"]\n\n  def check_following(self, value):\n    \"\"\"Check if the language of the entire response follows the instruction.\n\n    Args:\n      value: A string representing the response.\n\n    Returns:\n      True if the language of `value` follows instruction; otherwise False.\n    \"\"\"\n    assert isinstance(value, str)\n\n    try:\n      return langdetect.detect(value) == self._language\n    except langdetect.LangDetectException as e:\n      # Count as instruction is followed.\n      logging.error(\n          \"Unable to detect language for text %s due to %s\", value, e\n      )  # refex: disable=pytotw.037\n      return True\n\n\nclass NumberOfSentences(Instruction):\n  \"\"\"Check the number of sentences.\"\"\"\n\n  def build_description(self, *, num_sentences = None,\n                        relation = None):\n    \"\"\"Build the instruction description.\n\n    Args:\n      num_sentences: An integer specifying the number of sentences as a\n        threshold.\n      relation: A string in (`less than`, `at least`), defining the relational\n        operator for comparison.\n        Two relational comparisons are supported for now:\n        if 'less than', the actual number of sentences < the threshold;\n        if 'at least', the actual number of sentences >= the threshold.\n\n    Returns:\n      A string representing the instruction description.\n    \"\"\"\n    # The number of sentences as a threshold for comparison.\n    self._num_sentences_threshold = num_sentences\n    if (self._num_sentences_threshold is None or\n        self._num_sentences_threshold < 0):\n      self._num_sentences_threshold = random.randint(1, _MAX_NUM_SENTENCES)\n\n    if relation is None:\n      self._comparison_relation = random.choice(_COMPARISON_RELATION)\n    elif relation not in _COMPARISON_RELATION:\n      raise ValueError(\"The supported relation for comparison must be in \"\n                       f\"{_COMPARISON_RELATION}, but {relation} is given.\")\n    else:\n      self._comparison_relation = relation\n\n    self._description_pattern = (\n        \"Your response should contain {relation} {num_sentences} sentences.\")\n    return self._description_pattern.format(\n        relation=self._comparison_relation,\n        num_sentences=self._num_sentences_threshold)\n\n  def get_instruction_args(self):\n    \"\"\"Returns the keyward args of `build_description`.\"\"\"\n    return {\"num_sentences\": self._num_sentences_threshold,\n            \"relation\": self._comparison_relation}\n\n  def get_instruction_args_keys(self):\n    \"\"\"Returns the args keys of `build_description`.\"\"\"\n    return [\"num_sentences\", \"relation\"]\n\n  def check_following(self, value):\n    \"\"\"Check if the number of sentences follows the instruction.\n\n    Args:\n      value: A string representing the response.\n\n    Returns:\n      True if the response follows the instruction.\n\n    Raise:\n        ValueError if the string in `instruction_args` is not in\n        [`less_than`, `at_least`].\n    \"\"\"\n    num_sentences = instructions_util.count_sentences(value)\n    if self._comparison_relation == _COMPARISON_RELATION[0]:\n      return num_sentences < self._num_sentences_threshold\n    elif self._comparison_relation == _COMPARISON_RELATION[1]:\n      return num_sentences >= self._num_sentences_threshold\n\n\nclass PlaceholderChecker(Instruction):\n  \"\"\"Check the placeholders in template writing.\"\"\"\n\n  def build_description(self, *, num_placeholders = None):\n    \"\"\"Build the instruction description.\n\n    Args:\n      num_placeholders: An integer denoting the minimum number of\n        placeholders required in the response.\n\n    Returns:\n      A string representing the instruction description.\n    \"\"\"\n    self._num_placeholders = num_placeholders\n    if self._num_placeholders is None or self._num_placeholders < 0:\n      self._num_placeholders = random.randint(1, _NUM_PLACEHOLDERS)\n    self._description_pattern = (\n        \"The response must contain at least {num_placeholders} placeholders \" +\n        \"represented by square brackets, such as [address].\")\n    return self._description_pattern.format(\n        num_placeholders=self._num_placeholders)\n\n  def get_instruction_args(self):\n    \"\"\"Returns the keyward args of `build_description`.\"\"\"\n    return {\"num_placeholders\": self._num_placeholders}\n\n  def get_instruction_args_keys(self):\n    \"\"\"Returns the args keys of `build_description`.\"\"\"\n    return [\"num_placeholders\"]\n\n  def check_following(self, value):\n    \"\"\"Check if the number of placeholders follows the instruction.\n\n    Args:\n      value: A string representing the response.\n\n    Returns:\n      True if the actual number of placeholders in the response is greater than\n      or equal to `num_placeholders`; otherwise, False.\n    \"\"\"\n    placeholders = re.findall(r\"\\[.*?\\]\", value)\n    num_placeholders = len(placeholders)\n    return num_placeholders >= self._num_placeholders\n\n\nclass BulletListChecker(Instruction):\n  \"\"\"Checks the bullet list in the prompt.\"\"\"\n\n  def build_description(self, *, num_bullets = None):\n    \"\"\"Build the instruction description.\n\n    Args:\n      num_bullets: An integer specifying the exact number of bullet lists\n        that is required to appear in the response.\n\n    Returns:\n      A string representing the instruction description.\n    \"\"\"\n    self._num_bullets = num_bullets\n    if self._num_bullets is None or self._num_bullets < 0:\n      self._num_bullets = random.randint(1, _NUM_BULLETS)\n    self._description_pattern = (\n        \"Your answer must contain exactly {num_bullets} bullet points. \" +\n        \"Use the markdown bullet points such as:\\n\" +\n        \"* This is point 1. \\n\" +\n        \"* This is point 2\")\n    return self._description_pattern.format(\n        num_bullets=self._num_bullets)\n\n  def get_instruction_args(self):\n    \"\"\"Returns the keyward args of `build_description`.\"\"\"\n    return {\"num_bullets\": self._num_bullets}\n\n  def get_instruction_args_keys(self):\n    \"\"\"Returns the args keys of `build_description`.\"\"\"\n    return [\"num_bullets\"]\n\n  def check_following(self, value):\n    r\"\"\"Check if the number of bullet lists meets the requirement.\n\n    Args:\n      value: A string representing the response. The response is expected to\n        contain some bullet lists that start with `\\*`.\n\n    Returns:\n      True if the actual number of bullet lists in the response meets the\n      requirement.\n    \"\"\"\n    bullet_lists = re.findall(r\"^\\s*\\*[^\\*].*$\", value, flags=re.MULTILINE)\n    bullet_lists_2 = re.findall(r\"^\\s*-.*$\", value, flags=re.MULTILINE)\n    num_bullet_lists = len(bullet_lists) + len(bullet_lists_2)\n    return num_bullet_lists == self._num_bullets\n\n\nclass ConstrainedResponseChecker(Instruction):\n  \"\"\"Checks the constrained response.\"\"\"\n\n  def build_description(self):\n    \"\"\"Build the instruction description.\"\"\"\n    # A sequence of string(s) representing the options of the expected response.\n    self._constrained_responses = _CONSTRAINED_RESPONSE_OPTIONS\n    self._description_pattern = (\n        \"Answer with one of the following options: {response_options}\")\n    return self._description_pattern.format(\n        response_options=self._constrained_responses)\n\n  def get_instruction_args(self):\n    \"\"\"Returns the keyward args of `build_description`.\"\"\"\n    return None\n\n  def get_instruction_args_keys(self):\n    \"\"\"Returns the args keys of `build_description`.\"\"\"\n    return []\n\n  def check_following(self, value):\n    \"\"\"Checks if the response matches the constrained options.\n\n    Args:\n      value: A string representing the response.\n\n    Returns:\n      True if the actual response contains one of the options in the constrained\n      responses; otherwise False.\n    \"\"\"\n    value = value.strip()\n    for constrained_response in self._constrained_responses:\n      if constrained_response in value:\n        return True\n    return False\n\n\nclass ConstrainedStartChecker(Instruction):\n  \"\"\"Checks the response start.\"\"\"\n\n  def build_description(self, *, starter = None):\n    \"\"\"Build the instruction description.\n\n    Args:\n      starter: A string representing the keyward that the response should start\n        with.\n\n    Returns:\n      A string representing the instruction description.\n    \"\"\"\n    self._starter = starter.strip() if isinstance(starter, str) else starter\n    if self._starter is None:\n      self._starter = random.choice(_STARTER_OPTIONS)\n    self._description_pattern = (\n        \"During the conversation, when it is your turn, \" +\n        \"please always start with {starter}\")\n    return self._description_pattern.format(starter=self._starter)\n\n  def get_instruction_args(self):\n    \"\"\"Returns the keyward args of `build_description`.\"\"\"\n    return {\"starter\": self._starter}\n\n  def get_instruction_args_keys(self):\n    \"\"\"Returns the args keys of `build_description`.\"\"\"\n    return [\"starter\"]\n\n  def check_following(self, value):\n    \"\"\"Checks if the response starts with the constrained keyword or phrase.\n\n    Args:\n      value: A string representing the response.\n\n    Returns:\n      True if the response starts with the given phrase or keyword that is\n      contained in `instruction_args`; otherwise, False.\n    \"\"\"\n    response_pattern = r\"^\\s*\" + self._starter + r\".*$\"\n    response_with_constrained_start = re.search(response_pattern, value,\n                                                flags=re.MULTILINE)\n    return True if response_with_constrained_start else False\n\n\nclass HighlightSectionChecker(Instruction):\n  \"\"\"Checks the highlighted section.\"\"\"\n\n  def build_description(self, *, num_highlights = None):\n    \"\"\"Build the instruction description.\n\n    Args:\n      num_highlights: An integer specifying the minimum number of highlighted\n        sections.\n\n    Returns:\n      A string representing the instruction description.\n    \"\"\"\n    self._num_highlights = num_highlights\n    if self._num_highlights is None or self._num_highlights < 0:\n      self._num_highlights = random.randint(1, _NUM_HIGHLIGHTED_SECTIONS)\n\n    self._description_pattern = (\n        \"Highlight at least {num_highlights} sections in your answer with \" +\n        \"markdown, i.e. *highlighted section*.\")\n\n    return self._description_pattern.format(num_highlights=self._num_highlights)\n\n  def get_instruction_args(self):\n    \"\"\"Returns the keyward args of `build_description`.\"\"\"\n    return {\"num_highlights\": self._num_highlights}\n\n  def get_instruction_args_keys(self):\n    \"\"\"Returns the args keys of `build_description`.\"\"\"\n    return [\"num_highlights\"]\n\n  def check_following(self, value):\n    \"\"\"Checks if the number of highlighted sections meets the requirement.\n\n    Args:\n      value: a string repesenting the response. The response is expected to\n        contain highlighted sections in the format of *highlighted*.\n\n    Returns:\n      True if the actual number of highlighted sections in the format of\n      *highlighed sections* meets the minimum requirement; otherwise False.\n    \"\"\"\n    num_highlights = 0\n    highlights = re.findall(r\"\\*[^\\n\\*]*\\*\", value)\n    double_highlights = re.findall(r\"\\*\\*[^\\n\\*]*\\*\\*\", value)\n    for highlight in highlights:\n      if highlight.strip(\"*\").strip():\n        num_highlights += 1\n    for highlight in double_highlights:\n      if removesuffix(removeprefix(highlight, \"**\"), \"**\").strip():\n        num_highlights += 1\n\n    return num_highlights >= self._num_highlights\n\n\nclass SectionChecker(Instruction):\n  \"\"\"Checks the sections.\"\"\"\n\n  def build_description(self, *, section_spliter = None,\n                        num_sections = None):\n    \"\"\"Build the instruction description.\n\n    Args:\n      section_spliter: A string represents the section spliter keyword that\n        marks a new section, i.e., `Section` or `SECTION`.\n      num_sections: An integer specifying the number of sections.\n\n    Returns:\n      A string representing the instruction description.\n    \"\"\"\n    self._section_spliter = section_spliter.strip() if isinstance(\n        section_spliter, str) else section_spliter\n    if self._section_spliter is None:\n      self._section_spliter = random.choice(_SECTION_SPLITER)\n\n    self._num_sections = num_sections\n    if self._num_sections is None or self._num_sections < 0:\n      self._num_sections = random.randint(1, _NUM_SECTIONS)\n\n    self._description_pattern = (\n        \"Your response must have {num_sections} sections. Mark the beginning \" +\n        \"of each section with {section_spliter} X, such as:\\n\" +\n        \"{section_spliter} 1\\n\" +\n        \"[content of section 1]\\n\" +\n        \"{section_spliter} 2\\n\" +\n        \"[content of section 2]\")\n\n    return self._description_pattern.format(\n        num_sections=self._num_sections,\n        section_spliter=self._section_spliter)\n\n  def get_instruction_args(self):\n    \"\"\"Returns the keyward args of `build_description`.\"\"\"\n    return {\"section_spliter\": self._section_spliter,\n            \"num_sections\": self._num_sections}\n\n  def get_instruction_args_keys(self):\n    \"\"\"Returns the args keys of `build_description`.\"\"\"\n    return [\"section_spliter\", \"num_sections\"]\n\n  def check_following(self, value):\n    \"\"\"Checks the response contains multiple sections.\n\n    Args:\n      value: A string representing the response. The response is expected\n        to contain multiple sections (number of sections is greater than 1).\n        A new section starts with `Section 1`, where the number denotes the\n        section index.\n\n    Returns:\n      True if the number of sections in the response is greater than or equal to\n      the minimum number of sections; otherwise, False.\n    \"\"\"\n    section_splitter_patten = r\"\\s?\" + self._section_spliter  + r\"\\s?\\d+\\s?\"\n    sections = re.split(section_splitter_patten, value)\n    num_sections = len(sections) - 1\n    return num_sections >= self._num_sections\n\n\nclass ParagraphChecker(Instruction):\n  \"\"\"Checks the paragraphs.\"\"\"\n\n  def build_description(self, *, num_paragraphs = None):\n    \"\"\"Build the instruction description.\n\n    Args:\n      num_paragraphs: An integer specifying the number of paragraphs.\n\n    Returns:\n      A string representing the instruction description.\n    \"\"\"\n    self._num_paragraphs = num_paragraphs\n    if self._num_paragraphs is None or self._num_paragraphs < 0:\n      self._num_paragraphs = random.randint(1, _NUM_PARAGRAPHS)\n\n    self._description_pattern = (\n        \"There should be {num_paragraphs} paragraphs. \" +\n        \"Paragraphs are separated with the markdown divider: ***\")\n\n    return self._description_pattern.format(num_paragraphs=self._num_paragraphs)\n\n  def get_instruction_args(self):\n    \"\"\"Returns the keyward args of `build_description`.\"\"\"\n    return {\"num_paragraphs\": self._num_paragraphs}\n\n  def get_instruction_args_keys(self):\n    \"\"\"Returns the args keys of `build_description`.\"\"\"\n    return [\"num_paragraphs\"]\n\n  def check_following(self, value):\n    \"\"\"Checks the response contains required number of paragraphs.\n\n    Args:\n      value: A string representing the response. The response may contain\n        paragraphs that are separated by the markdown divider: `***`.\n\n    Returns:\n      True if the actual number of paragraphs is the same as required;\n      otherwise, False.\n    \"\"\"\n    paragraphs = re.split(r\"\\s?\\*\\*\\*\\s?\", value)\n    num_paragraphs = len(paragraphs)\n\n    for index, paragraph in enumerate(paragraphs):\n      if not paragraph.strip():\n        if index == 0 or index == len(paragraphs) - 1:\n          num_paragraphs -= 1\n        else:\n          return False\n\n    return num_paragraphs == self._num_paragraphs\n\n\nclass PostscriptChecker(Instruction):\n  \"\"\"Checks the postscript.\"\"\"\n\n  def build_description(self, *, postscript_marker = None\n                        ):\n    \"\"\"Build the instruction description.\n\n    Args:\n      postscript_marker: A string containing the keyword that marks the start\n        of the postscript section.\n\n    Returns:\n      A string representing the instruction description.\n    \"\"\"\n    self._postscript_marker = postscript_marker.strip() if isinstance(\n        postscript_marker, str) else postscript_marker\n    if self._postscript_marker is None:\n      self._postscript_marker = random.choice(_POSTSCRIPT_MARKER)\n\n    self._description_pattern = (\n        \"At the end of your response, please explicitly add a postscript \" +\n        \"starting with {postscript}\")\n\n    return self._description_pattern.format(postscript=self._postscript_marker)\n\n  def get_instruction_args(self):\n    \"\"\"Returns the keyward args of `build_description`.\"\"\"\n    return {\"postscript_marker\": self._postscript_marker}\n\n  def get_instruction_args_keys(self):\n    \"\"\"Returns the args keys of `build_description`.\"\"\"\n    return [\"postscript_marker\"]\n\n  def check_following(self, value):\n    \"\"\"Checks if the response follows the postscript format.\n\n    Args:\n      value: a string representing the response. The response is expected to\n        contain a postscript section.\n\n    Returns:\n      True if the response contains a postscript section starting with\n      the keyword containing in the `instruction_args`; otherwise False.\n    \"\"\"\n    value = value.lower()\n    if self._postscript_marker == \"P.P.S\":\n      postscript_pattern = r\"\\s*p\\.\\s?p\\.\\s?s.*$\"\n    elif self._postscript_marker == \"P.S.\":\n      postscript_pattern = r\"\\s*p\\.\\s?s\\..*$\"\n    else:\n      postscript_pattern = r\"\\s*\" + self._postscript_marker.lower() + r\".*$\"\n    postscript = re.findall(postscript_pattern, value, flags=re.MULTILINE)\n    return True if postscript else False\n\n\nclass RephraseChecker(Instruction):\n  \"\"\"Checks the repharse.\"\"\"\n\n  def build_description(self, *, original_message):\n    \"\"\"Build the instruction description.\n\n    Args:\n      original_message: A string representing the original message. The\n        rephrased response should only change its words/sentences in between\n        its two asterisks, for example, *change me*. Both original and rephrased\n        messages should contain the changes in the form of *change me*.\n\n    Returns:\n      A string representing the instruction description.\n    \"\"\"\n    if not self.is_change(original_message):\n      raise ValueError(f\"Message {original_message} does not contain changes \"\n                       \"in the form of *change me*.\")\n\n    self._reference_without_change = original_message\n    self._description = (\"Rephrasing: Your rephrased response should only\" +\n                         \"change the words/sentences in between two asterisks\" +\n                         \"such as *change me*.\")\n    return self._description\n\n  def get_instruction_args(self):\n    \"\"\"Returns the keyward args of `build_description`.\"\"\"\n    return {\"original_message\": self._reference_without_change}\n\n  def get_instruction_args_keys(self):\n    \"\"\"Returns the args keys of `build_description`.\"\"\"\n    return [\"original_message\"]\n\n  def check_following(self, value):\n    r\"\"\"Checks if the rephrasing follows the instruction.\n\n    Args:\n      value: A string representing the response, which is expected to rephras\n        the string of `instruction_args`.\n\n    Returns:\n      True if `value` and `instruction_args` only differ by the words/sentences\n      in between two asterisks such as *change me*; otherwise, False.\n    \"\"\"\n\n    if not self.is_change(value):\n      raise ValueError(f\"value {value} does not contain \"\n                       \"changes in the form of *change me*.\")\n\n    response_without_changes = self.strip_changes(value)\n    reference_without_changes = self.strip_changes(\n        self._reference_without_change)\n\n    return response_without_changes == reference_without_changes\n\n  def is_change(self, response):\n    \"\"\"Check if there is change in the response in the form of *change me*.\"\"\"\n    return re.search(r\"\\*.*\\*\", response)\n\n  def strip_changes(self, response):\n    \"\"\"Strips off the changes.\"\"\"\n    return re.sub(r\"\\*.*\\*\", \"\", response)\n\n\nclass KeywordChecker(Instruction):\n  \"\"\"Check the exisitence of certain keywords.\"\"\"\n\n  def build_description(self, *, keywords = None\n                        ):\n    \"\"\"Build the instruction description.\n\n    Args:\n      keywords: A sequence of strings representing the keywords that are\n        expected in the response.\n\n    Returns:\n      A string representing the instruction description.\n    \"\"\"\n\n    if not keywords:\n      self._keywords = instructions_util.generate_keywords(\n          num_keywords=_NUM_KEYWORDS)\n    else:\n      self._keywords = keywords\n    self._keywords = sorted(self._keywords)\n\n    self._description_pattern = (\"Include keywords {keywords} in the response.\")\n\n    return self._description_pattern.format(keywords=self._keywords)\n\n  def get_instruction_args(self):\n    \"\"\"Returns the keyward args of `build_description`.\"\"\"\n    return {\"keywords\": self._keywords}\n\n  def get_instruction_args_keys(self):\n    \"\"\"Returns the args keys of `build_description`.\"\"\"\n    return [\"keywords\"]\n\n  def check_following(self, value):\n    \"\"\"Check if the response contain the expected keywords.\"\"\"\n    for keyword in self._keywords:\n      if not re.search(keyword, value, flags=re.IGNORECASE):\n        return False\n    return True\n\n\nclass KeywordFrequencyChecker(Instruction):\n  \"\"\"Check the keyword frequency.\"\"\"\n\n  def build_description(self, *, keyword = None,\n                        frequency = None,\n                        relation = None):\n    \"\"\"Build the instruction description.\n\n    Args:\n      keyword: A string representing a keyword that is expected in the response.\n      frequency: An integer specifying the number of times `keyword` is expected\n        to appear in the response.\n      relation: A string in (`less than`, `at least`), defining the relational\n        operator for comparison.\n        Two relational comparisons are supported for now:\n        if 'less than', the actual number of occurrences < frequency;\n        if 'at least', the actual number of occurrences >= frequency.\n\n    Returns:\n      A string representing the instruction description.\n    \"\"\"\n    if not keyword:\n      self._keyword = instructions_util.generate_keywords(num_keywords=1)[0]\n    else:\n      self._keyword = keyword.strip()\n\n    self._frequency = frequency\n    if self._frequency is None or self._frequency < 0:\n      self._frequency = random.randint(1, _KEYWORD_FREQUENCY)\n\n    if relation is None:\n      self._comparison_relation = random.choice(_COMPARISON_RELATION)\n    elif relation not in _COMPARISON_RELATION:\n      raise ValueError(\"The supported relation for comparison must be in \"\n                       f\"{_COMPARISON_RELATION}, but {relation} is given.\")\n    else:\n      self._comparison_relation = relation\n\n    self._description_pattern = (\n        \"In your response, the word {keyword} should appear {relation} \" +\n        \"{frequency} times.\")\n\n    return self._description_pattern.format(\n        keyword=self._keyword,\n        relation=self._comparison_relation,\n        frequency=self._frequency)\n\n  def get_instruction_args(self):\n    \"\"\"Returns the keyward args of `build_description`.\"\"\"\n    return {\"keyword\": self._keyword,\n            \"frequency\": self._frequency,\n            \"relation\": self._comparison_relation}\n\n  def get_instruction_args_keys(self):\n    \"\"\"Returns the args keys of `build_description`.\"\"\"\n    return [\"keyword\", \"frequency\", \"relation\"]\n\n  def check_following(self, value):\n    \"\"\"Checks if the response contain the keyword with required frequency.\"\"\"\n    actual_occurrences = len(re.findall(\n        self._keyword, value, flags=re.IGNORECASE))\n\n    if self._comparison_relation == _COMPARISON_RELATION[0]:\n      return actual_occurrences < self._frequency\n    elif self._comparison_relation == _COMPARISON_RELATION[1]:\n      return actual_occurrences >= self._frequency\n\n\nclass NumberOfWords(Instruction):\n  \"\"\"Checks the number of words.\"\"\"\n\n  def build_description(self, *, num_words = None,\n                        relation = None):\n    \"\"\"Build the instruction description.\n\n    Args:\n      num_words: An integer specifying the number of words contained in the\n        response.\n      relation: A string in (`less than`, `at least`), defining the relational\n        operator for comparison.\n        Two relational comparisons are supported for now:\n        if 'less than', the actual number of words < num_words;\n        if 'at least', the actual number of words >= num_words.\n\n    Returns:\n      A string representing the instruction description.\n    \"\"\"\n\n    self._num_words = num_words\n    if self._num_words is None or self._num_words < 0:\n      self._num_words = random.randint(\n          _NUM_WORDS_LOWER_LIMIT, _NUM_WORDS_UPPER_LIMIT\n      )\n\n    if relation is None:\n      self._comparison_relation = random.choice(_COMPARISON_RELATION)\n    elif relation not in _COMPARISON_RELATION:\n      raise ValueError(\"The supported relation for comparison must be in \"\n                       f\"{_COMPARISON_RELATION}, but {relation} is given.\")\n    else:\n      self._comparison_relation = relation\n\n    self._description_pattern = (\n        \"Answer with {relation} {num_words} words.\")\n\n    return self._description_pattern.format(\n        relation=self._comparison_relation,\n        num_words=self._num_words)\n\n  def get_instruction_args(self):\n    \"\"\"Returns the keyward args of `build_description`.\"\"\"\n    return {\"num_words\": self._num_words,\n            \"relation\": self._comparison_relation}\n\n  def get_instruction_args_keys(self):\n    \"\"\"Returns the args keys of `build_description`.\"\"\"\n    return [\"num_words\", \"relation\"]\n\n  def check_following(self, value):\n    \"\"\"Checks if the response contains the expected number of words.\"\"\"\n    num_words = instructions_util.count_words(value)\n\n    if self._comparison_relation == _COMPARISON_RELATION[0]:\n      return num_words < self._num_words\n    elif self._comparison_relation == _COMPARISON_RELATION[1]:\n      return num_words >= self._num_words\n\n\nclass JsonFormat(Instruction):\n  \"\"\"Check the Json format.\"\"\"\n\n  def build_description(self):\n    self._description_pattern = (\n        \"Entire output should be wrapped in JSON format. You can use markdown\"\n        \" ticks such as ```.\"\n    )\n    return self._description_pattern\n\n  def get_instruction_args(self):\n    \"\"\"Returns the keyward args of `build_description`.\"\"\"\n    return None\n\n  def get_instruction_args_keys(self):\n    \"\"\"Returns the args keys of `build_description`.\"\"\"\n    return []\n\n  def check_following(self, value):\n    value = (\n        removesuffix(\n          removeprefix(\n            removeprefix(\n              removeprefix(\n                removeprefix(\n                  value.strip()\n                , \"```json\")\n              , \"```Json\")\n            , \"```JSON\")\n          , \"```\")\n        , \"```\")\n        .strip()\n    )\n    try:\n      json.loads(value)\n    except ValueError as _:\n      return False\n    return True\n\n\nclass ParagraphFirstWordCheck(Instruction):\n  \"\"\"Check the paragraph and the first word of the nth paragraph.\"\"\"\n\n  def build_description(self, num_paragraphs = None,\n                        nth_paragraph = None,\n                        first_word = None):\n    r\"\"\"Build the instruction description.\n\n    Args:\n      num_paragraphs: An integer indicating the number of paragraphs expected\n        in the response. A paragraph is a subset of the string that is\n        expected to be separated by '\\n\\n'.\n      nth_paragraph: An integer indicating the paragraph number that we look at.\n        Note that n starts from 1.\n      first_word: A string that represent the first word of the bth paragraph.\n\n    Returns:\n      A string representing the instruction description.\n    \"\"\"\n    self._num_paragraphs = num_paragraphs\n    if self._num_paragraphs is None or self._num_paragraphs < 0:\n      self._num_paragraphs = random.randint(1, _NUM_PARAGRAPHS)\n\n    self._nth_paragraph = nth_paragraph\n    if (\n        self._nth_paragraph is None\n        or self._nth_paragraph <= 0\n        or self._nth_paragraph > self._num_paragraphs\n    ):\n      self._nth_paragraph = random.randint(1, self._num_paragraphs + 1)\n\n    self._first_word = first_word\n    if self._first_word is None:\n      self._first_word = instructions_util.generate_keywords(num_keywords=1)[0]\n    self._first_word = self._first_word.lower()\n\n    self._description_pattern = (\n        \"There should be {num_paragraphs} paragraphs. \" +\n        \"Paragraphs and only paragraphs are separated with each other by two \" +\n        \"new lines as if it was '\\\\n\\\\n' in python. \" +\n        \"Paragraph {nth_paragraph} must start with word {first_word}.\")\n\n    return self._description_pattern.format(\n        num_paragraphs=self._num_paragraphs,\n        nth_paragraph=self._nth_paragraph,\n        first_word=self._first_word)\n\n  def get_instruction_args(self):\n    \"\"\"Returns the keyward args of `build_description`.\"\"\"\n    return {\"num_paragraphs\": self._num_paragraphs,\n            \"nth_paragraph\": self._nth_paragraph,\n            \"first_word\": self._first_word}\n\n  def get_instruction_args_keys(self):\n    \"\"\"Returns the args keys of `build_description`.\"\"\"\n    return [\"num_paragraphs\", \"nth_paragraph\", \"first_word\"]\n\n  def check_following(self, value):\n    \"\"\"Checks for required number of paragraphs and correct first word.\n\n    Args:\n      value: a string representing the response. The response may contain\n        paragraphs that are separated by two new lines and the first word of\n        the nth paragraph will have to match a specified word.\n\n    Returns:\n      True if the number of paragraphs is the same as required and the first\n      word of the specified paragraph is the same as required. Otherwise, false.\n    \"\"\"\n\n    paragraphs = re.split(r\"\\n\\n\", value)\n    num_paragraphs = len(paragraphs)\n\n    for paragraph in paragraphs:\n      if not paragraph.strip():\n        num_paragraphs -= 1\n\n    # check that index doesn't go out of bounds\n    if self._nth_paragraph <= num_paragraphs:\n      paragraph = paragraphs[self._nth_paragraph - 1].strip()\n      if not paragraph:\n        return False\n    else:\n      return False\n\n    first_word = \"\"\n    punctuation = {\".\", \",\", \"?\", \"!\", \"'\", '\"'}\n\n    # get first word and remove punctuation\n    word = paragraph.split()[0].strip()\n    # TODO(jeffrey): make more complex?\n    word = word.lstrip(\"'\")\n    word = word.lstrip('\"')\n\n    for letter in word:\n      if letter in punctuation:\n        break\n      first_word += letter.lower()\n\n    return (\n        num_paragraphs == self._num_paragraphs\n        and first_word == self._first_word\n    )\n\n\n# TODO(jeffrey) add relation - at least/at most?\nclass KeySentenceChecker(Instruction):\n  \"\"\"Check the existence of certain key sentences.\"\"\"\n\n  def build_description(self, key_sentences = None,\n                        num_sentences = None):\n    \"\"\"Build the instruction description.\n\n    Args:\n      key_sentences: A sequences of strings representing the key sentences that\n        are expected in the response.\n      num_sentences: The number of key sentences that are expected to be seen in\n        the response.\n\n    Returns:\n      A string representing the instruction description.\n    \"\"\"\n\n    if not key_sentences:\n      # TODO(jeffrey) make a generate sentences function? wonderwords package\n      self._key_sentences = set([\"For now, this is fine.\"])\n    else:\n      self._key_sentences = key_sentences\n\n    if not num_sentences:\n      self._num_sentences = random.randint(1, len(self._key_sentences))\n    else:\n      self._num_sentences = num_sentences\n\n    self._description_pattern = (\n        \"Include {num_sentences} of the following sentences {key_sentences}\"\n    )\n\n    return self._description_pattern.format(\n        num_sentences=self._num_sentences, key_sentences=self._key_sentences\n    )\n\n  def get_instruction_args(self):\n    \"\"\"Returns the keyward args of `build_description`.\"\"\"\n    return {\"num_sentences\": self._num_sentences,\n            \"key_sentences\": list(self._key_sentences)}\n\n  def get_instruction_args_keys(self):\n    \"\"\"Returns the args keys of `build_description`.\"\"\"\n    return [\"num_sentences\", \"key_sentences\"]\n\n  def check_following(self, value):\n    \"\"\"Checks if the response contains the expected key sentences.\"\"\"\n    count = 0\n    sentences = instructions_util.split_into_sentences(value)\n    for sentence in self._key_sentences:\n      if sentence in sentences:\n        count += 1\n\n    return count == self._num_sentences\n\n\nclass ForbiddenWords(Instruction):\n  \"\"\"Checks that specified words are not used in response.\"\"\"\n\n  def build_description(self, forbidden_words = None\n                        ):\n    \"\"\"Build the instruction description.\n\n    Args:\n      forbidden_words: A sequences of strings respresenting words that are not\n        allowed in the response.\n\n    Returns:\n      A string representing the instruction description.\n    \"\"\"\n\n    if not forbidden_words:\n      self._forbidden_words = instructions_util.generate_keywords(\n          num_keywords=_NUM_KEYWORDS)\n    else:\n      self._forbidden_words = list(set(forbidden_words))\n    self._forbidden_words = sorted(self._forbidden_words)\n    self._description_pattern = (\n        \"Do not include keywords {forbidden_words} in the response.\"\n    )\n\n    return self._description_pattern.format(\n        forbidden_words=self._forbidden_words\n    )\n\n  def get_instruction_args(self):\n    \"\"\"Returns the keyward args of `build_description`.\"\"\"\n    return {\"forbidden_words\": self._forbidden_words}\n\n  def get_instruction_args_keys(self):\n    \"\"\"Returns the args keys of `build_description`.\"\"\"\n    return [\"forbidden_words\"]\n\n  def check_following(self, value):\n    \"\"\"Check if the response does not contain the expected keywords.\"\"\"\n    for word in self._forbidden_words:\n      if re.search(r\"\\b\" + word + r\"\\b\", value, flags=re.IGNORECASE):\n        return False\n    return True\n\n\nclass RephraseParagraph(Instruction):\n  \"\"\"Checks that the paragraph is rephrased.\"\"\"\n\n  def build_description(self, *, original_paragraph, low, high\n                        ):\n    \"\"\"Builds the instruction description.\n\n    Args:\n      original_paragraph: A string presenting the original paragraph. The\n        rephrases response should have betweeb low-high words in common.\n      low: An integer presenting the lower bound of similar words.\n      high: An integer representing the upper bound of similar words.\n\n    Returns:\n      A string representing the instruction description.\n    \"\"\"\n    # TODO(jeffrey) make more encompassing\n    self._original_paragraph = original_paragraph\n    self._low = low\n    self._high = high\n\n    self._description = (\"Rephrase the following paragraph: \" +\n                         \"{original_paragraph}\\nYour response should have \" +\n                         \"between {low} and {high} of the same words. \" +\n                         \"Words are the same if and only if all of the \" +\n                         \"letters, ignoring cases, are the same. For \" +\n                         \"example, 'run' is the same as 'Run' but different \" +\n                         \"to 'ran'.\")\n\n    return self._description.format(original_paragraph=original_paragraph,\n                                    low=self._low, high=self._high)\n\n  def get_instruction_args(self):\n    \"\"\"Returns the keyward args of `build_description`.\"\"\"\n    return {\"original_paragraph\": self._original_paragraph,\n            \"low\": self._low,\n            \"high\": self._high}\n\n  def get_instruction_args_keys(self):\n    \"\"\"Returns the args keys of `build_description`.\"\"\"\n    return [\"original_paragraph\", \"low\", \"high\"]\n\n  def check_following(self, value):\n    val_words = re.findall(r\"\\w+\", value.lower())\n    original_words = re.findall(r\"\\w+\", self._original_paragraph.lower())\n    similar_words = 0\n\n    dict_val = collections.Counter(val_words)\n    dict_original = collections.Counter(original_words)\n\n    for word in dict_original:\n      similar_words += min(dict_original[word], dict_val[word])\n\n    return similar_words >= self._low and similar_words <= self._high\n\n\nclass TwoResponsesChecker(Instruction):\n  \"\"\"Check that two responses were given.\"\"\"\n\n  def build_description(self):\n    \"\"\"Build the instruction description.\"\"\"\n    self._description_pattern = (\n        \"Give two different responses. Responses and only responses should\"\n        \" be separated by 6 asterisk symbols: ******.\"\n    )\n    return self._description_pattern\n\n  def get_instruction_args(self):\n    \"\"\"Returns the keyward args of `build_description`.\"\"\"\n    return None\n\n  def get_instruction_args_keys(self):\n    \"\"\"Returns the args keys of `build_description`.\"\"\"\n    return []\n\n  def check_following(self, value):\n    \"\"\"Checks if the response has two different answers.\n\n    Args:\n      value: A string representing the response.\n\n    Returns:\n      True if two responses are detected and false otherwise.\n    \"\"\"\n    valid_responses = list()\n    responses = value.split(\"******\")\n    for index, response in enumerate(responses):\n      if not response.strip():\n        if index != 0 and index != len(responses) - 1:\n          return False\n      else:\n        valid_responses.append(response)\n    return (\n        len(valid_responses) == 2\n        and valid_responses[0].strip() != valid_responses[1].strip()\n    )\n\n\nclass RepeatPromptThenAnswer(Instruction):\n  \"\"\"Checks that Prompt is first repeated then answered.\"\"\"\n\n  def build_description(self, *, prompt_to_repeat = None):\n    \"\"\"Build the instruction description.\n\n    Args:\n      prompt_to_repeat: The prompt that is meant to be repeated.\n\n    Returns:\n      A string representing the instruction description.\n    \"\"\"\n    if not prompt_to_repeat:\n      raise ValueError(\"prompt_to_repeat must be set.\")\n    else:\n      self._prompt_to_repeat = prompt_to_repeat\n    self._description_pattern = (\n        \"First repeat the request word for word without change,\"\n        \" then give your answer (1. do not say any words or characters\"\n        \" before repeating the request; 2. the request you need to repeat\"\n        \" does not include this sentence)\"\n    )\n    return self._description_pattern\n\n  def get_instruction_args(self):\n    return {\"prompt_to_repeat\": self._prompt_to_repeat}\n\n  def get_instruction_args_keys(self):\n    \"\"\"Returns the args keys of `build_description`.\"\"\"\n    return [\"prompt_to_repeat\"]\n\n  def check_following(self, value):\n    if value.strip().lower().startswith(self._prompt_to_repeat.strip().lower()):\n      return True\n    return False\n\n\nclass EndChecker(Instruction):\n  \"\"\"Checks that the prompt ends with a given phrase.\"\"\"\n\n  def build_description(self, *, end_phrase = None):\n    \"\"\"Build the instruction description.\n\n    Args:\n      end_phrase: A string representing the phrase the response should end with.\n\n    Returns:\n      A string representing the instruction description.\n    \"\"\"\n    self._end_phrase = (\n        end_phrase.strip() if isinstance(end_phrase, str) else end_phrase\n    )\n    if self._end_phrase is None:\n      self._end_phrase = random.choice(_ENDING_OPTIONS)\n    self._description_pattern = (\n        \"Finish your response with this exact phrase {ender}. \"\n        \"No other words should follow this phrase.\")\n    return self._description_pattern.format(ender=self._end_phrase)\n\n  def get_instruction_args(self):\n    return {\"end_phrase\": self._end_phrase}\n\n  def get_instruction_args_keys(self):\n    \"\"\"Returns the args keys of `build_description`.\"\"\"\n    return [\"end_phrase\"]\n\n  def check_following(self, value):\n    \"\"\"Checks if the response ends with the expected phrase.\"\"\"\n    value = value.strip().strip(\"\\\"\").lower()\n    self._end_phrase = self._end_phrase.strip().lower()\n    return value.endswith(self._end_phrase)\n\n\nclass TitleChecker(Instruction):\n  \"\"\"Checks the response for a title.\"\"\"\n\n  def build_description(self):\n    \"\"\"Build the instruction description.\"\"\"\n    self._description_pattern = (\n        \"Your answer must contain a title, wrapped in double angular brackets,\"\n        \" such as <<poem of joy>>.\"\n    )\n    return self._description_pattern\n\n  def get_instruction_args(self):\n    return None\n\n  def get_instruction_args_keys(self):\n    \"\"\"Returns the args keys of `build_description`.\"\"\"\n    return []\n\n  def check_following(self, value):\n    \"\"\"Checks if the response contains a title.\"\"\"\n    pattern = r\"<<[^\\n]+>>\"\n    re_pattern = re.compile(pattern)\n    titles = re.findall(re_pattern, value)\n\n    for title in titles:\n      if title.lstrip(\"<\").rstrip(\">\").strip():\n        return True\n    return False\n\n\nclass LetterFrequencyChecker(Instruction):\n  \"\"\"Checks letter frequency.\"\"\"\n\n  def build_description(self, *, letter = None,\n                        let_frequency = None,\n                        let_relation = None):\n    \"\"\"Build the instruction description.\n\n    Args:\n      letter: A string representing a letter that is expected in the response.\n      let_frequency: An integer specifying the number of times `keyword` is\n        expected to appear in the response.\n      let_relation: A string in (`less than`, `at least`), defining the\n        relational operator for comparison. Two relational comparisons are\n        supported for now; if 'less than', the actual number of\n        occurrences < frequency; if 'at least', the actual number of\n        occurrences >= frequency.\n\n    Returns:\n      A string representing the instruction description.\n    \"\"\"\n    if (\n        not letter\n        or len(letter) > 1\n        or ord(letter.lower()) < 97\n        or ord(letter.lower()) > 122\n    ):\n      self._letter = random.choice(list(string.ascii_letters))\n    else:\n      self._letter = letter.strip()\n    self._letter = self._letter.lower()\n\n    self._frequency = let_frequency\n    if self._frequency is None or self._frequency < 0:\n      self._frequency = random.randint(1, _LETTER_FREQUENCY)\n\n    if let_relation is None:\n      self._comparison_relation = random.choice(_COMPARISON_RELATION)\n    elif let_relation not in _COMPARISON_RELATION:\n      raise ValueError(\n          \"The supported relation for comparison must be in \"\n          f\"{_COMPARISON_RELATION}, but {let_relation} is given.\"\n      )\n    else:\n      self._comparison_relation = let_relation\n\n    self._description_pattern = (\n        \"In your response, the letter {letter} should appear {let_relation}\"\n        \" {let_frequency} times.\"\n    )\n\n    return self._description_pattern.format(\n        letter=self._letter,\n        let_frequency=self._frequency,\n        let_relation=self._comparison_relation,\n    )\n\n  def get_instruction_args(self):\n    \"\"\"Returns the keyword args of build description.\"\"\"\n    return {\"letter\": self._letter,\n            \"let_frequency\": self._frequency,\n            \"let_relation\": self._comparison_relation}\n\n  def get_instruction_args_keys(self):\n    \"\"\"Returns the args keys of `build_description`.\"\"\"\n    return [\"letter\", \"let_frequency\", \"let_relation\"]\n\n  def check_following(self, value):\n    \"\"\"Checks that the response contains the letter at the right frequency.\"\"\"\n    value = value.lower()\n    letters = collections.Counter(value)\n\n    if self._comparison_relation == _COMPARISON_RELATION[0]:\n      return letters[self._letter] < self._frequency\n    else:\n      return letters[self._letter] >= self._frequency\n\n\nclass CapitalLettersEnglishChecker(Instruction):\n  \"\"\"Checks that the response is in english and is in all capital letters.\"\"\"\n\n  def build_description(self):\n    \"\"\"Build the instruction description.\"\"\"\n    self._description_pattern = (\n        \"Your entire response should be in English, and in all capital letters.\"\n    )\n    return self._description_pattern\n\n  def get_instruction_args(self):\n    return None\n\n  def get_instruction_args_keys(self):\n    \"\"\"Returns the args keys of `build_description`.\"\"\"\n    return []\n\n  def check_following(self, value):\n    \"\"\"Checks that the response is in English and in all capital letters.\"\"\"\n    assert isinstance(value, str)\n\n    try:\n      return value.isupper() and langdetect.detect(value) == \"en\"\n    except langdetect.LangDetectException as e:\n      # Count as instruction is followed.\n      logging.error(\n          \"Unable to detect language for text %s due to %s\", value, e\n      )  # refex: disable=pytotw.037\n      return True\n\n\nclass LowercaseLettersEnglishChecker(Instruction):\n  \"\"\"Checks that the response is in english and is in all lowercase letters.\"\"\"\n\n  def build_description(self):\n    \"\"\"Build the instruction description.\"\"\"\n    self._description_pattern = (\n        \"Your entire response should be in English, and in all lowercase\"\n        \" letters. No capital letters are allowed.\"\n    )\n    return self._description_pattern\n\n  def get_instruction_args(self):\n    return None\n\n  def get_instruction_args_keys(self):\n    \"\"\"Returns the args keys of `build_description`.\"\"\"\n    return []\n\n  def check_following(self, value):\n    \"\"\"Checks that the response is in English and in all lowercase letters.\"\"\"\n    assert isinstance(value, str)\n\n    try:\n      return value.islower() and langdetect.detect(value) == \"en\"\n    except langdetect.LangDetectException as e:\n      # Count as instruction is followed.\n      logging.error(\n          \"Unable to detect language for text %s due to %s\", value, e\n      )  # refex: disable=pytotw.037\n      return True\n\n\nclass CommaChecker(Instruction):\n  \"\"\"Checks the response for no commas.\"\"\"\n\n  def build_description(self):\n    \"\"\"Build the instruction description.\"\"\"\n    self._description_pattern = (\n        \"In your entire response, refrain from the use of any commas.\"\n    )\n    return self._description_pattern\n\n  def get_instruction_args(self):\n    return None\n\n  def get_instruction_args_keys(self):\n    \"\"\"Returns the args keys of `build_description`.\"\"\"\n    return []\n\n  def check_following(self, value):\n    \"\"\"Checks that the response does not contain commas.\"\"\"\n    return not re.search(r\"\\,\", value)\n\n\nclass CapitalWordFrequencyChecker(Instruction):\n  \"\"\"Checks frequency of words with all capital letters.\"\"\"\n\n  def build_description(\n      self,\n      capital_frequency = None,\n      capital_relation = None,\n  ):\n    \"\"\"Build the instruction description.\n\n    Args:\n      capital_frequency: An integer that represents the number of words that\n        should be in all capital letters.\n      capital_relation: A string that is 'at least' or 'at most' that refers to\n        the frequency.\n\n    Returns:\n      A string representing the instruction description.\n    \"\"\"\n    self._frequency = capital_frequency\n    if self._frequency is None:\n      self._frequency = random.randint(1, _ALL_CAPITAL_WORD_FREQUENCY)\n\n    self._comparison_relation = capital_relation\n    if capital_relation is None:\n      self._comparison_relation = random.choice(_COMPARISON_RELATION)\n    elif capital_relation not in _COMPARISON_RELATION:\n      raise ValueError(\n          \"The supported relation for comparison must be in \"\n          f\"{_COMPARISON_RELATION}, but {capital_relation} is given.\"\n      )\n\n    self._description_pattern = (\n        \"In your response, words with all capital letters should appear\"\n        \" {relation} {frequency} times.\"\n    )\n\n    return self._description_pattern.format(\n        frequency=self._frequency, relation=self._comparison_relation\n    )\n\n  def get_instruction_args(self):\n    \"\"\"Returns the keyword args of build description.\"\"\"\n    return {\n        \"capital_frequency\": self._frequency,\n        \"capital_relation\": self._comparison_relation,\n    }\n\n  def get_instruction_args_keys(self):\n    \"\"\"Returns the args keys of `build_description`.\"\"\"\n    return [\"capital_frequency\", \"capital_relation\"]\n\n  def check_following(self, value):\n    \"\"\"Checks the frequency of words with all capital letters.\"\"\"\n    # Hyphenated words will count as one word\n    words = instructions_util.nltk.word_tokenize(value)\n    capital_words = [word for word in words if word.isupper()]\n\n    capital_words = len(capital_words)\n\n    if self._comparison_relation == _COMPARISON_RELATION[0]:\n      return capital_words < self._frequency\n    else:\n      return capital_words >= self._frequency\n\n\nclass QuotationChecker(Instruction):\n  \"\"\"Checks response is wrapped with double quotation marks.\"\"\"\n\n  def build_description(self):\n    \"\"\"Build the instruction description.\"\"\"\n    self._description_pattern = (\n        \"Wrap your entire response with double quotation marks.\"\n    )\n    return self._description_pattern\n\n  def get_instruction_args(self):\n    \"\"\"Returns the keyword args of build description.\"\"\"\n    return None\n\n  def get_instruction_args_keys(self):\n    \"\"\"Returns the args keys of `build_description`.\"\"\"\n    return []\n\n  def check_following(self, value):\n    \"\"\"Checks if the response is wrapped with double quotation marks.\"\"\"\n    value = value.strip()\n    return len(value) > 1 and value[0] == '\"' and value[-1] == '\"'",
        "eval/eval/ifeval_utils/instructions_registry.py": "# coding=utf-8\n# Copyright 2023 The Google Research Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Registry of all instructions.\"\"\"\nfrom . import instructions\n\n_KEYWORD = \"keywords:\"\n\n_LANGUAGE = \"language:\"\n\n_LENGTH = \"length_constraints:\"\n\n_CONTENT = \"detectable_content:\"\n\n_FORMAT = \"detectable_format:\"\n\n_MULTITURN = \"multi-turn:\"\n\n_COMBINATION = \"combination:\"\n\n_STARTEND = \"startend:\"\n\n_CHANGE_CASES = \"change_case:\"\n\n_PUNCTUATION = \"punctuation:\"\n\nINSTRUCTION_DICT = {\n    _KEYWORD + \"existence\": instructions.KeywordChecker,\n    _KEYWORD + \"frequency\": instructions.KeywordFrequencyChecker,\n    # TODO(jeffreyzhou): make a proper set of sentences to choose from\n    # _KEYWORD + \"key_sentences\": instructions.KeySentenceChecker,\n    _KEYWORD + \"forbidden_words\": instructions.ForbiddenWords,\n    _KEYWORD + \"letter_frequency\": instructions.LetterFrequencyChecker,\n    _LANGUAGE + \"response_language\": instructions.ResponseLanguageChecker,\n    _LENGTH + \"number_sentences\": instructions.NumberOfSentences,\n    _LENGTH + \"number_paragraphs\": instructions.ParagraphChecker,\n    _LENGTH + \"number_words\": instructions.NumberOfWords,\n    _LENGTH + \"nth_paragraph_first_word\": instructions.ParagraphFirstWordCheck,\n    _CONTENT + \"number_placeholders\": instructions.PlaceholderChecker,\n    _CONTENT + \"postscript\": instructions.PostscriptChecker,\n    _FORMAT + \"number_bullet_lists\": instructions.BulletListChecker,\n    # TODO(jeffreyzhou): Pre-create paragraph or use prompt to replace\n    # _CONTENT + \"rephrase_paragraph\": instructions.RephraseParagraph,\n    _FORMAT + \"constrained_response\": instructions.ConstrainedResponseChecker,\n    _FORMAT + \"number_highlighted_sections\": (\n        instructions.HighlightSectionChecker),\n    _FORMAT + \"multiple_sections\": instructions.SectionChecker,\n    # TODO(tianjianlu): Re-enable rephrasing with preprocessing the message.\n    # _FORMAT + \"rephrase\": instructions.RephraseChecker,\n    _FORMAT + \"json_format\": instructions.JsonFormat,\n    _FORMAT + \"title\": instructions.TitleChecker,\n    # TODO(tianjianlu): Re-enable with specific prompts.\n    # _MULTITURN + \"constrained_start\": instructions.ConstrainedStartChecker,\n    _COMBINATION + \"two_responses\": instructions.TwoResponsesChecker,\n    _COMBINATION + \"repeat_prompt\": instructions.RepeatPromptThenAnswer,\n    _STARTEND + \"end_checker\": instructions.EndChecker,\n    _CHANGE_CASES\n    + \"capital_word_frequency\": instructions.CapitalWordFrequencyChecker,\n    _CHANGE_CASES\n    + \"english_capital\": instructions.CapitalLettersEnglishChecker,\n    _CHANGE_CASES\n    + \"english_lowercase\": instructions.LowercaseLettersEnglishChecker,\n    _PUNCTUATION + \"no_comma\": instructions.CommaChecker,\n    _STARTEND + \"quotation\": instructions.QuotationChecker,\n}\n\nINSTRUCTION_CONFLICTS = {\n    _KEYWORD + \"existence\": {_KEYWORD + \"existence\"},\n    _KEYWORD + \"frequency\": {_KEYWORD + \"frequency\"},\n    # TODO(jeffreyzhou): make a proper set of sentences to choose from\n    # _KEYWORD + \"key_sentences\": instructions.KeySentenceChecker,\n    _KEYWORD + \"forbidden_words\": {_KEYWORD + \"forbidden_words\"},\n    _KEYWORD + \"letter_frequency\": {_KEYWORD + \"letter_frequency\"},\n    _LANGUAGE\n    + \"response_language\": {\n        _LANGUAGE + \"response_language\",\n        _FORMAT + \"multiple_sections\",\n        _KEYWORD + \"existence\",\n        _KEYWORD + \"frequency\",\n        _KEYWORD + \"forbidden_words\",\n        _STARTEND + \"end_checker\",\n        _CHANGE_CASES + \"english_capital\",\n        _CHANGE_CASES + \"english_lowercase\",\n    },\n    _LENGTH + \"number_sentences\": {_LENGTH + \"number_sentences\"},\n    _LENGTH + \"number_paragraphs\": {\n        _LENGTH + \"number_paragraphs\",\n        _LENGTH + \"nth_paragraph_first_word\",\n        _LENGTH + \"number_sentences\",\n        _LENGTH + \"nth_paragraph_first_word\",\n    },\n    _LENGTH + \"number_words\": {_LENGTH + \"number_words\"},\n    _LENGTH + \"nth_paragraph_first_word\": {\n        _LENGTH + \"nth_paragraph_first_word\",\n        _LENGTH + \"number_paragraphs\",\n    },\n    _CONTENT + \"number_placeholders\": {_CONTENT + \"number_placeholders\"},\n    _CONTENT + \"postscript\": {_CONTENT + \"postscript\"},\n    _FORMAT + \"number_bullet_lists\": {_FORMAT + \"number_bullet_lists\"},\n    # TODO(jeffreyzhou): Pre-create paragraph or use prompt to replace\n    # _CONTENT + \"rephrase_paragraph\": instructions.RephraseParagraph,\n    _FORMAT + \"constrained_response\": set(INSTRUCTION_DICT.keys()),\n    _FORMAT\n    + \"number_highlighted_sections\": {_FORMAT + \"number_highlighted_sections\"},\n    _FORMAT\n    + \"multiple_sections\": {\n        _FORMAT + \"multiple_sections\",\n        _LANGUAGE + \"response_language\",\n        _FORMAT + \"number_highlighted_sections\",\n    },\n    # TODO(tianjianlu): Re-enable rephrasing with preprocessing the message.\n    # _FORMAT + \"rephrase\": instructions.RephraseChecker,\n    _FORMAT\n    + \"json_format\": set(INSTRUCTION_DICT.keys()).difference(\n        {_KEYWORD + \"forbidden_words\", _KEYWORD + \"existence\"}\n    ),\n    _FORMAT + \"title\": {_FORMAT + \"title\"},\n    # TODO(tianjianlu): Re-enable with specific prompts.\n    # _MULTITURN + \"constrained_start\": instructions.ConstrainedStartChecker,\n    _COMBINATION\n    + \"two_responses\": set(INSTRUCTION_DICT.keys()).difference({\n        _KEYWORD + \"forbidden_words\",\n        _KEYWORD + \"existence\",\n        _LANGUAGE + \"response_language\",\n        _FORMAT + \"title\",\n        _PUNCTUATION + \"no_comma\"\n    }),\n    _COMBINATION + \"repeat_prompt\": set(INSTRUCTION_DICT.keys()).difference({\n        _KEYWORD + \"existence\",\n        _FORMAT + \"title\",\n        _PUNCTUATION + \"no_comma\"\n    }),\n    _STARTEND + \"end_checker\": {_STARTEND + \"end_checker\"},\n    _CHANGE_CASES + \"capital_word_frequency\": {\n        _CHANGE_CASES + \"capital_word_frequency\",\n        _CHANGE_CASES + \"english_lowercase\",\n        _CHANGE_CASES + \"english_capital\",\n    },\n    _CHANGE_CASES + \"english_capital\": {_CHANGE_CASES + \"english_capital\"},\n    _CHANGE_CASES + \"english_lowercase\": {\n        _CHANGE_CASES + \"english_lowercase\",\n        _CHANGE_CASES + \"english_capital\",\n    },\n    _PUNCTUATION + \"no_comma\": {_PUNCTUATION + \"no_comma\"},\n    _STARTEND + \"quotation\": {_STARTEND + \"quotation\", _FORMAT + \"title\"},\n}\n\n\ndef conflict_make(conflicts):\n  \"\"\"Makes sure if A conflicts with B, B will conflict with A.\n\n  Args:\n    conflicts: Dictionary of potential conflicts where key is instruction id\n      and value is set of instruction ids that it conflicts with.\n\n  Returns:\n    Revised version of the dictionary. All instructions conflict with\n    themselves. If A conflicts with B, B will conflict with A.\n  \"\"\"\n  for key in conflicts:\n    for k in conflicts[key]:\n      conflicts[k].add(key)\n    conflicts[key].add(key)\n  return conflicts",
        "eval/eval/ifeval_utils/instructions_util.py": "# coding=utf-8\n# Copyright 2023 The Google Research Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Utility library of instructions.\"\"\"\n\nimport functools\nimport random\nimport re\nfrom typing import List\n\nimport immutabledict\nimport nltk\n\nWORD_LIST = [\"western\", \"sentence\", \"signal\", \"dump\", \"spot\", \"opposite\", \"bottom\", \"potato\", \"administration\", \"working\", \"welcome\", \"morning\", \"good\", \"agency\", \"primary\", \"wish\", \"responsibility\", \"press\", \"problem\", \"president\", \"steal\", \"brush\", \"read\", \"type\", \"beat\", \"trainer\", \"growth\", \"lock\", \"bone\", \"case\", \"equal\", \"comfortable\", \"region\", \"replacement\", \"performance\", \"mate\", \"walk\", \"medicine\", \"film\", \"thing\", \"rock\", \"tap\", \"total\", \"competition\", \"ease\", \"south\", \"establishment\", \"gather\", \"parking\", \"world\", \"plenty\", \"breath\", \"claim\", \"alcohol\", \"trade\", \"dear\", \"highlight\", \"street\", \"matter\", \"decision\", \"mess\", \"agreement\", \"studio\", \"coach\", \"assist\", \"brain\", \"wing\", \"style\", \"private\", \"top\", \"brown\", \"leg\", \"buy\", \"procedure\", \"method\", \"speed\", \"high\", \"company\", \"valuable\", \"pie\", \"analyst\", \"session\", \"pattern\", \"district\", \"pleasure\", \"dinner\", \"swimming\", \"joke\", \"order\", \"plate\", \"department\", \"motor\", \"cell\", \"spend\", \"cabinet\", \"difference\", \"power\", \"examination\", \"engine\", \"horse\", \"dimension\", \"pay\", \"toe\", \"curve\", \"literature\", \"bother\", \"fire\", \"possibility\", \"debate\", \"activity\", \"passage\", \"hello\", \"cycle\", \"background\", \"quiet\", \"author\", \"effect\", \"actor\", \"page\", \"bicycle\", \"error\", \"throat\", \"attack\", \"character\", \"phone\", \"tea\", \"increase\", \"outcome\", \"file\", \"specific\", \"inspector\", \"internal\", \"potential\", \"staff\", \"building\", \"employer\", \"shoe\", \"hand\", \"direction\", \"garden\", \"purchase\", \"interview\", \"study\", \"recognition\", \"member\", \"spiritual\", \"oven\", \"sandwich\", \"weird\", \"passenger\", \"particular\", \"response\", \"reaction\", \"size\", \"variation\", \"a\", \"cancel\", \"candy\", \"exit\", \"guest\", \"condition\", \"fly\", \"price\", \"weakness\", \"convert\", \"hotel\", \"great\", \"mouth\", \"mind\", \"song\", \"sugar\", \"suspect\", \"telephone\", \"ear\", \"roof\", \"paint\", \"refrigerator\", \"organization\", \"jury\", \"reward\", \"engineering\", \"day\", \"possession\", \"crew\", \"bar\", \"road\", \"description\", \"celebration\", \"score\", \"mark\", \"letter\", \"shower\", \"suggestion\", \"sir\", \"luck\", \"national\", \"progress\", \"hall\", \"stroke\", \"theory\", \"offer\", \"story\", \"tax\", \"definition\", \"history\", \"ride\", \"medium\", \"opening\", \"glass\", \"elevator\", \"stomach\", \"question\", \"ability\", \"leading\", \"village\", \"computer\", \"city\", \"grand\", \"confidence\", \"candle\", \"priest\", \"recommendation\", \"point\", \"necessary\", \"body\", \"desk\", \"secret\", \"horror\", \"noise\", \"culture\", \"warning\", \"water\", \"round\", \"diet\", \"flower\", \"bus\", \"tough\", \"permission\", \"week\", \"prompt\", \"connection\", \"abuse\", \"height\", \"save\", \"corner\", \"border\", \"stress\", \"drive\", \"stop\", \"rip\", \"meal\", \"listen\", \"confusion\", \"girlfriend\", \"living\", \"relation\", \"significance\", \"plan\", \"creative\", \"atmosphere\", \"blame\", \"invite\", \"housing\", \"paper\", \"drink\", \"roll\", \"silver\", \"drunk\", \"age\", \"damage\", \"smoke\", \"environment\", \"pack\", \"savings\", \"influence\", \"tourist\", \"rain\", \"post\", \"sign\", \"grandmother\", \"run\", \"profit\", \"push\", \"clerk\", \"final\", \"wine\", \"swim\", \"pause\", \"stuff\", \"singer\", \"funeral\", \"average\", \"source\", \"scene\", \"tradition\", \"personal\", \"snow\", \"nobody\", \"distance\", \"sort\", \"sensitive\", \"animal\", \"major\", \"negotiation\", \"click\", \"mood\", \"period\", \"arrival\", \"expression\", \"holiday\", \"repeat\", \"dust\", \"closet\", \"gold\", \"bad\", \"sail\", \"combination\", \"clothes\", \"emphasis\", \"duty\", \"black\", \"step\", \"school\", \"jump\", \"document\", \"professional\", \"lip\", \"chemical\", \"front\", \"wake\", \"while\", \"inside\", \"watch\", \"row\", \"subject\", \"penalty\", \"balance\", \"possible\", \"adult\", \"aside\", \"sample\", \"appeal\", \"wedding\", \"depth\", \"king\", \"award\", \"wife\", \"blow\", \"site\", \"camp\", \"music\", \"safe\", \"gift\", \"fault\", \"guess\", \"act\", \"shame\", \"drama\", \"capital\", \"exam\", \"stupid\", \"record\", \"sound\", \"swing\", \"novel\", \"minimum\", \"ratio\", \"machine\", \"shape\", \"lead\", \"operation\", \"salary\", \"cloud\", \"affair\", \"hit\", \"chapter\", \"stage\", \"quantity\", \"access\", \"army\", \"chain\", \"traffic\", \"kick\", \"analysis\", \"airport\", \"time\", \"vacation\", \"philosophy\", \"ball\", \"chest\", \"thanks\", \"place\", \"mountain\", \"advertising\", \"red\", \"past\", \"rent\", \"return\", \"tour\", \"house\", \"construction\", \"net\", \"native\", \"war\", \"figure\", \"fee\", \"spray\", \"user\", \"dirt\", \"shot\", \"task\", \"stick\", \"friend\", \"software\", \"promotion\", \"interaction\", \"surround\", \"block\", \"purpose\", \"practice\", \"conflict\", \"routine\", \"requirement\", \"bonus\", \"hole\", \"state\", \"junior\", \"sweet\", \"catch\", \"tear\", \"fold\", \"wall\", \"editor\", \"life\", \"position\", \"pound\", \"respect\", \"bathroom\", \"coat\", \"script\", \"job\", \"teach\", \"birth\", \"view\", \"resolve\", \"theme\", \"employee\", \"doubt\", \"market\", \"education\", \"serve\", \"recover\", \"tone\", \"harm\", \"miss\", \"union\", \"understanding\", \"cow\", \"river\", \"association\", \"concept\", \"training\", \"recipe\", \"relationship\", \"reserve\", \"depression\", \"proof\", \"hair\", \"revenue\", \"independent\", \"lift\", \"assignment\", \"temporary\", \"amount\", \"loss\", \"edge\", \"track\", \"check\", \"rope\", \"estimate\", \"pollution\", \"stable\", \"message\", \"delivery\", \"perspective\", \"mirror\", \"assistant\", \"representative\", \"witness\", \"nature\", \"judge\", \"fruit\", \"tip\", \"devil\", \"town\", \"emergency\", \"upper\", \"drop\", \"stay\", \"human\", \"neck\", \"speaker\", \"network\", \"sing\", \"resist\", \"league\", \"trip\", \"signature\", \"lawyer\", \"importance\", \"gas\", \"choice\", \"engineer\", \"success\", \"part\", \"external\", \"worker\", \"simple\", \"quarter\", \"student\", \"heart\", \"pass\", \"spite\", \"shift\", \"rough\", \"lady\", \"grass\", \"community\", \"garage\", \"youth\", \"standard\", \"skirt\", \"promise\", \"blind\", \"television\", \"disease\", \"commission\", \"positive\", \"energy\", \"calm\", \"presence\", \"tune\", \"basis\", \"preference\", \"head\", \"common\", \"cut\", \"somewhere\", \"presentation\", \"current\", \"thought\", \"revolution\", \"effort\", \"master\", \"implement\", \"republic\", \"floor\", \"principle\", \"stranger\", \"shoulder\", \"grade\", \"button\", \"tennis\", \"police\", \"collection\", \"account\", \"register\", \"glove\", \"divide\", \"professor\", \"chair\", \"priority\", \"combine\", \"peace\", \"extension\", \"maybe\", \"evening\", \"frame\", \"sister\", \"wave\", \"code\", \"application\", \"mouse\", \"match\", \"counter\", \"bottle\", \"half\", \"cheek\", \"resolution\", \"back\", \"knowledge\", \"make\", \"discussion\", \"screw\", \"length\", \"accident\", \"battle\", \"dress\", \"knee\", \"log\", \"package\", \"it\", \"turn\", \"hearing\", \"newspaper\", \"layer\", \"wealth\", \"profile\", \"imagination\", \"answer\", \"weekend\", \"teacher\", \"appearance\", \"meet\", \"bike\", \"rise\", \"belt\", \"crash\", \"bowl\", \"equivalent\", \"support\", \"image\", \"poem\", \"risk\", \"excitement\", \"remote\", \"secretary\", \"public\", \"produce\", \"plane\", \"display\", \"money\", \"sand\", \"situation\", \"punch\", \"customer\", \"title\", \"shake\", \"mortgage\", \"option\", \"number\", \"pop\", \"window\", \"extent\", \"nothing\", \"experience\", \"opinion\", \"departure\", \"dance\", \"indication\", \"boy\", \"material\", \"band\", \"leader\", \"sun\", \"beautiful\", \"muscle\", \"farmer\", \"variety\", \"fat\", \"handle\", \"director\", \"opportunity\", \"calendar\", \"outside\", \"pace\", \"bath\", \"fish\", \"consequence\", \"put\", \"owner\", \"go\", \"doctor\", \"information\", \"share\", \"hurt\", \"protection\", \"career\", \"finance\", \"force\", \"golf\", \"garbage\", \"aspect\", \"kid\", \"food\", \"boot\", \"milk\", \"respond\", \"objective\", \"reality\", \"raw\", \"ring\", \"mall\", \"one\", \"impact\", \"area\", \"news\", \"international\", \"series\", \"impress\", \"mother\", \"shelter\", \"strike\", \"loan\", \"month\", \"seat\", \"anything\", \"entertainment\", \"familiar\", \"clue\", \"year\", \"glad\", \"supermarket\", \"natural\", \"god\", \"cost\", \"conversation\", \"tie\", \"ruin\", \"comfort\", \"earth\", \"storm\", \"percentage\", \"assistance\", \"budget\", \"strength\", \"beginning\", \"sleep\", \"other\", \"young\", \"unit\", \"fill\", \"store\", \"desire\", \"hide\", \"value\", \"cup\", \"maintenance\", \"nurse\", \"function\", \"tower\", \"role\", \"class\", \"camera\", \"database\", \"panic\", \"nation\", \"basket\", \"ice\", \"art\", \"spirit\", \"chart\", \"exchange\", \"feedback\", \"statement\", \"reputation\", \"search\", \"hunt\", \"exercise\", \"nasty\", \"notice\", \"male\", \"yard\", \"annual\", \"collar\", \"date\", \"platform\", \"plant\", \"fortune\", \"passion\", \"friendship\", \"spread\", \"cancer\", \"ticket\", \"attitude\", \"island\", \"active\", \"object\", \"service\", \"buyer\", \"bite\", \"card\", \"face\", \"steak\", \"proposal\", \"patient\", \"heat\", \"rule\", \"resident\", \"broad\", \"politics\", \"west\", \"knife\", \"expert\", \"girl\", \"design\", \"salt\", \"baseball\", \"grab\", \"inspection\", \"cousin\", \"couple\", \"magazine\", \"cook\", \"dependent\", \"security\", \"chicken\", \"version\", \"currency\", \"ladder\", \"scheme\", \"kitchen\", \"employment\", \"local\", \"attention\", \"manager\", \"fact\", \"cover\", \"sad\", \"guard\", \"relative\", \"county\", \"rate\", \"lunch\", \"program\", \"initiative\", \"gear\", \"bridge\", \"breast\", \"talk\", \"dish\", \"guarantee\", \"beer\", \"vehicle\", \"reception\", \"woman\", \"substance\", \"copy\", \"lecture\", \"advantage\", \"park\", \"cold\", \"death\", \"mix\", \"hold\", \"scale\", \"tomorrow\", \"blood\", \"request\", \"green\", \"cookie\", \"church\", \"strip\", \"forever\", \"beyond\", \"debt\", \"tackle\", \"wash\", \"following\", \"feel\", \"maximum\", \"sector\", \"sea\", \"property\", \"economics\", \"menu\", \"bench\", \"try\", \"language\", \"start\", \"call\", \"solid\", \"address\", \"income\", \"foot\", \"senior\", \"honey\", \"few\", \"mixture\", \"cash\", \"grocery\", \"link\", \"map\", \"form\", \"factor\", \"pot\", \"model\", \"writer\", \"farm\", \"winter\", \"skill\", \"anywhere\", \"birthday\", \"policy\", \"release\", \"husband\", \"lab\", \"hurry\", \"mail\", \"equipment\", \"sink\", \"pair\", \"driver\", \"consideration\", \"leather\", \"skin\", \"blue\", \"boat\", \"sale\", \"brick\", \"two\", \"feed\", \"square\", \"dot\", \"rush\", \"dream\", \"location\", \"afternoon\", \"manufacturer\", \"control\", \"occasion\", \"trouble\", \"introduction\", \"advice\", \"bet\", \"eat\", \"kill\", \"category\", \"manner\", \"office\", \"estate\", \"pride\", \"awareness\", \"slip\", \"crack\", \"client\", \"nail\", \"shoot\", \"membership\", \"soft\", \"anybody\", \"web\", \"official\", \"individual\", \"pizza\", \"interest\", \"bag\", \"spell\", \"profession\", \"queen\", \"deal\", \"resource\", \"ship\", \"guy\", \"chocolate\", \"joint\", \"formal\", \"upstairs\", \"car\", \"resort\", \"abroad\", \"dealer\", \"associate\", \"finger\", \"surgery\", \"comment\", \"team\", \"detail\", \"crazy\", \"path\", \"tale\", \"initial\", \"arm\", \"radio\", \"demand\", \"single\", \"draw\", \"yellow\", \"contest\", \"piece\", \"quote\", \"pull\", \"commercial\", \"shirt\", \"contribution\", \"cream\", \"channel\", \"suit\", \"discipline\", \"instruction\", \"concert\", \"speech\", \"low\", \"effective\", \"hang\", \"scratch\", \"industry\", \"breakfast\", \"lay\", \"join\", \"metal\", \"bedroom\", \"minute\", \"product\", \"rest\", \"temperature\", \"many\", \"give\", \"argument\", \"print\", \"purple\", \"laugh\", \"health\", \"credit\", \"investment\", \"sell\", \"setting\", \"lesson\", \"egg\", \"middle\", \"marriage\", \"level\", \"evidence\", \"phrase\", \"love\", \"self\", \"benefit\", \"guidance\", \"affect\", \"you\", \"dad\", \"anxiety\", \"special\", \"boyfriend\", \"test\", \"blank\", \"payment\", \"soup\", \"obligation\", \"reply\", \"smile\", \"deep\", \"complaint\", \"addition\", \"review\", \"box\", \"towel\", \"minor\", \"fun\", \"soil\", \"issue\", \"cigarette\", \"internet\", \"gain\", \"tell\", \"entry\", \"spare\", \"incident\", \"family\", \"refuse\", \"branch\", \"can\", \"pen\", \"grandfather\", \"constant\", \"tank\", \"uncle\", \"climate\", \"ground\", \"volume\", \"communication\", \"kind\", \"poet\", \"child\", \"screen\", \"mine\", \"quit\", \"gene\", \"lack\", \"charity\", \"memory\", \"tooth\", \"fear\", \"mention\", \"marketing\", \"reveal\", \"reason\", \"court\", \"season\", \"freedom\", \"land\", \"sport\", \"audience\", \"classroom\", \"law\", \"hook\", \"win\", \"carry\", \"eye\", \"smell\", \"distribution\", \"research\", \"country\", \"dare\", \"hope\", \"whereas\", \"stretch\", \"library\", \"if\", \"delay\", \"college\", \"plastic\", \"book\", \"present\", \"use\", \"worry\", \"champion\", \"goal\", \"economy\", \"march\", \"election\", \"reflection\", \"midnight\", \"slide\", \"inflation\", \"action\", \"challenge\", \"guitar\", \"coast\", \"apple\", \"campaign\", \"field\", \"jacket\", \"sense\", \"way\", \"visual\", \"remove\", \"weather\", \"trash\", \"cable\", \"regret\", \"buddy\", \"beach\", \"historian\", \"courage\", \"sympathy\", \"truck\", \"tension\", \"permit\", \"nose\", \"bed\", \"son\", \"person\", \"base\", \"meat\", \"usual\", \"air\", \"meeting\", \"worth\", \"game\", \"independence\", \"physical\", \"brief\", \"play\", \"raise\", \"board\", \"she\", \"key\", \"writing\", \"pick\", \"command\", \"party\", \"yesterday\", \"spring\", \"candidate\", \"physics\", \"university\", \"concern\", \"development\", \"change\", \"string\", \"target\", \"instance\", \"room\", \"bitter\", \"bird\", \"football\", \"normal\", \"split\", \"impression\", \"wood\", \"long\", \"meaning\", \"stock\", \"cap\", \"leadership\", \"media\", \"ambition\", \"fishing\", \"essay\", \"salad\", \"repair\", \"today\", \"designer\", \"night\", \"bank\", \"drawing\", \"inevitable\", \"phase\", \"vast\", \"chip\", \"anger\", \"switch\", \"cry\", \"twist\", \"personality\", \"attempt\", \"storage\", \"being\", \"preparation\", \"bat\", \"selection\", \"white\", \"technology\", \"contract\", \"side\", \"section\", \"station\", \"till\", \"structure\", \"tongue\", \"taste\", \"truth\", \"difficulty\", \"group\", \"limit\", \"main\", \"move\", \"feeling\", \"light\", \"example\", \"mission\", \"might\", \"wait\", \"wheel\", \"shop\", \"host\", \"classic\", \"alternative\", \"cause\", \"agent\", \"consist\", \"table\", \"airline\", \"text\", \"pool\", \"craft\", \"range\", \"fuel\", \"tool\", \"partner\", \"load\", \"entrance\", \"deposit\", \"hate\", \"article\", \"video\", \"summer\", \"feature\", \"extreme\", \"mobile\", \"hospital\", \"flight\", \"fall\", \"pension\", \"piano\", \"fail\", \"result\", \"rub\", \"gap\", \"system\", \"report\", \"suck\", \"ordinary\", \"wind\", \"nerve\", \"ask\", \"shine\", \"note\", \"line\", \"mom\", \"perception\", \"brother\", \"reference\", \"bend\", \"charge\", \"treat\", \"trick\", \"term\", \"homework\", \"bake\", \"bid\", \"status\", \"project\", \"strategy\", \"orange\", \"let\", \"enthusiasm\", \"parent\", \"concentrate\", \"device\", \"travel\", \"poetry\", \"business\", \"society\", \"kiss\", \"end\", \"vegetable\", \"employ\", \"schedule\", \"hour\", \"brave\", \"focus\", \"process\", \"movie\", \"illegal\", \"general\", \"coffee\", \"ad\", \"highway\", \"chemistry\", \"psychology\", \"hire\", \"bell\", \"conference\", \"relief\", \"show\", \"neat\", \"funny\", \"weight\", \"quality\", \"club\", \"daughter\", \"zone\", \"touch\", \"tonight\", \"shock\", \"burn\", \"excuse\", \"name\", \"survey\", \"landscape\", \"advance\", \"satisfaction\", \"bread\", \"disaster\", \"item\", \"hat\", \"prior\", \"shopping\", \"visit\", \"east\", \"photo\", \"home\", \"idea\", \"father\", \"comparison\", \"cat\", \"pipe\", \"winner\", \"count\", \"lake\", \"fight\", \"prize\", \"foundation\", \"dog\", \"keep\", \"ideal\", \"fan\", \"struggle\", \"peak\", \"safety\", \"solution\", \"hell\", \"conclusion\", \"population\", \"strain\", \"alarm\", \"measurement\", \"second\", \"train\", \"race\", \"due\", \"insurance\", \"boss\", \"tree\", \"monitor\", \"sick\", \"course\", \"drag\", \"appointment\", \"slice\", \"still\", \"care\", \"patience\", \"rich\", \"escape\", \"emotion\", \"royal\", \"female\", \"childhood\", \"government\", \"picture\", \"will\", \"sock\", \"big\", \"gate\", \"oil\", \"cross\", \"pin\", \"improvement\", \"championship\", \"silly\", \"help\", \"sky\", \"pitch\", \"man\", \"diamond\", \"most\", \"transition\", \"work\", \"science\", \"committee\", \"moment\", \"fix\", \"teaching\", \"dig\", \"specialist\", \"complex\", \"guide\", \"people\", \"dead\", \"voice\", \"original\", \"break\", \"topic\", \"data\", \"degree\", \"reading\", \"recording\", \"bunch\", \"reach\", \"judgment\", \"lie\", \"regular\", \"set\", \"painting\", \"mode\", \"list\", \"player\", \"bear\", \"north\", \"wonder\", \"carpet\", \"heavy\", \"officer\", \"negative\", \"clock\", \"unique\", \"baby\", \"pain\", \"assumption\", \"disk\", \"iron\", \"bill\", \"drawer\", \"look\", \"double\", \"mistake\", \"finish\", \"future\", \"brilliant\", \"contact\", \"math\", \"rice\", \"leave\", \"restaurant\", \"discount\", \"sex\", \"virus\", \"bit\", \"trust\", \"event\", \"wear\", \"juice\", \"failure\", \"bug\", \"context\", \"mud\", \"whole\", \"wrap\", \"intention\", \"draft\", \"pressure\", \"cake\", \"dark\", \"explanation\", \"space\", \"angle\", \"word\", \"efficiency\", \"management\", \"habit\", \"star\", \"chance\", \"finding\", \"transportation\", \"stand\", \"criticism\", \"flow\", \"door\", \"injury\", \"insect\", \"surprise\", \"apartment\"]  # pylint: disable=line-too-long\n\n# ISO 639-1 codes to language names.\nLANGUAGE_CODES = immutabledict.immutabledict({\n    \"en\": \"English\",\n    \"es\": \"Spanish\",\n    \"pt\": \"Portuguese\",\n    \"ar\": \"Arabic\",\n    \"hi\": \"Hindi\",\n    \"fr\": \"French\",\n    \"ru\": \"Russian\",\n    \"de\": \"German\",\n    \"ja\": \"Japanese\",\n    \"it\": \"Italian\",\n    \"bn\": \"Bengali\",\n    \"uk\": \"Ukrainian\",\n    \"th\": \"Thai\",\n    \"ur\": \"Urdu\",\n    \"ta\": \"Tamil\",\n    \"te\": \"Telugu\",\n    \"bg\": \"Bulgarian\",\n    \"ko\": \"Korean\",\n    \"pl\": \"Polish\",\n    \"he\": \"Hebrew\",\n    \"fa\": \"Persian\",\n    \"vi\": \"Vietnamese\",\n    \"ne\": \"Nepali\",\n    \"sw\": \"Swahili\",\n    \"kn\": \"Kannada\",\n    \"mr\": \"Marathi\",\n    \"gu\": \"Gujarati\",\n    \"pa\": \"Punjabi\",\n    \"ml\": \"Malayalam\",\n    \"fi\": \"Finnish\",\n    })\n\n_ALPHABETS = \"([A-Za-z])\"\n_PREFIXES = \"(Mr|St|Mrs|Ms|Dr)[.]\"\n_SUFFIXES = \"(Inc|Ltd|Jr|Sr|Co)\"\n_STARTERS = r\"(Mr|Mrs|Ms|Dr|Prof|Capt|Cpt|Lt|He\\s|She\\s|It\\s|They\\s|Their\\s|Our\\s|We\\s|But\\s|However\\s|That\\s|This\\s|Wherever)\"\n_ACRONYMS = \"([A-Z][.][A-Z][.](?:[A-Z][.])?)\"\n_WEBSITES = \"[.](com|net|org|io|gov|edu|me)\"\n_DIGITS = \"([0-9])\"\n_MULTIPLE_DOTS = r\"\\.{2,}\"\n\n\ndef split_into_sentences(text):\n  \"\"\"Split the text into sentences.\n\n  Args:\n    text: A string that consists of more than or equal to one sentences.\n\n  Returns:\n    A list of strings where each string is a sentence.\n  \"\"\"\n  text = \" \" + text + \"  \"\n  text = text.replace(\"\\n\", \" \")\n  text = re.sub(_PREFIXES, \"\\\\1<prd>\", text)\n  text = re.sub(_WEBSITES, \"<prd>\\\\1\", text)\n  text = re.sub(_DIGITS + \"[.]\" + _DIGITS, \"\\\\1<prd>\\\\2\", text)\n  text = re.sub(\n      _MULTIPLE_DOTS,\n      lambda match: \"<prd>\" * len(match.group(0)) + \"<stop>\",\n      text,\n  )\n  if \"Ph.D\" in text:\n    text = text.replace(\"Ph.D.\", \"Ph<prd>D<prd>\")\n  text = re.sub(r\"\\s\" + _ALPHABETS + \"[.] \", \" \\\\1<prd> \", text)\n  text = re.sub(_ACRONYMS + \" \" + _STARTERS, \"\\\\1<stop> \\\\2\", text)\n  text = re.sub(\n      _ALPHABETS + \"[.]\" + _ALPHABETS + \"[.]\" + _ALPHABETS + \"[.]\",\n      \"\\\\1<prd>\\\\2<prd>\\\\3<prd>\",\n      text,\n  )\n  text = re.sub(\n      _ALPHABETS + \"[.]\" + _ALPHABETS + \"[.]\", \"\\\\1<prd>\\\\2<prd>\", text\n  )\n  text = re.sub(\" \" + _SUFFIXES + \"[.] \" + _STARTERS, \" \\\\1<stop> \\\\2\", text)\n  text = re.sub(\" \" + _SUFFIXES + \"[.]\", \" \\\\1<prd>\", text)\n  text = re.sub(\" \" + _ALPHABETS + \"[.]\", \" \\\\1<prd>\", text)\n  if \"‚Äù\" in text:\n    text = text.replace(\".‚Äù\", \"‚Äù.\")\n  if '\"' in text:\n    text = text.replace('.\"', '\".')\n  if \"!\" in text:\n    text = text.replace('!\"', '\"!')\n  if \"?\" in text:\n    text = text.replace('?\"', '\"?')\n  text = text.replace(\".\", \".<stop>\")\n  text = text.replace(\"?\", \"?<stop>\")\n  text = text.replace(\"!\", \"!<stop>\")\n  text = text.replace(\"<prd>\", \".\")\n  sentences = text.split(\"<stop>\")\n  sentences = [s.strip() for s in sentences]\n  if sentences and not sentences[-1]:\n    sentences = sentences[:-1]\n  return sentences\n\n\ndef count_words(text):\n  \"\"\"Counts the number of words.\"\"\"\n  tokenizer = nltk.tokenize.RegexpTokenizer(r\"\\w+\")\n  tokens = tokenizer.tokenize(text)\n  num_words = len(tokens)\n  return num_words\n\n\n@functools.lru_cache(maxsize=None)\ndef _get_sentence_tokenizer():\n  return nltk.data.load(\"nltk:tokenizers/punkt/english.pickle\")\n\n\ndef count_sentences(text):\n  \"\"\"Count the number of sentences.\"\"\"\n  tokenizer = _get_sentence_tokenizer()\n  tokenized_sentences = tokenizer.tokenize(text)\n  return len(tokenized_sentences)\n\n\ndef generate_keywords(num_keywords):\n  \"\"\"Randomly generates a few keywords.\"\"\"\n  return random.sample(WORD_LIST, k=num_keywords)",
        "eval/eval/livecodebench_v5.py": "from pathlib import Path\nfrom collections import defaultdict\nfrom datetime import datetime\n\nimport os\nimport hashlib\nimport json\nimport logging\nimport multiprocessing\nfrom multiprocessing.pool import ThreadPool\nimport numpy as np\nfrom statistics import mean\nfrom tqdm import tqdm\nimport copy\n\nfrom livecodebench_v5_utils.compute_code_generation_metrics import _temp_run\n\nLIVECODEBENCH_TESTS = os.getenv(\"LIVECODEBENCH_TESTS\", \"data/livecodebench_v5_tests\")\n\ndef _extract_code(text: str) -> str:\n    outputlines = text.split(\"\\n\")\n    indexlines = [i for i, line in enumerate(outputlines) if \"```\" in line]\n    if len(indexlines) < 2:\n        return \"\"\n    return \"\\n\".join(outputlines[indexlines[-2] + 1:indexlines[-1]])\n\ndef preprocess(job):\n    tests = job['tests']\n    raw_gen = job['gen'] if isinstance(job['gen'], str) else job['gen'][0]\n    gen_code = _extract_code(raw_gen)\n\n    return tests, gen_code\n\ndef work(job):\n    tests, generation = preprocess(job)\n    res = check_correctness(\n        tests=tests,\n        generation=generation,\n    )\n    assert res['md5'] == tests['md5'], \"test md5 mismatched\"\n    return res, job\n\ndef compute_scores(jobs, cache_path):\n    with ThreadPool(max(1, int(os.cpu_count() * 0.5))) as pool:\n        for res, job in tqdm(pool.imap_unordered(work, jobs), total=len(jobs)):\n            extraction_failed = 0\n            ispass = res['ispass']\n            metadata = res['metadata']\n            extraction_failed = metadata.get(\"error_code\", 0) == -1\n            results = res['results']\n\n            job.update({\n                \"pass-1\": ispass,\n                \"results\": results,\n                \"metadata\": metadata,\n                \"extraction_failed\": extraction_failed,\n            })\n            save_cache(job, cache_path)\n    with open(cache_path, \"r\") as f:\n        jobs = [json.loads(l) for l in f]\n\n    # Retry all timeout jobs sequentially (without using multiprocessing)\n    new_jobs = []\n    for job in tqdm(jobs, desc=\"Processing jobs\"):\n        error_code = job[\"metadata\"].get(\"error_code\", 0)\n        if error_code == -3:\n            res, job = work(job)\n            job.update(res)\n            new_jobs.append(job)\n            save_cache(job, cache_path.replace(\".jsonl\", \"_try2.jsonl\"))\n        else:\n            new_jobs.append(job)\n\n    return mean(x['pass-1'] for x in new_jobs)\ndef check_correctness(tests: dict, generation: str, timeout: int = 30, debug: bool = False):\n    \"\"\"Check correctness of code generation with a global timeout.\n    The global timeout is to catch some extreme/rare cases not handled by the timeouts\n    inside `run_test`\"\"\"\n\n    tests_path = Path(LIVECODEBENCH_TESTS) / tests['fname']\n    with open(tests_path, \"r\") as f:\n        sample = json.load(f)\n\n    md5 = calculate_string_md5(json.dumps(sample))\n\n    manager = multiprocessing.Manager()\n    result = manager.list()\n    metadata_list = manager.list()\n    p = multiprocessing.Process(\n        target=_temp_run,\n        args=(sample, generation, debug, result, metadata_list, timeout),\n    )\n    p.start()\n    p.join(timeout=(timeout + 1) * len(json.loads(sample[\"input_output\"])[\"inputs\"]) + 5)\n    if p.is_alive():\n        p.kill()\n    if not result:\n        in_outs = json.loads(sample[\"input_output\"])\n        # consider that all tests failed\n        result = [[-1 for i in range(len(in_outs[\"inputs\"]))]]\n        metadata_list = [{\"error_code\": -3}]\n        if debug:\n            print(f\"global timeout\")\n\n    res, metadata = result[0], metadata_list[0]\n    fixed = []\n    for e in res:\n        if isinstance(e, np.ndarray):\n            e = e.item(0)\n        if isinstance(e, np.bool_):\n            e = bool(e)\n        if e != True and e != False:\n            e = False\n        fixed.append(e)\n    res = fixed\n    # print(res)\n    if not np.all(res):\n        print(\"fail\")\n        return dict(ispass=0, md5=md5, results=res, metadata=metadata)\n    else:\n        print(\"pass\")\n        return dict(ispass=1, md5=md5, results=res, metadata=metadata)\n\ndef calculate_string_md5(input_string: str):\n    md5 = hashlib.md5()\n    md5.update(input_string.encode('utf-8'))\n    return md5.hexdigest()\n\ndef save_cache(job, cache_path):\n    with open(cache_path, \"a\") as g:\n        g.write(json.dumps(job, ensure_ascii=False) + \"\\n\")\n        g.flush()\n",
        "eval/eval/livecodebench_v5_utils/compute_code_generation_metrics.py": "# borrowed and extended from\n# https://github.com/Naman-ntc/codescratch/blob/main/evaluation/bigcode-evaluation-harness/lm_eval/tasks/custom_metrics/apps_custom_metrics/utils.py\n\nimport os\nimport sys\n\nsys.set_int_max_str_digits(50000)\n\nos.environ[\"TOKENIZERS_PARALLELISM\"] = \"false\"\nimport json\nimport multiprocessing\nfrom collections import defaultdict\nfrom concurrent.futures import ProcessPoolExecutor, as_completed\n\nimport numpy as np\nfrom tqdm import tqdm\n\nfrom livecodebench_v5_utils.testing_util import run_test\nfrom livecodebench_v5_utils.pass_k_utils import compute_metrics_from_results\n\n\ndef _temp_run(sample, generation, debug, result, metadata_list, timeout):\n    res, metadata = run_test(sample, test=generation, debug=debug, timeout=timeout)\n    result.append(res)\n    metadata_list.append(metadata)\n\n\ndef check_correctness(sample, generation, timeout, debug=True):\n    \"\"\"Check correctness of code generation with a global timeout.\n    The global timeout is to catch some extreme/rare cases not handled by the timeouts\n    inside `run_test`\"\"\"\n\n    manager = multiprocessing.Manager()\n    result = manager.list()\n    metadata_list = manager.list()\n    p = multiprocessing.Process(\n        target=_temp_run,\n        args=(sample, generation, debug, result, metadata_list, timeout),\n    )\n    p.start()\n    p.join(timeout=(timeout + 1) * len(json.loads(sample[\"input_output\"])[\"inputs\"]) + 5)\n    if p.is_alive():\n        p.kill()\n    if not result:\n        in_outs = json.loads(sample[\"input_output\"])\n        # consider that all tests failed\n        result = [[-1 for i in range(len(in_outs[\"inputs\"]))]]\n        if debug:\n            print(f\"global timeout\")\n    return result[0], metadata_list[0]\n\n\ndef evaluate_generations_by_problem(args):\n    problem_generations: list[str] = args[0]\n    sample = args[1]\n    debug: bool = args[2]\n    timeout: int = args[3]\n\n    res = []\n    metadata = []\n    for o_idx, o in enumerate(problem_generations):\n        curr_res = [-2]\n        try:\n            curr_res, curr_metadata = check_correctness(sample, o, timeout=timeout, debug=debug)\n            if debug:\n                print(f\"\\nSuccessful compilation of task {o_idx}!\")\n            fixed = []\n            for e in curr_res:\n                if isinstance(e, np.ndarray):\n                    e = e.item(0)\n                if isinstance(e, np.bool_):\n                    e = bool(e)\n                fixed.append(e)\n            curr_res = fixed\n            if not np.all(curr_res):\n                if debug:\n                    print(f\"Results were not True for all test cases {curr_res=}\\n\")\n        except Exception as e:\n            if debug:\n                print(f\"Compilation failed, test framework exception = {repr(e)}{e}\\n\")\n            # break\n            curr_metadata = {\n                \"error\": repr(e),\n                \"error_code\": -5,\n                \"error_message\": \"TestRunnerError\",\n            }\n        finally:\n            assert isinstance(curr_res, list), curr_res\n            assert isinstance(curr_metadata, dict), curr_metadata\n            res.append(curr_res)\n            metadata.append(curr_metadata)\n    if debug:\n        for i, r in enumerate(problem_generations):\n            print(\"Sample\\n\")\n            print(r)\n            print(\"\\n\")\n            print(\"Result\\n\")\n            print(res[i])\n            print(\"*\" * 30 + \"\\n\\n\")\n    return res, metadata\n\n\ndef evaluate_generations(\n    samples_list: list,\n    generations_list: list[list[str]],\n    debug: bool = False,\n    num_process_evaluate: int = 16,\n    timeout=6,\n):\n    \"\"\"We take the list of code generations and try to compile them\n     and the run their corresponding unit tests which are retrieved from the APPS dataset.\n\n    Args:\n        generations: list of code generations (same order as samples in APPS dataset)\n        level: difficulty level used in the generation, can be \"all\", \"introductory\", \"interview\" or \"competition\"\n\n    Returns:\n        results: dictionary of results, key is the problem index, value is a list of results for each generation\n    \"\"\"\n\n    # generations are code generations in the same order of the dataset\n\n    inputs = [[(generations_list[index], samples_list[index], debug, timeout), index] for index in range(len(generations_list))]\n\n    with tqdm(total=len(inputs)) as pbar:\n        with ProcessPoolExecutor(max_workers=1 if debug else num_process_evaluate) as executor:\n            futures = {executor.submit(evaluate_generations_by_problem, arg): index for arg, index in inputs}\n\n            results = {}\n            metadata = {}\n            for future in as_completed(futures):\n                index = futures[future]\n                results[index], metadata[index] = future.result()\n                pbar.update(1)\n\n    assert len(results) == len(inputs), f\"results = {len(results)} inputs = {len(inputs)} {results=}\"\n    # results = {i: r for r, (_, i) in zip(results, inputs)}\n\n    return results, metadata\n\n\ndef codegen_metrics(\n    samples_list,\n    generations_list,\n    k_list=[1, 5, 10, 20, 40, 50, 75, 100, 125, 150, 200, 500, 1000],\n    num_process_evaluate=16,\n    timeout=6,\n    debug=False,\n):\n\n    samples_linear = []\n    generations_linear = []\n    remap_index = []\n    results = defaultdict(list)\n    metadatas = defaultdict(list)\n    for idx, (sample, generation_list) in enumerate(zip(samples_list, generations_list)):\n        assert isinstance(generation_list, list), generations_list[0]\n        for generation in generation_list:\n            assert isinstance(generation, str), generations_list[0]\n            samples_linear.append(sample)\n            generations_linear.append([generation])\n            remap_index.append(idx)\n\n    print(f\"Evaluating {len(samples_linear)}...\")\n\n    results_linear, metadatas_linear = evaluate_generations(\n        samples_linear,\n        generations_linear,\n        debug=debug,\n        num_process_evaluate=num_process_evaluate,\n        timeout=timeout,\n    )\n\n    for idx, sub_results in sorted(results_linear.items(), key=lambda x: x[0]):\n        results[remap_index[idx]].append(sub_results[0])\n\n    for idx, sub_metadatas in sorted(metadatas_linear.items(), key=lambda x: x[0]):\n        metadatas[remap_index[idx]].append(sub_metadatas[0])\n\n    metrics = compute_metrics_from_results(results, k_list=k_list)\n\n    final_metadata = []\n    for key in sorted(list(metadatas.keys())):\n        final_metadata.append(metadatas[key])\n    for i in range(len(final_metadata)):\n        if type(final_metadata[i]) is not list:\n            final_metadata[i] = [json.dumps(final_metadata[i])]\n        else:\n            final_metadata[i] = [json.dumps(x) for x in final_metadata[i]]\n\n        assert len(final_metadata[i]) == len(generations_list[0]), f\"{len(final_metadata[i])=}\"\n\n    return [metrics, results, final_metadata]\n\n\nif __name__ == \"__main__\":\n    # print(\n    #     check_correctness(\n    #         {\n    #             \"input_output\": json.dumps(\n    #                 {\n    #                     \"inputs\": [\n    #                         json.dumps([1] * 100000)\n    #                         + \"\\n\"\n    #                         + json.dumps([100000, -100000] * (100000 // 2))\n    #                     ],\n    #                     \"outputs\": [json.dumps([100000, 0] * (100000 // 2))],\n    #                     \"fn_name\": \"mostFrequentIDs\",\n    #                 }\n    #             )\n    #         },\n    #         \"class Solution:\\n    def mostFrequentIDs(self, nums: List[int], freq: List[int]) -> List[int]:\\n        from collections import defaultdict\\n        \\n        # Count of each ID\\n        count = defaultdict(int)\\n        # How many IDs exist for a given frequency\\n        freq_of_count = defaultdict(int)\\n        \\n        max_freq = 0\\n        ans = []\\n        \\n        for i in range(len(nums)):\\n            x = nums[i]\\n            change = freq[i]\\n            \\n            old_freq = count[x]\\n            new_freq = old_freq + change\\n            \\n            # If there was an old frequency, decrease its usage\\n            if old_freq > 0:\\n                freq_of_count[old_freq] -= 1\\n                if freq_of_count[old_freq] == 0:\\n                    del freq_of_count[old_freq]\\n            \\n            # Update with the new frequency\\n            count[x] = new_freq\\n            freq_of_count[new_freq] += 1\\n            \\n            # Update max_freq if needed\\n            if new_freq > max_freq:\\n                max_freq = new_freq\\n            \\n            # If the collection at max_freq is empty, reduce max_freq until we find a non-empty bin\\n            while max_freq > 0 and max_freq not in freq_of_count:\\n                max_freq -= 1\\n            \\n            # If the collection is empty, max_freq will be 0\\n            ans.append(max_freq)\\n        \\n        return ans\",\n    #         6,\n    #         debug=True,\n    #     )\n    # )\n\n    print(\n        check_correctness(\n            {\"input_output\": json.dumps({\n                \"inputs\": \")))))\",\n                \"outputs\": \"0\",\n            },)},\n            \"\\nMOD = 998244353\\n\\nS = input().strip()\\nn = len(S)\\n\\nif n % 2 != 0:\\n    print(0)\\n    exit()\\n\\n# Initialize DP table\\ndp = [[0] * (n + 2) for _ in range(n + 1)]\\ndp[0][0] = 1\\n\\nfor i in range(1, n + 1):\\n    c = S[i-1]\\n    for b in range(n + 1):\\n        if dp[i-1][b] == 0:\\n            continue\\n        if c == '(':\\n            new_b = b + 1\\n            if new_b <= n:\\n                dp[i][new_b] = (dp[i][new_b] + dp[i-1][b]) % MOD\\n        elif c == ')':\\n            if b > 0:\\n                new_b = b - 1\\n                dp[i][new_b] = (dp[i][new_b] + dp[i-1][b]) % MOD\\n        else:  # '?'\\n            # Replace with '('\\n            new_b = b + 1\\n            if new_b <= n:\\n                dp[i][new_b] = (dp[i][new_b] + dp[i-1][b]) % MOD\\n            # Replace with ')'\\n            if b > 0:\\n                new_b = b - 1\\n                dp[i][new_b] = (dp[i][new_b] + dp[i-1][b]) % MOD\\n\\nprint(dp[n][0] % MOD)\\n\",\n            6,\n            debug=True,\n        ))\n",
        "eval/eval/livecodebench_v5_utils/pass_k_utils.py": "import numpy as np\n\n\ndef estimate_pass_at_k(num_samples, num_correct, k):\n    \"\"\"Estimates pass@k of each problem and returns them in an array.\"\"\"\n\n    def estimator(n: int, c: int, k: int) -> float:\n        \"\"\"Calculates 1 - comb(n - c, k) / comb(n, k).\"\"\"\n        if n - c < k:\n            return 1.0\n        return 1.0 - np.prod(1.0 - k / np.arange(n - c + 1, n + 1))\n\n    import itertools\n\n    if isinstance(num_samples, int):\n        num_samples_it = itertools.repeat(num_samples, len(num_correct))\n    else:\n        assert len(num_samples) == len(num_correct)\n        num_samples_it = iter(num_samples)\n\n    return np.array([estimator(int(n), int(c), k) for n, c in zip(num_samples_it, num_correct)])\n\n\ndef compute_metrics_from_results(results, k_list=[1, 5]):\n    total = []\n    correct = []\n    task_ids = []\n    for task_id, res in results.items():\n        all_correct = []\n        for generation in res:\n            gen = np.array(generation)\n            all_correct.append(np.all(gen > 0))\n        task_ids.append(task_id)\n        total.append(len(all_correct))\n        correct.append(sum(all_correct))\n    total = np.array(total)\n    correct = np.array(correct)\n    ks = k_list\n    detail_pass_at_k = {f\"pass@{k}\": estimate_pass_at_k(total, correct, k).tolist() for k in ks if (total >= k).all()}\n    pass_at_k = {f\"pass@{k}\": estimate_pass_at_k(total, correct, k).mean() for k in ks if (total >= k).all()}\n    detail_metrics = {k: dict(zip(task_ids, v)) for k, v in detail_pass_at_k.items()}\n    pass_at_k[\"detail\"] = detail_metrics\n    return pass_at_k\n\n\ndef extract_instance_results(results):\n    instance_wise_grades = {}\n    for task_id, res in results.items():\n        instance_wise_grades[task_id] = []\n        for generation in res:\n            instance_wise_grades[task_id].append(all([g > 0 for g in generation]))\n\n    instance_wise_grades = [v for _, v in sorted(instance_wise_grades.items(), key=lambda item: item[0])]\n    return instance_wise_grades\n",
        "eval/eval/livecodebench_v5_utils/process_data.py": "import json\nimport zlib\nimport pickle\nimport base64\nimport hashlib\nfrom enum import Enum\nfrom datetime import datetime\nfrom dataclasses import dataclass\n\nfrom pathlib import Path\nfrom datasets import load_dataset\nfrom tqdm import tqdm\n\n\nclass Platform(Enum):\n    LEETCODE = \"leetcode\"\n    CODEFORCES = \"codeforces\"\n    ATCODER = \"atcoder\"\n\n\nclass Difficulty(Enum):\n    EASY = \"easy\"\n    MEDIUM = \"medium\"\n    HARD = \"hard\"\n\n\nclass TestType(Enum):\n    STDIN = \"stdin\"\n    FUNCTIONAL = \"functional\"\n\n\n@dataclass\nclass Test:\n    input: str\n    output: str\n    testtype: TestType\n\n    def __post_init__(self):\n        self.testtype = TestType(self.testtype)\n        # if self.testtype == TestType.FUNCTIONAL:\n        #     self.input = json.loads(self.input)\n        #     self.output = json.loads(self.output)\n\n\n@dataclass\nclass CodeGenerationProblem:\n    question_title: str\n    question_content: str\n    platform: Platform\n    question_id: str\n    contest_id: str\n    contest_date: datetime\n    starter_code: str\n    difficulty: Difficulty\n    public_test_cases: list[Test]\n    private_test_cases: list[Test]\n    metadata: dict\n\n    def __post_init__(self):\n        self.platform = Platform(self.platform)\n        self.difficulty = Difficulty(self.difficulty)\n        self.contest_date = datetime.fromisoformat(self.contest_date)\n\n        self.public_test_cases = json.loads(self.public_test_cases)  # type: ignore\n        self.public_test_cases = [Test(**t) for t in self.public_test_cases]\n\n        try:\n            self.private_test_cases = json.loads(self.private_test_cases)  # type: ignore\n        except:\n            self.private_test_cases = json.loads(pickle.loads(zlib.decompress(base64.b64decode(self.private_test_cases.encode(\"utf-8\"))  # type: ignore\n                                                                             )))  # type: ignore\n        self.private_test_cases = [Test(**t) for t in self.private_test_cases]\n\n        self.metadata = json.loads(self.metadata)  # type: ignore\n\n    def insert_output(self, output_list: list[str], code_list: list[str]) -> dict:\n        return {\n            \"question_title\": self.question_title,\n            \"question_content\": self.question_content,\n            \"platform\": self.platform.value,\n            \"question_id\": self.question_id,\n            \"contest_id\": self.contest_id,\n            \"contest_date\": self.contest_date.isoformat(),\n            \"starter_code\": self.starter_code,\n            \"difficulty\": self.difficulty.value,\n            \"output_list\": output_list,\n            \"code_list\": code_list,\n        }\n\n    def insert_output_evaluation(\n        self,\n        output_list: list[str],\n        code_list: list[str],\n        graded_list: list[bool],\n        **kwargs,\n    ) -> dict:\n        output = self.insert_output(output_list, code_list)\n        output[\"graded_list\"] = graded_list\n        output[\"pass@1\"] = graded_list.count(True) / len(graded_list)\n        for k, v in kwargs.items():\n            output[k] = v\n        return output\n\n    def get_evaluation_sample(self):\n        return {\n            \"input_output\": json.dumps({\n                \"inputs\": [t.input for t in self.public_test_cases + self.private_test_cases],\n                \"outputs\": [t.output for t in self.public_test_cases + self.private_test_cases],\n                \"fn_name\": self.metadata.get(\"func_name\", None),\n            }),\n        }\n\n\nclass PromptConstants:\n    SYSTEM_MESSAGE_GENERIC = f\"You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\"\n\n    SYSTEM_MESSAGE_GEMINI = f\"You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests. Do NOT use system calls like `exit` in the generated program. Ensure that the first code block contains the solution.\"\n\n    SYSTEM_MESSAGE_GEMINITHINK = f\"You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\"\n\n    SYSTEM_MESSAGE_DEEPSEEK = f\"You are an AI programming assistant, utilizing the DeepSeek Coder model, developed by DeepSeek Company, and you answer questions related to computer science.\"\n\n    SYSTEM_MESSAGE_CODEQWEN = f\"<|im_start|>system\\nYou are a helpful assistant.<|im_end|>\\n<|im_start|>user\"\n\n    FORMATTING_MESSAGE_WITH_STARTER_CODE = \"You will use the following starter code to write the solution to the problem and enclose your code within delimiters.\"\n\n    FORMATTING_WITHOUT_STARTER_CODE = \"Read the inputs from stdin solve the problem and write the answer to stdout (do not directly test on the sample inputs). Enclose your code within delimiters as follows. Ensure that when the python program runs, it reads the inputs, runs the algorithm and writes output to STDOUT.\"\n\n\ndef load_code_generation_dataset(release_version=\"release_v5\") -> list[CodeGenerationProblem]:\n    dataset = load_dataset(\"livecodebench/code_generation_lite\", split=\"test\", version_tag=release_version, trust_remote_code=True)\n    dataset = [CodeGenerationProblem(**p) for p in dataset]  # type: ignore\n    print(f\"Loaded {len(dataset)} problems\")\n    return dataset\n\n\ndef get_qwen_question_template_answer(question: CodeGenerationProblem):\n    prompt = \"You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests. You will NOT return anything except for the program.\\n\\n\"\n    prompt += f\"Question: {question.question_content}\\n\\n\"\n    if question.starter_code:\n        prompt += f\"{PromptConstants.FORMATTING_MESSAGE_WITH_STARTER_CODE}\\n\"\n        prompt += f\"```python\\n{question.starter_code}\\n```\\n\\n\"\n    else:\n        prompt += f\"{PromptConstants.FORMATTING_WITHOUT_STARTER_CODE}\\n\"\n        prompt += f\"```python\\n# YOUR CODE HERE\\n```\\n\\n\"\n    return prompt\n\n\ndef get_qwen_reasoning_question_template_answer(question: CodeGenerationProblem):\n    prompt = \"You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests.\\n\\n\"\n    prompt += f\"Question: {question.question_content}\\n\\n\"\n    if question.starter_code:\n        prompt += f\"{PromptConstants.FORMATTING_MESSAGE_WITH_STARTER_CODE}\\n\"\n        prompt += f\"```python\\n{question.starter_code}\\n```\\n\\n\"\n    else:\n        prompt += f\"{PromptConstants.FORMATTING_WITHOUT_STARTER_CODE}\\n\"\n        prompt += f\"```python\\n# YOUR CODE HERE\\n```\\n\\n\"\n    return prompt\n\n\ndef calculate_string_md5(input_string: str):\n    md5 = hashlib.md5()\n    md5.update(input_string.encode('utf-8'))\n    return md5.hexdigest()\n\n\nif __name__ == \"__main__\":\n\n    output_livecodebench_v5_tests_dir = \"/home/data/public/data/eval/code/livecodebench_v5_tests\"\n    output_livecodebench_v5_data_path = \"/home/data/public/data/eval/code/livecodebench_v5.jsonl\"\n    Path(output_livecodebench_v5_tests_dir).mkdir(parents=True, exist_ok=True)\n    Path(output_livecodebench_v5_data_path).parent.mkdir(parents=True, exist_ok=True)\n\n    dataset = load_code_generation_dataset(release_version=\"release_v5\")\n    num_samples = 10\n\n    livecodebench_v5_inputs_outputs = []\n    livecodebench_v5_dataset = []\n\n    # template for general language model\n    # prompt_template = get_qwen_question_template_answer\n    # template for reasoning model\n    prompt_template = get_qwen_reasoning_question_template_answer\n\n    for global_id, sample in enumerate(tqdm(dataset)):\n        inputs_outputs = sample.get_evaluation_sample()\n        livecodebench_v5_dataset.append({\n            \"global_id\": global_id,\n            \"question_id\": sample.question_id,\n            \"contest_id\": sample.contest_id,\n            \"contest_date\": sample.contest_date.isoformat(),\n            \"prompt\": prompt_template(sample),\n            \"tests\": {\n                \"fname\": f\"{global_id}.json\",\n                \"md5\": calculate_string_md5(json.dumps(inputs_outputs)),\n            },\n            \"tags\": \"coding,en,python,core\",\n            \"task\": \"livecodebench_v5\",\n            \"source\": \"livecodebench_v5\",\n            \"beam_size\": num_samples,\n            # \"eval_args\": eval_args,\n        })\n        livecodebench_v5_inputs_outputs.append(inputs_outputs)\n\n        # save test cases\n        with open(Path(output_livecodebench_v5_tests_dir) / f\"{global_id}.json\", \"w\") as f:\n            json.dump(inputs_outputs, f)\n\n    # save dataset\n    with open(output_livecodebench_v5_data_path, \"w\") as f:\n        for sample in livecodebench_v5_dataset:\n            f.write(json.dumps(sample) + \"\\n\")\n",
        "eval/eval/livecodebench_v5_utils/testing_util.py": "import ast\nimport json\nimport sys\nimport faulthandler\nimport platform\n\n# used for debugging to time steps\nfrom datetime import datetime\n\n# to run the solution files we're using a timing based approach\nimport signal\n\nimport numpy as np\n\nfrom io import StringIO\n\n# used for testing the code that reads from input\nfrom unittest.mock import patch, mock_open\n\n# from pyext import RuntimeModule\nfrom types import ModuleType\n\nfrom enum import Enum\nfrom decimal import Decimal\nimport time\n\nimport_string = \"from string import *\\nfrom re import *\\nfrom datetime import *\\nfrom collections import *\\nfrom heapq import *\\nfrom bisect import *\\nfrom copy import *\\nfrom math import *\\nfrom random import *\\nfrom statistics import *\\nfrom itertools import *\\nfrom functools import *\\nfrom operator import *\\nfrom io import *\\nfrom sys import *\\nfrom json import *\\nfrom builtins import *\\nfrom typing import *\\nimport string\\nimport re\\nimport datetime\\nimport collections\\nimport heapq\\nimport bisect\\nimport copy\\nimport math\\nimport random\\nimport statistics\\nimport itertools\\nimport functools\\nimport operator\\nimport io\\nimport sys\\nimport json\\nsys.setrecursionlimit(50000)\\n\"\n\n\ndef truncatefn(s, length=300):\n    if isinstance(s, str):\n        pass\n    else:\n        s = str(s)\n    if len(s) <= length:\n        return s\n\n    return s[:length // 2] + \"...(truncated) ...\" + s[-length // 2:]\n\n\nclass CODE_TYPE(Enum):\n    call_based = 0\n    standard_input = 1\n\n\n# stuff for setting up signal timer\nclass TimeoutException(Exception):\n    pass\n\n\ndef timeout_handler(signum, frame):\n    print(\"timeout occured: alarm went off\")\n    raise TimeoutException\n\n\n# used to capture stdout as a list\n# from https://stackoverflow.com/a/16571630/6416660\n# alternative use redirect_stdout() from contextlib\nclass Capturing(list):\n\n    def __enter__(self):\n        self._stdout = sys.stdout\n        sys.stdout = self._stringio = StringIO()\n        # Make closing the StringIO a no-op\n        self._stringio.close = lambda x: 1\n        return self\n\n    def __exit__(self, *args):\n        self.append(self._stringio.getvalue())\n        del self._stringio  # free up some memory\n        sys.stdout = self._stdout\n\n\ndef clean_if_name(code: str) -> str:\n    try:\n        astree = ast.parse(code)\n        last_block = astree.body[-1]\n        if isinstance(last_block, ast.If):\n            condition = last_block.test\n            if ast.unparse(condition).strip() == \"__name__ == '__main__'\":\n                code = (\n                    ast.unparse(astree.body[:-1]) + \"\\n\" + ast.unparse(last_block.body)  # type: ignore\n                )\n    except:\n        pass\n\n    return code\n\n\ndef make_function(code: str) -> str:\n    try:\n        import_stmts = []\n        all_other_stmts = []\n        astree = ast.parse(code)\n        for stmt in astree.body:\n            if isinstance(stmt, (ast.Import, ast.ImportFrom)):\n                import_stmts.append(stmt)\n            else:\n                all_other_stmts.append(stmt)\n\n        function_ast = ast.FunctionDef(\n            name=\"wrapped_function\",\n            args=ast.arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]),\n            body=all_other_stmts,\n            decorator_list=[],\n            lineno=-1,\n        )\n        main_code = (\n            import_string + \"\\n\" + ast.unparse(import_stmts)  # type: ignore\n            + \"\\n\" + ast.unparse(function_ast)  # type: ignore\n        )\n        return main_code\n    except Exception as e:\n        return code\n\n\ndef call_method(method, inputs):\n\n    if isinstance(inputs, list):\n        inputs = \"\\n\".join(inputs)\n\n    inputs_line_iterator = iter(inputs.split(\"\\n\"))\n\n    # sys.setrecursionlimit(10000)\n\n    # @patch('builtins.input', side_effect=inputs.split(\"\\n\"))\n    @patch(\"builtins.open\", mock_open(read_data=inputs))\n    @patch(\"sys.stdin\", StringIO(inputs))\n    @patch(\"sys.stdin.readline\", lambda *args: next(inputs_line_iterator))\n    @patch(\"sys.stdin.readlines\", lambda *args: inputs.split(\"\\n\"))\n    @patch(\"sys.stdin.read\", lambda *args: inputs)\n    # @patch('sys.stdout.write', print)\n    def _inner_call_method(_method):\n        try:\n            return _method()\n        except SystemExit as e:\n            pass\n        finally:\n            pass\n\n    return _inner_call_method(method)\n\n\ndef get_function(compiled_sol, fn_name: str):  # type: ignore\n    try:\n        assert hasattr(compiled_sol, fn_name)\n        return getattr(compiled_sol, fn_name)\n    except Exception as e:\n        return\n\n\ndef compile_code(code: str, timeout: int):\n    signal.alarm(timeout)\n    try:\n        tmp_sol = ModuleType(\"tmp_sol\", \"\")\n        exec(code, tmp_sol.__dict__)\n        if \"class Solution\" in code:\n            # leetcode wraps solutions in `Solution`\n            # this is a hack to check if it is leetcode solution or not\n            # currently livecodebench only supports LeetCode but\n            # else condition allows future extensibility to other platforms\n            compiled_sol = tmp_sol.Solution()\n        else:\n            # do nothing in the other case since function is accesible\n            compiled_sol = tmp_sol\n\n        assert compiled_sol is not None\n    finally:\n        signal.alarm(0)\n\n    return compiled_sol\n\n\ndef convert_line_to_decimals(line: str) -> tuple[bool, list[Decimal]]:\n    try:\n        decimal_line = [Decimal(elem) for elem in line.split()]\n    except:\n        return False, []\n    return True, decimal_line\n\n\ndef get_stripped_lines(val: str):\n    ## you don't want empty lines to add empty list after splitlines!\n    val = val.strip()\n\n    return [val_line.strip() for val_line in val.split(\"\\n\")]\n\n\ndef grade_call_based(code: str, all_inputs: list, all_outputs: list, fn_name: str, timeout: int):\n    # call-based clean up logic\n    # need to wrap in try-catch logic after to catch the correct errors, but for now this is fine.\n    code = import_string + \"\\n\\n\" + code\n    compiled_sol = compile_code(code, timeout)\n\n    if compiled_sol is None:\n        return\n\n    method = get_function(compiled_sol, fn_name)\n\n    if method is None:\n        return\n\n    all_inputs = [[json.loads(line) for line in inputs.split(\"\\n\")] for inputs in all_inputs]\n\n    all_outputs = [json.loads(output) for output in all_outputs]\n\n    total_execution = 0\n    all_results = []\n    for idx, (gt_inp, gt_out) in enumerate(zip(all_inputs, all_outputs)):\n        signal.alarm(timeout)\n        faulthandler.enable()\n        try:\n            # can lock here so time is useful\n            start = time.time()\n            prediction = method(*gt_inp)\n            total_execution += time.time() - start\n            signal.alarm(0)\n\n            # don't penalize model if it produces tuples instead of lists\n            # ground truth sequences are not tuples\n            if isinstance(prediction, tuple):\n                prediction = list(prediction)\n\n            tmp_result = prediction == gt_out\n\n            # handle floating point comparisons\n\n            all_results.append(tmp_result)\n\n            if not tmp_result:\n                return all_results, {\n                    \"output\": truncatefn(prediction),\n                    \"inputs\": truncatefn(gt_inp),\n                    \"expected\": truncatefn(gt_out),\n                    \"error_code\": -2,\n                    \"error_message\": \"Wrong Answer\",\n                }\n        except Exception as e:\n            signal.alarm(0)\n            if \"timeoutexception\" in repr(e).lower():\n                all_results.append(-3)\n                return all_results, {\n                    \"error\": repr(e),\n                    \"error_code\": -3,\n                    \"error_message\": \"Time Limit Exceeded\",\n                    \"inputs\": truncatefn(gt_inp),\n                    \"expected\": truncatefn(gt_out),\n                }\n            else:\n                all_results.append(-4)\n                return all_results, {\n                    \"error\": repr(e),\n                    \"error_code\": -4,\n                    \"error_message\": \"Runtime Error\",\n                    \"inputs\": truncatefn(gt_inp),\n                    \"expected\": truncatefn(gt_out),\n                }\n\n        finally:\n            signal.alarm(0)\n            faulthandler.disable()\n\n    return all_results, {\"execution time\": total_execution}\n\n\ndef grade_stdio(\n    code: str,\n    all_inputs: list,\n    all_outputs: list,\n    timeout: int,\n):\n    ## runtime doesn't interact well with __name__ == '__main__'\n    code = clean_if_name(code)\n\n    ## we wrap the given code inside another function\n    code = make_function(code)\n\n    compiled_sol = compile_code(code, timeout)\n    if compiled_sol is None:\n        return\n\n    method = get_function(compiled_sol, \"wrapped_function\")\n\n    if method is None:\n        return\n\n    all_results = []\n    total_execution_time = 0\n    for idx, (gt_inp, gt_out) in enumerate(zip(all_inputs, all_outputs)):\n        signal.alarm(timeout)\n        faulthandler.enable()\n\n        signal.alarm(timeout)\n        with Capturing() as captured_output:\n            try:\n                start = time.time()\n                call_method(method, gt_inp)\n                total_execution_time += time.time() - start\n                # reset the alarm\n                signal.alarm(0)\n            except Exception as e:\n                signal.alarm(0)\n                if \"timeoutexception\" in repr(e).lower():\n                    all_results.append(-3)\n                    return all_results, {\n                        \"error\": repr(e),\n                        \"error_code\": -3,\n                        \"error_message\": \"Time Limit Exceeded\",\n                        \"inputs\": truncatefn(gt_inp),\n                        \"expected\": truncatefn(gt_out),\n                    }\n                else:\n                    all_results.append(-4)\n                    return all_results, {\n                        \"error\": repr(e),\n                        \"error_code\": -4,\n                        \"error_message\": \"Runtime Error\",\n                        \"inputs\": truncatefn(gt_inp),\n                        \"expected\": truncatefn(gt_out),\n                    }\n\n            finally:\n                signal.alarm(0)\n                faulthandler.disable()\n\n        prediction = captured_output[0]\n\n        stripped_prediction_lines = get_stripped_lines(prediction)\n        stripped_gt_out_lines = get_stripped_lines(gt_out)\n\n        ## WA happens in multiple circumstances\n        ## so cache the return to make it clean!\n        WA_send_args = {\n            \"output\": truncatefn(prediction),\n            \"inputs\": truncatefn(gt_inp),\n            \"expected\": truncatefn(gt_out),\n            \"error_code\": -2,\n        }\n\n        if len(stripped_prediction_lines) != len(stripped_gt_out_lines):\n            all_results.append(-2)\n            WA_send_args[\"error_message\"] = \"Wrong answer: mismatched output length\"\n            return all_results, WA_send_args\n\n        for output_line_idx, (\n                stripped_prediction_line,\n                stripped_gt_out_line,\n        ) in enumerate(zip(stripped_prediction_lines, stripped_gt_out_lines)):\n            WA_send_args[\"error_message\"] = (f\"Wrong answer at {output_line_idx=}: {truncatefn(stripped_prediction_line)} != {truncatefn(stripped_gt_out_line)}\")\n\n            ## CASE 1: exact match\n            if stripped_prediction_line == stripped_gt_out_line:\n                continue\n\n            ## CASE 2: element-wise comparision\n            ## if there are floating elements\n            ## use `decimal` library for good floating point comparision\n            ## otherwise gotcha: np.isclose(50000000000000000, 50000000000000001) = True\n            ## note that we should always be able to convert to decimals\n\n            success, decimal_prediction_line = convert_line_to_decimals(stripped_prediction_line)\n            if not success:\n                all_results.append(-2)\n                return all_results, WA_send_args\n            success, decimal_gtout_line = convert_line_to_decimals(stripped_gt_out_line)\n            if not success:\n                all_results.append(-2)\n                return all_results, WA_send_args\n\n            if decimal_prediction_line == decimal_gtout_line:\n                continue\n\n            all_results.append(-2)\n            return all_results, WA_send_args\n        all_results.append(True)\n\n    return all_results, {\"execution time\": total_execution_time}\n\n\ndef run_test(sample, test=None, debug=False, timeout=6):\n    \"\"\"\n    if test(generated_code) is not None it'll try to run the code.\n    otherwise it'll just return an input and output pair.\n    \"\"\"\n    signal.signal(signal.SIGALRM, timeout_handler)\n\n    # Disable functionalities that can make destructive changes to the test.\n    # max memory is set to 4GB\n    reliability_guard()\n\n    if debug:\n        print(f\"start = {datetime.now().time()}\")\n\n    try:\n        in_outs = json.loads(sample[\"input_output\"])\n    except ValueError as e:\n        raise e\n        in_outs = None\n\n    if in_outs:\n        if in_outs.get(\"fn_name\") is None:\n            which_type = CODE_TYPE.standard_input  # Standard input\n            method_name = None\n\n        else:\n            which_type = CODE_TYPE.call_based  # Call-based\n            method_name = in_outs[\"fn_name\"]\n\n    if debug:\n        print(f\"loaded input_output = {datetime.now().time()}\")\n\n    if test is None:\n        assert False, \"should not happen: test code is none\"\n        return in_outs, {\"error\": \"no test code provided\"}\n    elif test is not None:\n        results = []\n        sol = import_string\n        if debug:\n            print(f\"loading test code = {datetime.now().time()}\")\n\n        if which_type == CODE_TYPE.call_based:\n            signal.alarm(timeout)\n            try:\n                results, metadata = grade_call_based(\n                    code=test,\n                    all_inputs=in_outs[\"inputs\"],\n                    all_outputs=in_outs[\"outputs\"],\n                    fn_name=method_name,\n                    timeout=timeout,\n                )\n                return results, metadata\n            except Exception as e:\n                return [-4], {\n                    \"error_code\": -4,\n                    \"error_message\": f\"Error during testing: {e}\",\n                }\n            finally:\n                signal.alarm(0)\n        elif which_type == CODE_TYPE.standard_input:\n            # sol\n            # if code has if __name__ == \"__main__\": then remove it\n\n            signal.alarm(timeout)\n            try:\n                results, metadata = grade_stdio(\n                    code=test,\n                    all_inputs=in_outs[\"inputs\"],\n                    all_outputs=in_outs[\"outputs\"],\n                    timeout=timeout,\n                )\n                return results, metadata\n            except Exception as e:\n                return [-4], {\n                    \"error_code\": -4,\n                    \"error_message\": f\"Error during testing: {e}\",\n                }\n            finally:\n                signal.alarm(0)\n\n\ndef reliability_guard(maximum_memory_bytes=None):\n    \"\"\"\n    This disables various destructive functions and prevents the generated code\n    from interfering with the test (e.g. fork bomb, killing other processes,\n    removing filesystem files, etc.)\n    WARNING\n    This function is NOT a security sandbox. Untrusted code, including, model-\n    generated code, should not be blindly executed outside of one. See the\n    Codex paper for more information about OpenAI's code sandbox, and proceed\n    with caution.\n    \"\"\"\n\n    if maximum_memory_bytes is not None:\n        import resource\n\n        resource.setrlimit(resource.RLIMIT_AS, (maximum_memory_bytes, maximum_memory_bytes))\n        resource.setrlimit(resource.RLIMIT_DATA, (maximum_memory_bytes, maximum_memory_bytes))\n        if not platform.uname().system == \"Darwin\":\n            resource.setrlimit(resource.RLIMIT_STACK, (maximum_memory_bytes, maximum_memory_bytes))\n\n    faulthandler.disable()\n\n    import builtins\n\n    # builtins.exit = None\n    builtins.quit = None\n\n    import os\n\n    os.environ[\"OMP_NUM_THREADS\"] = \"1\"\n\n    os.kill = None\n    os.system = None\n    os.putenv = None\n    os.remove = None\n    os.removedirs = None\n    os.rmdir = None\n    os.fchdir = None\n    os.setuid = None\n    os.fork = None\n    os.forkpty = None\n    os.killpg = None\n    os.rename = None\n    os.renames = None\n    os.truncate = None\n    os.replace = None\n    os.unlink = None\n    os.fchmod = None\n    os.fchown = None\n    os.chmod = None\n    os.chown = None\n    os.chroot = None\n    os.fchdir = None\n    os.lchflags = None\n    os.lchmod = None\n    os.lchown = None\n    os.getcwd = None\n    os.chdir = None\n\n    import shutil\n\n    shutil.rmtree = None\n    shutil.move = None\n    shutil.chown = None\n\n    import subprocess\n\n    subprocess.Popen = None  # type: ignore\n\n    __builtins__[\"help\"] = None\n\n    import sys\n\n    sys.modules[\"ipdb\"] = None\n    sys.modules[\"joblib\"] = None\n    sys.modules[\"resource\"] = None\n    sys.modules[\"psutil\"] = None\n    sys.modules[\"tkinter\"] = None\n",
        "eval/eval/math_opensource.py": "import json\nimport logging\nimport math\nimport os\nimport re\nfrom pathlib import Path\nfrom statistics import mean\n\nimport timeout_decorator\nfrom collections import Counter\nfrom pebble import ProcessPool\nfrom concurrent.futures import TimeoutError\nfrom tqdm import tqdm\n\ndef is_multi_choice(answer):\n    for c in answer:\n        if c not in [\"A\", \"B\", \"C\", \"D\", \"E\"]:\n            return False\n    return True\ndef init_fn():\n    from math_opensource_utils.parser import parse_ground_truth, STRIP_EXCEPTIONS, extract_answer, strip_string\n    from math_opensource_utils.parser import choice_answer_clean\n    from math_opensource_utils.grader import math_equal_process\n\ndef work(args):\n    i, job = args\n    from math_opensource_utils.parser import parse_ground_truth, STRIP_EXCEPTIONS, extract_answer, strip_string\n    from math_opensource_utils.parser import choice_answer_clean\n    from math_opensource_utils.grader import math_equal_process\n    assert len(job[\"gen\"]) == 1\n    # total_num = len(job[\"gen\"])\n\n    data_name = job['task'].split('/')[1]\n    job['gt_cot'], job['gt'] = parse_ground_truth(job, data_name)\n\n    prediction = extract_answer(job['gen'][0], data_name)\n    prediction = strip_string(prediction, skip_unit=data_name in STRIP_EXCEPTIONS)\n\n    # cleaning choice results\n    if job[\"gt\"] in [\"A\", \"B\", \"C\", \"D\", \"E\"] and prediction not in [\"A\", \"B\", \"C\", \"D\", \"E\"]:\n            prediction = choice_answer_clean(prediction)\n    elif is_multi_choice(job[\"gt\"]) and not is_multi_choice(prediction):\n            # remove any non-choice char\n            prediction = \"\".join(\n                [c for c in prediction if c in [\"A\", \"B\", \"C\", \"D\", \"E\"]]\n            )\n\n    params = [(prediction, job['gt'])]\n    result = math_equal_process(params[0])\n        \n    return i, float(result), prediction\n\ndef compute_scores(jobs, cache_path):\n    with tqdm(total=len(jobs)) as pbar:\n        with ProcessPool(max_workers=20, initializer=init_fn) as pool:\n            future = pool.map(work, list(enumerate(jobs)), timeout=10)\n            iterator = future.result()\n            while True:\n                try:\n                    i, result, prediction = next(iterator)\n                    jobs[i]['accuracy'] = result\n                    jobs[i]['extracted_answer'] = prediction\n                    jobs[i]['timeout_cnt'] = 0\n                    pbar.update(1)\n                except StopIteration:\n                    break\n                except TimeoutError as error:\n                    print(error)\n                except Exception as error:\n                    print(error.traceback)\n                    exit()\n        for job in jobs:\n            if \"accuracy\" not in job:\n                job['accuracy'] = 0\n                job['extracted_answer'] = \"Timeout\"\n                job['timeout_cnt'] = 1\n    save_cache(jobs, cache_path)\n    return mean(x['accuracy'] for x in jobs)\n\ndef save_cache(jobs, cache_path):\n    with open(cache_path, \"w\") as g:\n        for job in jobs:\n            g.write(json.dumps(job, ensure_ascii=False) + \"\\n\")\n            g.flush()",
        "eval/eval/math_opensource_utils/examples.py": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\ndef get_examples():\n    examples = {}\n    examples[\"gsm8k\"] = [\n        (\n            \"There are 15 trees in the grove. Grove workers will plant trees in the grove today. After they are done, there will be 21 trees. How many trees did the grove workers plant today?\",\n            \"There are 15 trees originally. Then there were 21 trees after some more were planted. So there must have been 21 - 15 = 6. The answer is 6.\",\n        ),\n        (\n            \"If there are 3 cars in the parking lot and 2 more cars arrive, how many cars are in the parking lot?\",\n            \"There are originally 3 cars. 2 more cars arrive. 3 + 2 = 5. The answer is 5.\",\n        ),\n        (\n            \"Leah had 32 chocolates and her sister had 42. If they ate 35, how many pieces do they have left in total?\",\n            \"Originally, Leah had 32 chocolates. Her sister had 42. So in total they had 32 + 42 = 74. After eating 35, they had 74 - 35 = 39. The answer is 39.\",\n        ),\n        (\n            \"Jason had 20 lollipops. He gave Denny some lollipops. Now Jason has 12 lollipops. How many lollipops did Jason give to Denny?\",\n            \"Jason started with 20 lollipops. Then he had 12 after giving some to Denny. So he gave Denny 20 - 12 = 8. The answer is 8.\",\n        ),\n        (\n            \"Shawn has five toys. For Christmas, he got two toys each from his mom and dad. How many toys does he have now?\",\n            \"Shawn started with 5 toys. If he got 2 toys each from his mom and dad, then that is 4 more toys. 5 + 4 = 9. The answer is 9.\",\n        ),\n        (\n            \"There were nine computers in the server room. Five more computers were installed each day, from monday to thursday. How many computers are now in the server room?\",\n            \"There were originally 9 computers. For each of 4 days, 5 more computers were added. So 5 * 4 = 20 computers were added. 9 + 20 is 29. The answer is 29.\",\n        ),\n        (\n            \"Michael had 58 golf balls. On tuesday, he lost 23 golf balls. On wednesday, he lost 2 more. How many golf balls did he have at the end of wednesday?\",\n            \"Michael started with 58 golf balls. After losing 23 on tuesday, he had 58 - 23 = 35. After losing 2 more, he had 35 - 2 = 33 golf balls. The answer is 33.\",\n        ),\n        (\n            \"Olivia has $23. She bought five bagels for $3 each. How much money does she have left?\",\n            \"Olivia had 23 dollars. 5 bagels for 3 dollars each will be 5 x 3 = 15 dollars. So she has 23 - 15 dollars left. 23 - 15 is 8. The answer is 8.\",\n        ),\n    ]\n    examples[\"gsm8k-pal\"] = [\n        (\n            \"Olivia has $23. She bought five bagels for $3 each. How much money does she have left?\",\n            '```python\\ndef solution():\\n    \"\"\"Olivia has $23. She bought five bagels for $3 each. How much money does she have left?\"\"\"\\n    money_initial = 23\\n    bagels = 5\\n    bagel_cost = 3\\n    money_spent = bagels * bagel_cost\\n    money_left = money_initial - money_spent\\n    result = money_left\\n    return result\\n```',\n        ),\n        (\n            \"Michael had 58 golf balls. On tuesday, he lost 23 golf balls. On wednesday, he lost 2 more. How many golf balls did he have at the end of wednesday?\",\n            '```python\\ndef solution():\\n    \"\"\"Michael had 58 golf balls. On tuesday, he lost 23 golf balls. On wednesday, he lost 2 more. How many golf balls did he have at the end of wednesday?\"\"\"\\n    golf_balls_initial = 58\\n    golf_balls_lost_tuesday = 23\\n    golf_balls_lost_wednesday = 2\\n    golf_balls_left = golf_balls_initial - golf_balls_lost_tuesday - golf_balls_lost_wednesday\\n    result = golf_balls_left\\n    return result\\n```',\n        ),\n        (\n            \"There were nine computers in the server room. Five more computers were installed each day, from monday to thursday. How many computers are now in the server room?\",\n            '```python\\ndef solution():\\n    \"\"\"There were nine computers in the server room. Five more computers were installed each day, from monday to thursday. How many computers are now in the server room?\"\"\"\\n    computers_initial = 9\\n    computers_per_day = 5\\n    num_days = 4  # 4 days between monday and thursday\\n    computers_added = computers_per_day * num_days\\n    computers_total = computers_initial + computers_added\\n    result = computers_total\\n    return result\\n```',\n        ),\n    ]\n    examples[\"gsm8k-tora\"] = [\n        (\n            \"Olivia has $23. She bought five bagels for $3 each. How much money does she have left?\",\n            \"```python\\ndef money_left():\\n    money_initial = 23\\n    bagels = 5\\n    bagel_cost = 3\\n    money_spent = bagels * bagel_cost\\n    remaining_money = money_initial - money_spent\\n    return remaining_money\\n \\nremaining_money = money_left()\\nprint(remaining_money)\\n```\\n```output\\n8\\n```\\nOlivia has $\\\\boxed{8}$ dollars left.\",\n        ),\n        (\n            \"Michael had 58 golf balls. On tuesday, he lost 23 golf balls. On wednesday, he lost 2 more. How many golf balls did he have at the end of wednesday?\",\n            \"```python\\ndef remaining_golf_balls():\\n    golf_balls_initial = 58\\n    golf_balls_lost_tuesday = 23\\n    golf_balls_lost_wednesday = 2\\n    golf_balls_left = golf_balls_initial - golf_balls_lost_tuesday - golf_balls_lost_wednesday\\n    remaining_golf_balls = golf_balls_left\\n    return remaining_golf_balls\\n\\nanswer = remaining_golf_balls() \\nprint(answer)\\n```\\n```output\\n33\\n```\\nMichael had $\\\\boxed{33}$ golf balls at the end of Wednesday.\",\n        ),\n        (\n            \"There were nine computers in the server room. Five more computers were installed each day, from monday to thursday. How many computers are now in the server room?\",\n            \"```python\\ndef total_computers():\\n    computers_initial = 9\\n    computers_per_day = 5\\n    num_days = 4  # 4 days between monday and thursday\\n    computers_added = computers_per_day * num_days\\n    computers_total = computers_initial + computers_added\\n    return computers_total\\n\\ntotal_computers = total_computers()\\nprint(total_computers)\\n```\\n```output\\n29\\n```\\nThere're $\\\\boxed{29}$ computers in the server room.\",\n        ),\n    ]\n\n    examples[\"math\"] = [\n        (\n            \"Kevin Kangaroo begins hopping on a number line at 0. He wants to get to 1, but he can hop only $\\\\frac{1}{3}$ of the distance. Each hop tires him out so that he continues to hop $\\\\frac{1}{3}$ of the remaining distance. How far has he hopped after five hops? Express your answer as a common fraction.\",\n            \"Let's think step by step\\nKevin hops $1/3$ of the remaining distance with every hop.\\nHis first hop takes $1/3$ closer.\\nFor his second hop, he has $2/3$ left to travel, so he hops forward $(2/3)(1/3)$.\\nFor his third hop, he has $(2/3)^2$ left to travel, so he hops forward $(2/3)^2(1/3)$.\\nIn general, Kevin hops forward $(2/3)^{k-1}(1/3)$ on his $k$th hop.\\nWe want to find how far he has hopped after five hops.\\nThis is a finite geometric series with first term $1/3$, common ratio $2/3$, and five terms.\\nThus, Kevin has hopped $\\\\frac{\\\\frac{1}{3}\\\\left(1-\\\\left(\\\\frac{2}{3}\\\\right)^5\\\\right)}{1-\\\\frac{2}{3}} = \\\\boxed{\\\\frac{211}{243}}$.\\nThe answer is \\\\frac{211}{243}}\",\n        ),\n        (\n            \"What is the area of the region defined by the equation $x^2+y^2 - 7 = 4y-14x+3$?\",\n            \"Let's think step by step\\nWe rewrite the equation as $x^2 + 14x + y^2 - 4y = 10$ and then complete the square,\\nresulting in  $(x+7)^2-49 + (y-2)^2-4=10$,\\nor $(x+7)^2+(y-2)^2=63$.\\nThis is the equation of a circle with center $(-7, 2)$ and radius $\\\\sqrt{63},$\\nso the area of this region is $\\\\pi r^2 = \\\\boxed{63\\\\pi}$.\\nThe answer is 63\\\\pi\",\n        ),\n        (\n            \"If $x^2+y^2=1$, what is the largest possible value of $|x|+|y|$?\",\n            \"Let's think step by step\\nIf $(x,y)$ lies on the circle,\\nso does $(x,-y),$ $(-x,-y),$ and $(-x,-y),$ (which all give the same value of $|x| + |y|$),\\nso we can assume that $x \\\\ge 0$ and $y \\\\ge 0.$\\nThen $|x| + |y| = x + y.$  Squaring, we get\\n\\\\[(x + y)^2 = x^2 + 2xy + y^2 = 1 + 2xy.\\\\]\\nNote that $(x - y)^2 \\\\ge 0.$\\nExpanding, we get $x^2 - 2xy + y^2 \\\\ge 0,$ so $2xy \\\\le x^2 + y^2 = 1.$\\nHence,\\\\[1 + 2xy \\\\le 2,\\\\]which means $x + y \\\\le \\\\sqrt{2}.$\\nEquality occurs when $x = y = \\\\frac{1}{\\\\sqrt{2}},$\\nso the maximum value of $|x| + |y|$ is $\\\\boxed{\\\\sqrt{2}}.$\\nThe answer is \\\\sqrt{2}\",\n        ),\n        (\n            \"If $f(x)=\\\\frac{ax+b}{cx+d}, abcd\\\\not=0$ and $f(f(x))=x$ for all $x$ in the domain of $f$, what is the value of $a+d$?\",\n            \"Let's think step by step\\nThe condition $f(f(x))$ means that $f$ is the inverse of itself,\\nso its graph is symmetrical about the line $y = x$.\\nWith a rational function of this form, we will have two asymptotes:\\na vertical one at $x=-d/c$ if $cx+d$ does not divide $ax+b$,\\nand a horizontal one at $y=a/c$,\\nif we take the limit of $f(x)$ as $x$ goes to $\\\\pm\\\\infty$.\\nIn order for $f$ to be its own inverse, the intersection of the asymptotes must lie on the line $y=x$\\nso that it and its asymptotes reflect onto themselves.\\nThis means that $-d/c=a/c$,\\nand therefore $-d=a$ and $a+d=\\\\boxed{0}$.\\nThe answer is 0\",\n        ),\n        (\n            \"Expand $(2z^2 + 5z - 6)(3z^3 - 2z + 1)$.\",\n            \"Let's think step by step\\n$$\\\\begin{array}{crrrrrrr}\\n& & & 3z^3 & & -2z & + 1 & \\\\\\\\\\n\\\\times & & & & 2z^2 & +5z & -6 \\\\\\\\\\n\\\\cline{1-7}\\\\rule{0pt}{0.17in}\\n& & & -18z^3 & & +12z & -6 & \\\\\\\\\\n& & +15z^4 & & -10z^2 & +5z & & \\\\\\\\\\n+ & 6z^5 & & -4z^3 & +2z^2 & & & \\\\\\\\\\n\\\\cline{1-7}\\\\rule{0pt}{0.17in}\\n& 6z^5 & +15z^4 & -22z^3 & - 8z^2 &+17z & -6 &\\n\\\\end{array}$$\\nThe answer is 6z^5+15z^4-22z^3-8z^2+17z-6\",\n        ),\n    ]\n\n    examples[\"math_pal\"] = [\n        (\n            \"Display the final result in LaTeX.\\n\\n Find the coefficient of $x^3$ when $3(x^2 - x^3+x) +3(x +2x^3- 3x^2 + 3x^5+x^3) -5(1+x-4x^3 - x^2)$ is simplifie.\",\n            \"```python\\nfrom sympy import symbols, simplify\\n\\ndef solution():\\n    x = symbols('x')\\n    expr = 3*(x**2 - x**3 + x) + 3*(x + 2*x**3 - 3*x**2 + 3*x**5 + x**3) - 5*(1 + x - 4*x**3 - x**2)\\n    simplified_expr = simplify(expr)\\n\\n    x3_coefficient = simplified_expr.as_coefficients_dict()[x**3]\\n    result = x3_coefficient\\n    return result\\n```\",\n        ),\n        (\n            \"The surface area of a sphere with radius $r$ is $4\\\\pi r^2$. Including the area of its circular base, what is the total surface area of a hemisphere with radius 6 cm? Express your answer in terms of $\\\\pi$.\",\n            \"```python\\nimport math\\n\\ndef solution():\\n    radius = 6\\n\\n    # Surface area of the hemisphere\\n    hemisphere_area = 2 * math.pi * radius**2\\n\\n    # Area of the circular base\\n    base_area = math.pi * radius**2\\n\\n    # Total surface area\\n    total_surface_area = hemisphere_area + base_area\\n\\n    # Formatting the result in LaTeX\\n    result = r'{}\\\\\\\\pi'.format(total_surface_area / math.pi)\\n    return result\\n```\",\n        ),\n        (\n            \"Monica tosses a fair 6-sided die.  If the roll is a prime number, then she wins that amount of dollars (so that, for example, if she rolls 3, then she wins 3 dollars).  If the roll is composite, she wins nothing. Otherwise, she loses 3 dollars. What is the expected value of her winnings on one die toss? Express your answer as a dollar value to the nearest cent.\",\n            '```python\\ndef solution():\\n    # Probabilities of each outcome\\n    prime_prob = 1 / 6\\n    composite_prob = 1 / 3\\n    otherwise_prob = 1 / 6\\n\\n    # Expected value of each outcome\\n    prime_expected_value = (2 * prime_prob) + (3 * prime_prob) + (5 * prime_prob)\\n    composite_expected_value = 0 * composite_prob\\n    otherwise_expected_value = -3 * otherwise_prob\\n\\n    # Total expected value\\n    total_expected_value = prime_expected_value + composite_expected_value + otherwise_expected_value\\n\\n    # Dollar value to the nearest cent\\n    result = \"{:.2f}\".format(total_expected_value)\\n    return result\\n```',\n        ),\n        (\n            \"Given $\\\\mathbf{a} = \\\\begin{pmatrix} -7 \\\\\\\\ 0 \\\\\\\\ 1 \\\\end{pmatrix}$ and $\\\\mathbf{b} = \\\\begin{pmatrix} 4 \\\\\\\\ 2 \\\\\\\\ -1 \\\\end{pmatrix},$ find $\\\\mathbf{a} - 3 \\\\mathbf{b}.$\",\n            \"```python\\nimport numpy as np\\n\\ndef solution()\\n    a = np.array([-7, 0, 1])\\n    b = np.array([4, 2, -1])\\n\\n    result = a - 3 * b\\n\\n    result = r'\\\\begin{{pmatrix}} {} \\\\\\\\ {} \\\\\\\\ {} \\\\end{{pmatrix}}'.format(result[0], result[1], result[2])\\n    return result\\n```\",\n        ),\n    ]\n    examples[\"math-tora\"] = [\n        (\n            \"Convert the point $(0, -3 \\\\sqrt{3}, 3)$ in rectangular coordinates to spherical coordinates.  Enter your answer in the form $(\\\\rho,\\\\theta,\\\\phi),$ where $\\\\rho > 0,$ $0 \\\\le \\\\theta < 2 \\\\pi,$ and $0 \\\\le \\\\phi \\\\le \\\\pi.$\",\n            \"To convert the point $(x, y, z)$ in rectangular coordinates to spherical coordinates $(\\\\rho, \\\\theta, \\\\phi)$, we use the following formulas:\\n1. $\\\\rho = \\\\sqrt{x^2 + y^2 + z^2}$\\n2. $\\\\theta = \\\\arctan{\\\\frac{y}{x}}$\\n3. $\\\\phi = \\\\arccos{\\\\frac{z}{\\\\rho}}$\\n\\nLet's write a function:\\n\\n```python\\nfrom sympy import sqrt, atan2, acos, pi\\n\\ndef rectangular_to_spherical():\\n    x, y, z = 0, -3*sqrt(3), 3\\n    rho = sqrt(x**2 + y**2 + z**2)\\n    theta = atan2(y, x)\\n    phi = acos(z/rho)\\n    return rho, theta, phi\\n\\nspherical_coordinates = rectangular_to_spherical()\\nprint(spherical_coordinates)\\n```\\n```output\\n(6, -pi/2, pi/3)\\n```\\n\\nThe required form of the answer is $(\\\\rho, \\\\theta, \\\\phi)$, where $\\\\rho > 0$, $0 \\\\le \\\\theta < 2\\\\pi$, and $0 \\\\le \\\\phi \\\\le \\\\pi$. Since our initial output has $\\\\theta = -\\\\pi/2$, which doesn't meet the condition for $\\\\theta$, we add $2\\\\pi$ to adjust its value.\\n\\nHence, the spherical coordinates for the point $(0, -3\\\\sqrt{3}, 3)$ are $\\\\boxed{(6, \\\\frac{3\\\\pi}{2}, \\\\frac{\\\\pi}{3})}$.\",\n        ),\n        (\n            \"Compute $1011_2 + 101_2 - 1100_2 + 1101_2$.  Express your answer in base 2.\",\n            'Let\\'s write a single python function for binary computation:\\n\\n```python\\ndef binary_sum_diff():\\n    # Convert binary to decimal\\n    num1 = int(\"1011\", 2)\\n    num2 = int(\"101\", 2)\\n    num3 = int(\"1100\", 2)\\n    num4 = int(\"1101\", 2)\\n\\n    # Perform the operations\\n    result = num1 + num2 - num3 + num4\\n\\n    # Convert the result back to binary\\n    result_binary = format(result, \"b\")\\n\\n    return result_binary\\n\\nresult = binary_sum_diff()\\nprint(result)\\n```\\n```output\\n10001\\n```\\nThe answer expressed in base 2 is $\\\\boxed{10001_2}$.',\n        ),\n        (\n            \"Find the matrix that corresponds to projecting onto the vector $\\\\begin{pmatrix} 2 \\\\\\\\ -3 \\\\end{pmatrix}.$\",\n            \"```python\\nfrom sympy import Matrix, simplify\\n\\ndef projection_matrix():\\n    v = Matrix([2, -3])\\n\\n    # Calculate the projection matrix\\n    P = (v * v.T) / (v.T * v)[0]\\n\\n    # Simplify the elements\\n    P = P.applyfunc(simplify)\\n\\n    return P\\n\\nresult = projection_matrix()\\nprint(result)\\n```\\n```output\\nMatrix([[4/13, -6/13], [-6/13, 9/13]])\\n```\\n\\nThe matrix is $\\\\boxed{\\\\begin{pmatrix} \\\\frac{4}{13} & -\\\\frac{6}{13} \\\\ -\\\\frac{6}{13} & \\\\frac{9}{13} \\\\end{pmatrix}}.$\",\n        ),\n        (\n            \"Solve the inequality\\n\\\\[\\\\frac{x^2 - 25}{x + 5} < 0.\\\\]\",\n            \"Let's use `sympy` to solve the inequality:\\n\\n```python\\nfrom sympy import symbols, simplify\\nfrom sympy.solvers.inequalities import solve_univariate_inequality\\nfrom sympy.core.relational import StrictLessThan\\n\\ndef solve_inequality():\\n    x = symbols('x')\\n    expression = (x**2 - 25) / (x + 5)\\n    inequality = StrictLessThan(expression, 0)\\n    solution = solve_univariate_inequality(inequality, x, relational=False)\\n    simplified_solution = simplify(solution)\\n    \\n    return simplified_solution\\n\\nresult = solve_inequality()\\nprint(result)\\n```\\n```output\\nUnion(Interval.open(-oo, -5), Interval.Lopen(-5, 5))\\n```\\nThe answer is $\\\\boxed{(-\\\\infty,-5)\\\\cup(-5,5)}$\",\n        ),\n        (\n            'In the figure, triangles $ABC$ and $BCD$ are equilateral triangles. What is the value of $AD \\\\div BC$ when expressed in simplest radical form?\\n\\n[asy]\\ndraw((0,0)--(5,8.7)--(10,0)--cycle);\\ndraw((10,0)--(15,8.7)--(5,8.7));\\nlabel(\"$A$\",(0,0),SW);\\nlabel(\"$B$\",(5,8.7),N);\\nlabel(\"$C$\",(10,0),SE);\\nlabel(\"$D$\",(15,8.7),NE);\\n[/asy]',\n            \"```python\\nfrom sympy import Rational, sqrt, simplify\\n\\ndef ad_divided_by_bc():\\n\\n    x = Rational(1, 1)  # Side length of equilateral triangles\\n\\n    ad_squared = 2 * x**2 * (1 + Rational(1, 2))  # Using the law of cosines with cos(2*pi/3) = -1/2\\n    ad = sqrt(ad_squared)\\n\\n    bc = x # BC is the side length of the equilateral triangles\\n\\n    simplified_ratio = simplify(ad / bc)\\n\\n    return simplified_ratio\\n\\nresult = ad_divided_by_bc()\\nprint(result)\\n```\\n```output\\nsqrt(3)\\n```\\nThe value of $AD \\\\div BC$ is $\\\\boxed{\\\\sqrt{3}}$.\",\n        ),\n    ]\n    examples[\"carp_en\"] = [\n        (\n            \"If $3 a ^ { m + 2 } b$ and $\\\\frac { 1 } { 2 } ab ^ { n - 1 }$ are similar terms, then $m + n$ is equal to.\",\n            \"Let's think step by step\\n$3 a ^ { m + 2 } b$ and $\\\\frac { 1 } { 2 } ab ^ { n - 1 }$ are like terms. We can obtain $m + 2 = 1$ and $n - 1 = 1$. Solving for $m$ and $n$, we get $m = - 1$ and $n = 2$. Therefore, $m + n = - 1 + 2 = 1$.\\nThe answer is: 1\",\n        ),\n        (\n            \"The solution to the equation $y - \\\\frac { y - 1 } { 2 } = - \\\\frac { y + 2 } { 5 }$ is ____ ?\",\n            \"Let's think step by step\\nTo eliminate the denominator, we have $10 y - 5 ( y - 1 ) = - 2 ( y + 2 )$. Expanding the brackets gives $10 y - 5 y + 5 = - 2 y - 4$. Rearranging terms gives $10 y - 5 y + 2 y = - 4 - 5$, which simplifies to $7 y = - 9$. Dividing both sides by 7 gives $y = - \\\\frac { 9 } { 7 }$.\\nThe answer is: y = - \\\\frac { 9 } { 7 }\",\n        ),\n        (\n            \"If $( m + 4 ) ^ 2 + | n - 3 | = 0$, then $\\\\frac { 1 } { 2 } m - n$ = ____?\",\n            \"Let's think step by step\\n$\\\\because ( m + 4 ) ^ 2 + | n - 3 | = 0$, $\\\\therefore m + 4 = 0$, $n - 3 = 0$, which means $m = - 4$, $n = 3$. Then the original expression equals $- 2 - 3 = - 5$.\\nThe answer is: - 5\",\n        ),\n        (\n            \"Given a quadratic equation in one variable $x$, $x ^ 2 + x + m = 0$, with one root being $x = 1$, what is the other root of this equation?\",\n            \"Let's think step by step\\nSuppose the quadratic equation in one variable about $x$ is $x ^ 2 + x + m = 0$, and $\\\\alpha$ is another real root of the equation. Since one real root of the quadratic equation in one variable about $x$ is $1$, we have $\\\\alpha + 1 = - 1$. Therefore, $\\\\alpha = - 2$.\\nThe answer is: - 2\",\n        ),\n        (\n            \"The parabola $y = - 5 { x } ^ 2 + 1$ is translated $2$ units upward and $1$ unit to the left, resulting in the parabola _____.\",\n            \"Let's think step by step\\nThe parabola $y = - 5 { x } ^ 2 + 1$ is first shifted upward by 2 units, resulting in $y = - 5 { x } ^ 2 + 3$. Then it is shifted left by 1 unit, resulting in $y = - 5 {( x + 1 )} ^ 2 + 3$.\\nThe answer is: y = - 5 ( x + 1 )  ^ { 2 } + 3\",\n        ),\n        (\n            \"If the radical $\\\\sqrt { x - 8 }$ is defined, then the range of real numbers for $x$ is ____ ?\",\n            \"Let's think step by step\\nSince the radical $\\\\sqrt { x - 8 }$ is defined, therefore $x - 8 \\\\ge 0$, which implies $x \\\\ge 8$.\\nThe answer is: x \\\\ge 8\",\n        ),\n        (\n            \"If $a ^ { m } \\\\times a ^ { 2 } = a ^ { 7 }$, then the value of $m$ is ____?\",\n            \"Let's think step by step\\nAccording to the multiplication rule of powers with the same base: when multiplying powers with the same base, keep the base the same and add the exponents. We have $m + 2 = 7$, so solving for $m$ gives $m = 5$.\\nThe answer is: 5\",\n        ),\n        (\n            \"If line segment $a$ and $b$ satisfy $\\\\frac { a } { b } = \\\\frac { 5 } { 2 }$, then the value of $\\\\frac { a - b } { b }$ is ____?\",\n            \"Let's think step by step\\n$\\\\because \\\\frac { a } { b } = \\\\frac { 5 } { 2 }$, $\\\\therefore$ we can assume $a = 5 k$, then $b = 2 k$, $\\\\therefore \\\\frac { a - b } { b } = \\\\frac { 5 k - 2 k } { 2 k } = \\\\frac { 3 } { 2 }$.\\nThe answer is: \\\\frac { 3 } { 2 }\",\n        ),\n    ]\n\n    examples[\"minerva_math\"] = [\n        (\n            \"Find the domain of the expression $\\\\frac{\\\\sqrt{x-2}}{\\\\sqrt{5-x}}$.}\",\n            \"The expressions inside each square root must be non-negative.\\nTherefore, $x-2 \\\\ge 0$, so $x\\\\ge2$, and $5 - x \\\\ge 0$, so $x \\\\le 5$.\\nAlso, the denominator cannot be equal to zero, so $5-x>0$, which gives $x<5$.\\nTherefore, the domain of the expression is $\\\\boxed{[2,5)}$.\",\n        ),\n        (\n            \"If $\\\\det \\\\mathbf{A} = 2$ and $\\\\det \\\\mathbf{B} = 12,$ then find $\\\\det (\\\\mathbf{A} \\\\mathbf{B}).$\",\n            \"We have that $\\\\det (\\\\mathbf{A} \\\\mathbf{B}) = (\\\\det \\\\mathbf{A})(\\\\det \\\\mathbf{B}) = (2)(12) = \\\\boxed{24}.$\",\n        ),\n        (\n            \"Terrell usually lifts two 20-pound weights 12 times. If he uses two 15-pound weights instead, how many times must Terrell lift them in order to lift the same total weight?\",\n            \"If Terrell lifts two 20-pound weights 12 times, he lifts a total of $2\\\\cdot 12\\\\cdot20=480$ pounds of weight.  If he lifts two 15-pound weights instead for $n$ times, he will lift a total of $2\\\\cdot15\\\\cdot n=30n$ pounds of weight.  Equating this to 480 pounds, we can solve for $n$: \\\\begin{align*}\\n30n&=480\\\\\\\\\\\\\\n\\\\Rightarrow\\\\qquad n&=480/30=\\\\boxed{16}\\n\\\\end{align*}\",\n        ),\n        (\n            \"If the system of equations\\n\\n\\\\begin{align*}\\n6x-4y&=a,\\\\\\\\\\\\\\n6y-9x &=b.\\n\\\\end{align*}has a solution $(x, y)$ where $x$ and $y$ are both nonzero, find $\\\\frac{a}{b},$ assuming $b$ is nonzero.\",\n            \"If we multiply the first equation by $-\\\\frac{3}{2}$, we obtain\\n\\n$$6y-9x=-\\\\frac{3}{2}a.$$Since we also know that $6y-9x=b$, we have\\n\\n$$-\\\\frac{3}{2}a=b\\\\Rightarrow\\\\frac{a}{b}=\\\\boxed{-\\\\frac{2}{3}}.$$\",\n        ),\n    ]\n\n    examples[\"aqua\"] = [\n        (\n            \"John found that the average of 15 numbers is 40. If 10 is added to each number then the mean of the numbers is?\\nAnswer Choices: (A) 50 (B) 45 (C) 65 (D) 78 (E) 64\",\n            \"If 10 is added to each number, then the mean of the numbers also increases by 10. So the new mean would be 50. The answer is (A).\",\n        ),\n        (\n            \"If a / b = 3/4 and 8a + 5b = 22,then find the value of a.\\nAnswer Choices: (A) 1/2 (B) 3/2 (C) 5/2 (D) 4/2 (E) 7/2\",\n            \"a / b = 3/4, then b = 4a / 3. So 8a + 5(4a / 3) = 22. This simplifies to 8a + 20a / 3 = 22, which means 44a / 3 = 22. So a is equal to 3/2. The answer is (B).\",\n        ),\n        (\n            \"A person is traveling at 20 km/hr and reached his destiny in 2.5 hr then find the distance?\\nAnswer Choices: (A) 53 km (B) 55 km (C) 52 km (D) 60 km (E) 50 km\",\n            \"The distance that the person traveled would have been 20 km/hr * 2.5 hrs = 50 km. The answer is (E).\",\n        ),\n        (\n            \"How many keystrokes are needed to type the numbers from 1 to 500?\\nAnswer Choices: (A) 1156 (B) 1392 (C) 1480 (D) 1562 (E) 1788\",\n            \"There are 9 one-digit numbers from 1 to 9. There are 90 two-digit numbers from 10 to 99. There are 401 three-digit numbers from 100 to 500. 9 + 90(2) + 401(3) = 1392. The answer is (B).\",\n        ),\n    ]\n    examples[\"sat_math\"] = [\n        (\n            \"If $\\frac{x-1}{3}=k$ and $k=3$, what is the value of $x$ ? \\nAnswer Choices: (A) 2 (B) 4 (C) 9 (D) 10\",\n            \"If k = 3, then x - 1 = 3 * 3, therfore, x - 1 = 9 and x = 10. The answer is D\",\n        ),\n        (\n            \"For $i=\\\\sqrt{-1}$, what is the sum $(7+3 i)+(-8+9 i)$ ? \\nAnswer Choices: (A) $-1+12 i$ (B) $-1-6 i$ (C) $15+12 i$ (D) $15-6 i$ 3\",\n            \"For (7+3 i)+(-8+9 i), the real part is 7 + (-8) = -1, the imageinary part is 3 i + 9 i = 12 i. The answer is A\",\n        ),\n        (\n            \"On Saturday afternoon, Armand sent $m$ text messages each hour for 5 hours, and Tyrone sent $p$ text messages each hour for 4 hours. Which of the following represents the total number of messages sent by Armand and Tyrone on Saturday afternoon?\\nAnswer Choices: (A) $9 m p$ (B) $20 m p$ (C) $5 m+4 p$ (D) $4 m+5 p$\",\n            \"Armand texts m messages each hour for 5 hours, which leads to 5m messages. Tyrone texts p messages each hour for 4 hours, which leds to 4p messages. The total is 5m + 4p. The answer is C.\",\n        ),\n        (\n            \"$$\\begin{array}{r}3 x+4 y=-23 \\\\2 y-x=-19\\\\end{array}$$What is the solution $(x, y)$ to the system of equations above?\\nAnswer Choices: (A) $(-5,-2)$ (B) $(3,-8)$ (C) $(4,-6)$ (D) $(9,-6)$\",\n            \"By solving this equation, we found that x = 3 and y = -8. The answer is B.\",\n        ),\n    ]\n    examples[\"mmlu_mathematics\"] = [\n        (\n            \"Simplify and write the result with a rational denominator: $$\\\\sqrt{\\\\sqrt[3]{\\\\sqrt{\\frac{1}{729}}}}$$\\nAnswer Choices: (A) \\\\frac{3\\\\sqrt{3}}{3} (B) \\\\frac{1}{3} (C) \\\\sqrt{3} (D) \\\\frac{\\\\sqrt{3}}{3}\",\n            \"Factoring $729=3^6$ and combining the roots $\\frac{1}{2}\\frac{1}{3}\\frac{1}{2}=\\frac{1}{12}$, we get that $\\\\sqrt{\\\\sqrt[3]{\\\\sqrt{\\frac{1}{729}}}}=\\\\left(\\frac{1}{3^6}\\right)^{\\frac{1}{12}}=\\frac{1}{3^{\\frac{1}{2}}}=\\frac{3}{\\\\sqrt{3}}$. The answer is (D).\",\n        ),\n        (\n            \"Five thousand dollars compounded annually at an $x\\\\%$ interest rate takes six years to double. At the same interest rate, how many years will it take $\\\\$300$ to grow to $\\\\$9600$?\\nAnswer Choices:(A) 12 (B) 1 (C) 30 (D) 5\",\n            \"To go from $\\\\$300$ to $\\\\$9600$, the value must go up by a factor of $9600/300=32=2^5$. Since at this interest rate it takes six years for it to double, it will take $5*6=30$ years to grow to $\\\\$9600$. The answer is (C).\",\n        ),\n        (\n            \"Ten students take a biology test and receive the following scores: 45, 55, 50, 70, 65, 80, 40, 90, 70, 85. What is the mean of the students‚Äô test scores?\\nAnswer Choices: (A) 55 (B) 60 (C) 62 (D) 65\",\n            \"There are 10 students and the sum of their scores is $45 + 55 + 50 + 70 + 65 + 80 + 40 + 90 + 70 + 85 = 650$, the mean is $650/10=65$. The answer is (D).\",\n        ),\n        (\n            \"The variable $x$ varies directly as the square of $y$, and $y$ varies directly as the cube of $z$. If $x$ equals $-16$ when $z$ equals 2, what is the value of $x$ when $z$ equals $\\frac{1}{2}$?\\nAnswer Choices: (A) -1 (B) 16 (C) -\\frac{1}{256} (D) \\\\frac{1}{16}\",\n            \"We know that $x \\\\propto y^2$ and $y \\\\propto z^3$, so $x = k z^6$ for some constant $k$. Plugging in for $x=-16$ and $z=2$, the constant value is $k=\\frac{x}{z^6}=\\frac{-16}{64}=-\\frac{1}{4}$. So, when $z=\\frac{1}{2}$, the value of $x$ is $x=kz^6=-\\frac{1}{4}\\frac{1}{2^6}=-\\frac{1}{256}$. The answer is (C).\",\n        ),\n        (\n            \"Joe was in charge of lights for a dance. The red light blinks every two seconds, the yellow light every three seconds, and the blue light every five seconds. If we include the very beginning and very end of the dance, how many times during a seven minute dance will all the lights come on at the same time? (Assume that all three lights blink simultaneously at the very beginning of the dance.)\\nAnswer Choices: (A) 3 (B) 15 (C) 6 (D) 5\",\n            \"The least common multiple of 2, 3 and 5 is 30, so during a 7 minute dance, all the three lights will come on at the same time $2*7+1=15$ times. The answer is (B).\",\n        ),\n    ]\n    examples[\"mmlu_physics\"] = [\n        (\n            \"A microwave oven is connected to an outlet, 120 V, and draws a current of 2 amps. At what rate is energy being used by the microwave oven?\\nAnswer Choices: (A) 10 W (B) 30 W (C) 60 W (D) 240 W\",\n            \"Rate of energy usage is known as power; in an dissipative electrical circuit, power is given by voltage times current. So in our case, the power is 120 V times 2 amps, or 240 W. The answer is (D).\",\n        ),\n        (\n            \"A point charge, Q = +1 mC, is fixed at the origin. How much work is required to move a charge, Q = +8 ¬µC, from the point (0, 4 meters) to the point (3 meters, 0)?\\nAnswer Choices: (A) 3.5 J (B) 6.0 J (C) 22.5 J (D) 40 J\",\n            \"To calculate the work required to move a charge from one location to another in a fixed electric field, it is enough to calculate the potential difference between the two locations. Here, the potential only depends on the distance between the charges; it‚Äôs $k q_1 q_2 / r$, where $k$ is Coulomb‚Äôs constant. Plugging in values $q_1 = $ 1 mC, $q_2 = 8 \\\\mu$ C, gives the answer as 5.992 J, which rounds to 6 J. The answer is (B).\",\n        ),\n        (\n            \"Which of the following conditions will ensure that angular momentum is conserved? I. Conservation of linear momentum II. Zero net external force III. Zero net external torque.\\nAnswer Choices: (A) I and II only (B) I and III only (C) II and III only (D) III only\",\n            \"Torque is defined as the change in angular momentum; if there is zero external torque, angular momentum is conserved. The answer is (D).\",\n        ),\n        (\n            \"A photocell of work function œï = 2eV is connected to a resistor in series. Light of frequency f = 1 √ó 10^15 Hz hits a metal plate of the photocell. If the power of the light is P = 100 W, what is the current through the resistor?\\nAnswer Choices: (A) 2:00 AM (B) 6:00 AM (C) 12:00 AM (D) 24 A\",\n            \"The only answer above which has units of current is D, 24 A. The answer is (D).\",\n        ),\n        (\n            \"A pipe full of air is closed at one end. A standing wave is produced in the pipe, causing the pipe to sound a note. Which of the following is a correct statement about the wave‚Äôs properties at the closed end of the pipe?\\nAnswer Choices: (A) The pressure is at a node, but the particle displacement is at an antinode. (B) The pressure is at an antinode, but the particle displacement is at a node. (C) The pressure and the particle displacement are both at nodes. (D) The pressure and the particle displacement are both at antinodes.\",\n            \"At the closed end of the pipe, the particles cannot have any net displacement because the pipe closure stops them. So the particle displacement is at a node. This closure also causes the pressure to be maximal, i.e. an antinode. The answer is (B).\",\n        ),\n    ]\n    examples[\"mmlu_chemistry\"] = [\n        (\n            \"Which of the following is considered an acid anhydride?\\nAnswer Choices: (A) HCl (B) H2SO3 (C) SO2 (D) Al(NO3)3\",\n            \"An acid anhydride is a compound that is derived by removing water from an acid. The chemical formula for water is H2O, which means that we need to determine which of these options, when combined with H2O, forms an acid. SO2, or Sulfur dioxide, when combined with H2O, makes H2SO4, or sulfuric acid. The answer is (C).\",\n        ),\n        (\n            \"Which of the following is expected to be a polar molecule?\\nAnswer Choices: (A) PCl4F (B) BF3 (C) CO2 (D) Si(CH3)4\",\n            \"A polar molecule is one that has a slightly positive charge on one end of the molecule and a slightly negative charge on the other end. Boron trifluoride (BF3) has Boron as the center atom and three fluorine atoms attached to it; it is trigonal planar and symmetric, so it is nonpolar. Carbon Dioxide (CO2) has Carbon as the central atom with double bonds to two Oxygen atoms - this is also symmetrical and therefore nonpolar. The same is the case for tetramethyl silane (SI(CH3)4), which is a Silicon atom surrounded by four methyl groups. The structure of PCL4F is that Phosphorus is the central atom, attached to four chlorines and one fluorine atom. This is asymmetrical, and therefore has a net dipole and is expected to be a polar molecule. The answer is (A).\",\n        ),\n        (\n            \"From the solubility rules, which of the following is true?\\nAnswer Choices: (A) All chlorides, bromides, and iodides are soluble (B) All sulfates are soluble (C) All hydroxides are soluble (D) All ammonium-containing compounds are soluble\",\n            \"The chlorides, bromides, and iodides of lead, silver, and mercury are not soluble in water. This rules out (A). The sulfates of lead, barium, and calcium are not soluble in water, which rules out (B). The hydroxides of any metal besides sodium, potassium, ammonium, calcium, and barium are insoluble. This rules out (C). Typically ammonium ions indicate a soluble ionic substance. The answer is (D).\",\n        ),\n        (\n            \"A new compound is synthesized and found to be a monoprotic acid with a molar mass of 248 g/mol. When 0.0050 mol of this acid are dissolved in 0.500 L of water, the pH is measured as 3.89. What is the pKa of this acid?\\nAnswer Choices: (A) 3.89 (B) 7.78 (C) 5.78 (D) 2.33\",\n            \"Recall that $[A] = [H^{+}]$. Here, this is equal to $$10^{-3.89}$. Then we have $K_{a} = $frac{[H^{+}][A^{-}]}{[HA]} = \\\\frac{10^{-3.89} \\\\cdot 10^{-3.89}}{10^{-2}}. The resulting exponent is $-3.89 + (-3.89) - (-2) = 5.78$, therefore $K_a = 10^{-5.78}$. The $pK_a$ is the negative log of $K_a$, which is equal to $5.78$. The answer is (C).\",\n        ),\n        (\n            \"A solution contains 2.00 mole of acetic acid, CH3COOH, and 1.00 mole of calcium acetate, Ca(CH3COO)2. The solution is able to resist the addition of a small amount of strong acid or strong base with only minor changes in the pH of the solution. Larger quantities of strong acid or strong base can cause a significant change in pH. How many moles of nitric acid, HNO3, may be added before the pH begins to change significantly?\\nAnswer Choices: (A) 0.500 mole (B) 1.00 mole (C) 2.00 mole (D) 3.00 mole\",\n            \"We would like to compute the buffer capacity of this solution. First we write the equation for the ionization of the weak acid, in this case of acetic acid. $CH_{3}COOH (aq) + H_{2}O \\rightarrow H_{3}O^{+} + CH3COO^{-}$. The conjugate base is therefore the acetate ion. The added strong acid, Nitric acid, will react with the conjugate base. Therefore the maximum amount of acid that can be added will be equal to the amount of acetate ion, or 2 moles. The answer is (C).\",\n        ),\n    ]\n    examples[\"mmlu_biology\"] = [\n        (\n            \"In animal cells, which of the following represents the most likely pathway that a secretory protein takes as it is synthesized in a cell?\\nAnswer Choices: (A) Plasma membrane‚ÄìGolgi apparatus‚Äìribosome‚Äìsecretory vesicle‚Äìrough ER (B) Ribosome‚ÄìGolgi apparatus‚Äìrough ER‚Äìsecretory vesicle‚Äìplasma membrane (C) Plasma membrane‚ÄìGolgi apparatus‚Äìribosome‚Äìsecretory vesicle‚Äìrough ER (D) Ribosome‚Äìrough ER‚ÄìGolgi apparatus‚Äìsecretory vesicle‚Äìplasma membrane\",\n            \"Protein synthesis starts at the ribosome, so we can eliminate (A) and (C). The ribosome is often in the endoplasmic reticulum and moves from there to the Golgi apparatus, where it is modified and packaged into a vesicle. The vesicle then floats to the plasma membrane and is secreted. The answer is (D).\",\n        ),\n        (\n            \"A mutation in a bacterial enzyme changed a previously polar amino acid into a nonpolar amino acid. This amino acid was located at a site distant from the enzyme‚Äôs active site. How might this mutation alter the enzyme‚Äôs substrate specificity?\\nAnswer Choices: (A) By changing the enzyme‚Äôs pH optimum (B) By changing the enzyme‚Äôs location in the cell (C) By changing the shape of the protein (D) An amino acid change away from the active site cannot alter the enzyme‚Äôs substrate specificity.\",\n            \"A change in an amino acid leads to a change in the primary structure of the protein. A change in the primary structure may lead to a change in the secondary and the tertiary structure of the protein. A change in the tertiary structure means a change in the shape of the protein, so (C) has to be correct. Since the change does not affect the active site of the enzyme, we do not expect the activity of the enzyme to be affected. The answer is (C).\",\n        ),\n        (\n            \"Which of the following is not a way to form recombinant DNA?\\nAnswer Choices: (A) Translation (B) Conjugation (C) Specialized transduction (D) Transformation\",\n            \"The introduction of foreign DNA or RNA into bacteria or eukaryotic cells is a common technique in molecular biology and scientific research. There are multiple ways foreign DNA can be introduced into cells including transformation, transduction, conjugation, and transfection. In contrast, (A) is not a way to form DNA: during translation the ribosomes synthesize proteins from RNA. The answer is (A).\",\n        ),\n        (\n            \"Homologous structures are often cited as evidence for the process of natural selection. All of the following are examples of homologous structures EXCEPT\\nAnswer Choices: (A) the wings of a bird and the wings of a bat (B) the flippers of a whale and the arms of a man (C) the pectoral fins of a porpoise and the flippers of a seal (D) the forelegs of an insect and the forelimbs of a dog\",\n            \"Homologous structures are similar physical features in organisms that share a common ancestor ‚Äã‚Äãbut different functions. Comparisons (B) and (C) are clearly homologous because they share a common ancestor and the structures serve different purposes. Bat wings and birg wings are also homologous, while they are both wings, the forelimbs serve different purposes. Insects and dogs are very far ancestors since one is vertebrate while the other is invertebrate and the forelimbs serve the same purpose, so they are not homologous. The answer is (D).\",\n        ),\n        (\n            \"Which of the following is not known to be involved in the control of cell division?\\nAnswer Choices: (A) Cyclins (B) Protein kinases (C) Checkpoints (D) Fibroblast cells\",\n            \"Normal cells move through the cell cycle in a regulated way. At the checkpoint stage, they use information about their own internal state and cues from the environment around them to decide whether to proceed with cell division. Cues like these act by changing the activity of core cell cycle regulators inside the cell. The most common regulators are cyclins and cyclin-dependent kinases. Fibroblast cells do not play any role in cell division. The answer is (D).\",\n        ),\n    ]\n    examples[\"mmlu_computer\"] = [\n        (\n            \"Which of the following is an example of the use of a device on the Internet of Things (IoT) ?\\nAnswer Choices: (A) A car alerts a driver that it is about to hit an object. (B) A hiker uses a G P S watch to keep track of her position. (C) A refrigerator orders milk from an online delivery service when the milk in the refrigerator is almost gone. (D) A runner uses a watch with optical sensors to monitor his heart rate.\",\n            \"The term Internet of Things (IoT) refers to common devices which are connected to the internet, enabling new functionality. Choice A is incorrect because it does not describe an internet connected device. In choice B, the watch is only described as having GPS functionality but no internet connectivity. Choice C describes a common device (a refrigerator) which has internet connectivity enabling new functionality (online ordering). Choice D does not mention internet connectivity for the watch, only optical sensors. The answer is (C).\",\n        ),\n        (\n            \"Many Web browsers allow users to open anonymous windows. During a browsing session in an anonymous window, the browser does not record a browsing history or a list of downloaded files. When the anonymous window is exited, cookies created during the session are deleted. Which of the following statements about browsing sessions in an anonymous window is true?\\nAnswer Choices: (A) The activities of a user browsing in an anonymous window will not be visible to people who monitor the user's network, such as the system administrator. (B) Items placed in a Web store's shopping cart for future purchase during the anonymous browsing session will not be saved on the user's computer. (C) A user will not be able to log in to e-mail or social media accounts during the anonymous browsing session. (D) A user browsing in an anonymous window will be protected from viruses launched from any web sites visited or files downloaded.\",\n            \"Choice A is incorrect as it only describes network traffic, which an anonymous browser does not change. Choice B is correct as it correctly describes how an anonymous browser will prevent saving data on the user‚Äôs computer after the session is ended. Choice C is incorrect because an anonymous browser will not prevent logging in to email or social media accounts. Choice D is incorrect because an anonymous browser in itself performs no virus protection. The answer is (B).\",\n        ),\n        (\n            'What is the output of \"abc\"[::-1] in Python 3? \\nAnswer Choices: (A) Error (B) abc (C) cba (D) c',\n            'We know that the slicing operator [::-1] takes all of the elements in the string in reverse order, so we reverse the order of the string \"abc\", resulting in \"cba\". The answer is (C).',\n        ),\n        (\n            'In the program below, the initial value of X is 5 and the initial value of Y is 10.\\nIF (X < 0){\\n DISPLAY (\"Foxtrot\")\\n} ELSE {\\n IF (X > Y){\\n  DISPLAY (\"Hotel\")\\n } ELSE {\\n  IF (Y > 0){\\n   DISPLAY (\"November\")\\n  } ELSE {\\n   DISPLAY (\"Yankee\")\\n  }\\n }\\n}\\nWhat is displayed as a result of running the program?\\nAnswer Choices: (A) Foxtrot (B) Hotel (C) November (D) Yankee',\n            'Because X has the value 5, the first conditional IF (X < 0) is false, so we move to the first ELSE clause. Because X is 5 and Y is 10, the second conditional IF (X > Y) is false, so we move to the following ELSE clause. Since Y is 10, the conditional IF (Y > 0) is true, so the command DISPLAY (\"November\") is executed. The answer is (C).',\n        ),\n        (\n            \"A list of numbers has n elements, indexed from 1 to n. The following algorithm is intended to display the number of elements in the list that have a value greater than 100. The algorithm uses the variables count and position. Steps 3 and 4 are missing.\\n Step 1: Set count to 0 and position to 1.\\n Step 2: If the value of the element at index position is greater than 100, increase the value of count by 1.\\n Step 3: (missing step)\\n Step 4: (missing step)\\n Step 5: Display the value of count.\\nWhich of the following could be used to replace steps 3 and 4 so that the algorithm works as intended?\\nAnswer Choices: (A) Step 3: Increase the value of position by 1.\\n  Step 4: Repeat steps 2 and 3 until the value of count is greater than 100.\\n(B) Step 3: Increase the value of position by 1.\\n  Step 4: Repeat steps 2 and 3 until the value of position is greater than n.\\n(C) Step 3: Repeat step 2 until the value of count is greater than 100.\\n  Step 4: Increase the value of position by 1.\\n(D) Step 3: Repeat step 2 until the value of position is greater than n.\\n  Step 4: Increase the value of count by 1.\",\n            \"Choice A is incorrect, because its Step 4 has an incorrect termination condition, stopping when count is greater than 100. We need to stop after inspecting all elements in the list. Choice B is correct because it correctly increments both count and position, and correctly repeats these steps and terminates when all elements in the list have been inspected. Choice C is incorrect because it incorrectly increments the variable count until its value is greater than 100, regardless of the elements in the list. Choice D is incorrect because its step 3 does not increment the value of position, so it will repeat forever. The answer is (B).\",\n        ),\n    ]\n    # mammoth\n    examples[\"mmlu_stem\"] = [\n        (\n            \"Simplify and write the result with a rational denominator: $$\\\\sqrt{\\\\sqrt[3]{\\\\sqrt{\\frac{1}{729}}}}$$\\nAnswer Choices: (A) \\\\frac{3\\\\sqrt{3}}{3} (B) \\\\frac{1}{3} (C) \\\\sqrt{3} (D) \\\\frac{\\\\sqrt{3}}{3}\",\n            \"Factoring $729=3^6$ and combining the roots $\\\\frac{1}{2}\\\\frac{1}{3}\\\\frac{1}{2}=\\\\frac{1}{12}$, we get that $\\\\sqrt{\\\\sqrt[3]{\\\\sqrt{\\frac{1}{729}}}}=\\\\left(\\frac{1}{3^6}\\right)^{\\frac{1}{12}}=\\frac{1}{3^{\\frac{1}{2}}}=\\frac{3}{\\\\sqrt{3}}$. The answer is (D).\",\n        ),\n        (\n            \"In animal cells, which of the following represents the most likely pathway that a secretory protein takes as it is synthesized in a cell?\\nAnswer Choices: (A) Plasma membrane‚ÄìGolgi apparatus‚Äìribosome‚Äìsecretory vesicle‚Äìrough ER (B) Ribosome‚ÄìGolgi apparatus‚Äìrough ER‚Äìsecretory vesicle‚Äìplasma membrane (C) Plasma membrane‚ÄìGolgi apparatus‚Äìribosome‚Äìsecretory vesicle‚Äìrough ER (D) Ribosome‚Äìrough ER‚ÄìGolgi apparatus‚Äìsecretory vesicle‚Äìplasma membrane\",\n            \"Protein synthesis starts at the ribosome, so we can eliminate (A) and (C). The ribosome is often in the endoplasmic reticulum and moves from there to the Golgi apparatus, where it is modified and packaged into a vesicle. The vesicle then floats to the plasma membrane and is secreted. The answer is (D).\",\n        ),\n        (\n            \"A microwave oven is connected to an outlet, 120 V, and draws a current of 2 amps. At what rate is energy being used by the microwave oven?\\nAnswer Choices: (A) 10 W (B) 30 W (C) 60 W (D) 240 W\",\n            \"Rate of energy usage is known as power; in an dissipative electrical circuit, power is given by voltage times current. So in our case, the power is 120 V times 2 amps, or 240 W. The answer is (D).\",\n        ),\n        (\n            \"Which of the following is considered an acid anhydride?\\nAnswer Choices: (A) HCl (B) H2SO3 (C) SO2 (D) Al(NO3)3\",\n            \"An acid anhydride is a compound that is derived by removing water from an acid. The chemical formula for water is H2O, which means that we need to determine which of these options, when combined with H2O, forms an acid. SO2, or Sulfur dioxide, when combined with H2O, makes H2SO4, or sulfuric acid. The answer is (C).\",\n        ),\n        (\n            'What is the output of \"abc\"[::-1] in Python 3? \\nAnswer Choices: (A) Error (B) abc (C) cba (D) c',\n            'We know that the slicing operator [::-1] takes all of the elements in the string in reverse order, so we reverse the order of the string \"abc\", resulting in \"cba\". The answer is (C).',\n        ),\n    ]\n    examples[\"gaokao\"] = [\n        (\n            \"Â∑≤Áü• $\\\\alpha, \\\\beta, \\\\gamma$ ÊòØ‰∫í‰∏çÁõ∏ÂêåÁöÑÈîêËßí, ÂàôÂú® $\\\\sin \\\\alpha \\\\cos \\\\beta, \\\\sin \\\\beta \\\\cos \\\\gamma, \\\\sin \\\\gamma \\\\cos \\\\alpha$ ‰∏â‰∏™ÂÄº‰∏≠, Â§ß‰∫é $\\\\frac{1}{2}$ ÁöÑ‰∏™Êï∞ÁöÑÊúÄÂ§ßÂÄºÊòØ ( )\\n‰ªé‰ª•‰∏ãÈÄâÈ°π‰∏≠ÈÄâÊã©:\\n(A) 0\\n(B) 1\\n(C) 2\\n(D) 3\",\n            \"1. Â¶ÇÊûú $\\\\alpha, \\\\beta, \\\\gamma$ ÂùáÂ∞è‰∫é $60^\\\\circ$ÔºåÈÇ£‰πà‰ªñ‰ª¨ÁöÑÊ≠£Âº¶ÂÄºÈÉΩÂ∞è‰∫é $\\\\frac{1}{2}$ÔºåÂõ†Ê≠§‰∏â‰∏™ÂÄº‰∏≠‰∏çÂèØËÉΩÊúâÂ§ß‰∫é $\\\\frac{1}{2}$ ÁöÑÂÄº„ÄÇ\\n2. Â¶ÇÊûúÊúâ‰∏Ä‰∏™ËßíÂ§ß‰∫é $60^\\\\circ$ÔºåÂÅáËÆæ‰∏∫ $\\\\alpha$ÔºåÈÇ£‰πàÂØπÂ∫îÁöÑÊ≠£Âº¶ÂÄºÂ§ß‰∫é $\\\\frac{1}{2}$„ÄÇÊ≠§Êó∂ÔºåÁî±‰∫é‰∏âËßíÂΩ¢ÂÜÖËßíÂíå‰∏∫ $180^\\\\circ$ÔºåÊâÄ‰ª• $\\\\beta + \\\\gamma < 120^\\\\circ$„ÄÇËøôÊÑèÂë≥ÁùÄ $\\\\beta, \\\\gamma$ ÁöÑ‰ΩôÂº¶ÂÄºÂùáÂ§ß‰∫é $\\\\frac{1}{2}$ÔºåÊâÄ‰ª•Ê≠§Êó∂ $\\\\sin \\\\alpha \\\\cos \\\\beta > \\\\frac{1}{2}, \\\\sin \\\\beta \\\\cos \\\\gamma > \\\\frac{1}{2}$„ÄÇ\\n3. Â¶ÇÊûúÊúâ‰∏§‰∏™ËßíÂ§ß‰∫é $60^\\\\circ$Ôºå‰æãÂ¶Ç $\\\\alpha$ Âíå $\\\\beta$ÔºåÈÇ£‰πàÁî±‰∫é‰∏âËßíÂΩ¢ÂÜÖËßíÂíå‰∏∫ $180^\\\\circ$ÔºåÊàë‰ª¨ÂèØ‰ª•ÂæóÂà∞ $\\\\gamma < 60^\\\\circ$ÔºåÊ≠§Êó∂ $\\\\sin \\\\gamma < \\\\frac{1}{2}$„ÄÇÁî±‰∫é $\\\\alpha$ Âíå $\\\\beta$ ÁöÑ‰ΩôÂº¶ÂÄºÈÉΩÂ∞è‰∫é $\\\\frac{1}{2}$ÔºåÂõ†Ê≠§‰∏â‰∏™ÂÄº‰∏≠‰∏çÂèØËÉΩÊúâÂ§ß‰∫é $\\\\frac{1}{2}$ ÁöÑÂÄº„ÄÇ\\n4. Â¶ÇÊûú‰∏â‰∏™ËßíÈÉΩÂ§ß‰∫é $60^\\\\circ$ÔºåÊòæÁÑ∂‰∏çÁ¨¶ÂêàÈ¢òÊÑè„ÄÇ\\nÁªº‰∏äÊâÄËø∞ÔºåÂΩìÊúâ‰∏Ä‰∏™ËßíÂ§ß‰∫é $60^\\\\circ$ Êó∂ÔºåÂ§ß‰∫é $\\\\frac{1}{2}$ ÁöÑ‰∏™Êï∞ÁöÑÊúÄÂ§ßÂÄºÊòØ 2„ÄÇ\\nÁ≠îÊ°àÊòØ C\",\n        ),\n        (\n            \"Ê≠£Êñπ‰Ωì $A B C D-A_{1} B_{1} C_{1} D_{1}$ ‰∏≠, $B B_{1}$ ‰∏éÂπ≥Èù¢ $A C D_{1}$ ÊâÄÊàêËßíÁöÑ‰ΩôÂº¶ÂÄº‰∏∫ ( )\\n‰ªé‰ª•‰∏ãÈÄâÈ°π‰∏≠ÈÄâÊã©:\\n(A) $\\\\frac{\\\\sqrt{2}}{3}$\\n(B) $\\\\frac{\\\\sqrt{3}}{3}$\\n(C) $\\\\frac{2}{3}$\\n(D) $\\\\frac{\\\\sqrt{6}}{3}$\",\n            \"ËÆæ‰∏ä‰∏ãÂ∫ïÈù¢ÁöÑ‰∏≠ÂøÉÂàÜÂà´‰∏∫ $\\\\mathrm{O}_{1}, \\\\mathrm{O}$, ËÆæÊ≠£Êñπ‰ΩìÁöÑÊ£±ÈïøÁ≠â‰∫é 1 , Âàô $O_{1} O$ ‰∏éÂπ≥Èù¢ $A C D_{1}$ ÊâÄÊàêËßíÂ∞±ÊòØ $B B_{1}$ ‰∏éÂπ≥Èù¢ $A C D_{1}$ ÊâÄÊàêËßí, Âç≥ $\\\\angle O_{1} O D_{1}$, Áõ¥Ëßí‰∏âËßíÂΩ¢ $\\\\mathrm{OO}_{1} \\\\mathrm{D}_{1}$ ‰∏≠, $\\\\cos \\\\angle \\\\mathrm{O}_{1} \\\\mathrm{OD}_{1}=\\\\frac{\\\\mathrm{O}_{1} \\\\mathrm{O}}{\\\\mathrm{OD}_{1}}=\\\\frac{\\\\frac{1}{\\\\sqrt{6}}}{2}=\\\\frac{\\\\sqrt{6}}{3}$. \\nÁ≠îÊ°àÊòØ C\",\n        ),\n        (\n            \"ËÆæÂáΩÊï∞ $f(x)=\\\\left\\\\{\\\\begin{array}{ll}1+\\\\log _{2}(2-x), & x<1 \\\\ 2^{x-1}, & x \\\\geqslant 1,\\\\end{array}\\\\right.$ Âàô $f(-2)+f\\\\left(\\\\log _{2} 12\\\\right)=$ ( )\\n‰ªé‰ª•‰∏ãÈÄâÈ°π‰∏≠ÈÄâÊã©:\\n(A) 3\\n(B) 6\\n(C) 9\\n(D) 12\",\n            \"È¶ñÂÖàÔºåÊàë‰ª¨ÂèØ‰ª•Ê†πÊçÆÂÆö‰πâËÆ°ÁÆó $f(-2)$ Âíå $f(\\\\log_2 12)$Ôºö\\n$f(-2)=1+\\\\log_2(2-(-2))=1+\\\\log_2 4=3$\\n$f(\\\\log_2 12)=2^{\\\\log_2 12-1}=6$\\nÂõ†Ê≠§Ôºå$f(-2)+f(\\\\log_2 12)=3+6=9$„ÄÇ\\nÁ≠îÊ°àÊòØ C\",\n        ),\n        (\n            \"Â∑≤Áü•ÂáΩÊï∞ $f(x)=a x^{3}-3 x^{2}+1$, Ëã• $f(x)$ Â≠òÂú®ÂîØ‰∏ÄÁöÑÈõ∂ÁÇπ $x_{0}$, ‰∏î $x_{0}>$ 0 , ÂàôÂÆûÊï∞ $\\\\mathrm{a}$ ÁöÑÂèñÂÄºËåÉÂõ¥ÊòØ ( )\\n‰ªé‰ª•‰∏ãÈÄâÈ°π‰∏≠ÈÄâÊã©:\\n(A) $(1,+\\\\infty)$\\n(B) $(2,+\\\\infty)$\\n(C) $(-\\\\infty,-1)$\\n(D) $(-\\\\infty,-2)$\",\n            \"È¶ñÂÖàÔºåÊàë‰ª¨ÂèØ‰ª•ÈÄöËøáÊ±ÇÂá∫ÂáΩÊï∞ÁöÑÂØºÂáΩÊï∞ $f'(x)$ Êù•Âà§Êñ≠ÂáΩÊï∞Âú® $x>0$ Âå∫Èó¥ÂÜÖÁöÑÂçïË∞ÉÊÄß„ÄÇÂú®ËøôÈáåÔºåÊàë‰ª¨Ê±ÇÂá∫ÂØºÂáΩÊï∞ $f'(x)$ ‰∏∫ $f'(x)=3ax^2-6x$„ÄÇ\\nÁÑ∂ÂêéÔºåÊàë‰ª¨ÈúÄË¶ÅÊ±ÇÂá∫ÂØºÂáΩÊï∞ $f'(x)$ ÁöÑÈõ∂ÁÇπÔºå‰ª•Á°ÆÂÆöÂáΩÊï∞ $f(x)$ Âú® $x>0$ Âå∫Èó¥ÂÜÖÁöÑÂçïË∞ÉÊÄß„ÄÇÂØºÂáΩÊï∞ $f'(x)$ ÁöÑÈõ∂ÁÇπ‰∏∫ $x=0$ Âíå $x=\\\\frac{2}{\\\\sqrt{a}}$„ÄÇÊ≥®ÊÑèÂà∞ $x>0$ÔºåÊâÄ‰ª•Êàë‰ª¨ÂæóÂà∞ $a<0$„ÄÇÊ≠§Â§ñÔºåÁî±‰∫éÂáΩÊï∞ $f(x)$ Âú® $x=0$ Â§ÑÁöÑÂáΩÊï∞ÂÄº‰∏∫ $1$ÔºåÂõ†Ê≠§‰∏çËÉΩÊúâ $a=\\\\frac{4}{3}$„ÄÇ\\nÁªº‰∏äÊâÄËø∞ÔºåÂΩì $a$ ÁöÑÂèñÂÄºËåÉÂõ¥‰∏∫ $a<-\\\\frac{4}{3}$ Êó∂ÔºåÂáΩÊï∞ $f(x)$ Âú® $x>0$ Âå∫Èó¥ÂÜÖÊòØÂçïË∞ÉÈÄíÂáèÁöÑÔºåÊ≠§Êó∂Â≠òÂú®ÂîØ‰∏ÄÁöÑÈõ∂ÁÇπ $x_0$„ÄÇÂõ†Ê≠§ÔºåÁ≠îÊ°à‰∏∫ $(-\\\\infty,-2)$„ÄÇ\\nÁ≠îÊ°àÊòØ D\",\n        ),\n        (\n            \"ËÆæ $\\\\left\\\\{a_{n}\\\\right\\\\}$ ÊòØÂÖ¨Â∑Æ‰∏ç‰∏∫ 0 ÁöÑÊó†Á©∑Á≠âÂ∑ÆÊï∞Âàó, Âàô‚Äú $\\\\left\\\\{a_{n}\\\\right\\\\}$ ‰∏∫ÈÄíÂ¢ûÊï∞Âàó‚ÄùÊòØ‚ÄúÂ≠òÂú®Ê≠£Êï¥Êï∞ $N_{0}$, ÂΩì $n>N_{0}$ Êó∂, $a_{n}>0$ ‚ÄùÁöÑ ( )\\n‰ªé‰ª•‰∏ãÈÄâÈ°π‰∏≠ÈÄâÊã©:\\n(A) ÂÖÖÂàÜËÄå‰∏çÂøÖË¶ÅÊù°‰ª∂\\n(B) ÂøÖË¶ÅËÄå‰∏çÂÖÖÂàÜÊù°‰ª∂\\n(C) ÂÖÖÂàÜÂøÖË¶ÅÊù°‰ª∂\\n(D) Êó¢‰∏çÂÖÖÂàÜ‰πü‰∏çÂøÖË¶ÅÊù°‰ª∂\",\n            \"È¶ñÂÖàÔºåÊàë‰ª¨ÂèØ‰ª•ÈÄöËøá‰∏æ‰æãÊù•Âà§Êñ≠ËØ•Êù°‰ª∂ÊòØÂÖÖÂàÜËøòÊòØÂøÖË¶ÅÊù°‰ª∂„ÄÇÂ¶ÇÊûú‰∏Ä‰∏™Êï∞ÂàóÈÄíÂ¢ûÔºåÈÇ£‰πàÂÆÉÁöÑÂÖ¨Â∑Æ‰∏ÄÂÆöÂ§ß‰∫é 0Ôºå‰πüÂ∞±ÊòØÂ≠òÂú®Ê≠£Êï¥Êï∞ $N_{0}$ÔºåÂΩì $n>N_{0}$ Êó∂Ôºå$a_{n}>0$„ÄÇÂõ†Ê≠§Ôºå‚Äú $\\\\left\\\\{a_{n}\\\\right\\\\}$ ‰∏∫ÈÄíÂ¢ûÊï∞Âàó‚ÄùÊòØ‚ÄúÂ≠òÂú®Ê≠£Êï¥Êï∞ $N_{0}$, ÂΩì $n>N_{0}$ Êó∂, $a_{n}>0$ ‚ÄùÁöÑÂøÖË¶ÅÊù°‰ª∂„ÄÇ\\nÊé•‰∏ãÊù•ÔºåÊàë‰ª¨ÈúÄË¶ÅÂà§Êñ≠ÊòØÂê¶ÂÖÖÂàÜ„ÄÇ‰πüÂ∞±ÊòØËØ¥ÔºåÂ¶ÇÊûúÂ≠òÂú®Ê≠£Êï¥Êï∞ $N_{0}$ÔºåÂΩì $n>N_{0}$ Êó∂Ôºå$a_{n}>0$ÔºåÈÇ£‰πàËÉΩÂê¶ÂæóÂá∫‚Äú $\\\\left\\\\{a_{n}\\\\right\\\\}$ ‰∏∫ÈÄíÂ¢ûÊï∞Âàó‚ÄùËøô‰∏ÄÁªìËÆ∫„ÄÇÁ≠îÊ°àÊòØËÇØÂÆöÁöÑ„ÄÇÂõ†‰∏∫Â¶ÇÊûú $a_{n}>0$ÔºåÈÇ£‰πà $a_{n+1}-a_{n}>0$ÔºåÂç≥ÂÖ¨Â∑ÆÂ§ß‰∫é 0ÔºåÂõ†Ê≠§ËØ•Êï∞ÂàóÊòØÈÄíÂ¢ûÁöÑ„ÄÇÂõ†Ê≠§ÔºåËØ•Êù°‰ª∂ÊòØÂÖÖÂàÜÊù°‰ª∂„ÄÇ\\nÁªº‰∏äÊâÄËø∞ÔºåÈÄâÈ°π‰∏∫ (C) ÂÖÖÂàÜÂøÖË¶ÅÊù°‰ª∂„ÄÇ\\nÁ≠îÊ°àÊòØ C\",\n        ),\n    ]\n\n    return examples\n",
        "eval/eval/math_opensource_utils/grader.py": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\"\nThis logic is largely copied from the Hendrycks' MATH release (math_equivalence), and borrowed from:\n- https://github.com/microsoft/ProphetNet/tree/master/CRITIC\n- https://github.com/openai/prm800k\n- https://github.com/microsoft/ToRA/blob/main/src/eval/grader.py\n- https://github.com/deepseek-ai/DeepSeek-Math/blob/main/evaluation/eval/eval_utils.py\n\"\"\"\n\nimport multiprocessing\nimport re\nfrom math import isclose\nfrom typing import Union\n\nimport regex\nfrom latex2sympy2 import latex2sympy\n# from uniform_eval.bundled.latex2sympy2.latex2sympy2 import latex2sympy\n\n\ndef choice_answer_clean(pred: str):\n    pred = pred.strip(\"\\n\").rstrip(\".\").rstrip(\"/\").strip(\" \").lstrip(\":\")\n    # Clean the answer based on the dataset\n    tmp = re.findall(r\"\\b([A-E])\\b\", pred.upper())\n    if tmp:\n        pred = tmp\n    else:\n        pred = [pred.strip().strip(\".\")]\n    pred = pred[-1]\n    # Remove the period at the end, again!\n    pred = pred.rstrip(\".\").rstrip(\"/\")\n    return pred\n\n\ndef parse_digits(num):\n    num = regex.sub(\",\", \"\", str(num))\n    try:\n        return float(num)\n    except:\n        if num.endswith(\"%\"):\n            num = num[:-1]\n            if num.endswith(\"\\\\\"):\n                num = num[:-1]\n            try:\n                return float(num) / 100\n            except:\n                pass\n    return None\n\n\ndef is_digit(num):\n    # paired with parse_digits\n    return parse_digits(num) is not None\n\n\ndef str_to_pmatrix(input_str):\n    input_str = input_str.strip()\n    matrix_str = re.findall(r\"\\{.*,.*}\", input_str)\n    pmatrix_list = []\n\n    for m in matrix_str:\n        m = m.strip(\"{}\")\n        pmatrix = r\"\\begin{pmatrix}\" + m.replace(\",\", \"\\\\\") + r\"\\end{pmatrix}\"\n        pmatrix_list.append(pmatrix)\n\n    return \", \".join(pmatrix_list)\n\n\ndef math_equal(\n    prediction: Union[bool, float, str],\n    reference: Union[float, str],\n    include_percentage: bool = True,\n    is_close: bool = True,\n    timeout: bool = False,\n) -> bool:\n    \"\"\"\n    Exact match of math if and only if:\n    1. numerical equal: both can convert to float and are equal\n    2. symbolic equal: both can convert to sympy expression and are equal\n    \"\"\"\n    # print(\"Judge:\", prediction, reference)\n    if prediction is None or reference is None:\n        return False\n    if str(prediction.strip().lower()) == str(reference.strip().lower()):\n        return True\n    if (\n        reference in [\"A\", \"B\", \"C\", \"D\", \"E\"]\n        and choice_answer_clean(prediction) == reference\n    ):\n        return True\n\n    try:  # 1. numerical equal\n        if is_digit(prediction) and is_digit(reference):\n            prediction = parse_digits(prediction)\n            reference = parse_digits(reference)\n            # number questions\n            if include_percentage:\n                gt_result = [reference / 100, reference, reference * 100]\n            else:\n                gt_result = [reference]\n            for item in gt_result:\n                try:\n                    if is_close:\n                        if numeric_equal(prediction, item):\n                            return True\n                    else:\n                        if item == prediction:\n                            return True\n                except Exception:\n                    continue\n            return False\n    except:\n        pass\n\n    if not prediction and prediction not in [0, False]:\n        return False\n\n    # 2. symbolic equal\n    reference = str(reference).strip()\n    prediction = str(prediction).strip()\n\n    ## pmatrix (amps)\n    if \"pmatrix\" in prediction and not \"pmatrix\" in reference:\n        reference = str_to_pmatrix(reference)\n\n    ## deal with [], (), {}\n    pred_str, ref_str = prediction, reference\n    if (\n        prediction.startswith(\"[\")\n        and prediction.endswith(\"]\")\n        and not reference.startswith(\"(\")\n    ) or (\n        prediction.startswith(\"(\")\n        and prediction.endswith(\")\")\n        and not reference.startswith(\"[\")\n    ):\n        pred_str = pred_str.strip(\"[]()\")\n        ref_str = ref_str.strip(\"[]()\")\n    for s in [\"{\", \"}\", \"(\", \")\"]:\n        ref_str = ref_str.replace(s, \"\")\n        pred_str = pred_str.replace(s, \"\")\n    if pred_str.lower() == ref_str.lower():\n        return True\n\n    ## [a, b] vs. [c, d], return a==c and b==d\n    if (\n        regex.match(r\"(\\(|\\[).+(\\)|\\])\", prediction) is not None\n        and regex.match(r\"(\\(|\\[).+(\\)|\\])\", reference) is not None\n    ):\n        pred_parts = prediction[1:-1].split(\",\")\n        ref_parts = reference[1:-1].split(\",\")\n        if len(pred_parts) == len(ref_parts):\n            if all(\n                [\n                    math_equal(\n                        pred_parts[i], ref_parts[i], include_percentage, is_close\n                    )\n                    for i in range(len(pred_parts))\n                ]\n            ):\n                return True\n    if (\n        (\n            prediction.startswith(\"\\\\begin{pmatrix}\")\n            or prediction.startswith(\"\\\\begin{bmatrix}\")\n        )\n        and (\n            prediction.endswith(\"\\\\end{pmatrix}\")\n            or prediction.endswith(\"\\\\end{bmatrix}\")\n        )\n        and (\n            reference.startswith(\"\\\\begin{pmatrix}\")\n            or reference.startswith(\"\\\\begin{bmatrix}\")\n        )\n        and (\n            reference.endswith(\"\\\\end{pmatrix}\") or reference.endswith(\"\\\\end{bmatrix}\")\n        )\n    ):\n        pred_lines = [\n            line.strip()\n            for line in prediction[\n                len(\"\\\\begin{pmatrix}\") : -len(\"\\\\end{pmatrix}\")\n            ].split(\"\\\\\\\\\")\n            if line.strip()\n        ]\n        ref_lines = [\n            line.strip()\n            for line in reference[\n                len(\"\\\\begin{pmatrix}\") : -len(\"\\\\end{pmatrix}\")\n            ].split(\"\\\\\\\\\")\n            if line.strip()\n        ]\n        matched = True\n        if len(pred_lines) == len(ref_lines):\n            for pred_line, ref_line in zip(pred_lines, ref_lines):\n                pred_parts = pred_line.split(\"&\")\n                ref_parts = ref_line.split(\"&\")\n                if len(pred_parts) == len(ref_parts):\n                    if not all(\n                        [\n                            math_equal(\n                                pred_parts[i],\n                                ref_parts[i],\n                                include_percentage,\n                                is_close,\n                            )\n                            for i in range(len(pred_parts))\n                        ]\n                    ):\n                        matched = False\n                        break\n                else:\n                    matched = False\n                if not matched:\n                    break\n        else:\n            matched = False\n        if matched:\n            return True\n\n    if prediction.count(\"=\") == 1 and reference.count(\"=\") == 1:\n        pred = prediction.split(\"=\")\n        pred = f\"{pred[0].strip()} - ({pred[1].strip()})\"\n        ref = reference.split(\"=\")\n        ref = f\"{ref[0].strip()} - ({ref[1].strip()})\"\n        if symbolic_equal(pred, ref) or symbolic_equal(f\"-({pred})\", ref):\n            return True\n    elif (\n        prediction.count(\"=\") == 1\n        and len(prediction.split(\"=\")[0].strip()) <= 2\n        and \"=\" not in reference\n    ):\n        if math_equal(\n            prediction.split(\"=\")[1], reference, include_percentage, is_close\n        ):\n            return True\n    elif (\n        reference.count(\"=\") == 1\n        and len(reference.split(\"=\")[0].strip()) <= 2\n        and \"=\" not in prediction\n    ):\n        if math_equal(\n            prediction, reference.split(\"=\")[1], include_percentage, is_close\n        ):\n            return True\n\n    # symbolic equal with sympy\n    if timeout:\n        if call_with_timeout(symbolic_equal_process, prediction, reference):\n            return True\n    else:\n        if symbolic_equal(prediction, reference):\n            return True\n\n    return False\n\n\ndef math_equal_process(param):\n    return math_equal(param[-2], param[-1])\n\n\ndef numeric_equal(prediction: float, reference: float):\n    # Note that relative tolerance has significant impact\n    # on the result of the synthesized GSM-Hard dataset\n    # if reference.is_integer():\n    #     return isclose(reference, round(prediction), abs_tol=1e-4)\n    # else:\n    # prediction = round(prediction, len(str(reference).split(\".\")[-1]))\n    return isclose(reference, prediction, rel_tol=1e-4)\n\n\ndef symbolic_equal(a, b):\n    from sympy import simplify, N\n    from sympy.parsing.latex import parse_latex\n    from sympy.parsing.sympy_parser import parse_expr\n\n    def _parse(s):\n        for f in [parse_latex, parse_expr, latex2sympy]:\n            try:\n                return f(s.replace(\"\\\\\\\\\", \"\\\\\"))\n            except:\n                try:\n                    return f(s)\n                except:\n                    pass\n        return s\n\n    a = _parse(a)\n    b = _parse(b)\n\n    # direct equal\n    try:\n        if str(a) == str(b) or a == b:\n            return True\n    except:\n        pass\n\n    # simplify equal\n    try:\n        if a.equals(b) or simplify(a - b) == 0:\n            return True\n    except:\n        pass\n\n    # equation equal\n    try:\n        if (abs(a.lhs - a.rhs)).equals(abs(b.lhs - b.rhs)):\n            return True\n    except:\n        pass\n\n    try:\n        if numeric_equal(float(N(a)), float(N(b))):\n            return True\n    except:\n        pass\n\n    # matrix\n    try:\n        # if a and b are matrix\n        if a.shape == b.shape:\n            _a = a.applyfunc(lambda x: round(x, 3))\n            _b = b.applyfunc(lambda x: round(x, 3))\n            if _a.equals(_b):\n                return True\n    except:\n        pass\n\n    return False\n\n\ndef symbolic_equal_process(a, b, output_queue):\n    result = symbolic_equal(a, b)\n    output_queue.put(result)\n\n\ndef call_with_timeout(func, *args, timeout=1, **kwargs):\n    output_queue = multiprocessing.Queue()\n    process_args = args + (output_queue,)\n    process = multiprocessing.Process(target=func, args=process_args, kwargs=kwargs)\n    process.start()\n    process.join(timeout)\n\n    if process.is_alive():\n        process.terminate()\n        process.join()\n        return False\n\n    return output_queue.get()\n\ndef _test_math_equal():\n    # print(math_equal(\"0.0833333333333333\", \"\\\\frac{1}{12}\"))\n    # print(math_equal(\"(1,4.5)\", \"(1,\\\\frac{9}{2})\"))\n    # print(math_equal(\"\\\\frac{x}{7}+\\\\frac{2}{7}\", \"\\\\frac{x+2}{7}\", timeout=True))\n    # print(math_equal(\"\\\\sec^2(y)\", \"\\\\tan^2(y)+1\", timeout=True))\n    # print(math_equal(\"\\\\begin{pmatrix}-\\\\frac{7}{4}&-2\\\\\\\\4&\\\\frac{1}{4}\\\\end{pmatrix}\", \"(\\\\begin{pmatrix}-\\\\frac{7}{4}&-2\\\\\\\\4&\\\\frac{1}{4}\\\\\\\\\\\\end{pmatrix})\", timeout=True))\n\n    # pred = '\\\\begin{pmatrix}\\\\frac{1}{3x^{2/3}}&0&0\\\\\\\\0&1&0\\\\\\\\-\\\\sin(x)&0&0\\\\end{pmatrix}'\n    # gt = '(\\\\begin{pmatrix}\\\\frac{1}{3\\\\sqrt[3]{x}^2}&0&0\\\\\\\\0&1&0\\\\\\\\-\\\\sin(x)&0&0\\\\\\\\\\\\end{pmatrix})'\n\n    # pred= '-\\\\frac{8x^2}{9(x^2-2)^{5/3}}+\\\\frac{2}{3(x^2-2)^{2/3}}'\n    # gt= '-\\\\frac{2(x^2+6)}{9(x^2-2)\\\\sqrt[3]{x^2-2}^2}'\n\n    # pred =  '-34x-45y+20z-100=0'\n    # gt = '34x+45y-20z+100=0'\n\n    # pred = '\\\\frac{100}{3}'\n    # gt = '33.3'\n\n    # pred = '\\\\begin{pmatrix}0.290243531202435\\\\\\\\0.196008371385084\\\\\\\\-0.186381278538813\\\\end{pmatrix}'\n    # gt = '(\\\\begin{pmatrix}0.29\\\\\\\\0.196\\\\\\\\-0.186\\\\\\\\\\\\end{pmatrix})'\n\n    # pred = '\\\\frac{\\\\sqrt{\\\\sqrt{11}+\\\\sqrt{194}}}{2\\\\sqrt{33}+15}'\n    # gt = '\\\\frac{\\\\sqrt{\\\\sqrt{11}+\\\\sqrt{194}}}{15+2\\\\sqrt{33}}'\n\n    # pred = '(+5)(b+2)'\n    # gt = '(a+5)(b+2)'\n\n    # pred = '\\\\frac{1+\\\\sqrt{5}}{2}'\n    # gt = '2'\n\n    # pred = '\\\\frac{34}{16}+\\\\frac{\\\\sqrt{1358}}{16}', gt = '4'\n    # pred = '1', gt = '1\\\\\\\\sqrt{19}'\n\n    # pred = \"(0.6,2.6667]\"\n    # gt = \"(\\\\frac{3}{5},\\\\frac{8}{3}]\"\n\n    gt = \"x+2n+1\"\n    pred = \"x+1\"\n\n    print(math_equal(pred, gt, timeout=True))\n\n\nif __name__ == \"__main__\":\n    _test_math_equal()\n",
        "eval/eval/math_opensource_utils/math_utils.py": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport re\nfrom collections import Counter\n\nimport sympy as sp\nimport timeout_decorator\nfrom sympy.parsing.latex import parse_latex\n\n\ndef compare_numerical_ans(ans_p, ans_l):\n    if ans_p is None:\n        return False\n    ans_p = ans_p.replace(\",\", \"\").replace(\"$\", \"\")\n    ans_l = ans_l.replace(\",\", \"\").replace(\"$\", \"\")\n    try:\n        if ans_p.endswith(\"%\"):\n            ans_p = float(ans_p.rstrip(\"%\")) / 100\n        if isinstance(ans_p, str):\n            ans_p = float(ans_p)\n        if isinstance(ans_l, str):\n            ans_l = float(ans_l)\n    except Exception as e:\n        return False\n    return abs(ans_p - float(ans_l)) < 1e-3\n\n\ndef my_parse_latex(expr_str):\n    expr_str = expr_str.replace(\"dfrac\", \"frac\")\n    expr = parse_latex(expr_str)\n    if \"\\\\pi\" in expr_str:\n        expr = expr.subs({sp.Symbol(\"pi\"): sp.pi})\n    expr = expr.subs({sp.Symbol(\"i\"): sp.I})\n    return expr\n\n\ndef is_number(element: str) -> bool:\n    try:\n        float(element.replace(\" \", \"\"))\n        return True\n    except ValueError:\n        return False\n\n\ndef percentage_to_fraction(text):\n    pattern = r\"(\\d+(\\.\\d+)?%)\"\n    matches = re.findall(pattern, text)\n    for match in matches:\n        percentage_str = match[0]\n        percentage = float(percentage_str.strip(\"%\")) / 100\n        fraction = str(percentage)\n        text = text.replace(percentage_str, fraction)\n    return text\n\n\ndef clean_expr_str(expr_str):\n    expr_str = (\n        expr_str.replace(\" . \", \".\")\n        .replace(\". \", \".\")\n        .replace(\"**\", \"^\")\n        .replace(\"\\\\pm\", \"\")\n        .replace(\"*\", \"\\\\times \")\n        .replace(\"\\\\\\\\\", \"\\\\\")\n        .replace(\"\\\\ne \", \"\\\\neq \")\n        .replace(\"!=\", \"\\\\neq\")\n        .replace(\">=\", \"\\\\ge\")\n        .replace(\"<=\", \"\\\\le\")\n        .replace(\"‚â†\", \"\\\\neq\")\n        .replace(\"dfrac\", \"frac\")\n        .replace(\"tfrac\", \"frac\")\n        .replace(\"\\\\$\", \"\")\n        .replace(\"$\", \"\")\n        .replace(\"\\\\%\", \"\")\n        .replace(\"%\", \"\")\n        .replace(\"\\\\!\", \"\")\n        .replace(\"^\\circ\", \"\\\\times \\\\pi / 180\")\n        .replace(\"//\", \"/\")\n        .replace('\"', \"\")\n        # .replace(\",\", \"\") # TODO\n    )\n    # expr_str = re.sub(r\"\\^\\s(.*)\", r\"\\^\\s{\\1}\", expr_str)\n    expr_str = re.sub(r\"\\\\+\", r\"\\\\\", expr_str)\n    expr_str = re.sub(r\"\\^\\s?\\((.*?)\\)\", r\"^{\\1}\", expr_str)\n    expr_str = re.sub(r\"\\\\frac\\s?(\\d)\\s?(\\d+)\", r\"\\\\frac{\\1}{\\2}\", expr_str)\n    expr_str = re.sub(r\"\\\\log_\\s?(\\d)\\s?(\\d+)\", r\"\\\\log_{\\1}{\\2}\", expr_str)\n    expr_str = re.sub(r\"\\\\frac\\s?{(.*?)}\\s?(\\d)\", r\"\\\\frac{\\1}{\\2}\", expr_str)\n    expr_str = re.sub(r\"\\\\frac\\s?(\\d)\\s?{(.*?)}\", r\"\\\\frac{\\1}{\\2}\", expr_str)\n    expr_str = re.sub(r\"\\\\sqrt\\s?(\\d)\", r\"\\\\sqrt{\\1}\", expr_str)\n    expr_str = re.sub(r\"sqrt\\s?\\((\\d+)\\)\", r\"\\\\sqrt{\\1}\", expr_str)\n    expr_str = re.sub(r\"sqrt\\s?\\((.*?)\\)\", r\"\\\\sqrt{\\1}\", expr_str)\n    expr_str = expr_str.replace(\" sqrt\", \"\\\\sqrt\")\n    expr_str = (\n        expr_str.replace(\"\\\\left\", \"\").replace(\"\\\\right.\", \"\").replace(\"\\\\right\", \"\")\n    )\n    return expr_str\n\n\ndef parse_latex_answer(sample):\n    if isinstance(sample, int) or isinstance(sample, float):\n        sample = str(sample)\n    #     return sample\n    sample = clean_expr_str(sample)\n    try:\n        expr = my_parse_latex(sample)\n    except:\n        print(\"[parse failed]\", sample)\n        return None\n    return expr\n\n\ndef my_equals(ans_p, ans_l):\n    return ans_p.equals(ans_l)\n\n\ndef is_expr_equal(ans_p, ans_l, is_strict=False):\n    def is_equ_num_equal(equation, number):\n        if (\n            isinstance(equation, sp.Eq)\n            # and isinstance(equation.lhs, sp.Symbol)\n            and equation.rhs.is_number\n            and number.is_number\n        ):\n            try:\n                ret = my_equals(equation.rhs, number)\n                return bool(ret)\n            except:\n                return equation.rhs == number\n\n    if ans_p is None or ans_l is None:\n        return False\n    if isinstance(ans_l, str):\n        return ans_p == ans_l\n\n    if (\n        not is_strict\n        and is_equ_num_equal(ans_l, ans_p)\n        or is_equ_num_equal(ans_p, ans_l)\n    ):\n        return True\n\n    if ans_p.free_symbols != ans_l.free_symbols:\n        return False\n\n    if ans_p == ans_l:\n        return True\n\n    if isinstance(ans_l, sp.core.relational.Relational):\n        try:\n            if (\n                type(ans_l) == type(ans_p)\n                and my_equals(ans_p.lhs, ans_l.lhs)\n                and my_equals(ans_p.rhs, ans_l.rhs)\n            ):\n                return True\n        except Exception as e:\n            print(ans_p, ans_l, e)\n    try:\n        ret = my_equals(ans_p, ans_l)\n        return bool(ret)\n    except:\n        return False\n\n\n# @timeout_decorator.timeout(5)\n# def compare_ans(ans_p_str, ans_l_str, is_strict=False):\n#     ans_p_str = clean_expr_str(ans_p_str)\n#     ans_p_str = ans_p_str.replace(\",\", \"\").replace(\"$\", \"\")\n#     ans_l_str = clean_expr_str(ans_l_str)\n#     ans_l_str = ans_l_str.replace(\",\", \"\").replace(\"$\", \"\")\n#     if ans_p_str is None:\n#         return False\n#     if ans_p_str.replace(\" \", \"\") == ans_l_str.replace(\" \", \"\"):\n#         return True\n#     ans_p = parse_latex_answer(ans_p_str)\n#     if ans_p is None:\n#         return False\n#     ans_l = parse_latex_answer(ans_l_str)\n#     if ans_l is None:\n#         return False\n#     return is_expr_equal(ans_p, ans_l, is_strict=is_strict)\n\n\ndef extract_answer_number(sentence: str) -> float:\n    sentence = sentence.replace(\",\", \"\")\n    pred = [s for s in re.findall(r\"-?\\d+\\.?\\d*\", sentence)]\n    if not pred:\n        return \"\"\n    return pred[-1]\n\n\n@timeout_decorator.timeout(5)\ndef compare_ans(ans_p_str, ans_l_str, is_strict=False):\n    ans_p_str = clean_expr_str(ans_p_str)\n    ans_p_str = ans_p_str.replace(\",\", \"\").replace(\"$\", \"\")\n    ans_l_str = clean_expr_str(ans_l_str)\n    ans_l_str = ans_l_str.replace(\",\", \"\").replace(\"$\", \"\")\n    if ans_p_str is None:\n        return False\n    if ans_p_str.replace(\" \", \"\") == ans_l_str.replace(\" \", \"\"):\n        return True\n    ans_p = parse_latex_answer(ans_p_str)\n    if ans_p is None:\n        return False\n    ans_l = parse_latex_answer(ans_l_str)\n    if ans_l is None:\n        return False\n    if is_expr_equal(ans_p, ans_l, is_strict=is_strict):\n        return True\n    # TODO not suitable\n    ans_p_str = extract_answer_number(ans_p_str)\n    if is_number(ans_p_str):\n        ans_p = parse_latex_answer(ans_p_str)\n        if is_expr_equal(ans_p, ans_l, is_strict=is_strict):\n            return True\n    return False\n\n\ndef vote(answers):\n    counter = Counter(answers)\n    return counter.most_common(1)[0][0]\n\n\ndef contains_number(s):\n    return any(i.isdigit() for i in s)\n\n\ndef rough_compare_ans(generation, answer):\n    for line in generation.split(\"\\n\")[::-1]:\n        if contains_number(line):\n            break\n    words = line.split()\n    for i, w in enumerate(words):\n        if i > 0 and words[i - 1] in [\"+\", \"-\", \"*\", \"/\", \"^\"]:\n            continue\n        if i < len(words) - 1 and words[i + 1] in [\"+\", \"-\", \"*\", \"/\", \"^\"]:\n            continue\n        if not contains_number(w):\n            continue\n        if compare_numerical_ans(w.replace(\"$\", \"\"), answer) and \"=\" not in \" \".join(\n            w[i:]\n        ):\n            return 1\n    return 0\n\n\nif __name__ == \"__main__\":\n    pred = \"To find the minimum value of $f(x)$, we need to find the critical points where the derivative of $f(x)$ is either zero or undefined. Let's write a function to solve this problem:\\n\\n```python\\nfrom sympy import symbols, diff, solve\\n\\ndef find_minimum_value():\\n    x, p = symbols('x p')\\n    f = abs(x - p) + abs(x - 15) + abs(x - p - 15)\\n    f_prime = diff(f, x)\\n    critical_points = solve(f_prime, x)\\n    \\n    # Evaluate f(x) at the critical points and endpoints\\n    values = [f.subs(x, p), f.subs(x, 15)]\\n    for point in critical_points:\\n        values.append(f.subs(x, point))\\n    \\n    # Find the minimum value\\n    minimum_value = min(values)\\n    \\n    return minimum_value\\n\\nresult = find_minimum_value()\\nprint(result)\\n```\\n```output\\nValueError(\\\"\\\\nCan't calculate derivative wrt re(x) + I*im(x).\\\")\\n```\\nIt seems that there is an error in the code. Let's modify the code to handle the case when the derivative is undefined.\\n\\n```python\\nfrom sympy import symbols, diff, solve, oo\\n\\ndef find_minimum_value():\\n    x, p = symbols('x p')\\n    f = abs(x - p) + abs(x - 15) + abs(x - p - 15)\\n    f_prime = diff(f, x)\\n    critical_points = solve(f_prime, x)\\n    \\n    # Evaluate f(x) at the critical points and endpoints\\n    values = [f.subs(x, p), f.subs(x, 15)]\\n    for point in critical_points:\\n        if point.is_real:\\n            values.append(f.subs(x, point))\\n    \\n    # Find the minimum value\\n    minimum_value = min(values)\\n    \\n    return minimum_value\\n\\nresult = find_minimum_value()\\nprint(result)\\n```\\n```output\\nValueError(\\\"\\\\nCan't calculate derivative wrt re(x) + I*im(x).\\\")\\n```\\nApologies for the error in the code. It seems that the derivative calculation is causing an issue. Let's modify the code to handle the absolute value function and find the minimum value using a different approach.\\n\\n```python\\nfrom sympy import symbols, Piecewise, Min, oo\\n\\ndef find_minimum_value():\\n    x, p = symbols('x p')\\n    f = abs(x - p) + abs(x - 15) + abs(x - p - 15)\\n    \\n    # Define the piecewise function for f(x)\\n    f_piecewise = Piecewise((f, x <= p), (f.subs(x, p), p < x <= 15), (f.subs(x, 15), x > 15))\\n    \\n    # Find the minimum value\\n    minimum_value = Min(f_piecewise, (x, p, 15))\\n    \\n    return minimum_value\\n\\nresult = find_minimum_value()\\nprint(result)\\n```\\n```output\\nTypeError('cannot determine truth value of Relational')\\n```\\nApologies for the error in the code. It seems that the piecewise function is causing an issue. Let's modify the code to handle the absolute value function and find the minimum value using a different approach.\\n\\n```python\\nfrom sympy import symbols, Min, oo\\n\\ndef find_minimum_value():\\n    x, p = symbols('x p')\\n    f = abs(x - p) + abs(x - 15) + abs(x - p - 15)\\n    \\n    # Find the minimum value\\n    minimum_value = Min(f, (x, p, 15))\\n    \\n    return minimum_value\\n\\nresult = find_minimum_value()\\nprint(result)\\n```\\n\"\n    label = \"15\"\n    print(compare_ans(pred, label))\n",
        "eval/eval/math_opensource_utils/parser.py": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport re\nfrom typing import Dict\n\nimport regex\n# from uniform_eval.bundled.latex2sympy2.latex2sympy2 import latex2sympy\nfrom latex2sympy2 import latex2sympy\nfrom word2number import w2n\n\nfrom .utils import *\n\n\ndef _fix_fracs(string):\n    substrs = string.split(\"\\\\frac\")\n    new_str = substrs[0]\n    if len(substrs) > 1:\n        substrs = substrs[1:]\n        for substr in substrs:\n            new_str += \"\\\\frac\"\n            if len(substr) > 0 and substr[0] == \"{\":\n                new_str += substr\n            else:\n                try:\n                    assert len(substr) >= 2\n                except:\n                    return string\n                a = substr[0]\n                b = substr[1]\n                if b != \"{\":\n                    if len(substr) > 2:\n                        post_substr = substr[2:]\n                        new_str += \"{\" + a + \"}{\" + b + \"}\" + post_substr\n                    else:\n                        new_str += \"{\" + a + \"}{\" + b + \"}\"\n                else:\n                    if len(substr) > 2:\n                        post_substr = substr[2:]\n                        new_str += \"{\" + a + \"}\" + b + post_substr\n                    else:\n                        new_str += \"{\" + a + \"}\" + b\n    string = new_str\n    return string\n\n\ndef _fix_a_slash_b(string):\n    if len(string.split(\"/\")) != 2:\n        return string\n    a = string.split(\"/\")[0]\n    b = string.split(\"/\")[1]\n    try:\n        if \"sqrt\" not in a:\n            a = int(a)\n        if \"sqrt\" not in b:\n            b = int(b)\n        assert string == \"{}/{}\".format(a, b)\n        new_string = \"\\\\frac{\" + str(a) + \"}{\" + str(b) + \"}\"\n        return new_string\n    except:\n        return string\n\n\ndef _fix_sqrt(string):\n    _string = re.sub(r\"\\\\sqrt(\\w+)\", r\"\\\\sqrt{\\1}\", string)\n    return _string\n\n\ndef convert_word_number(text: str) -> str:\n    try:\n        text = str(w2n.word_to_num(text))\n    except:\n        pass\n    return text\n\n\n# units mainly from MathQA\nunit_texts = [\n    \"east\",\n    \"degree\",\n    \"mph\",\n    \"kmph\",\n    \"ft\",\n    \"m sqaure\",\n    \" m east\",\n    \"sq m\",\n    \"deg\",\n    \"mile\",\n    \"q .\",\n    \"monkey\",\n    \"prime\",\n    \"ratio\",\n    \"profit of rs\",\n    \"rd\",\n    \"o\",\n    \"gm\",\n    \"p . m\",\n    \"lb\",\n    \"tile\",\n    \"per\",\n    \"dm\",\n    \"lt\",\n    \"gain\",\n    \"ab\",\n    \"way\",\n    \"west\",\n    \"a .\",\n    \"b .\",\n    \"c .\",\n    \"d .\",\n    \"e .\",\n    \"f .\",\n    \"g .\",\n    \"h .\",\n    \"t\",\n    \"a\",\n    \"h\",\n    \"no change\",\n    \"men\",\n    \"soldier\",\n    \"pie\",\n    \"bc\",\n    \"excess\",\n    \"st\",\n    \"inches\",\n    \"noon\",\n    \"percent\",\n    \"by\",\n    \"gal\",\n    \"kmh\",\n    \"c\",\n    \"acre\",\n    \"rise\",\n    \"a . m\",\n    \"th\",\n    \"œÄ r 2\",\n    \"sq\",\n    \"mark\",\n    \"l\",\n    \"toy\",\n    \"coin\",\n    \"sq . m\",\n    \"gallon\",\n    \"¬∞ f\",\n    \"profit\",\n    \"minw\",\n    \"yr\",\n    \"women\",\n    \"feet\",\n    \"am\",\n    \"pm\",\n    \"hr\",\n    \"cu cm\",\n    \"square\",\n    \"v √¢ ‚Ç¨ ‚Ñ¢\",\n    \"are\",\n    \"rupee\",\n    \"rounds\",\n    \"cubic\",\n    \"cc\",\n    \"mtr\",\n    \"s\",\n    \"ohm\",\n    \"number\",\n    \"kmph\",\n    \"day\",\n    \"hour\",\n    \"minute\",\n    \"min\",\n    \"second\",\n    \"man\",\n    \"woman\",\n    \"sec\",\n    \"cube\",\n    \"mt\",\n    \"sq inch\",\n    \"mp\",\n    \"‚àè cm ¬≥\",\n    \"hectare\",\n    \"more\",\n    \"sec\",\n    \"unit\",\n    \"cu . m\",\n    \"cm 2\",\n    \"rs .\",\n    \"rs\",\n    \"kg\",\n    \"g\",\n    \"month\",\n    \"km\",\n    \"m\",\n    \"cm\",\n    \"mm\",\n    \"apple\",\n    \"liter\",\n    \"loss\",\n    \"yard\",\n    \"pure\",\n    \"year\",\n    \"increase\",\n    \"decrease\",\n    \"d\",\n    \"less\",\n    \"Surface\",\n    \"litre\",\n    \"pi sq m\",\n    \"s .\",\n    \"metre\",\n    \"meter\",\n    \"inch\",\n]\n\nunit_texts.extend([t + \"s\" for t in unit_texts])\n\n\ndef strip_string(string, skip_unit=False):\n    string = str(string).strip()\n    # linebreaks\n    string = string.replace(\"\\n\", \"\")\n\n    # right \".\"\n    string = string.rstrip(\".\")\n\n    # remove inverse spaces\n    # replace \\\\ with \\\n    string = string.replace(\"\\\\!\", \"\")\n    # string = string.replace(\"\\\\ \", \"\")\n    # string = string.replace(\"\\\\\\\\\", \"\\\\\")\n\n    # matrix\n    string = re.sub(r\"\\\\begin\\{array\\}\\{.*?\\}\", r\"\\\\begin{pmatrix}\", string)\n    string = re.sub(r\"\\\\end\\{array\\}\", r\"\\\\end{pmatrix}\", string)\n    string = string.replace(\"bmatrix\", \"pmatrix\")\n\n    # replace tfrac and dfrac with frac\n    string = string.replace(\"tfrac\", \"frac\")\n    string = string.replace(\"dfrac\", \"frac\")\n    string = (\n        string.replace(\"\\\\neq\", \"\\\\ne\")\n        .replace(\"\\\\leq\", \"\\\\le\")\n        .replace(\"\\\\geq\", \"\\\\ge\")\n    )\n\n    # remove \\left and \\right\n    string = string.replace(\"\\\\left\", \"\")\n    string = string.replace(\"\\\\right\", \"\")\n    string = string.replace(\"\\\\{\", \"{\")\n    string = string.replace(\"\\\\}\", \"}\")\n\n    # Remove unit: miles, dollars if after is not none\n    _string = re.sub(r\"\\\\text{.*?}$\", \"\", string).strip()\n    if _string != \"\" and _string != string:\n        # print(\"Warning: unit not removed: '{}' -> '{}'\".format(string, _string))\n        string = _string\n\n    if not skip_unit:\n        # Remove unit: texts\n        for _ in range(2):\n            for unit_text in unit_texts:\n                # use regex, the prefix should be either the start of the string or a non-alphanumeric character\n                # the suffix should be either the end of the string or a non-alphanumeric character\n                _string = re.sub(r\"(^|\\W)\" + unit_text + r\"($|\\W)\", r\"\\1\\2\", string)\n                if _string != \"\":\n                    string = _string\n\n    # Remove circ (degrees)\n    string = string.replace(\"^{\\\\circ}\", \"\")\n    string = string.replace(\"^\\\\circ\", \"\")\n\n    # remove dollar signs\n    string = string.replace(\"\\\\$\", \"\")\n    string = string.replace(\"$\", \"\")\n    string = string.replace(\"\\\\(\", \"\").replace(\"\\\\)\", \"\")\n\n    # convert word number to digit\n    string = convert_word_number(string)\n\n    # replace \"\\\\text{...}\" to \"...\"\n    string = re.sub(r\"\\\\text\\{(.*?)\\}\", r\"\\1\", string)\n    for key in [\"x=\", \"y=\", \"z=\", \"x\\\\in\", \"y\\\\in\", \"z\\\\in\", \"x\\\\to\", \"y\\\\to\", \"z\\\\to\"]:\n        string = string.replace(key, \"\")\n    string = string.replace(\"\\\\emptyset\", r\"{}\")\n    string = string.replace(\"(-\\\\infty,\\\\infty)\", \"\\\\mathbb{R}\")\n\n    # remove percentage\n    string = string.replace(\"\\\\%\", \"\")\n    string = string.replace(\"\\%\", \"\")\n    string = string.replace(\"%\", \"\")\n\n    # \" 0.\" equivalent to \" .\" and \"{0.\" equivalent to \"{.\" Alternatively, add \"0\" if \".\" is the start of the string\n    string = string.replace(\" .\", \" 0.\")\n    string = string.replace(\"{.\", \"{0.\")\n\n    # cdot\n    # string = string.replace(\"\\\\cdot\", \"\")\n    if (\n        string.startswith(\"{\")\n        and string.endswith(\"}\")\n        and string.isalnum()\n        or string.startswith(\"(\")\n        and string.endswith(\")\")\n        and string.isalnum()\n        or string.startswith(\"[\")\n        and string.endswith(\"]\")\n        and string.isalnum()\n    ):\n        string = string[1:-1]\n\n    # inf\n    string = string.replace(\"infinity\", \"\\\\infty\")\n    if \"\\\\infty\" not in string:\n        string = string.replace(\"inf\", \"\\\\infty\")\n    string = string.replace(\"+\\\\inity\", \"\\\\infty\")\n\n    # and\n    string = string.replace(\"and\", \"\")\n    string = string.replace(\"\\\\mathbf\", \"\")\n\n    # use regex to remove \\mbox{...}\n    string = re.sub(r\"\\\\mbox{.*?}\", \"\", string)\n\n    # quote\n    string.replace(\"'\", \"\")\n    string.replace('\"', \"\")\n\n    # i, j\n    if \"j\" in string and \"i\" not in string:\n        string = string.replace(\"j\", \"i\")\n\n    # replace a.000b where b is not number or b is end, with ab, use regex\n    string = re.sub(r\"(\\d+)\\.0*([^\\d])\", r\"\\1\\2\", string)\n    string = re.sub(r\"(\\d+)\\.0*$\", r\"\\1\", string)\n\n    # if empty, return empty string\n    if len(string) == 0:\n        return string\n    if string[0] == \".\":\n        string = \"0\" + string\n\n    # to consider: get rid of e.g. \"k = \" or \"q = \" at beginning\n    if len(string.split(\"=\")) == 2:\n        if len(string.split(\"=\")[0]) <= 2:\n            string = string.split(\"=\")[1]\n\n    string = _fix_sqrt(string)\n    string = string.replace(\" \", \"\")\n\n    # \\frac1b or \\frac12 --> \\frac{1}{b} and \\frac{1}{2}, etc. Even works with \\frac1{72} (but not \\frac{72}1). Also does a/b --> \\\\frac{a}{b}\n    string = _fix_fracs(string)\n\n    # NOTE: X/Y changed to \\frac{X}{Y} in dataset, but in simple cases fix in case the model output is X/Y\n    string = _fix_a_slash_b(string)\n\n    return string\n\n\ndef extract_multi_choice_answer(pred_str):\n    # TODO: SFT models\n    if \"Problem:\" in pred_str:\n        pred_str = pred_str.split(\"Problem:\", 1)[0]\n    pred_str = pred_str.replace(\"choice is\", \"answer is\")\n    patt = regex.search(r\"answer is \\(?(?P<ans>[abcde])\\)?\", pred_str.lower())\n    if patt is not None:\n        return patt.group(\"ans\").upper()\n    return \"placeholder\"\n\n\ndirect_answer_trigger_for_fewshot = (\"choice is\", \"answer is\")\n\n\ndef choice_answer_clean(pred: str):\n    pred = pred.strip(\"\\n\")\n\n    # Determine if this is ICL, if so, use \\n\\n to split the first chunk.\n    ICL = False\n    for trigger in direct_answer_trigger_for_fewshot:\n        if pred.count(trigger) > 1:\n            ICL = True\n    if ICL:\n        pred = pred.split(\"\\n\\n\")[0]\n\n    # Split the trigger to find the answer.\n    preds = re.split(\"|\".join(direct_answer_trigger_for_fewshot), pred)\n    if len(preds) > 1:\n        answer_flag = True\n        pred = preds[-1]\n    else:\n        answer_flag = False\n\n    pred = pred.strip(\"\\n\").rstrip(\".\").rstrip(\"/\").strip(\" \").lstrip(\":\")\n\n    # Clean the answer based on the dataset\n    tmp = re.findall(r\"\\b(A|B|C|D|E)\\b\", pred.upper())\n    if tmp:\n        pred = tmp\n    else:\n        pred = [pred.strip().strip(\".\")]\n\n    if len(pred) == 0:\n        pred = \"\"\n    else:\n        if answer_flag:\n            # choose the first element in list ...\n            pred = pred[0]\n        else:\n            # choose the last e\n            pred = pred[-1]\n\n    # Remove the period at the end, again!\n    pred = pred.rstrip(\".\").rstrip(\"/\")\n\n    return pred\n\n\ndef find_box(pred_str: str):\n    ans = pred_str.split(\"boxed\")[-1]\n    if not ans:\n        return \"\"\n    if ans[0] == \"{\":\n        stack = 1\n        a = \"\"\n        for c in ans[1:]:\n            if c == \"{\":\n                stack += 1\n                a += c\n            elif c == \"}\":\n                stack -= 1\n                if stack == 0:\n                    break\n                a += c\n            else:\n                a += c\n    else:\n        a = ans.split(\"$\")[0].strip()\n    return a\n\n\ndef clean_units(pred_str: str):\n    \"\"\"Clean the units in the number.\"\"\"\n\n    def convert_pi_to_number(code_string):\n        code_string = code_string.replace(\"\\\\pi\", \"œÄ\")\n        # Replace \\pi or œÄ not preceded by a digit or } with 3.14\n        code_string = re.sub(r\"(?<![\\d}])\\\\?œÄ\", \"3.14\", code_string)\n        # Replace instances where œÄ is preceded by a digit but without a multiplication symbol, e.g., \"3œÄ\" -> \"3*3.14\"\n        code_string = re.sub(r\"(\\d)(\\\\?œÄ)\", r\"\\1*3.14\", code_string)\n        # Handle cases where œÄ is within braces or followed by a multiplication symbol\n        # This replaces \"{œÄ}\" with \"3.14\" directly and \"3*œÄ\" with \"3*3.14\"\n        code_string = re.sub(r\"\\{(\\\\?œÄ)\\}\", \"3.14\", code_string)\n        code_string = re.sub(r\"\\*(\\\\?œÄ)\", \"*3.14\", code_string)\n        return code_string\n\n    pred_str = convert_pi_to_number(pred_str)\n    pred_str = pred_str.replace(\"%\", \"/100\")\n    pred_str = pred_str.replace(\"$\", \"\")\n    pred_str = pred_str.replace(\"¬•\", \"\")\n    pred_str = pred_str.replace(\"¬∞C\", \"\")\n    pred_str = pred_str.replace(\" C\", \"\")\n    pred_str = pred_str.replace(\"¬∞\", \"\")\n    return pred_str\n\n\ndef extract_theoremqa_answer(pred: str, answer_flag: bool = True):\n    if any([option in pred.lower() for option in [\"yes\", \"true\"]]):\n        pred = \"True\"\n    elif any([option in pred.lower() for option in [\"no\", \"false\"]]):\n        pred = \"False\"\n    elif any(\n        [\n            option in pred.lower()\n            for option in [\"(a)\", \"(b)\", \"(c)\", \"(d)\", \"(e)\", \"(f)\"]\n        ]\n    ):\n        pass\n    else:\n        # Some of the models somehow get used to boxed output from pre-training\n        if \"boxed\" in pred:\n            pred = find_box(pred)\n\n        if answer_flag:\n            # Extract the numbers out of the string\n            pred = pred.split(\"=\")[-1].strip()\n            pred = clean_units(pred)\n            try:\n                tmp = str(latex2sympy(pred))\n                pred = str(eval(tmp))\n            except Exception:\n                if re.match(r\"-?[\\d\\.]+\\s\\D+$\", pred):\n                    pred = pred.split(\" \")[0]\n                elif re.match(r\"-?[\\d\\.]+\\s[^\\s]+$\", pred):\n                    pred = pred.split(\" \")[0]\n        else:\n            # desparate search over the last number\n            preds = re.findall(r\"-?\\d*\\.?\\d+\", pred)\n            if len(preds) >= 1:\n                pred = preds[-1]\n            else:\n                pred = \"\"\n\n    return pred\n\n\ndef extract_answer(pred_str, data_name, use_last_number=True):\n    pred_str = pred_str.replace(\"\\u043a\\u0438\", \"\")\n    if data_name in [\"mmlu_stem\", \"sat_math\", \"aqua\", \"gaokao2023\"]:\n        # TODO check multiple choice\n        return choice_answer_clean(pred_str)\n\n    if \"final answer is $\" in pred_str and \"$. I hope\" in pred_str:\n        # minerva_math\n        tmp = pred_str.split(\"final answer is $\", 1)[1]\n        pred = tmp.split(\"$. I hope\", 1)[0].strip()\n    elif \"boxed\" in pred_str:\n        ans = pred_str.split(\"boxed\")[-1]\n        if len(ans) == 0:\n            return \"\"\n        elif ans[0] == \"{\":\n            stack = 1\n            a = \"\"\n            for c in ans[1:]:\n                if c == \"{\":\n                    stack += 1\n                    a += c\n                elif c == \"}\":\n                    stack -= 1\n                    if stack == 0:\n                        break\n                    a += c\n                else:\n                    a += c\n        else:\n            a = ans.split(\"$\")[0].strip()\n        pred = a\n    elif \"he answer is\" in pred_str:\n        pred = pred_str.split(\"he answer is\")[-1].strip()\n    elif \"final answer is\" in pred_str:\n        pred = pred_str.split(\"final answer is\")[-1].strip()\n    # elif extract_program_output(pred_str) != \"\":\n    # fall back to program\n    # pred = extract_program_output(pred_str)\n    else:  # use the last number\n        if use_last_number:\n            pattern = \"-?\\d*\\.?\\d+\"\n            pred = re.findall(pattern, pred_str.replace(\",\", \"\"))\n            if len(pred) >= 1:\n                pred = pred[-1]\n            else:\n                pred = \"\"\n        else:\n            pred = \"\"\n\n    # choice answer\n    if (\n        data_name in [\"sat_math\", \"aqua\"]\n        or \"mmlu\" in data_name\n    ):\n        tmp = re.findall(r\"\\b(A|B|C|D|E)\\b\", pred.upper())\n        if tmp:\n            pred = tmp[-1]\n        else:\n            pred = pred.strip().strip(\".\")\n\n    # multiple line\n    # pred = pred.split(\"\\n\")[0]\n    pred = re.sub(r\"\\n\\s*\", \"\", pred)\n    if pred != \"\" and pred[0] == \":\":\n        pred = pred[1:]\n    if pred != \"\" and pred[-1] == \".\":\n        pred = pred[:-1]\n    if pred != \"\" and pred[-1] == \"/\":\n        pred = pred[:-1]\n    pred = strip_string(pred, skip_unit=data_name in [\"carp_en\", \"minerva_math\"])\n    return pred\n\n\nSTRIP_EXCEPTIONS = [\"carp_en\", \"minerva_math\"]\n\n\ndef parse_ground_truth(example: Dict[str, Any], data_name):\n    if \"gt_cot\" in example and \"gt\" in example:\n        if data_name in [\"math\"]:\n            gt_ans = extract_answer(example[\"gt_cot\"], data_name)\n        elif data_name in STRIP_EXCEPTIONS:\n            gt_ans = example[\"gt\"]\n        else:\n            gt_ans = strip_string(example[\"gt\"])\n        return example[\"gt_cot\"], gt_ans\n\n    # parse ground truth\n    if data_name in [\"math\", \"minerva_math\", \"math500\"]:\n        gt_cot = example[\"solution\"]\n        gt_ans = extract_answer(gt_cot, data_name)\n    elif data_name == \"gsm8k\":\n        gt_cot, gt_ans = example[\"answer\"].split(\"####\")\n    elif data_name == \"svamp\":\n        gt_cot, gt_ans = example[\"Equation\"], example[\"Answer\"]\n    elif data_name == \"asdiv\":\n        gt_cot = example[\"formula\"]\n        gt_ans = re.sub(r\"\\(.*?\\)\", \"\", example[\"answer\"])\n    elif data_name == \"mawps\":\n        gt_cot, gt_ans = None, example[\"target\"]\n    elif data_name == \"tabmwp\":\n        gt_cot = example[\"solution\"]\n        gt_ans = example[\"answer\"]\n        if example[\"ans_type\"] in [\"integer_number\", \"decimal_number\"]:\n            if \"/\" in gt_ans:\n                gt_ans = int(gt_ans.split(\"/\")[0]) / int(gt_ans.split(\"/\")[1])\n            elif \",\" in gt_ans:\n                gt_ans = float(gt_ans.replace(\",\", \"\"))\n            elif \"%\" in gt_ans:\n                gt_ans = float(gt_ans.split(\"%\")[0]) / 100\n            else:\n                gt_ans = float(gt_ans)\n    elif data_name == \"carp_en\":\n        gt_cot, gt_ans = example[\"steps\"], example[\"answer\"]\n    elif data_name == \"mmlu_stem\":\n        abcd = \"ABCD\"\n        gt_cot, gt_ans = None, abcd[example[\"answer\"]]\n    elif data_name == \"sat_math\":\n        gt_cot, gt_ans = None, example[\"Answer\"]\n    elif data_name == \"aqua\":\n        gt_cot, gt_ans = None, example[\"correct\"]\n    elif data_name in [\"gaokao2023en\", \"college_math\", \"gaokao_math_cloze\"]:\n        gt_cot, gt_ans = None, example[\"answer\"].replace(\"$\", \"\").strip()\n    elif data_name == \"gaokao_math_qa\":\n        gt_cot, gt_ans = None, example[\"label\"]\n    elif data_name in [\"gaokao2024_mix\", \"cn_middle_school\"]:\n        if len(example[\"choice_answer\"]) > 0:\n            gt_cot, gt_ans = None, example[\"choice_answer\"]\n        else:\n            gt_cot, gt_ans = None, example[\"answer\"]\n    elif data_name == \"olympiadbench\":\n        gt_cot, gt_ans = None, example[\"final_answer\"][0].strip(\"$\")\n    elif data_name in [\n        \"aime24\",\n        \"amc23\",\n        \"cmath\",\n        \"gaokao2024_I\",\n        \"gaokao2024_II\",\n        \"imo2024\",\n        \"aimo12\",\n        \"cnmo24\",\n        \"aime25\",\n        \"math500box\",\n        \"train\",\n    ]:\n        gt_cot, gt_ans = None, example[\"answer\"]\n    else:\n        raise NotImplementedError(f\"`{data_name}`\")\n    # post process\n    gt_cot = str(gt_cot).strip()\n    if data_name not in STRIP_EXCEPTIONS:\n        gt_ans = strip_string(gt_ans, skip_unit=data_name == \"carp_en\")\n    else:\n        gt_ans = (\n            gt_ans.replace(\"\\\\neq\", \"\\\\ne\")\n            .replace(\"\\\\leq\", \"\\\\le\")\n            .replace(\"\\\\geq\", \"\\\\ge\")\n        )\n    return gt_cot, gt_ans\n\n\ndef parse_question(example, data_name):\n    question = \"\"\n    if data_name == \"asdiv\":\n        question = f\"{example['body'].strip()} {example['question'].strip()}\"\n    elif data_name == \"svamp\":\n        body = example[\"Body\"].strip()\n        if not body.endswith(\".\"):\n            body = body + \".\"\n        question = f'{body} {example[\"Question\"].strip()}'\n    elif data_name == \"tabmwp\":\n        title_str = (\n            f'regarding \"{example[\"table_title\"]}\" ' if example[\"table_title\"] else \"\"\n        )\n        question = f\"Read the following table {title_str}and answer a question:\\n\"\n        question += f'{example[\"table\"]}\\n{example[\"question\"]}'\n        if example[\"choices\"]:\n            question += (\n                f' Please select from the following options: {example[\"choices\"]}'\n            )\n    elif data_name == \"carp_en\":\n        question = example[\"content\"]\n    elif data_name == \"mmlu_stem\":\n        options = example[\"choices\"]\n        assert len(options) == 4\n        for i, (label, option) in enumerate(zip(\"ABCD\", options)):\n            options[i] = f\"({label}) {str(option).strip()}\"\n        options = \" \".join(options)\n        # question = f\"{example['question'].strip()}\\nWhat of the following is the right choice? Explain your answer.\\n{options}\"\n        question = f\"{example['question'].strip()}\\nAnswer Choices: {options}\"\n    elif data_name == \"sat_math\":\n        options = example[\"options\"].strip()\n        assert \"A\" == options[0]\n        options = \"(\" + options\n        for ch in \"BCD\":\n            if f\" {ch}) \" in options:\n                options = regex.sub(f\" {ch}\\) \", f\" ({ch}) \", options)\n        # question = f\"{example['question'].strip()}\\nWhat of the following is the right choice? Explain your answer.\\n{options.strip()}\"\n        question = f\"{example['question'].strip()}\\nAnswer Choices: {options}\"\n    elif \"aqua\" in data_name:\n        options = example[\"options\"]\n        choice = \"(\" + \"(\".join(options)\n        choice = choice.replace(\"(\", \" (\").replace(\")\", \") \").strip()\n        choice = \"\\nAnswer Choices: \" + choice\n        question = example[\"question\"].strip() + choice\n    elif data_name == \"gaokao_math_qa\":\n        options_dict = example[\"options\"]\n        options = []\n        for key in options_dict:\n            options.append(f\"({key}) {options_dict[key]}\")\n        options = \" \".join(options)\n        question = f\"{example['question'].strip()}\\nÈÄâÈ°π: {options}\"\n    else:\n        for key in [\"question\", \"problem\", \"Question\", \"input\"]:\n            if key in example:\n                question = example[key]\n                break\n    # assert question != \"\"\n    # Yes or No question\n    _, gt_ans = parse_ground_truth(example, data_name)\n    if isinstance(gt_ans, str):\n        gt_lower = gt_ans.lower()\n        if gt_lower in [\"true\", \"false\"]:\n            question += \" (True or False)\"\n        if gt_lower in [\"yes\", \"no\"]:\n            question += \" (Yes or No)\"\n    return question.strip()\n\n\ndef run_execute(executor, result, prompt_type, data_name, execute=False):\n    if not result or result == \"error\":\n        return None, None\n    report = None\n\n    if \"program_only\" in prompt_type:\n        prediction = extract_program_output(result)\n    elif prompt_type in [\"pot\", \"pal\"] and execute:\n        code = extract_program(result)\n        prediction, report = executor.apply(code)\n    else:\n        prediction = extract_answer(result, data_name)\n\n    # prediction = strip_string(prediction, skip_unit=data_name == \"carp_en\")\n    prediction = strip_string(prediction, skip_unit=data_name in STRIP_EXCEPTIONS)\n    return prediction, report\n\n\ndef _test_extract_answer():\n    text = \"\"\"\nThis is still not equal to $0$, so we must have made another mistake.\n\nWhen we subtracted $7$ from $\\frac{386}{64}$, we should have subtracted $7 \\cdot 64$ from $386$, not the other way around. Let's correct that:\n\n\\[\\frac{386}{64} - 7 = \\frac{386}{64} - \\frac{7 \\cdot 64}{1 \\cdot 64} = \\frac{386 - 448}{64} = \\frac{-62}{64}.\\]\n\nThis is still not equal to $0$, so we must have made another mistake.\n\nWhen we subtracted $7$ from $\\frac{386}{64}$, we should have subtracted $7 \\cdot 64$ from $386$, not the other way around. Let's correct that:\n\n\\[\\frac{386}{64}\n\"\"\"\n    print(extract_answer(text, \"math-oai\", use_last_number=False))\n    print(choice_answer_clean(\"\\mathrm{(D)\\}1,008,016\"))\n    # should output a dict\n\n\nif __name__ == \"__main__\":\n    _test_extract_answer()\n",
        "eval/eval/math_opensource_utils/python_executor.py": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport copy\nimport datetime\nimport io\nimport logging\nimport multiprocessing\nimport pickle\nimport traceback\nfrom concurrent.futures import TimeoutError\nfrom contextlib import redirect_stdout\nfrom functools import partial\nfrom multiprocessing import Pool\nfrom typing import Any, Dict, Optional\n\nimport dateutil.relativedelta\nimport regex\nfrom pebble import ProcessPool\nfrom timeout_decorator import timeout\nfrom tqdm import tqdm\n\n\n\n\nclass GenericRuntime:\n    GLOBAL_DICT = {}\n    LOCAL_DICT = None\n    HEADERS = []\n\n    def __init__(self):\n        self._global_vars = copy.copy(self.GLOBAL_DICT)\n        self._local_vars = copy.copy(self.LOCAL_DICT) if self.LOCAL_DICT else None\n\n        for c in self.HEADERS:\n            self.exec_code(c)\n\n    def exec_code(self, code_piece: str) -> None:\n        if regex.search(r'(\\s|^)?input\\(', code_piece):\n            # regex.search(r'(\\s|^)?os.', code_piece):\n            raise RuntimeError()\n        exec(code_piece, self._global_vars)\n\n        # TODO: use: https://github.com/shroominic/codebox-api\n        # @high safe exec in sandbox\n        # byte_code = compile_restricted(\n        #     code_piece,\n        #     filename='<inline code>',\n        #     mode='exec'\n        # )\n        # print(\"global vars:\", self._global_vars)\n        # _print_ = PrintCollector\n        # exec(byte_code, {'__builtins__': utility_builtins}, None)\n\n    def eval_code(self, expr: str) -> Any:\n        return eval(expr, self._global_vars)\n\n    def inject(self, var_dict: Dict[str, Any]) -> None:\n        for k, v in var_dict.items():\n            self._global_vars[k] = v\n\n    @property\n    def answer(self):\n        return self._global_vars['answer']\n\n\nclass DateRuntime(GenericRuntime):\n    GLOBAL_DICT = {\n        'datetime': datetime.datetime,\n        'timedelta': dateutil.relativedelta.relativedelta,\n        'relativedelta': dateutil.relativedelta.relativedelta\n    }\n\n\nclass CustomDict(dict):\n    def __iter__(self):\n        return list(super().__iter__()).__iter__()\n\n\nclass ColorObjectRuntime(GenericRuntime):\n    GLOBAL_DICT = {'dict': CustomDict}\n\n\nclass PythonExecutor:\n    def __init__(\n        self,\n        runtime: Optional[Any] = None,\n        get_answer_symbol: Optional[str] = None,\n        get_answer_expr: Optional[str] = None,\n        get_answer_from_stdout: bool = False,\n        timeout_length: int = 5,\n    ) -> None:\n        self.runtime = runtime if runtime else GenericRuntime()\n        self.answer_symbol = get_answer_symbol\n        self.answer_expr = get_answer_expr\n        self.get_answer_from_stdout = get_answer_from_stdout\n        self.pool = Pool(multiprocessing.cpu_count())\n        self.timeout_length = timeout_length\n\n    def process_generation_to_code(self, gens: str):\n        return [g.strip().split('\\n') for g in gens]\n\n    @staticmethod\n    def execute(\n        code,\n        get_answer_from_stdout=None,\n        runtime=None,\n        answer_symbol=None,\n        answer_expr=None,\n        timeout_length=10,\n        auto_mode=False\n    ):\n        try:\n            if auto_mode:\n                if \"print(\" in code[-1]:\n                    program_io = io.StringIO()\n                    with redirect_stdout(program_io):\n                        timeout(timeout_length)(runtime.exec_code)('\\n'.join(code))\n                    program_io.seek(0)\n                    result = program_io.read()\n                else:\n                    print(code)\n                    timeout(timeout_length)(runtime.exec_code)('\\n'.join(code[:-1]))\n                    result = timeout(timeout_length)(runtime.eval_code)(code[-1])\n            else:\n                if get_answer_from_stdout:\n                    program_io = io.StringIO()\n                    with redirect_stdout(program_io):\n                        timeout(timeout_length)(runtime.exec_code)('\\n'.join(code))\n                    program_io.seek(0)\n                    result = program_io.read()\n                elif answer_symbol:\n                    timeout(timeout_length)(runtime.exec_code)('\\n'.join(code))\n                    result = runtime._global_vars[answer_symbol]\n                elif answer_expr:\n                    timeout(timeout_length)(runtime.exec_code)('\\n'.join(code))\n                    result = timeout(timeout_length)(runtime.eval_code)(answer_expr)\n                else:\n                    timeout(timeout_length)(runtime.exec_code)('\\n'.join(code[:-1]))\n                    result = timeout(timeout_length)(runtime.eval_code)(code[-1])\n            report = \"Done\"\n            str(result)           # codec check\n            pickle.dumps(result)  # serialization check\n        except:\n            result = ''\n            report = traceback.format_exc().split('\\n')[-2]\n        return result, report\n\n    def apply(self, code):\n        return self.batch_apply([code])[0]\n\n    @staticmethod\n    def truncate(s, max_length=400):\n        half = max_length // 2\n        if len(s) > max_length:\n            s = s[:half] + \"...\" + s[-half:]\n        return s\n\n    def batch_apply(self, batch_code):\n        all_code_snippets = self.process_generation_to_code(batch_code)\n\n        timeout_cnt = 0\n        all_exec_results = []\n        # with ProcessPool(max_workers=min(len(all_code_snippets), os.cpu_count())) as pool:\n        with ProcessPool(max_workers=min(len(all_code_snippets), 1)) as pool:\n            executor = partial(\n                self.execute,\n                get_answer_from_stdout=self.get_answer_from_stdout,\n                runtime=self.runtime,\n                answer_symbol=self.answer_symbol,\n                answer_expr=self.answer_expr,\n                timeout_length=self.timeout_length,  # this timeout not work\n                auto_mode=True\n            )\n            future = pool.map(executor, all_code_snippets, timeout=self.timeout_length)\n            iterator = future.result()\n\n            if len(all_code_snippets) > 100:\n                progress_bar = tqdm(total=len(all_code_snippets), desc=\"Execute\")\n            else:\n                progress_bar = None\n\n            while True:\n                try:\n                    result = next(iterator)\n                    all_exec_results.append(result)\n                except StopIteration:\n                    break\n                except TimeoutError as error:\n                    logging.warning(f\"Timeout error in code execution: {error}\")\n                    all_exec_results.append((\"\", \"Timeout Error\"))\n                    timeout_cnt += 1\n                except Exception as error:\n                    raise\n                if progress_bar is not None:\n                    progress_bar.update(1)\n\n            if progress_bar is not None:\n                progress_bar.close()\n\n        batch_results = []\n        for code, (res, report) in zip(all_code_snippets, all_exec_results):\n            # post processing\n            res, report = str(res).strip(), str(report).strip()\n            res, report = self.truncate(res), self.truncate(report)\n            batch_results.append((res, report))\n        return batch_results\n\n\ndef _test():\n    batch_code = [\n        \"\"\"\nfrom sympy import Matrix\n\ndef null_space_basis():\n    # Define the matrix\n    A = Matrix([[3, 3, -1, -6], [9, -1, -8, -1], [7, 4, -2, -9]])\n\n    # Compute the basis for the null space\n    basis = A.nullspace()\n\n    # Round the elements of the basis vectors to three decimal places\n    basis_rounded = [v.evalf(3) for v in basis]\n\n    return basis_rounded\n\nresult = null_space_basis()\nprint(result)\n        \"\"\"\n    ]\n\n    executor = PythonExecutor(get_answer_from_stdout=True)\n    predictions = executor.apply(batch_code[0])\n    print(predictions)\n\n\nif __name__ == '__main__':\n    _test()\n",
        "eval/eval/math_opensource_utils/trajectory.py": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\"\ntrajectory:\n[\n    {\"role\": \"rationale\", \"content\": \"...\"},\n    {\"role\": \"program\", \"content\": \"...\"},\n    {\"role\": \"output\", \"content\": \"...\"},\n    {\"role\": \"rationale\", \"content\": \"...\"},\n    ...\n]\n\"\"\"\n\nimport re\nfrom typing import List\n\n\ndef text_to_trajectory(traj_str: str) -> List[dict]:\n    \"\"\"parse the above interleaved string of raionale, program, output, raionale, program, output, ...\n    output a list of dict.\n    \"\"\"\n    trajectory = []\n    cur_role = \"rationale\"\n    cur_content = \"\"\n\n    for i, line in enumerate(traj_str.split(\"\\n\")):\n        if line == \"```python\":  # program begin\n            assert cur_role == \"rationale\"\n            if cur_content:\n                trajectory.append({\"role\": cur_role, \"content\": cur_content})\n                cur_content = \"\"\n            cur_role = \"program\"\n        elif cur_role == \"program\" and line == \"```\":  # program end\n            assert cur_content\n            trajectory.append({\"role\": cur_role, \"content\": cur_content})\n            cur_content = \"\"\n            cur_role = \"output\"\n        elif cur_role == \"output\" and line.startswith(\"```output\"):  # output begin\n            assert cur_content == \"\"\n        elif cur_role == \"output\" and line == \"```\":  # output end\n            trajectory.append({\"role\": cur_role, \"content\": cur_content})\n            cur_content = \"\"\n            cur_role = \"rationale\"\n        else:  # content\n            cur_content += line\n            if i < len(traj_str.split(\"\\n\")) - 1:\n                cur_content += \"\\n\"\n    # the last content\n    if cur_content:\n        trajectory.append({\"role\": cur_role, \"content\": cur_content})\n    return trajectory\n\n\ndef trajectory_to_text(trajectory: list) -> str:\n    text = \"\"\n    for item in trajectory:\n        content = item[\"content\"]\n        if item[\"role\"] == \"program\":\n            content = f\"```python\\n{content}```\\n\"\n        elif item[\"role\"] == \"output\":\n            content = f\"```output\\n{content}```\\n\"\n        text += content\n    return text\n\n\ndef is_execution_success(output):\n    error_key_words = [\"error\", \"exception\", \"no algorithms\", \"no algorithms\", \"cannot\", \"nan\", \"...\"]\n    success = all([k not in output.lower() for k in error_key_words])\n    return success\n\n\ndef extract_program(text: str = None, trajectory: list = None, last_only=False) -> str:\n    assert text is not None or trajectory is not None, \"Either text or trajectory should be provided.\"\n    if trajectory is None:\n        try:\n            trajectory = text_to_trajectory(text)\n        except:\n            return \"raise ValueError('Invalid trajectory')\"\n\n    program_list = []\n    import_lines = []\n    for i, item in enumerate(trajectory):\n        if item[\"role\"] == \"program\":\n            cur_program = item[\"content\"]\n            if i < len(trajectory) - 1:\n                assert trajectory[i + 1][\"role\"] == \"output\"\n                output = trajectory[i + 1][\"content\"].strip()\n                if is_execution_success(output):\n                    program_list.append(cur_program)\n                else:\n                    # extract import lines only\n                    for line in cur_program.split(\"\\n\"):\n                        if line.startswith(\"import\") or line.startswith(\"from\"):\n                            import_lines.append(line)\n            else:\n                program_list.append(cur_program)\n    # add import lines to the first program\n    if len(program_list) == 0:\n        program_list.append(\"\")\n    if len(import_lines) > 0:\n        program_list[0] = \"\\n\".join(import_lines) + \"\\n\" + program_list[0]\n    for i, program in enumerate(program_list[:-1]):\n        program_list[i] = \"\\n\".join([line for line in program.split(\"\\n\") if not line.strip().startswith(\"print(\")])\n\n    if last_only:\n        program = program_list[-1]\n    else:\n        program = \"\\n\".join(program_list)\n    return program\n\n\ndef extract_program_output(pred_str, last_only=True):\n    r\"\"\"\n    extract output between ```output\\n...\\n```, use regex, there might be multiple outputs, each output may have multiple lines\n    \"\"\"\n    outputs = re.findall(r\"```output\\n(.*?)\\n```\", pred_str, re.DOTALL)\n    if last_only:\n        return outputs[-1] if len(outputs) > 0 else \"\"\n    else:\n        return outputs\n\n\ndef _test_str_to_trajectory():\n    traj_text = r\"\"\"We can use the Chinese Remainder Theorem to solve this system of congruences. The Chinese Remainder Theorem states that if $n_1, n_2, \\ldots, n_k$ are pairwise coprime (i.e., the greatest common divisor of any two of them is 1), and if $a_1, a_2, \\ldots, a_k$ are any integers, then there is a number $x$ that satisfies the system of congruences:\n\n$x \\equiv a_1 \\pmod{n_1}$\n$x \\equiv a_2 \\pmod{n_2}$\n$\\vdots$\n$x \\equiv a_k \\pmod{n_k}$\n\nMoreover, any two solutions of this system are congruent modulo the product $n_1n_2 \\cdots n_k$.\n\nLet's write a function to solve this:\n\n```python\nfrom sympy import symbols, solve\n\ndef smallest_x():\n    x = symbols('x')\n    # Solve the system of congruences\n    solution = solve([x - 7, x - 17], x, domain='Z')\n    # Return the smallest positive solution\n    return min([sol for sol in solution if sol >= 0])\n\nresult = smallest_x()\nprint(result)\n```\n```output\nValueError: min() arg is an empty sequence\n```\nThe error in the last example is due to the incorrect usage of the `solve` function. The `solve` function is used to solve equations, not congruences. To solve a system of congruences, we can use the `solve_congruence` function from the `sympy.ntheory.modular` module.\n\nHere is the corrected code:\n\n```python\nfrom sympy.ntheory.modular import solve_congruence\n\ndef smallest_x():\n    # Solve the system of congruences\n    solution = solve_congruence(('x', 7, 12), ('x', 17, 11))\n    # Return the smallest positive solution\n    return solution[0][0]\n\nresult = smallest_x()\nprint(result)\n```\n```output\ngood\n```\nValueError: too many values to unpack (expected 2)\nThe error in the last example is due to the incorrect usage of the `solve_congruence` function. The `solve_congruence` function returns a tuple of two elements: the solution and the modulus. We need to unpack these two values correctly.\n\nHere is the corrected code:\n\n```python\nfrom sympy.ntheory.modular import solve_congruence\n\ndef smallest_x():\n    # Solve the system of congruences\n    solution, modulus = solve_congruence(('x', 7, 12), ('x', 17, 11))\n    # Return the smallest positive solution\n    return solution\n\nresult = smallest_x()\nprint(result)\n```\"\"\"\n\n    import pprint\n    trajectory = text_to_trajectory(traj_text)\n    pprint.pprint(trajectory)\n\n    text = trajectory_to_text(trajectory)\n    assert text == traj_text\n\n    # print(extract_program(traj_text))\n\n\nif __name__ == \"__main__\":\n    _test_str_to_trajectory()\n",
        "eval/eval/math_opensource_utils/utils.py": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport json\nimport logging\nimport os\nimport random\nfrom pathlib import Path\nfrom typing import Iterable, Union, Any\n\nimport numpy as np\n\nfrom .examples import get_examples\n\n\n\n\ndef set_seed(seed: int = 42) -> None:\n    np.random.seed(seed)\n    random.seed(seed)\n    os.environ[\"PYTHONHASHSEED\"] = str(seed)\n    logging.debug(f\"Random seed set as {seed}\")\n\n\ndef load_jsonl(file: Union[str, Path]) -> Iterable[Any]:\n    with open(file, \"r\", encoding=\"utf-8\") as f:\n        for idx, line in enumerate(f, start=1):\n            try:\n                yield json.loads(line)\n            except Exception as e:\n                raise ValueError(f\"Error in loading line {idx}: {line}\") from e\n\n\ndef save_jsonl(samples, save_path):\n    # ensure path\n    folder = os.path.dirname(save_path)\n    os.makedirs(folder, exist_ok=True)\n\n    with open(save_path, \"w\", encoding=\"utf-8\") as f:\n        for sample in samples:\n            f.write(json.dumps(sample, ensure_ascii=False) + \"\\n\")\n    logging.debug(\"Saved to\", save_path)\n\n\ndef lower_keys(example):\n    new_example = {}\n    for key, value in example.items():\n        if key != key.lower():\n            new_key = key.lower()\n            new_example[new_key] = value\n        else:\n            new_example[key] = value\n    return new_example\n\n\nEXAMPLES = get_examples()\n\n\ndef load_prompt(data_name, prompt_type, num_shots):\n    if not num_shots:\n        return []\n\n    if data_name in [\"gsm_hard\", \"svamp\", \"tabmwp\", \"asdiv\", \"mawps\"]:\n        data_name = \"gsm8k\"\n    if data_name in [\"math_oai\", \"hungarian_exam\", \"math-oai\", \"aime24\", \"amc23\"]:\n        data_name = \"math\"\n    if data_name in [\"sat_math\"]:\n        data_name = \"mmlu_stem\"\n    if data_name in [\n        \"gaokao2024_I\",\n        \"gaokao2024_II\",\n        \"gaokao_math_qa\",\n        \"gaokao2024_mix\",\n        \"cn_middle_school\",\n    ]:\n        data_name = \"gaokao\"\n\n    if prompt_type in [\"tool-integrated\"]:\n        prompt_type = \"tora\"\n\n    return EXAMPLES[data_name][:num_shots]\n\n\nPROMPT_TEMPLATES = {\n    \"direct\": (\"Question: {input}\\nAnswer: \", \"{output}\", \"\\n\\n\"),\n    \"cot\": (\"Question: {input}\\nAnswer: \", \"{output}\", \"\\n\\n\\n\"),\n    \"pal\": (\"Question: {input}\\n\\n\", \"{output}\", \"\\n---\\n\"),\n    \"tool-integrated\": (\"Question: {input}\\n\\nSolution:\\n\", \"{output}\", \"\\n---\\n\"),\n    \"self-instruct\": (\"<|user|>\\n{input}\\n<|assistant|>\\n\", \"{output}\", \"\\n\"),\n    \"tora\": (\"<|user|>\\n{input}\\n<|assistant|>\\n\", \"{output}\", \"\\n\"),\n    \"wizard_zs\": (\n        \"### Instruction:\\n{input}\\n\\n### Response: Let's think step by step.\",\n        \"{output}\",\n        \"\\n\\n\\n\",\n    ),\n    \"platypus_fs\": (\n        \"### Instruction:\\n{input}\\n\\n### Response:\\n\",\n        \"{output}\",\n        \"\\n\\n\\n\",\n    ),\n    \"deepseek-math\": (\n        \"User: {input}\\nPlease reason step by step, \"\n        \"and put your final answer within \\\\boxed{{}}.\\n\\nAssistant:\",\n        \"{output}\",\n        \"\\n\\n\\n\",\n    ),\n    \"kpmath\": (\n        \"User: Please reason step by step and put your final answer at the end \"\n        'with \"The answer is: \".\\n\\n{input}\\n\\nAssistant:',\n        \"{output}\",\n    ),\n    \"jiuzhang\": (\n        \"## Question\\n{input}\\n\\n## Solution\\n\",\n        \"{output}\",\n        \"\\n\\n\\n\",\n    ),\n    \"jiuzhang_tora\": (\n        \"## Question\\n{input}\\n\\n## Code Solution\\n\",\n        \"{output}\",\n        \"\\n\\n\\n\",\n    ),\n    \"jiuzhang_nl\": (\n        \"## Question\\n{input}\\n\\n## Natural Language Solution\\n\",\n        \"{output}\",\n        \"\\n\\n\\n\",\n    ),\n    \"mmiqc\": (\n        'Please solve the following problem and put your answer at the end with \"The answer is: \".\\n\\n{input}\\n\\n',\n        \"{output}\",\n        \"\\n\\n\\n\",\n    ),\n    \"abel\": (\n        \"Question:\\n{input}\\nAnswer:\\nLet's think step by step.\\n\",\n        \"{output}\",\n        \"\\n\\n\",\n    ),\n    \"shepherd\": (\"{input}\\n\", \"{output}\", \"\\n\\n\\n\"),\n    \"qwen-boxed\": (\n        \"<|im_start|>system\\nYou are a helpful assistant.<|im_end|>\\n\"\n        \"<|im_start|>user\\n{input}\\nPlease reason step by step, and put your final answer within \\\\boxed{{}}.<|im_end|>\\n\"\n        \"<|im_start|>assistant\\n\",\n        \"{output}\",\n        \"\\n\\n\",\n    ),\n    \"mathstral\": (\n        \"{input}\\nPlease reason step by step, and put your final answer within \\\\boxed{{}}.\",\n        \"{output}\",\n        \"\\n\\n\",\n    ),\n    \"internlm-math-fs\": (\"Question:{input}\\nAnswer:\", \"{output}\", \"\\n\"),\n    \"internlm-math-chat\": (\n        \"<|im_start|>user\\n{input}<|im_end|>\\n\" \"<|im_start|>assistant\\n\",\n        \"{output}\",\n        \"\\n\\n\",\n    ),\n    \"mistral\": (\n        \"[INST] {input}[/INST]\",\n        \"{output}\",\n        \"\\n\\n\",\n    ),\n    \"numina\": (\"### Problem: {input}\\n### Solution:\", \" {output}\", \"\\n\\n\"),\n}\n\n\ndef construct_prompt(example, data_name, args):\n    if args.adapt_few_shot and data_name in [\n        \"gaokao2024_I\",\n        \"gaokao2024_II\",\n        \"gaokao_math_qa\",\n        \"gaokao2024_mix\",\n        \"cn_middle_school\",\n    ]:\n        demos = load_prompt(data_name, args.prompt_type, 5)\n    else:\n        demos = load_prompt(data_name, args.prompt_type, args.num_shots)\n    prompt_type = args.prompt_type\n    if prompt_type == \"platypus_fs\":\n        prompt_type = \"cot\"\n    if prompt_type == \"tool-integrated\":\n        prompt_type = \"tora\"\n\n    prompt_temp = PROMPT_TEMPLATES[args.prompt_type]\n\n    splitter = prompt_temp[2]\n    input_template, output_template, splitter = (\n        prompt_temp[0],\n        prompt_temp[1],\n        prompt_temp[2],\n    )\n    demo_prompt = splitter.join(\n        [\n            input_template.format(input=q) + output_template.format(output=a)\n            for q, a in demos\n        ]\n    )\n    context = input_template.format(input=example[\"question\"])\n    if len(demo_prompt) == 0 or (\n        args.adapt_few_shot and example[\"gt_ans\"] not in [\"A\", \"B\", \"C\", \"D\", \"E\"]\n    ):\n        full_prompt = context\n    else:\n        full_prompt = demo_prompt + splitter + context\n\n    if args.prompt_type == \"platypus_fs\":\n        full_prompt_temp = (\n            \"Below is an instruction that describes a task. \"\n            \"Write a response that appropriately completes the request.\\n\\n\"\n            \"### Instruction:\\n{instruction}\\n\\n### Response:\\n\"\n        )\n        full_prompt = full_prompt_temp.format(instruction=full_prompt)\n\n    if prompt_type == \"tora\":\n        full_prompt = (\n            \"\"\"Integrate step-by-step reasoning and Python code to solve math problems using the following guidelines:\n\n- Analyze the question and write functions to solve the problem; the function should not take any arguments.\n- Present the final result in LaTeX using a `\\boxed{}` without any units.\n- Utilize the `pi` symbol and `Rational`` from Sympy for $\\pi$ and fractions, and simplify all fractions and square roots without converting them to decimal values.\n\nHere are some examples you may refer to:\n\n---\n\n\"\"\"\n            + full_prompt\n        )\n\n    return full_prompt.strip(\" \")  # important!\n\n\nkey_map = {\n    \"gt\": \"Ground Truth\",\n    \"pred\": \"Prediction\",\n    \"gt_cot\": \"Reference CoT\",\n    \"score\": \"Score\",\n}\n\n\ndef show_sample(sample, print_all_preds=False):\n    print(\"==\" * 20)\n    for key in [\"idx\", \"type\", \"level\", \"dataset\"]:\n        if key in sample:\n            # capitalize\n            print(\"{}: {}\".format(key[0].upper() + key[1:], sample[key]))\n    print(\"Question:\", repr(sample[\"question\"]))\n    if \"code\" in sample:\n        if print_all_preds:\n            for code in sample[\"code\"]:\n                print(\"-\" * 20)\n                print(\"code:\", code)\n            print(\"Execution:\", sample[\"report\"])\n        else:\n            print(\"Solution:\\n\", sample[\"code\"][0])\n            print(\"Execution:\", sample[\"report\"][0])\n    if \"pred\" in sample:\n        print(\"Prediction:\", repr(sample[\"pred\"][0]))\n    for key in [\"gt\", \"score\", \"unit\", \"gt_cot\"]:\n        if key in sample:\n            _key = key_map.get(key, key)\n            print(\"{}: {}\".format(_key, repr(sample[key])))\n    print()\n",
        "eval/generate_api_answers/infer_multithread.py": "import json\nimport argparse\nfrom tqdm import tqdm\nimport copy\nimport concurrent.futures\nimport threading\nimport os\nimport collections\n\nfrom utils_vllm import get_content\n\nfile_lock = threading.Lock()\n\ndef count_completed_samples(output_file):\n    prompt_counts = collections.defaultdict(int)\n    if os.path.exists(output_file) and os.path.getsize(output_file) > 0:\n        with open(output_file, 'r', encoding='utf-8') as f:\n            for line in f:\n                try:\n                    item = json.loads(line)\n                    prompt = item['prompt']\n                    gen_count = len(item.get('gen', []))\n                    prompt_counts[prompt] += gen_count\n                except json.JSONDecodeError:\n                    continue\n    return prompt_counts\n\ndef process_item(item, output_file, base_url, model_name):\n    result = copy.deepcopy(item)\n\n    response = get_content(item['prompt'], base_url, model_name)\n\n    if 'gen' not in result:\n        result['gen'] = []\n    \n    result['gen'].append(response)\n    with file_lock:\n        with open(output_file, 'a', encoding='utf-8') as g:\n            g.write(json.dumps(result, ensure_ascii=False) + '\\n')\n            g.flush()\n    \n    return result\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Run inference on model with prompts from a jsonl file\")\n    parser.add_argument(\"--input_file\", type=str, required=True, help=\"Input jsonl file path\")\n    parser.add_argument(\"--output_file\", type=str, required=True, help=\"Output file path\")\n    parser.add_argument(\"--n_samples\", type=int, default=64, help=\"Number of samples per prompt\")\n    parser.add_argument(\"--max_workers\", type=int, default=128, help=\"Maximum number of worker threads\")\n    parser.add_argument(\"--base_url\", type=str, default='http://10.77.249.36:8030/v1', help=\"base url of vllm server\")\n    parser.add_argument(\"--model_name\", type=str, default='Qwen/QwQ-32B', help=\"model name of vllm server\")\n    args = parser.parse_args()\n\n    with open(args.input_file, 'r', encoding='utf-8') as f:\n        data = [json.loads(l) for l in f]\n    \n    if os.path.exists(args.output_file):\n        completed_counts = count_completed_samples(args.output_file)\n        total_completed = sum(completed_counts.values())\n        print(f\"Found {total_completed} completed samples from previous run\")\n    else:\n        with open(args.output_file, 'w', encoding='utf-8') as g:\n            completed_counts = dict()\n\n    expanded_data = []\n    for item in data:\n        prompt = item['prompt']\n        completed = completed_counts.get(prompt, 0)\n        remaining = args.n_samples - completed\n        for _ in range(remaining):\n            expanded_data.append(copy.deepcopy(item))\n    \n    total_tasks = len(expanded_data)\n    print(f\"Total remaining samples to process: {total_tasks}\")\n\n    completed_count = 0\n\n    with concurrent.futures.ThreadPoolExecutor(max_workers=args.max_workers) as executor:\n        future_to_item = {executor.submit(process_item, item, args.output_file, args.base_url, args.model_name): i \n                          for i, item in enumerate(expanded_data)}\n        \n        with tqdm(total=len(expanded_data), desc=\"Processing samples\") as pbar:\n            for future in concurrent.futures.as_completed(future_to_item):\n                idx = future_to_item[future]\n                try:\n                    future.result()  \n                    completed_count += 1\n                except Exception as exc:\n                    print(f'Error processing sample {idx}: {exc}')\n                pbar.update(1)\n    \n    print(f\"Completed {completed_count}/{len(expanded_data)} samples\")\n    print(f\"Results saved to {args.output_file}\")\n\nif __name__ == \"__main__\":\n    main()",
        "eval/generate_api_answers/utils_vllm.py": "import os\nimport time\nimport random\nimport openai\nimport logging\nfrom packaging.version import parse as parse_version\n\nIS_OPENAI_V1 = parse_version(openai.__version__) >= parse_version('1.0.0')\n\nif IS_OPENAI_V1:\n    from openai import APIError, APIConnectionError, RateLimitError\nelse:\n    from openai.error import APIError, APIConnectionError, RateLimitError\n\nclass ClientError(RuntimeError):\n    pass\ndef get_content(query, base_url, model_name):\n    API_KEY = os.environ.get(\"OPENAI_API_KEY\", \"EMPTY\")\n    API_REQUEST_TIMEOUT = int(os.getenv('OPENAI_API_REQUEST_TIMEOUT', '99999'))\n    if IS_OPENAI_V1:\n        import httpx\n        client = openai.OpenAI(\n            api_key=API_KEY,\n            base_url=base_url,\n            timeout=httpx.Timeout(API_REQUEST_TIMEOUT),\n        )\n    else:\n        client = None\n    messages = [{'role': 'user', 'content': query}]\n    call_args = dict(\n            model=model_name,\n            messages=messages,\n            temperature=0.6,\n            top_p=0.95,\n            max_tokens=32768,\n        )\n    if IS_OPENAI_V1:\n            call_args['extra_body'] = {}\n            extra_args_dict = call_args['extra_body']\n    else:\n        extra_args_dict = call_args\n    extra_args_dict.update({\n        'top_k': 40,\n    })\n    \n    if IS_OPENAI_V1:\n        call_func = client.chat.completions.create\n        call_args['timeout'] = API_REQUEST_TIMEOUT\n    else:\n        call_func = openai.ChatCompletion.create\n        call_args['api_key'] = API_KEY\n        call_args['api_base'] = base_url\n        call_args['request_timeout'] = API_REQUEST_TIMEOUT\n\n    result = ''\n    try:\n        completion = call_func(**call_args, )\n        result = completion.choices[0].message.content              \n    except AttributeError as e:\n        err_msg = getattr(completion, \"message\", \"\")\n        if err_msg:\n            time.sleep(random.randint(25, 35))\n            raise ClientError(err_msg) from e\n        raise ClientError(err_msg) from e\n    except (APIConnectionError, RateLimitError) as e:\n        err_msg = e.message if IS_OPENAI_V1 else e.user_message\n        time.sleep(random.randint(25, 35))\n        raise ClientError(err_msg) from e\n    except APIError as e:\n        err_msg = e.message if IS_OPENAI_V1 else e.user_message\n        if \"maximum context length\" in err_msg:  # or \"Expecting value: line 1 column 1 (char 0)\" in err_msg:\n            logging.warn(f\"max length exceeded. Error: {err_msg}\")\n            return {'gen': \"\", 'end_reason': \"max length exceeded\"}\n        time.sleep(1)\n        raise ClientError(err_msg) from e\n    return result\n\nif __name__ == \"__main__\":\n    conversation_history = []\n    user_input = \"Hello!\"\n    res = get_content(user_input, \"http://10.77.249.36:8030/v1\", \"Qwen/QwQ\")\n    print(f\"Response: {res}\")\n\n    user_input = \"How are you?\"\n    res = get_content(user_input, \"http://10.77.249.36:8030/v1\", \"Qwen/QwQ\")\n    print(f\"Response: {res}\")"
    }
}