{
  "model_id": "meta-llama/llama-3.3-70b-instruct",
  "full_texts": [
    {
      "arxiv_id": "https://www.llama.com/docs/overview",
      "full_text": " Docs &amp; Resources | Llama AI "
    },
    {
      "arxiv_id": "https://llama.com/docs/overview",
      "full_text": " Docs &amp; Resources | Llama AI "
    },
    {
      "arxiv_id": "https://llama.meta.com/docs/model-cards-and-prompt-formats/llama3_1/",
      "full_text": " Llama 3.1 | Model Cards and Prompt formats "
    },
    {
      "arxiv_id": "https://huggingface.co/docs/transformers/main/chat_templating#advanced-tool-use--function-calling",
      "full_text": " Llama Hugging Face Models Datasets Spaces Community Docs Enterprise Pricing Log In Sign Up Transformers documentation Llama Transformers ðŸ¡ View all docs AWS Trainium &amp; Inferentia Accelerate Argilla AutoTrain Bitsandbytes Chat UI Dataset viewer Datasets Deploying on AWS Diffusers Distilabel Evaluate Gradio Hub Hub Python Library Huggingface.js Inference Endpoints (dedicated) Inference Providers LeRobot Leaderboards Lighteval Microsoft Azure Optimum PEFT Safetensors Sentence Transformers TRL Tasks Text Embeddings Inference Text Generation Inference Tokenizers Trackio Transformers Transformers.js smolagents timm Search documentation main v4.56.1 v4.55.4 v4.53.3 v4.52.3 v4.51.3 v4.50.0 v4.49.0 v4.48.2 v4.47.1 v4.46.3 v4.45.2 v4.44.2 v4.43.4 v4.42.4 v4.41.2 v4.40.2 v4.39.3 v4.38.2 v4.37.2 v4.36.1 v4.35.2 v4.34.1 v4.33.3 v4.32.1 v4.31.0 v4.30.0 v4.29.1 v4.28.1 v4.27.2 v4.26.1 v4.25.1 v4.24.0 v4.23.1 v4.22.2 v4.21.3 v4.20.1 v4.19.4 v4.18.0 v4.17.0 v4.16.2 v4.15.0 v4.14.1 v4.13.0 v4.12.5 v4.11.3 v4.10.1 v4.9.2 v4.8.2 v4.7.0 v4.6.0 v4.5.1 v4.4.2 v4.3.3 v4.2.2 v4.1.1 v4.0.1 v3.5.1 v3.4.0 v3.3.1 v3.2.0 v3.1.0 v3.0.2 v2.11.0 v2.10.0 v2.9.1 v2.8.0 v2.7.0 v2.6.0 v2.5.1 v2.4.1 v2.3.0 v2.2.2 v2.1.1 v2.0.0 v1.2.0 v1.1.0 v1.0.0 doc-builder-html AR DE EN ES FR HI IT JA KO PT TE TR ZH Get started Transformers Installation Quickstart Base classes Inference Training Quantization Export to production Resources Contribute API Main Classes Models Text models ALBERT Apertus Arcee Bamba BART BARThez BARTpho BERT BertGeneration BertJapanese BERTweet BigBird BigBirdPegasus BioGpt BitNet Blenderbot Blenderbot Small BLOOM BORT ByT5 CamemBERT CANINE CodeGen CodeLlama Cohere Cohere2 ConvBERT CPM CPMANT CTRL DBRX DeBERTa DeBERTa-v2 DeepSeek-V3 DialoGPT DiffLlama DistilBERT Doge dots1 DPR ELECTRA Encoder Decoder Models ERNIE Ernie4_5 Ernie4_5_MoE ErnieM ESM EXAONE-4.0 Falcon Falcon3 FalconH1 FalconMamba FLAN-T5 FLAN-UL2 FlauBERT FNet FSMT Funnel Transformer Fuyu Gemma Gemma2 GLM glm4 glm4_moe GPT GPT Neo GPT NeoX GPT NeoX Japanese GPT-J GPT2 GPTBigCode GptOss GPTSAN Japanese GPTSw3 Granite GraniteMoe GraniteMoeHybrid GraniteMoeShared Helium HerBERT HGNet-V2 HunYuanDenseV1 HunYuanMoEV1 I-BERT Jamba JetMoe Jukebox LED LFM2 LLaMA Llama2 Llama3 Longformer LongT5 LUKE M2M100 MADLAD-400 Mamba Mamba2 MarianMT MarkupLM MBart and MBart-50 MEGA MegatronBERT MegatronGPT2 MiniMax Ministral Mistral Mixtral mLUKE MobileBERT ModernBert ModernBERTDecoder MPNet MPT MRA MT5 MVP myt5 Nemotron NEZHA NLLB NLLB-MoE NystrÃ¶mformer OLMo OLMo2 OLMoE Open-Llama OPT Pegasus PEGASUS-X Persimmon Phi Phi-3 PhiMoE PhoBERT PLBart ProphetNet QDQBert Qwen2 Qwen2MoE Qwen3 Qwen3MoE Qwen3Next RAG REALM RecurrentGemma Reformer RemBERT RetriBERT RoBERTa RoBERTa-PreLayerNorm RoCBert RoFormer RWKV Seed-Oss Splinter SqueezeBERT StableLm Starcoder2 SwitchTransformers T5 T5Gemma T5v1.1 TAPEX Transformer XL UL2 UMT5 VaultGemma X-MOD XGLM XLM XLM-ProphetNet XLM-RoBERTa XLM-RoBERTa-XL XLM-V XLNet xLSTM YOSO Zamba Zamba2 Vision models Audio models Video models Multimodal models Reinforcement learning models Time series models Graph models Internal helpers Reference You are viewing main version, which requires installation from source . If you&#39;d like regular pip install, checkout the latest stable version ( v4.56.1 ). Join the Hugging Face community and get access to the augmented documentation experience Collaborate on models, datasets and Spaces Faster examples with accelerated inference Switch between documentation themes Sign Up to get started This model was released on 2023-02-27 and added to Hugging Face Transformers on 2023-03-16. Llama Llama is a family of large language models ranging from 7B to 65B parameters. These models are focused on efficient inference (important for serving language models) by training a smaller model on more tokens rather than training a larger model on fewer tokens. The Llama model is based on the GPT architecture, but it uses pre-normalization to improve training stability, replaces ReLU with SwiGLU to improve performance, and replaces absolute positional embeddings with rotary positional embeddings (RoPE) to better handle longer sequence lengths. You can find all the original Llama checkpoints under the Huggy Llama organization. Click on the Llama models in the right sidebar for more examples of how to apply Llama to different language tasks. The example below demonstrates how to generate text with Pipeline or the AutoModel , and from the command line. Pipeline AutoModel transformers CLI Copied import torch from transformers import pipeline pipeline = pipeline( task= &quot;text-generation&quot; , model= &quot;huggyllama/llama-7b&quot; , dtype=torch.float16, device= 0 ) pipeline( &quot;Plants create energy through a process known as&quot; ) Quantization reduces the memory burden of large models by representing the weights in a lower precision. Refer to the Quantization overview for more available quantization backends. The example below uses torchao to only quantize the weights to int4. Copied # pip install torchao import torch from transformers import TorchAoConfig, AutoModelForCausalLM, AutoTokenizer quantization_config = TorchAoConfig( &quot;int4_weight_only&quot; , group_size= 128 ) model = AutoModelForCausalLM.from_pretrained( &quot;huggyllama/llama-30b&quot; , dtype=torch.bfloat16, device_map= &quot;auto&quot; , quantization_config=quantization_config ) tokenizer = AutoTokenizer.from_pretrained( &quot;huggyllama/llama-30b&quot; ) input_ids = tokenizer( &quot;Plants create energy through a process known as&quot; , return_tensors= &quot;pt&quot; ).to(model.device) output = model.generate(**input_ids, cache_implementation= &quot;static&quot; ) print (tokenizer.decode(output[ 0 ], skip_special_tokens= True )) Use the AttentionMaskVisualizer to better understand what tokens the model can and cannot attend to. Copied from transformers.utils.attention_visualizer import AttentionMaskVisualizer visualizer = AttentionMaskVisualizer( &quot;huggyllama/llama-7b&quot; ) visualizer( &quot;Plants create energy through a process known as&quot; ) Notes The tokenizer is a byte-pair encoding model based on SentencePiece . During decoding, if the first token is the start of the word (for example, â€œBananaâ€), the tokenizer doesnâ€™t prepend the prefix space to the string. LlamaConfig class transformers. LlamaConfig &lt; source &gt; ( vocab_size = 32000 hidden_size = 4096 intermediate_size = 11008 num_hidden_layers = 32 num_attention_heads = 32 num_key_value_heads = None hidden_act = 'silu' max_position_embeddings = 2048 initializer_range = 0.02 rms_norm_eps = 1e-06 use_cache = True pad_token_id = None bos_token_id = 1 eos_token_id = 2 pretraining_tp = 1 tie_word_embeddings = False rope_theta = 10000.0 rope_scaling = None attention_bias = False attention_dropout = 0.0 mlp_bias = False head_dim = None **kwargs ) Parameters vocab_size ( int , optional , defaults to 32000) &#x2014; Vocabulary size of the LLaMA model. Defines the number of different tokens that can be represented by the inputs_ids passed when calling LlamaModel hidden_size ( int , optional , defaults to 4096) &#x2014; Dimension of the hidden representations. intermediate_size ( int , optional , defaults to 11008) &#x2014; Dimension of the MLP representations. num_hidden_layers ( int , optional , defaults to 32) &#x2014; Number of hidden layers in the Transformer decoder. num_attention_heads ( int , optional , defaults to 32) &#x2014; Number of attention heads for each attention layer in the Transformer decoder. num_key_value_heads ( int , optional ) &#x2014; This is the number of key_value heads that should be used to implement Grouped Query Attention. If num_key_value_heads=num_attention_heads , the model will use Multi Head Attention (MHA), if num_key_value_heads=1 the model will use Multi Query Attention (MQA) otherwise GQA is used. When converting a multi-head checkpoint to a GQA checkpoint, each group key and value head should be constructed by meanpooling all the original heads within that group. For more details, check out this paper . If it is not specified, will default to num_attention_heads . hidden_act ( str or function , optional , defaults to &quot;silu&quot; ) &#x2014; The non-linear activation function (function or string) in the decoder. max_position_embeddings ( int , optional , defaults to 2048) &#x2014; The maximum sequence length that this model might ever be used with. Llama 1 supports up to 2048 tokens, Llama 2 up to 4096, CodeLlama up to 16384. initializer_range ( float , optional , defaults to 0.02) &#x2014; The standard deviation of the truncated_normal_initializer for initializing all weight matrices. rms_norm_eps ( float , optional , defaults to 1e-06) &#x2014; The epsilon used by the rms normalization layers. use_cache ( bool , optional , defaults to True ) &#x2014; Whether or not the model should return the last key/values attentions (not used by all models). Only relevant if config.is_decoder=True . pad_token_id ( int , optional ) &#x2014; Padding token id. bos_token_id ( int , optional , defaults to 1) &#x2014; Beginning of stream token id. eos_token_id ( int , optional , defaults to 2) &#x2014; End of stream token id. pretraining_tp ( int , optional , defaults to 1) &#x2014; Experimental feature. Tensor parallelism rank used during pretraining. Please refer to this document to understand more about it. This value is necessary to ensure exact reproducibility of the pretraining results. Please refer to this issue . tie_word_embeddings ( bool , optional , defaults to False ) &#x2014; Whether to tie weight embeddings rope_theta ( float , optional , defaults to 10000.0) &#x2014; The base period of the RoPE embeddings. rope_scaling ( Dict , optional ) &#x2014; Dictionary containing the scaling configuration for the RoPE embeddings. NOTE: if you apply new rope type and you expect the model to work on longer max_position_embeddings , we recommend you to update this value accordingly. Expected contents: rope_type ( str ): The sub-variant of RoPE to use. Can be one of [&#x2018;default&#x2019;, &#x2018;linear&#x2019;, &#x2018;dynamic&#x2019;, &#x2018;yarn&#x2019;, &#x2018;longrope&#x2019;, &#x2018;llama3&#x2019;], with &#x2018;default&#x2019; being the original RoPE implementation. factor ( float , optional ): Used with all rope types except &#x2018;default&#x2019;. The scaling factor to apply to the RoPE embeddings. In most scaling types, a factor of x will enable the model to handle sequences of length x original maximum pre-trained length. original_max_position_embeddings ( int , optional ): Used with &#x2018;dynamic&#x2019;, &#x2018;longrope&#x2019; and &#x2018;llama3&#x2019;. The original max position embeddings used during pretraining. attention_factor ( float , optional ): Used with &#x2018;yarn&#x2019; and &#x2018;longrope&#x2019;. The scaling factor to be applied on the attention computation. If unspecified, it defaults to value recommended by the implementation, using the factor field to infer the suggested value. beta_fast ( float , optional ): Only used with &#x2018;yarn&#x2019;. Parameter to set the boundary for extrapolation (only) in the linear ramp function. If unspecified, it defaults to 32. beta_slow ( float , optional ): Only used with &#x2018;yarn&#x2019;. Parameter to set the boundary for interpolation (only) in the linear ramp function. If unspecified, it defaults to 1. short_factor ( list[float] , optional ): Only used with &#x2018;longrope&#x2019;. The scaling factor to be applied to short contexts (&lt; original_max_position_embeddings ). Must be a list of numbers with the same length as the hidden size divided by the number of attention heads divided by 2 long_factor ( list[float] , optional ): Only used with &#x2018;longrope&#x2019;. The scaling factor to be applied to long contexts (&lt; original_max_position_embeddings ). Must be a list of numbers with the same length as the hidden size divided by the number of attention heads divided by 2 low_freq_factor ( float , optional ): Only used with &#x2018;llama3&#x2019;. Scaling factor applied to low frequency components of the RoPE high_freq_factor ( float , optional*): Only used with &#x2018;llama3&#x2019;. Scaling factor applied to high frequency components of the RoPE attention_bias ( bool , optional , defaults to False ) &#x2014; Whether to use a bias in the query, key, value and output projection layers during self-attention. attention_dropout ( float , optional , defaults to 0.0) &#x2014; The dropout ratio for the attention probabilities. mlp_bias ( bool , optional , defaults to False ) &#x2014; Whether to use a bias in up_proj, down_proj and gate_proj layers in the MLP layers. head_dim ( int , optional ) &#x2014; The attention head dimension. If None, it will default to hidden_size // num_attention_heads This is the configuration class to store the configuration of a LlamaModel . It is used to instantiate an LLaMA model according to the specified arguments, defining the model architecture. Instantiating a configuration with the defaults will yield a similar configuration to that of the LLaMA-7B. e.g. meta-llama/Llama-2-7b-hf Configuration objects inherit from PretrainedConfig and can be used to control the model outputs. Read the documentation from PretrainedConfig for more information. Copied &gt;&gt;&gt; from transformers import LlamaModel, LlamaConfig &gt;&gt;&gt; # Initializing a LLaMA llama-7b style configuration &gt;&gt;&gt; configuration = LlamaConfig() &gt;&gt;&gt; # Initializing a model from the llama-7b style configuration &gt;&gt;&gt; model = LlamaModel(configuration) &gt;&gt;&gt; # Accessing the model configuration &gt;&gt;&gt; configuration = model.config LlamaTokenizer class transformers. LlamaTokenizer &lt; source &gt; ( vocab_file unk_token = '&lt;unk>' bos_token = '&lt;s>' eos_token = '&lt;/s>' pad_token = None sp_model_kwargs : typing.Optional[dict[str, typing.Any]] = None add_bos_token = True add_eos_token = False clean_up_tokenization_spaces = False use_default_system_prompt = False spaces_between_special_tokens = False legacy = None add_prefix_space = True **kwargs ) Parameters vocab_file ( str ) &#x2014; Path to the vocabulary file. unk_token ( str or tokenizers.AddedToken , optional , defaults to &quot;&lt;unk&gt;&quot; ) &#x2014; The unknown token. A token that is not in the vocabulary cannot be converted to an ID and is set to be this token instead. bos_token ( str or tokenizers.AddedToken , optional , defaults to &quot;&lt;s&gt;&quot; ) &#x2014; The beginning of sequence token that was used during pretraining. Can be used a sequence classifier token. eos_token ( str or tokenizers.AddedToken , optional , defaults to &quot;&lt;/s&gt;&quot; ) &#x2014; The end of sequence token. pad_token ( str or tokenizers.AddedToken , optional ) &#x2014; A special token used to make arrays of tokens the same size for batching purpose. Will then be ignored by attention mechanisms or loss computation. sp_model_kwargs ( dict[str, Any] , Optional , optional ) &#x2014; Will be passed to the SentencePieceProcessor.__init__() method. The Python wrapper for SentencePiece can be used, among other things, to set: enable_sampling : Enable subword regularization. nbest_size : Sampling parameters for unigram. Invalid for BPE-Dropout. nbest_size = {0,1} : No sampling is performed. nbest_size &gt; 1 : samples from the nbest_size results. nbest_size &lt; 0 : assuming that nbest_size is infinite and samples from the all hypothesis (lattice) using forward-filtering-and-backward-sampling algorithm. alpha : Smoothing parameter for unigram sampling, and dropout probability of merge operations for BPE-dropout. add_bos_token ( bool , optional , defaults to True ) &#x2014; Whether or not to add an bos_token at the start of sequences. add_eos_token ( bool , optional , defaults to False ) &#x2014; Whether or not to add an eos_token at the end of sequences. clean_up_tokenization_spaces ( bool , optional , defaults to False ) &#x2014; Whether or not to cleanup spaces after decoding, cleanup consists in removing potential artifacts like extra spaces. use_default_system_prompt ( bool , optional , defaults to False ) &#x2014; Whether or not the default system prompt for Llama should be used. spaces_between_special_tokens ( bool , optional , defaults to False ) &#x2014; Whether or not to add spaces between special tokens. legacy ( bool , optional ) &#x2014; Whether or not the legacy behavior of the tokenizer should be used. Legacy is before the merge of #24622 and #25224 which includes fixes to properly handle tokens that appear after special tokens. Make sure to also set from_slow to True . A simple example: legacy=True : Construct a Llama tokenizer. Based on byte-level Byte-Pair-Encoding. The default padding token is unset as there is no padding token in the original model. build_inputs_with_special_tokens &lt; source &gt; ( token_ids_0 token_ids_1 = None ) get_special_tokens_mask &lt; source &gt; ( token_ids_0 : list token_ids_1 : typing.Optional[list[int]] = None already_has_special_tokens : bool = False ) â†’ list[int] Parameters token_ids_0 ( list[int] ) &#x2014; List of IDs. token_ids_1 ( list[int] , optional ) &#x2014; Optional second list of IDs for sequence pairs. already_has_special_tokens ( bool , optional , defaults to False ) &#x2014; Whether or not the token list is already formatted with special tokens for the model. Returns list[int] A list of integers in the range [0, 1]: 1 for a special token, 0 for a sequence token. Retrieve sequence ids from a token list that has no special tokens added. This method is called when adding special tokens using the tokenizer prepare_for_model method. create_token_type_ids_from_sequences &lt; source &gt; ( token_ids_0 : list token_ids_1 : typing.Optional[list[int]] = None ) â†’ list[int] Parameters token_ids_0 ( list[int] ) &#x2014; List of ids. token_ids_1 ( list[int] , optional ) &#x2014; Optional second list of IDs for sequence pairs. Returns list[int] List of token type IDs according to the given sequence(s). Creates a mask from the two sequences passed to be used in a sequence-pair classification task. An ALBERT sequence pair mask has the following format: Copied 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 | first sequence | second sequence | if token_ids_1 is None, only returns the first portion of the mask (0s). save_vocabulary &lt; source &gt; ( save_directory filename_prefix : typing.Optional[str] = None ) â†’ Tuple(str) Parameters save_directory ( str ) &#x2014; The directory in which to save the vocabulary. Returns Tuple(str) Paths to the files saved. Save the vocabulary and special tokens file to a directory. LlamaTokenizerFast class transformers. LlamaTokenizerFast &lt; source &gt; ( vocab_file = None tokenizer_file = None clean_up_tokenization_spaces = False unk_token = '&lt;unk>' bos_token = '&lt;s>' eos_token = '&lt;/s>' add_bos_token = True add_eos_token = False use_default_system_prompt = False legacy = None add_prefix_space = None **kwargs ) Parameters vocab_file ( str , optional ) &#x2014; SentencePiece file (generally has a .model extension) that contains the vocabulary necessary to instantiate a tokenizer. tokenizer_file ( str , optional ) &#x2014; tokenizers file (generally has a .json extension) that contains everything needed to load the tokenizer. clean_up_tokenization_spaces ( bool , optional , defaults to False ) &#x2014; Whether or not to cleanup spaces after decoding, cleanup consists in removing potential artifacts like extra spaces. unk_token ( str or tokenizers.AddedToken , optional , defaults to &quot;&lt;unk&gt;&quot; ) &#x2014; The unknown token. A token that is not in the vocabulary cannot be converted to an ID and is set to be this token instead. bos_token ( str or tokenizers.AddedToken , optional , defaults to &quot;&lt;s&gt;&quot; ) &#x2014; The beginning of sequence token that was used during pretraining. Can be used a sequence classifier token. eos_token ( str or tokenizers.AddedToken , optional , defaults to &quot;&lt;/s&gt;&quot; ) &#x2014; The end of sequence token. add_bos_token ( bool , optional , defaults to True ) &#x2014; Whether or not to add an bos_token at the start of sequences. add_eos_token ( bool , optional , defaults to False ) &#x2014; Whether or not to add an eos_token at the end of sequences. use_default_system_prompt ( bool , optional , defaults to False ) &#x2014; Whether or not the default system prompt for Llama should be used legacy ( bool , optional ) &#x2014; Whether or not the legacy behavior of the tokenizer should be used. Legacy is before the merge of #24622 and #25224 which includes fixes to properly handle tokens that appear after special tokens. Make sure to also set from_slow to True . A simple example: legacy=True : Construct a Llama tokenizer. Based on byte-level Byte-Pair-Encoding. This uses notably ByteFallback and no normalization. Copied &gt;&gt;&gt; from transformers import LlamaTokenizerFast &gt;&gt;&gt; tokenizer = LlamaTokenizerFast.from_pretrained( &quot;hf-internal-testing/llama-tokenizer&quot; ) &gt;&gt;&gt; tokenizer.encode( &quot;Hello this is a test&quot; ) [ 1 , 15043 , 445 , 338 , 263 , 1243 ] If you want to change the bos_token or the eos_token , make sure to specify them when initializing the model, or call tokenizer.update_post_processor() to make sure that the post-processing is correctly done (otherwise the values of the first token and final token of an encoded sequence will not be correct). For more details, checkout [post-processors] ( https://huggingface.co/docs/tokenizers/api/post-processors ) documentation. This tokenizer inherits from PreTrainedTokenizerFast which contains most of the main methods. Users should refer to this superclass for more information regarding those methods. build_inputs_with_special_tokens &lt; source &gt; ( token_ids_0 token_ids_1 = None ) get_special_tokens_mask &lt; source &gt; ( token_ids_0 : list token_ids_1 : typing.Optional[list[int]] = None already_has_special_tokens : bool = False ) â†’ A list of integers in the range [0, 1] Parameters token_ids_0 ( list[int] ) &#x2014; List of ids of the first sequence. token_ids_1 ( list[int] , optional ) &#x2014; List of ids of the second sequence. already_has_special_tokens ( bool , optional , defaults to False ) &#x2014; Whether or not the token list is already formatted with special tokens for the model. Returns A list of integers in the range [0, 1] 1 for a special token, 0 for a sequence token. Retrieves sequence ids from a token list that has no special tokens added. This method is called when adding special tokens using the tokenizer prepare_for_model or encode_plus methods. create_token_type_ids_from_sequences &lt; source &gt; ( token_ids_0 : list token_ids_1 : typing.Optional[list[int]] = None ) â†’ list[int] Parameters token_ids_0 ( list[int] ) &#x2014; The first tokenized sequence. token_ids_1 ( list[int] , optional ) &#x2014; The second tokenized sequence. Returns list[int] The token type ids. Create the token type IDs corresponding to the sequences passed. What are token type IDs? Should be overridden in a subclass if the model has a special way of building those. update_post_processor &lt; source &gt; ( ) Updates the underlying post processor with the current bos_token and eos_token . save_vocabulary &lt; source &gt; ( save_directory : str filename_prefix : typing.Optional[str] = None ) LlamaModel class transformers. LlamaModel &lt; source &gt; ( config : LlamaConfig ) Parameters config ( LlamaConfig ) &#x2014; Model configuration class with all the parameters of the model. Initializing with a config file does not load the weights associated with the model, only the configuration. Check out the from_pretrained() method to load the model weights. The bare Llama Model outputting raw hidden-states without any specific head on top. This model inherits from PreTrainedModel . Check the superclass documentation for the generic methods the library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads etc.) This model is also a PyTorch torch.nn.Module subclass. Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage and behavior. forward &lt; source &gt; ( input_ids : typing.Optional[torch.LongTensor] = None attention_mask : typing.Optional[torch.Tensor] = None position_ids : typing.Optional[torch.LongTensor] = None past_key_values : typing.Optional[transformers.cache_utils.Cache] = None inputs_embeds : typing.Optional[torch.FloatTensor] = None cache_position : typing.Optional[torch.LongTensor] = None use_cache : typing.Optional[bool] = None **kwargs : typing_extensions.Unpack[transformers.utils.generic.TransformersKwargs] ) â†’ transformers.modeling_outputs.BaseModelOutputWithPast or tuple(torch.FloatTensor) Parameters input_ids ( torch.LongTensor of shape (batch_size, sequence_length) , optional ) &#x2014; Indices of input sequence tokens in the vocabulary. Padding will be ignored by default. Indices can be obtained using AutoTokenizer . See PreTrainedTokenizer.encode() and PreTrainedTokenizer. call () for details. What are input IDs? attention_mask ( torch.Tensor of shape (batch_size, sequence_length) , optional ) &#x2014; Mask to avoid performing attention on padding token indices. Mask values selected in [0, 1] : 1 for tokens that are not masked , 0 for tokens that are masked . What are attention masks? position_ids ( torch.LongTensor of shape (batch_size, sequence_length) , optional ) &#x2014; Indices of positions of each input sequence tokens in the position embeddings. Selected in the range [0, config.n_positions - 1] . What are position IDs? past_key_values ( ~cache_utils.Cache , optional ) &#x2014; Pre-computed hidden-states (key and values in the self-attention blocks and in the cross-attention blocks) that can be used to speed up sequential decoding. This typically consists in the past_key_values returned by the model at a previous stage of decoding, when use_cache=True or config.use_cache=True . Only Cache instance is allowed as input, see our kv cache guide . If no past_key_values are passed, DynamicCache will be initialized by default. The model will output the same cache format that is fed as input. If past_key_values are used, the user is expected to input only unprocessed input_ids (those that don&#x2019;t have their past key value states given to this model) of shape (batch_size, unprocessed_length) instead of all input_ids of shape (batch_size, sequence_length) . inputs_embeds ( torch.FloatTensor of shape (batch_size, sequence_length, hidden_size) , optional ) &#x2014; Optionally, instead of passing input_ids you can choose to directly pass an embedded representation. This is useful if you want more control over how to convert input_ids indices into associated vectors than the model&#x2019;s internal embedding lookup matrix. cache_position ( torch.LongTensor of shape (sequence_length) , optional ) &#x2014; Indices depicting the position of the input sequence tokens in the sequence. Contrarily to position_ids , this tensor is not affected by padding. It is used to update the cache in the correct position and to infer the complete sequence length. use_cache ( bool , optional ) &#x2014; If set to True , past_key_values key value states are returned and can be used to speed up decoding (see past_key_values ). Returns transformers.modeling_outputs.BaseModelOutputWithPast or tuple(torch.FloatTensor) A transformers.modeling_outputs.BaseModelOutputWithPast or a tuple of torch.FloatTensor (if return_dict=False is passed or when config.return_dict=False ) comprising various elements depending on the configuration ( LlamaConfig ) and inputs. last_hidden_state ( torch.FloatTensor of shape (batch_size, sequence_length, hidden_size) ) â€” Sequence of hidden-states at the output of the last layer of the model. If past_key_values is used only the last hidden-state of the sequences of shape (batch_size, 1, hidden_size) is output. past_key_values ( Cache , optional , returned when use_cache=True is passed or when config.use_cache=True ) â€” It is a Cache instance. For more details, see our kv cache guide . Contains pre-computed hidden-states (key and values in the self-attention blocks and optionally if config.is_encoder_decoder=True in the cross-attention blocks) that can be used (see past_key_values input) to speed up sequential decoding. hidden_states ( tuple(torch.FloatTensor) , optional , returned when output_hidden_states=True is passed or when config.output_hidden_states=True ) â€” Tuple of torch.FloatTensor (one for the output of the embeddings, if the model has an embedding layer, + one for the output of each layer) of shape (batch_size, sequence_length, hidden_size) . Hidden-states of the model at the output of each layer plus the optional initial embedding outputs. attentions ( tuple(torch.FloatTensor) , optional , returned when output_attentions=True is passed or when config.output_attentions=True ) â€” Tuple of torch.FloatTensor (one for each layer) of shape (batch_size, num_heads, sequence_length, sequence_length) . Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads. The LlamaModel forward method, overrides the __call__ special method. Although the recipe for forward pass needs to be defined within this function, one should call the Module instance afterwards instead of this since the former takes care of running the pre and post processing steps while the latter silently ignores them. LlamaForCausalLM class transformers. LlamaForCausalLM &lt; source &gt; ( config ) Parameters config ( LlamaForCausalLM ) &#x2014; Model configuration class with all the parameters of the model. Initializing with a config file does not load the weights associated with the model, only the configuration. Check out the from_pretrained() method to load the model weights. The Llama Model for causal language modeling. This model inherits from PreTrainedModel . Check the superclass documentation for the generic methods the library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads etc.) This model is also a PyTorch torch.nn.Module subclass. Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage and behavior. forward &lt; source &gt; ( input_ids : typing.Optional[torch.LongTensor] = None attention_mask : typing.Optional[torch.Tensor] = None position_ids : typing.Optional[torch.LongTensor] = None past_key_values : typing.Optional[transformers.cache_utils.Cache] = None inputs_embeds : typing.Optional[torch.FloatTensor] = None labels : typing.Optional[torch.LongTensor] = None use_cache : typing.Optional[bool] = None cache_position : typing.Optional[torch.LongTensor] = None logits_to_keep : typing.Union[int, torch.Tensor] = 0 **kwargs : typing_extensions.Unpack[transformers.utils.generic.TransformersKwargs] ) â†’ transformers.modeling_outputs.CausalLMOutputWithPast or tuple(torch.FloatTensor) Parameters input_ids ( torch.LongTensor of shape (batch_size, sequence_length) , optional ) &#x2014; Indices of input sequence tokens in the vocabulary. Padding will be ignored by default. Indices can be obtained using AutoTokenizer . See PreTrainedTokenizer.encode() and PreTrainedTokenizer. call () for details. What are input IDs? attention_mask ( torch.Tensor of shape (batch_size, sequence_length) , optional ) &#x2014; Mask to avoid performing attention on padding token indices. Mask values selected in [0, 1] : 1 for tokens that are not masked , 0 for tokens that are masked . What are attention masks? position_ids ( torch.LongTensor of shape (batch_size, sequence_length) , optional ) &#x2014; Indices of positions of each input sequence tokens in the position embeddings. Selected in the range [0, config.n_positions - 1] . What are position IDs? past_key_values ( ~cache_utils.Cache , optional ) &#x2014; Pre-computed hidden-states (key and values in the self-attention blocks and in the cross-attention blocks) that can be used to speed up sequential decoding. This typically consists in the past_key_values returned by the model at a previous stage of decoding, when use_cache=True or config.use_cache=True . Only Cache instance is allowed as input, see our kv cache guide . If no past_key_values are passed, DynamicCache will be initialized by default. The model will output the same cache format that is fed as input. If past_key_values are used, the user is expected to input only unprocessed input_ids (those that don&#x2019;t have their past key value states given to this model) of shape (batch_size, unprocessed_length) instead of all input_ids of shape (batch_size, sequence_length) . inputs_embeds ( torch.FloatTensor of shape (batch_size, sequence_length, hidden_size) , optional ) &#x2014; Optionally, instead of passing input_ids you can choose to directly pass an embedded representation. This is useful if you want more control over how to convert input_ids indices into associated vectors than the model&#x2019;s internal embedding lookup matrix. labels ( torch.LongTensor of shape (batch_size, sequence_length) , optional ) &#x2014; Labels for computing the masked language modeling loss. Indices should either be in [0, ..., config.vocab_size] or -100 (see input_ids docstring). Tokens with indices set to -100 are ignored (masked), the loss is only computed for the tokens with labels in [0, ..., config.vocab_size] . use_cache ( bool , optional ) &#x2014; If set to True , past_key_values key value states are returned and can be used to speed up decoding (see past_key_values ). cache_position ( torch.LongTensor of shape (sequence_length) , optional ) &#x2014; Indices depicting the position of the input sequence tokens in the sequence. Contrarily to position_ids , this tensor is not affected by padding. It is used to update the cache in the correct position and to infer the complete sequence length. logits_to_keep ( Union[int, torch.Tensor] , defaults to 0 ) &#x2014; If an int , compute logits for the last logits_to_keep tokens. If 0 , calculate logits for all input_ids (special case). Only last token logits are needed for generation, and calculating them only for that token can save memory, which becomes pretty significant for long sequences or large vocabulary size. If a torch.Tensor , must be 1D corresponding to the indices to keep in the sequence length dimension. This is useful when using packed tensor format (single dimension for batch and sequence length). Returns transformers.modeling_outputs.CausalLMOutputWithPast or tuple(torch.FloatTensor) A transformers.modeling_outputs.CausalLMOutputWithPast or a tuple of torch.FloatTensor (if return_dict=False is passed or when config.return_dict=False ) comprising various elements depending on the configuration ( LlamaConfig ) and inputs. loss ( torch.FloatTensor of shape (1,) , optional , returned when labels is provided) â€” Language modeling loss (for next-token prediction). logits ( torch.FloatTensor of shape (batch_size, sequence_length, config.vocab_size) ) â€” Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax). past_key_values ( Cache , optional , returned when use_cache=True is passed or when config.use_cache=True ) â€” It is a Cache instance. For more details, see our kv cache guide . Contains pre-computed hidden-states (key and values in the self-attention blocks) that can be used (see past_key_values input) to speed up sequential decoding. hidden_states ( tuple(torch.FloatTensor) , optional , returned when output_hidden_states=True is passed or when config.output_hidden_states=True ) â€” Tuple of torch.FloatTensor (one for the output of the embeddings, if the model has an embedding layer, + one for the output of each layer) of shape (batch_size, sequence_length, hidden_size) . Hidden-states of the model at the output of each layer plus the optional initial embedding outputs. attentions ( tuple(torch.FloatTensor) , optional , returned when output_attentions=True is passed or when config.output_attentions=True ) â€” Tuple of torch.FloatTensor (one for each layer) of shape (batch_size, num_heads, sequence_length, sequence_length) . Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads. The LlamaForCausalLM forward method, overrides the __call__ special method. Although the recipe for forward pass needs to be defined within this function, one should call the Module instance afterwards instead of this since the former takes care of running the pre and post processing steps while the latter silently ignores them. Example: Copied &gt;&gt;&gt; from transformers import AutoTokenizer, LlamaForCausalLM &gt;&gt;&gt; model = LlamaForCausalLM.from_pretrained( &quot;meta-llama/Llama-2-7b-hf&quot; ) &gt;&gt;&gt; tokenizer = AutoTokenizer.from_pretrained( &quot;meta-llama/Llama-2-7b-hf&quot; ) &gt;&gt;&gt; prompt = &quot;Hey, are you conscious? Can you talk to me?&quot; &gt;&gt;&gt; inputs = tokenizer(prompt, return_tensors= &quot;pt&quot; ) &gt;&gt;&gt; # Generate &gt;&gt;&gt; generate_ids = model.generate(inputs.input_ids, max_length= 30 ) &gt;&gt;&gt; tokenizer.batch_decode(generate_ids, skip_special_tokens= True , clean_up_tokenization_spaces= False )[ 0 ] &quot;Hey, are you conscious? Can you talk to me?\\nI&#x27;m not conscious, but I can talk to you.&quot; LlamaForSequenceClassification class transformers. LlamaForSequenceClassification &lt; source &gt; ( config ) forward &lt; source &gt; ( input_ids : typing.Optional[torch.LongTensor] = None attention_mask : typing.Optional[torch.Tensor] = None position_ids : typing.Optional[torch.LongTensor] = None past_key_values : typing.Optional[transformers.cache_utils.Cache] = None inputs_embeds : typing.Optional[torch.FloatTensor] = None labels : typing.Optional[torch.LongTensor] = None use_cache : typing.Optional[bool] = None **kwargs : typing_extensions.Unpack[transformers.utils.generic.TransformersKwargs] ) â†’ transformers.modeling_outputs.SequenceClassifierOutputWithPast or tuple(torch.FloatTensor) Parameters input_ids ( torch.LongTensor of shape (batch_size, sequence_length) , optional ) &#x2014; Indices of input sequence tokens in the vocabulary. Padding will be ignored by default. Indices can be obtained using AutoTokenizer . See PreTrainedTokenizer.encode() and PreTrainedTokenizer. call () for details. What are input IDs? attention_mask ( torch.Tensor of shape (batch_size, sequence_length) , optional ) &#x2014; Mask to avoid performing attention on padding token indices. Mask values selected in [0, 1] : 1 for tokens that are not masked , 0 for tokens that are masked . What are attention masks? position_ids ( torch.LongTensor of shape (batch_size, sequence_length) , optional ) &#x2014; Indices of positions of each input sequence tokens in the position embeddings. Selected in the range [0, config.n_positions - 1] . What are position IDs? past_key_values ( ~cache_utils.Cache , optional ) &#x2014; Pre-computed hidden-states (key and values in the self-attention blocks and in the cross-attention blocks) that can be used to speed up sequential decoding. This typically consists in the past_key_values returned by the model at a previous stage of decoding, when use_cache=True or config.use_cache=True . Only Cache instance is allowed as input, see our kv cache guide . If no past_key_values are passed, DynamicCache will be initialized by default. The model will output the same cache format that is fed as input. If past_key_values are used, the user is expected to input only unprocessed input_ids (those that don&#x2019;t have their past key value states given to this model) of shape (batch_size, unprocessed_length) instead of all input_ids of shape (batch_size, sequence_length) . inputs_embeds ( torch.FloatTensor of shape (batch_size, sequence_length, hidden_size) , optional ) &#x2014; Optionally, instead of passing input_ids you can choose to directly pass an embedded representation. This is useful if you want more control over how to convert input_ids indices into associated vectors than the model&#x2019;s internal embedding lookup matrix. labels ( torch.LongTensor of shape (batch_size, sequence_length) , optional ) &#x2014; Labels for computing the masked language modeling loss. Indices should either be in [0, ..., config.vocab_size] or -100 (see input_ids docstring). Tokens with indices set to -100 are ignored (masked), the loss is only computed for the tokens with labels in [0, ..., config.vocab_size] . use_cache ( bool , optional ) &#x2014; If set to True , past_key_values key value states are returned and can be used to speed up decoding (see past_key_values ). Returns transformers.modeling_outputs.SequenceClassifierOutputWithPast or tuple(torch.FloatTensor) A transformers.modeling_outputs.SequenceClassifierOutputWithPast or a tuple of torch.FloatTensor (if return_dict=False is passed or when config.return_dict=False ) comprising various elements depending on the configuration ( None ) and inputs. loss ( torch.FloatTensor of shape (1,) , optional , returned when labels is provided) â€” Classification (or regression if config.num_labels==1) loss. logits ( torch.FloatTensor of shape (batch_size, config.num_labels) ) â€” Classification (or regression if config.num_labels==1) scores (before SoftMax). past_key_values ( Cache , optional , returned when use_cache=True is passed or when config.use_cache=True ) â€” It is a Cache instance. For more details, see our kv cache guide . Contains pre-computed hidden-states (key and values in the self-attention blocks) that can be used (see past_key_values input) to speed up sequential decoding. hidden_states ( tuple(torch.FloatTensor) , optional , returned when output_hidden_states=True is passed or when config.output_hidden_states=True ) â€” Tuple of torch.FloatTensor (one for the output of the embeddings, if the model has an embedding layer, + one for the output of each layer) of shape (batch_size, sequence_length, hidden_size) . Hidden-states of the model at the output of each layer plus the optional initial embedding outputs. attentions ( tuple(torch.FloatTensor) , optional , returned when output_attentions=True is passed or when config.output_attentions=True ) â€” Tuple of torch.FloatTensor (one for each layer) of shape (batch_size, num_heads, sequence_length, sequence_length) . Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads. The GenericForSequenceClassification forward method, overrides the __call__ special method. Although the recipe for forward pass needs to be defined within this function, one should call the Module instance afterwards instead of this since the former takes care of running the pre and post processing steps while the latter silently ignores them. LlamaForQuestionAnswering class transformers. LlamaForQuestionAnswering &lt; source &gt; ( config ) forward &lt; source &gt; ( input_ids : typing.Optional[torch.LongTensor] = None attention_mask : typing.Optional[torch.Tensor] = None position_ids : typing.Optional[torch.LongTensor] = None past_key_values : typing.Optional[transformers.cache_utils.Cache] = None inputs_embeds : typing.Optional[torch.FloatTensor] = None start_positions : typing.Optional[torch.LongTensor] = None end_positions : typing.Optional[torch.LongTensor] = None **kwargs : typing_extensions.Unpack[transformers.utils.generic.TransformersKwargs] ) â†’ transformers.modeling_outputs.QuestionAnsweringModelOutput or tuple(torch.FloatTensor) Parameters input_ids ( torch.LongTensor of shape (batch_size, sequence_length) , optional ) &#x2014; Indices of input sequence tokens in the vocabulary. Padding will be ignored by default. Indices can be obtained using AutoTokenizer . See PreTrainedTokenizer.encode() and PreTrainedTokenizer. call () for details. What are input IDs? attention_mask ( torch.Tensor of shape (batch_size, sequence_length) , optional ) &#x2014; Mask to avoid performing attention on padding token indices. Mask values selected in [0, 1] : 1 for tokens that are not masked , 0 for tokens that are masked . What are attention masks? position_ids ( torch.LongTensor of shape (batch_size, sequence_length) , optional ) &#x2014; Indices of positions of each input sequence tokens in the position embeddings. Selected in the range [0, config.n_positions - 1] . What are position IDs? past_key_values ( ~cache_utils.Cache , optional ) &#x2014; Pre-computed hidden-states (key and values in the self-attention blocks and in the cross-attention blocks) that can be used to speed up sequential decoding. This typically consists in the past_key_values returned by the model at a previous stage of decoding, when use_cache=True or config.use_cache=True . Only Cache instance is allowed as input, see our kv cache guide . If no past_key_values are passed, DynamicCache will be initialized by default. The model will output the same cache format that is fed as input. If past_key_values are used, the user is expected to input only unprocessed input_ids (those that don&#x2019;t have their past key value states given to this model) of shape (batch_size, unprocessed_length) instead of all input_ids of shape (batch_size, sequence_length) . inputs_embeds ( torch.FloatTensor of shape (batch_size, sequence_length, hidden_size) , optional ) &#x2014; Optionally, instead of passing input_ids you can choose to directly pass an embedded representation. This is useful if you want more control over how to convert input_ids indices into associated vectors than the model&#x2019;s internal embedding lookup matrix. start_positions ( torch.LongTensor of shape (batch_size,) , optional ) &#x2014; Labels for position (index) of the start of the labelled span for computing the token classification loss. Positions are clamped to the length of the sequence ( sequence_length ). Position outside of the sequence are not taken into account for computing the loss. end_positions ( torch.LongTensor of shape (batch_size,) , optional ) &#x2014; Labels for position (index) of the end of the labelled span for computing the token classification loss. Positions are clamped to the length of the sequence ( sequence_length ). Position outside of the sequence are not taken into account for computing the loss. Returns transformers.modeling_outputs.QuestionAnsweringModelOutput or tuple(torch.FloatTensor) A transformers.modeling_outputs.QuestionAnsweringModelOutput or a tuple of torch.FloatTensor (if return_dict=False is passed or when config.return_dict=False ) comprising various elements depending on the configuration ( None ) and inputs. loss ( torch.FloatTensor of shape (1,) , optional , returned when labels is provided) â€” Total span extraction loss is the sum of a Cross-Entropy for the start and end positions. start_logits ( torch.FloatTensor of shape (batch_size, sequence_length) ) â€” Span-start scores (before SoftMax). end_logits ( torch.FloatTensor of shape (batch_size, sequence_length) ) â€” Span-end scores (before SoftMax). hidden_states ( tuple(torch.FloatTensor) , optional , returned when output_hidden_states=True is passed or when config.output_hidden_states=True ) â€” Tuple of torch.FloatTensor (one for the output of the embeddings, if the model has an embedding layer, + one for the output of each layer) of shape (batch_size, sequence_length, hidden_size) . Hidden-states of the model at the output of each layer plus the optional initial embedding outputs. attentions ( tuple(torch.FloatTensor) , optional , returned when output_attentions=True is passed or when config.output_attentions=True ) â€” Tuple of torch.FloatTensor (one for each layer) of shape (batch_size, num_heads, sequence_length, sequence_length) . Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads. The GenericForQuestionAnswering forward method, overrides the __call__ special method. Although the recipe for forward pass needs to be defined within this function, one should call the Module instance afterwards instead of this since the former takes care of running the pre and post processing steps while the latter silently ignores them. LlamaForTokenClassification class transformers. LlamaForTokenClassification &lt; source &gt; ( config ) forward &lt; source &gt; ( input_ids : typing.Optional[torch.LongTensor] = None attention_mask : typing.Optional[torch.Tensor] = None position_ids : typing.Optional[torch.LongTensor] = None past_key_values : typing.Optional[transformers.cache_utils.Cache] = None inputs_embeds : typing.Optional[torch.FloatTensor] = None labels : typing.Optional[torch.LongTensor] = None use_cache : typing.Optional[bool] = None **kwargs : typing_extensions.Unpack[transformers.utils.generic.TransformersKwargs] ) â†’ transformers.modeling_outputs.TokenClassifierOutput or tuple(torch.FloatTensor) Parameters input_ids ( torch.LongTensor of shape (batch_size, sequence_length) , optional ) &#x2014; Indices of input sequence tokens in the vocabulary. Padding will be ignored by default. Indices can be obtained using AutoTokenizer . See PreTrainedTokenizer.encode() and PreTrainedTokenizer. call () for details. What are input IDs? attention_mask ( torch.Tensor of shape (batch_size, sequence_length) , optional ) &#x2014; Mask to avoid performing attention on padding token indices. Mask values selected in [0, 1] : 1 for tokens that are not masked , 0 for tokens that are masked . What are attention masks? position_ids ( torch.LongTensor of shape (batch_size, sequence_length) , optional ) &#x2014; Indices of positions of each input sequence tokens in the position embeddings. Selected in the range [0, config.n_positions - 1] . What are position IDs? past_key_values ( ~cache_utils.Cache , optional ) &#x2014; Pre-computed hidden-states (key and values in the self-attention blocks and in the cross-attention blocks) that can be used to speed up sequential decoding. This typically consists in the past_key_values returned by the model at a previous stage of decoding, when use_cache=True or config.use_cache=True . Only Cache instance is allowed as input, see our kv cache guide . If no past_key_values are passed, DynamicCache will be initialized by default. The model will output the same cache format that is fed as input. If past_key_values are used, the user is expected to input only unprocessed input_ids (those that don&#x2019;t have their past key value states given to this model) of shape (batch_size, unprocessed_length) instead of all input_ids of shape (batch_size, sequence_length) . inputs_embeds ( torch.FloatTensor of shape (batch_size, sequence_length, hidden_size) , optional ) &#x2014; Optionally, instead of passing input_ids you can choose to directly pass an embedded representation. This is useful if you want more control over how to convert input_ids indices into associated vectors than the model&#x2019;s internal embedding lookup matrix. labels ( torch.LongTensor of shape (batch_size, sequence_length) , optional ) &#x2014; Labels for computing the masked language modeling loss. Indices should either be in [0, ..., config.vocab_size] or -100 (see input_ids docstring). Tokens with indices set to -100 are ignored (masked), the loss is only computed for the tokens with labels in [0, ..., config.vocab_size] . use_cache ( bool , optional ) &#x2014; If set to True , past_key_values key value states are returned and can be used to speed up decoding (see past_key_values ). Returns transformers.modeling_outputs.TokenClassifierOutput or tuple(torch.FloatTensor) A transformers.modeling_outputs.TokenClassifierOutput or a tuple of torch.FloatTensor (if return_dict=False is passed or when config.return_dict=False ) comprising various elements depending on the configuration ( None ) and inputs. loss ( torch.FloatTensor of shape (1,) , optional , returned when labels is provided) â€” Classification loss. logits ( torch.FloatTensor of shape (batch_size, sequence_length, config.num_labels) ) â€” Classification scores (before SoftMax). hidden_states ( tuple(torch.FloatTensor) , optional , returned when output_hidden_states=True is passed or when config.output_hidden_states=True ) â€” Tuple of torch.FloatTensor (one for the output of the embeddings, if the model has an embedding layer, + one for the output of each layer) of shape (batch_size, sequence_length, hidden_size) . Hidden-states of the model at the output of each layer plus the optional initial embedding outputs. attentions ( tuple(torch.FloatTensor) , optional , returned when output_attentions=True is passed or when config.output_attentions=True ) â€” Tuple of torch.FloatTensor (one for each layer) of shape (batch_size, num_heads, sequence_length, sequence_length) . Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads. The GenericForTokenClassification forward method, overrides the __call__ special method. Although the recipe for forward pass needs to be defined within this function, one should call the Module instance afterwards instead of this since the former takes care of running the pre and post processing steps while the latter silently ignores them. &lt; &gt; Update on GitHub â† LFM2 Llama2 â†’ Llama Notes Llama Config Llama Tokenizer Llama Tokenizer Fast Llama Model Llama For CausalLM Llama For Sequence Classification Llama For Question Answering Llama For Token Classification "
    },
    {
      "arxiv_id": "https://llama.meta.com/docs/get-started/",
      "full_text": " Docs &amp; Resources | Llama AI "
    }
  ]
}